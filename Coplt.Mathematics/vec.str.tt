<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics;
<#
    foreach (var typ in Typ.Typs)
    {
        for (var i = 2; i <= 4; i++)
        {
            var typeName = $"{typ.name}{i}";

            var byteSize = typ.size * (i is 3 ? 4 : i);
            var bitSize = 8 * byteSize;

            var format = string.Join(", ", Enumerable.Range(0, i).Select(n => $"{{{Typ.xyzw[n]}}}"));
            var format2 = !typ.formattable
                ? format
                : string.Join(", ", Enumerable.Range(0, i).Select(n => $"{{{Typ.xyzw[n]}.ToString(format, formatProvider)}}"));
#>

#region <#= typeName #>

public partial struct <#= typeName #> : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"<#= typeName #>(<#= format #>)";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"<#= typeName #>(<#= format2 #>)";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "<#= typeName #>(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
<#
            for (var n = 0; n < i; n++)
            {
                var comp = Typ.xyzw[n];
                if (typ.formattable)
                {
#>
        r = <#= comp #>.TryFormat(dst, out ic, format, provider);
<#
                }
                else
                {
#>
        r = <#= comp #>.TryFormat(dst, out ic);
<#
                }
#>
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
<#
            }
#>
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }
<#
            if (typ.formattable)
            {
#>

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "<#= typeName #>("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
<#
            for (var n = 0; n < i; n++)
            {
                var comp = Typ.xyzw[n];
                if (typ.formattable)
                {
#>
        r = <#= comp #>.TryFormat(dst, out ic, format, provider);
<#
                }
                else
                {
#>
        r = <#= comp #>.TryFormat(dst, out ic);
<#
                }
#>
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
<#
            }
#>
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
<#
            }
#>
}

#endregion // <#= typeName #>
<#
        }
    }
#>
