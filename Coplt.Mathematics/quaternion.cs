// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region quaternion

public partial struct quaternion
{
    public float4 value;

    public static quaternion Identity
    {
        [MethodImpl(256 | 512)]
        get => new(default, default, default, 1.0f);
    }
    
    [MethodImpl(256 | 512)]
    public quaternion(float x, float y, float z, float w) => 
        value = new(x, y, z, w); 

    [MethodImpl(256 | 512)]
    public quaternion(float4 value) => this.value = value; 

    [MethodImpl(256 | 512)]
    public static implicit operator quaternion(float4 value) => new(value); 

    /// <summary>Constructs a unit quaternion from a float3x3 rotation matrix. The matrix must be orthonormal</summary>
    /// <param name="m">The float3x3 orthonormal rotation matrix</param>
    [MethodImpl(256 | 512)]
    public quaternion(float3x3 m)
    {
        var u = m.c0;
        var v = m.c1;
        var w = m.c2;

        var u_sign = (uint)(u.x.asu() & 0x80000000);
        var t = (v.y + ((uint)(w.z.asu() ^ u_sign)).asf());
        var u_mask = new uint4((uint)(u_sign >> 31)).asf();
        var t_mask = new int4((int)(t.asi() >> 31)).asf();

        var tr = (1.0f + u.x.abs());

        var sign_flips =
            new uint4(default, 0x80000000, 0x80000000, 0x80000000).asf()
            ^ (u_mask & new uint4(default, 0x80000000, default, 0x80000000).asf())
            ^ (t_mask & new uint4(0x80000000, 0x80000000, 0x80000000, default).asf());

        value = new float4(tr, u.y, w.x, v.z) + (new float4(t, v.x, u.z, w.y) ^ sign_flips); // +---, +++-, ++-+, +-++

        value = (value & ~u_mask) | (value.zwxy & u_mask);
        value = (value.wzyx & ~t_mask) | (value & t_mask);
        value = value.normalize();
    }

    /// <summary>Constructs a unit quaternion from an orthonormal float4x4 matrix</summary>
    /// <param name="m">The float4x4 orthonormal rotation matrix</param>
    [MethodImpl(256 | 512)]
    public quaternion(float4x4 m)
    {
        var u = m.c0;
        var v = m.c1;
        var w = m.c2;

        var u_sign = (uint)(u.x.asu() & 0x80000000);
        var t = (v.y + ((uint)(w.z.asu() ^ u_sign)).asf());
        var u_mask = new uint4((uint)(u_sign >> 31)).asf();
        var t_mask = new int4((int)(t.asi() >> 31)).asf();

        var tr = (1.0f + u.x.abs());

        var sign_flips =
            new uint4(default, 0x80000000, 0x80000000, 0x80000000).asf()
            ^ (u_mask & new uint4(default, 0x80000000, default, 0x80000000).asf())
            ^ (t_mask & new uint4(0x80000000, 0x80000000, 0x80000000, default).asf());

        value = new float4(tr, u.y, w.x, v.z) + (new float4(t, v.x, u.z, w.y) ^ sign_flips); // +---, +++-, ++-+, +-++

        value = (value & ~u_mask) | (value.zwxy & u_mask);
        value = (value.wzyx & ~t_mask) | (value & t_mask);
        value = value.normalize();
    }

    /// <summary>
    /// Returns a quaternion representing a rotation around a unit axis by an angle in radians
    /// The rotation direction is clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="axis">The axis of rotation</param>
    /// <param name="angle">The angle of rotation in radians</param>
    /// <returns>The quaternion representing a rotation around an axis</returns>
    [MethodImpl(256 | 512)]
    public static quaternion AxisAngle(float3 axis, float angle)
    {
        math.sincos((0.5f * angle), out var sina, out var cosa);
        return new(new float4(axis * sina, cosa));
    }
}

#endregion // quaternion

#region quaternion_d

public partial struct quaternion_d
{
    public double4 value;

    public static quaternion_d Identity
    {
        [MethodImpl(256 | 512)]
        get => new(default, default, default, 1.0);
    }
    
    [MethodImpl(256 | 512)]
    public quaternion_d(double x, double y, double z, double w) => 
        value = new(x, y, z, w); 

    [MethodImpl(256 | 512)]
    public quaternion_d(double4 value) => this.value = value; 

    [MethodImpl(256 | 512)]
    public static implicit operator quaternion_d(double4 value) => new(value); 

    /// <summary>Constructs a unit quaternion from a double3x3 rotation matrix. The matrix must be orthonormal</summary>
    /// <param name="m">The double3x3 orthonormal rotation matrix</param>
    [MethodImpl(256 | 512)]
    public quaternion_d(double3x3 m)
    {
        var u = m.c0;
        var v = m.c1;
        var w = m.c2;

        var u_sign = (ulong)(u.x.asu() & 0x8000000000000000);
        var t = (v.y + ((ulong)(w.z.asu() ^ u_sign)).asf());
        var u_mask = new ulong4((ulong)(u_sign >> 63)).asf();
        var t_mask = new long4((long)(t.asi() >> 63)).asf();

        var tr = (1.0 + u.x.abs());

        var sign_flips =
            new ulong4(default, 0x8000000000000000, 0x8000000000000000, 0x8000000000000000).asf()
            ^ (u_mask & new ulong4(default, 0x8000000000000000, default, 0x8000000000000000).asf())
            ^ (t_mask & new ulong4(0x8000000000000000, 0x8000000000000000, 0x8000000000000000, default).asf());

        value = new double4(tr, u.y, w.x, v.z) + (new double4(t, v.x, u.z, w.y) ^ sign_flips); // +---, +++-, ++-+, +-++

        value = (value & ~u_mask) | (value.zwxy & u_mask);
        value = (value.wzyx & ~t_mask) | (value & t_mask);
        value = value.normalize();
    }

    /// <summary>Constructs a unit quaternion from an orthonormal double4x4 matrix</summary>
    /// <param name="m">The double4x4 orthonormal rotation matrix</param>
    [MethodImpl(256 | 512)]
    public quaternion_d(double4x4 m)
    {
        var u = m.c0;
        var v = m.c1;
        var w = m.c2;

        var u_sign = (ulong)(u.x.asu() & 0x8000000000000000);
        var t = (v.y + ((ulong)(w.z.asu() ^ u_sign)).asf());
        var u_mask = new ulong4((ulong)(u_sign >> 63)).asf();
        var t_mask = new long4((long)(t.asi() >> 63)).asf();

        var tr = (1.0 + u.x.abs());

        var sign_flips =
            new ulong4(default, 0x8000000000000000, 0x8000000000000000, 0x8000000000000000).asf()
            ^ (u_mask & new ulong4(default, 0x8000000000000000, default, 0x8000000000000000).asf())
            ^ (t_mask & new ulong4(0x8000000000000000, 0x8000000000000000, 0x8000000000000000, default).asf());

        value = new double4(tr, u.y, w.x, v.z) + (new double4(t, v.x, u.z, w.y) ^ sign_flips); // +---, +++-, ++-+, +-++

        value = (value & ~u_mask) | (value.zwxy & u_mask);
        value = (value.wzyx & ~t_mask) | (value & t_mask);
        value = value.normalize();
    }

    /// <summary>
    /// Returns a quaternion representing a rotation around a unit axis by an angle in radians
    /// The rotation direction is clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="axis">The axis of rotation</param>
    /// <param name="angle">The angle of rotation in radians</param>
    /// <returns>The quaternion representing a rotation around an axis</returns>
    [MethodImpl(256 | 512)]
    public static quaternion_d AxisAngle(double3 axis, double angle)
    {
        math.sincos((0.5 * angle), out var sina, out var cosa);
        return new(new double4(axis * sina, cosa));
    }
}

#endregion // quaternion_d

#region quaternion_h

public partial struct quaternion_h
{
    public half4 value;

    public static quaternion_h Identity
    {
        [MethodImpl(256 | 512)]
        get => new(default, default, default, (half)1.0);
    }
    
    [MethodImpl(256 | 512)]
    public quaternion_h(half x, half y, half z, half w) => 
        value = new(x, y, z, w); 

    [MethodImpl(256 | 512)]
    public quaternion_h(half4 value) => this.value = value; 

    [MethodImpl(256 | 512)]
    public static implicit operator quaternion_h(half4 value) => new(value); 

    /// <summary>Constructs a unit quaternion from a half3x3 rotation matrix. The matrix must be orthonormal</summary>
    /// <param name="m">The half3x3 orthonormal rotation matrix</param>
    [MethodImpl(256 | 512)]
    public quaternion_h(half3x3 m)
    {
        var u = m.c0;
        var v = m.c1;
        var w = m.c2;

        var u_sign = (ushort)(u.x.asu() & 0x8000);
        var t = (half)(v.y + ((ushort)(w.z.asu() ^ u_sign)).asf());
        var u_mask = new ushort4((ushort)(u_sign >> 15)).asf();
        var t_mask = new short4((short)(t.asi() >> 15)).asf();

        var tr = (half)((half)1.0 + u.x.abs());

        var sign_flips =
            new ushort4(default, 0x8000, 0x8000, 0x8000).asf()
            ^ (u_mask & new ushort4(default, 0x8000, default, 0x8000).asf())
            ^ (t_mask & new ushort4(0x8000, 0x8000, 0x8000, default).asf());

        value = new half4(tr, u.y, w.x, v.z) + (new half4(t, v.x, u.z, w.y) ^ sign_flips); // +---, +++-, ++-+, +-++

        value = (value & ~u_mask) | (value.zwxy & u_mask);
        value = (value.wzyx & ~t_mask) | (value & t_mask);
        value = value.normalize();
    }

    /// <summary>Constructs a unit quaternion from an orthonormal half4x4 matrix</summary>
    /// <param name="m">The half4x4 orthonormal rotation matrix</param>
    [MethodImpl(256 | 512)]
    public quaternion_h(half4x4 m)
    {
        var u = m.c0;
        var v = m.c1;
        var w = m.c2;

        var u_sign = (ushort)(u.x.asu() & 0x8000);
        var t = (half)(v.y + ((ushort)(w.z.asu() ^ u_sign)).asf());
        var u_mask = new ushort4((ushort)(u_sign >> 15)).asf();
        var t_mask = new short4((short)(t.asi() >> 15)).asf();

        var tr = (half)((half)1.0 + u.x.abs());

        var sign_flips =
            new ushort4(default, 0x8000, 0x8000, 0x8000).asf()
            ^ (u_mask & new ushort4(default, 0x8000, default, 0x8000).asf())
            ^ (t_mask & new ushort4(0x8000, 0x8000, 0x8000, default).asf());

        value = new half4(tr, u.y, w.x, v.z) + (new half4(t, v.x, u.z, w.y) ^ sign_flips); // +---, +++-, ++-+, +-++

        value = (value & ~u_mask) | (value.zwxy & u_mask);
        value = (value.wzyx & ~t_mask) | (value & t_mask);
        value = value.normalize();
    }

    /// <summary>
    /// Returns a quaternion representing a rotation around a unit axis by an angle in radians
    /// The rotation direction is clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="axis">The axis of rotation</param>
    /// <param name="angle">The angle of rotation in radians</param>
    /// <returns>The quaternion representing a rotation around an axis</returns>
    [MethodImpl(256 | 512)]
    public static quaternion_h AxisAngle(half3 axis, half angle)
    {
        math.sincos((half)((half)0.5f * angle), out var sina, out var cosa);
        return new(new half4(axis * sina, cosa));
    }
}

#endregion // quaternion_h
