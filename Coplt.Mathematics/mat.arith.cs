// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region float2x2

public partial struct float2x2
{
    [MethodImpl(256 | 512)]
    public static float2x2 operator +(float2x2 a) => a;

    [MethodImpl(256 | 512)]
    public static float2x2 operator -(float2x2 a) => 
        new(-a.c0, -a.c1);

    [MethodImpl(256 | 512)]
    public static float2x2 operator +(float2x2 a, float2x2 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1);

    [MethodImpl(256 | 512)]
    public static float2x2 operator -(float2x2 a, float2x2 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1);

    [MethodImpl(256 | 512)]
    public static float2x2 operator *(float2x2 a, float2x2 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1);

    [MethodImpl(256 | 512)]
    public static float2x2 operator *(float2x2 a, float b) => 
        new(a.c0 * b, a.c1 * b);

    [MethodImpl(256 | 512)]
    public static float2x2 operator *(float a, float2x2 b) => 
        new(a * b.c0, a * b.c1);

    [MethodImpl(256 | 512)]
    public static float2x2 operator /(float2x2 a, float2x2 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1);

    [MethodImpl(256 | 512)]
    public static float2x2 operator /(float2x2 a, float b) => 
        new(a.c0 / b, a.c1 / b);

    [MethodImpl(256 | 512)]
    public static float2x2 operator %(float2x2 a, float2x2 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1);

    [MethodImpl(256 | 512)]
    public static float2x2 operator %(float2x2 a, float b) => 
        new(a.c0 % b, a.c1 % b);

    [MethodImpl(256 | 512)]
    public static float2x2 operator --(float2x2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static float2x2 operator ++(float2x2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float2x2 abs(this float2x2 a) => 
        new(a.c0.abs(), a.c1.abs());

    [MethodImpl(256 | 512)]
    public static float2x2 sign(this float2x2 a) => 
        new(a.c0.sign(), a.c1.sign());

    [MethodImpl(256 | 512)]
    public static float2x2 min(this float2x2 a, float2x2 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1));

    [MethodImpl(256 | 512)]
    public static float2x2 max(this float2x2 a, float2x2 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1));

    [MethodImpl(256 | 512)]
    public static float2x2 clamp(this float2x2 v, float2x2 min, float2x2 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1));

    [MethodImpl(256 | 512)]
    public static float2x2 square(this float2x2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float2x2 fma(this float2x2 a, float2x2 b, float2x2 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static float2x2 fms(this float2x2 a, float2x2 b, float2x2 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1));

    [MethodImpl(256 | 512)]
    public static float2 csum(this float2x2 a) => 
        new(a.c0.csum(), a.c1.csum());

    [MethodImpl(256 | 512)]
    public static float2 cmin(this float2x2 a) => 
        new(a.c0.cmin(), a.c1.cmin());

    [MethodImpl(256 | 512)]
    public static float2 cmax(this float2x2 a) => 
        new(a.c0.cmax(), a.c1.cmax());
}

#endregion // float2x2

#region float2x3

public partial struct float2x3
{
    [MethodImpl(256 | 512)]
    public static float2x3 operator +(float2x3 a) => a;

    [MethodImpl(256 | 512)]
    public static float2x3 operator -(float2x3 a) => 
        new(-a.c0, -a.c1, -a.c2);

    [MethodImpl(256 | 512)]
    public static float2x3 operator +(float2x3 a, float2x3 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2);

    [MethodImpl(256 | 512)]
    public static float2x3 operator -(float2x3 a, float2x3 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2);

    [MethodImpl(256 | 512)]
    public static float2x3 operator *(float2x3 a, float2x3 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2);

    [MethodImpl(256 | 512)]
    public static float2x3 operator *(float2x3 a, float b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b);

    [MethodImpl(256 | 512)]
    public static float2x3 operator *(float a, float2x3 b) => 
        new(a * b.c0, a * b.c1, a * b.c2);

    [MethodImpl(256 | 512)]
    public static float2x3 operator /(float2x3 a, float2x3 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2);

    [MethodImpl(256 | 512)]
    public static float2x3 operator /(float2x3 a, float b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b);

    [MethodImpl(256 | 512)]
    public static float2x3 operator %(float2x3 a, float2x3 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2);

    [MethodImpl(256 | 512)]
    public static float2x3 operator %(float2x3 a, float b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b);

    [MethodImpl(256 | 512)]
    public static float2x3 operator --(float2x3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static float2x3 operator ++(float2x3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float2x3 abs(this float2x3 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs());

    [MethodImpl(256 | 512)]
    public static float2x3 sign(this float2x3 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign());

    [MethodImpl(256 | 512)]
    public static float2x3 min(this float2x3 a, float2x3 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2));

    [MethodImpl(256 | 512)]
    public static float2x3 max(this float2x3 a, float2x3 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2));

    [MethodImpl(256 | 512)]
    public static float2x3 clamp(this float2x3 v, float2x3 min, float2x3 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2));

    [MethodImpl(256 | 512)]
    public static float2x3 square(this float2x3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float2x3 fma(this float2x3 a, float2x3 b, float2x3 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static float2x3 fms(this float2x3 a, float2x3 b, float2x3 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2));

    [MethodImpl(256 | 512)]
    public static float3 csum(this float2x3 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum());

    [MethodImpl(256 | 512)]
    public static float3 cmin(this float2x3 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin());

    [MethodImpl(256 | 512)]
    public static float3 cmax(this float2x3 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax());
}

#endregion // float2x3

#region float2x4

public partial struct float2x4
{
    [MethodImpl(256 | 512)]
    public static float2x4 operator +(float2x4 a) => a;

    [MethodImpl(256 | 512)]
    public static float2x4 operator -(float2x4 a) => 
        new(-a.c0, -a.c1, -a.c2, -a.c3);

    [MethodImpl(256 | 512)]
    public static float2x4 operator +(float2x4 a, float2x4 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2, a.c3 + b.c3);

    [MethodImpl(256 | 512)]
    public static float2x4 operator -(float2x4 a, float2x4 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2, a.c3 - b.c3);

    [MethodImpl(256 | 512)]
    public static float2x4 operator *(float2x4 a, float2x4 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2, a.c3 * b.c3);

    [MethodImpl(256 | 512)]
    public static float2x4 operator *(float2x4 a, float b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b, a.c3 * b);

    [MethodImpl(256 | 512)]
    public static float2x4 operator *(float a, float2x4 b) => 
        new(a * b.c0, a * b.c1, a * b.c2, a * b.c3);

    [MethodImpl(256 | 512)]
    public static float2x4 operator /(float2x4 a, float2x4 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2, a.c3 / b.c3);

    [MethodImpl(256 | 512)]
    public static float2x4 operator /(float2x4 a, float b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b, a.c3 / b);

    [MethodImpl(256 | 512)]
    public static float2x4 operator %(float2x4 a, float2x4 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2, a.c3 % b.c3);

    [MethodImpl(256 | 512)]
    public static float2x4 operator %(float2x4 a, float b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b, a.c3 % b);

    [MethodImpl(256 | 512)]
    public static float2x4 operator --(float2x4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static float2x4 operator ++(float2x4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float2x4 abs(this float2x4 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs(), a.c3.abs());

    [MethodImpl(256 | 512)]
    public static float2x4 sign(this float2x4 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign(), a.c3.sign());

    [MethodImpl(256 | 512)]
    public static float2x4 min(this float2x4 a, float2x4 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2), a.c3.min(b.c3));

    [MethodImpl(256 | 512)]
    public static float2x4 max(this float2x4 a, float2x4 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2), a.c3.max(b.c3));

    [MethodImpl(256 | 512)]
    public static float2x4 clamp(this float2x4 v, float2x4 min, float2x4 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2), v.c3.clamp(min.c3, max.c3));

    [MethodImpl(256 | 512)]
    public static float2x4 square(this float2x4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float2x4 fma(this float2x4 a, float2x4 b, float2x4 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2), a.c3.fma(b.c3, c.c3));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static float2x4 fms(this float2x4 a, float2x4 b, float2x4 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2), a.c3.fms(b.c3, c.c3));

    [MethodImpl(256 | 512)]
    public static float4 csum(this float2x4 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum(), a.c3.csum());

    [MethodImpl(256 | 512)]
    public static float4 cmin(this float2x4 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin(), a.c3.cmin());

    [MethodImpl(256 | 512)]
    public static float4 cmax(this float2x4 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax(), a.c3.cmax());
}

#endregion // float2x4

#region float3x2

public partial struct float3x2
{
    [MethodImpl(256 | 512)]
    public static float3x2 operator +(float3x2 a) => a;

    [MethodImpl(256 | 512)]
    public static float3x2 operator -(float3x2 a) => 
        new(-a.c0, -a.c1);

    [MethodImpl(256 | 512)]
    public static float3x2 operator +(float3x2 a, float3x2 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1);

    [MethodImpl(256 | 512)]
    public static float3x2 operator -(float3x2 a, float3x2 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1);

    [MethodImpl(256 | 512)]
    public static float3x2 operator *(float3x2 a, float3x2 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1);

    [MethodImpl(256 | 512)]
    public static float3x2 operator *(float3x2 a, float b) => 
        new(a.c0 * b, a.c1 * b);

    [MethodImpl(256 | 512)]
    public static float3x2 operator *(float a, float3x2 b) => 
        new(a * b.c0, a * b.c1);

    [MethodImpl(256 | 512)]
    public static float3x2 operator /(float3x2 a, float3x2 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1);

    [MethodImpl(256 | 512)]
    public static float3x2 operator /(float3x2 a, float b) => 
        new(a.c0 / b, a.c1 / b);

    [MethodImpl(256 | 512)]
    public static float3x2 operator %(float3x2 a, float3x2 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1);

    [MethodImpl(256 | 512)]
    public static float3x2 operator %(float3x2 a, float b) => 
        new(a.c0 % b, a.c1 % b);

    [MethodImpl(256 | 512)]
    public static float3x2 operator --(float3x2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static float3x2 operator ++(float3x2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float3x2 abs(this float3x2 a) => 
        new(a.c0.abs(), a.c1.abs());

    [MethodImpl(256 | 512)]
    public static float3x2 sign(this float3x2 a) => 
        new(a.c0.sign(), a.c1.sign());

    [MethodImpl(256 | 512)]
    public static float3x2 min(this float3x2 a, float3x2 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1));

    [MethodImpl(256 | 512)]
    public static float3x2 max(this float3x2 a, float3x2 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1));

    [MethodImpl(256 | 512)]
    public static float3x2 clamp(this float3x2 v, float3x2 min, float3x2 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1));

    [MethodImpl(256 | 512)]
    public static float3x2 square(this float3x2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float3x2 fma(this float3x2 a, float3x2 b, float3x2 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static float3x2 fms(this float3x2 a, float3x2 b, float3x2 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1));

    [MethodImpl(256 | 512)]
    public static float2 csum(this float3x2 a) => 
        new(a.c0.csum(), a.c1.csum());

    [MethodImpl(256 | 512)]
    public static float2 cmin(this float3x2 a) => 
        new(a.c0.cmin(), a.c1.cmin());

    [MethodImpl(256 | 512)]
    public static float2 cmax(this float3x2 a) => 
        new(a.c0.cmax(), a.c1.cmax());
}

#endregion // float3x2

#region float3x3

public partial struct float3x3
{
    [MethodImpl(256 | 512)]
    public static float3x3 operator +(float3x3 a) => a;

    [MethodImpl(256 | 512)]
    public static float3x3 operator -(float3x3 a) => 
        new(-a.c0, -a.c1, -a.c2);

    [MethodImpl(256 | 512)]
    public static float3x3 operator +(float3x3 a, float3x3 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2);

    [MethodImpl(256 | 512)]
    public static float3x3 operator -(float3x3 a, float3x3 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2);

    [MethodImpl(256 | 512)]
    public static float3x3 operator *(float3x3 a, float3x3 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2);

    [MethodImpl(256 | 512)]
    public static float3x3 operator *(float3x3 a, float b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b);

    [MethodImpl(256 | 512)]
    public static float3x3 operator *(float a, float3x3 b) => 
        new(a * b.c0, a * b.c1, a * b.c2);

    [MethodImpl(256 | 512)]
    public static float3x3 operator /(float3x3 a, float3x3 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2);

    [MethodImpl(256 | 512)]
    public static float3x3 operator /(float3x3 a, float b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b);

    [MethodImpl(256 | 512)]
    public static float3x3 operator %(float3x3 a, float3x3 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2);

    [MethodImpl(256 | 512)]
    public static float3x3 operator %(float3x3 a, float b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b);

    [MethodImpl(256 | 512)]
    public static float3x3 operator --(float3x3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static float3x3 operator ++(float3x3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float3x3 abs(this float3x3 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs());

    [MethodImpl(256 | 512)]
    public static float3x3 sign(this float3x3 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign());

    [MethodImpl(256 | 512)]
    public static float3x3 min(this float3x3 a, float3x3 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2));

    [MethodImpl(256 | 512)]
    public static float3x3 max(this float3x3 a, float3x3 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2));

    [MethodImpl(256 | 512)]
    public static float3x3 clamp(this float3x3 v, float3x3 min, float3x3 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2));

    [MethodImpl(256 | 512)]
    public static float3x3 square(this float3x3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float3x3 fma(this float3x3 a, float3x3 b, float3x3 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static float3x3 fms(this float3x3 a, float3x3 b, float3x3 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2));

    [MethodImpl(256 | 512)]
    public static float3 csum(this float3x3 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum());

    [MethodImpl(256 | 512)]
    public static float3 cmin(this float3x3 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin());

    [MethodImpl(256 | 512)]
    public static float3 cmax(this float3x3 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax());
}

#endregion // float3x3

#region float3x4

public partial struct float3x4
{
    [MethodImpl(256 | 512)]
    public static float3x4 operator +(float3x4 a) => a;

    [MethodImpl(256 | 512)]
    public static float3x4 operator -(float3x4 a) => 
        new(-a.c0, -a.c1, -a.c2, -a.c3);

    [MethodImpl(256 | 512)]
    public static float3x4 operator +(float3x4 a, float3x4 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2, a.c3 + b.c3);

    [MethodImpl(256 | 512)]
    public static float3x4 operator -(float3x4 a, float3x4 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2, a.c3 - b.c3);

    [MethodImpl(256 | 512)]
    public static float3x4 operator *(float3x4 a, float3x4 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2, a.c3 * b.c3);

    [MethodImpl(256 | 512)]
    public static float3x4 operator *(float3x4 a, float b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b, a.c3 * b);

    [MethodImpl(256 | 512)]
    public static float3x4 operator *(float a, float3x4 b) => 
        new(a * b.c0, a * b.c1, a * b.c2, a * b.c3);

    [MethodImpl(256 | 512)]
    public static float3x4 operator /(float3x4 a, float3x4 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2, a.c3 / b.c3);

    [MethodImpl(256 | 512)]
    public static float3x4 operator /(float3x4 a, float b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b, a.c3 / b);

    [MethodImpl(256 | 512)]
    public static float3x4 operator %(float3x4 a, float3x4 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2, a.c3 % b.c3);

    [MethodImpl(256 | 512)]
    public static float3x4 operator %(float3x4 a, float b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b, a.c3 % b);

    [MethodImpl(256 | 512)]
    public static float3x4 operator --(float3x4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static float3x4 operator ++(float3x4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float3x4 abs(this float3x4 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs(), a.c3.abs());

    [MethodImpl(256 | 512)]
    public static float3x4 sign(this float3x4 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign(), a.c3.sign());

    [MethodImpl(256 | 512)]
    public static float3x4 min(this float3x4 a, float3x4 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2), a.c3.min(b.c3));

    [MethodImpl(256 | 512)]
    public static float3x4 max(this float3x4 a, float3x4 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2), a.c3.max(b.c3));

    [MethodImpl(256 | 512)]
    public static float3x4 clamp(this float3x4 v, float3x4 min, float3x4 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2), v.c3.clamp(min.c3, max.c3));

    [MethodImpl(256 | 512)]
    public static float3x4 square(this float3x4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float3x4 fma(this float3x4 a, float3x4 b, float3x4 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2), a.c3.fma(b.c3, c.c3));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static float3x4 fms(this float3x4 a, float3x4 b, float3x4 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2), a.c3.fms(b.c3, c.c3));

    [MethodImpl(256 | 512)]
    public static float4 csum(this float3x4 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum(), a.c3.csum());

    [MethodImpl(256 | 512)]
    public static float4 cmin(this float3x4 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin(), a.c3.cmin());

    [MethodImpl(256 | 512)]
    public static float4 cmax(this float3x4 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax(), a.c3.cmax());
}

#endregion // float3x4

#region float4x2

public partial struct float4x2
{
    [MethodImpl(256 | 512)]
    public static float4x2 operator +(float4x2 a) => a;

    [MethodImpl(256 | 512)]
    public static float4x2 operator -(float4x2 a) => 
        new(-a.c0, -a.c1);

    [MethodImpl(256 | 512)]
    public static float4x2 operator +(float4x2 a, float4x2 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1);

    [MethodImpl(256 | 512)]
    public static float4x2 operator -(float4x2 a, float4x2 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1);

    [MethodImpl(256 | 512)]
    public static float4x2 operator *(float4x2 a, float4x2 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1);

    [MethodImpl(256 | 512)]
    public static float4x2 operator *(float4x2 a, float b) => 
        new(a.c0 * b, a.c1 * b);

    [MethodImpl(256 | 512)]
    public static float4x2 operator *(float a, float4x2 b) => 
        new(a * b.c0, a * b.c1);

    [MethodImpl(256 | 512)]
    public static float4x2 operator /(float4x2 a, float4x2 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1);

    [MethodImpl(256 | 512)]
    public static float4x2 operator /(float4x2 a, float b) => 
        new(a.c0 / b, a.c1 / b);

    [MethodImpl(256 | 512)]
    public static float4x2 operator %(float4x2 a, float4x2 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1);

    [MethodImpl(256 | 512)]
    public static float4x2 operator %(float4x2 a, float b) => 
        new(a.c0 % b, a.c1 % b);

    [MethodImpl(256 | 512)]
    public static float4x2 operator --(float4x2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static float4x2 operator ++(float4x2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float4x2 abs(this float4x2 a) => 
        new(a.c0.abs(), a.c1.abs());

    [MethodImpl(256 | 512)]
    public static float4x2 sign(this float4x2 a) => 
        new(a.c0.sign(), a.c1.sign());

    [MethodImpl(256 | 512)]
    public static float4x2 min(this float4x2 a, float4x2 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1));

    [MethodImpl(256 | 512)]
    public static float4x2 max(this float4x2 a, float4x2 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1));

    [MethodImpl(256 | 512)]
    public static float4x2 clamp(this float4x2 v, float4x2 min, float4x2 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1));

    [MethodImpl(256 | 512)]
    public static float4x2 square(this float4x2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float4x2 fma(this float4x2 a, float4x2 b, float4x2 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static float4x2 fms(this float4x2 a, float4x2 b, float4x2 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1));

    [MethodImpl(256 | 512)]
    public static float2 csum(this float4x2 a) => 
        new(a.c0.csum(), a.c1.csum());

    [MethodImpl(256 | 512)]
    public static float2 cmin(this float4x2 a) => 
        new(a.c0.cmin(), a.c1.cmin());

    [MethodImpl(256 | 512)]
    public static float2 cmax(this float4x2 a) => 
        new(a.c0.cmax(), a.c1.cmax());
}

#endregion // float4x2

#region float4x3

public partial struct float4x3
{
    [MethodImpl(256 | 512)]
    public static float4x3 operator +(float4x3 a) => a;

    [MethodImpl(256 | 512)]
    public static float4x3 operator -(float4x3 a) => 
        new(-a.c0, -a.c1, -a.c2);

    [MethodImpl(256 | 512)]
    public static float4x3 operator +(float4x3 a, float4x3 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2);

    [MethodImpl(256 | 512)]
    public static float4x3 operator -(float4x3 a, float4x3 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2);

    [MethodImpl(256 | 512)]
    public static float4x3 operator *(float4x3 a, float4x3 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2);

    [MethodImpl(256 | 512)]
    public static float4x3 operator *(float4x3 a, float b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b);

    [MethodImpl(256 | 512)]
    public static float4x3 operator *(float a, float4x3 b) => 
        new(a * b.c0, a * b.c1, a * b.c2);

    [MethodImpl(256 | 512)]
    public static float4x3 operator /(float4x3 a, float4x3 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2);

    [MethodImpl(256 | 512)]
    public static float4x3 operator /(float4x3 a, float b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b);

    [MethodImpl(256 | 512)]
    public static float4x3 operator %(float4x3 a, float4x3 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2);

    [MethodImpl(256 | 512)]
    public static float4x3 operator %(float4x3 a, float b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b);

    [MethodImpl(256 | 512)]
    public static float4x3 operator --(float4x3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static float4x3 operator ++(float4x3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float4x3 abs(this float4x3 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs());

    [MethodImpl(256 | 512)]
    public static float4x3 sign(this float4x3 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign());

    [MethodImpl(256 | 512)]
    public static float4x3 min(this float4x3 a, float4x3 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2));

    [MethodImpl(256 | 512)]
    public static float4x3 max(this float4x3 a, float4x3 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2));

    [MethodImpl(256 | 512)]
    public static float4x3 clamp(this float4x3 v, float4x3 min, float4x3 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2));

    [MethodImpl(256 | 512)]
    public static float4x3 square(this float4x3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float4x3 fma(this float4x3 a, float4x3 b, float4x3 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static float4x3 fms(this float4x3 a, float4x3 b, float4x3 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2));

    [MethodImpl(256 | 512)]
    public static float3 csum(this float4x3 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum());

    [MethodImpl(256 | 512)]
    public static float3 cmin(this float4x3 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin());

    [MethodImpl(256 | 512)]
    public static float3 cmax(this float4x3 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax());
}

#endregion // float4x3

#region float4x4

public partial struct float4x4
{
    [MethodImpl(256 | 512)]
    public static float4x4 operator +(float4x4 a) => a;

    [MethodImpl(256 | 512)]
    public static float4x4 operator -(float4x4 a) => 
        new(-a.c0, -a.c1, -a.c2, -a.c3);

    [MethodImpl(256 | 512)]
    public static float4x4 operator +(float4x4 a, float4x4 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2, a.c3 + b.c3);

    [MethodImpl(256 | 512)]
    public static float4x4 operator -(float4x4 a, float4x4 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2, a.c3 - b.c3);

    [MethodImpl(256 | 512)]
    public static float4x4 operator *(float4x4 a, float4x4 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2, a.c3 * b.c3);

    [MethodImpl(256 | 512)]
    public static float4x4 operator *(float4x4 a, float b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b, a.c3 * b);

    [MethodImpl(256 | 512)]
    public static float4x4 operator *(float a, float4x4 b) => 
        new(a * b.c0, a * b.c1, a * b.c2, a * b.c3);

    [MethodImpl(256 | 512)]
    public static float4x4 operator /(float4x4 a, float4x4 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2, a.c3 / b.c3);

    [MethodImpl(256 | 512)]
    public static float4x4 operator /(float4x4 a, float b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b, a.c3 / b);

    [MethodImpl(256 | 512)]
    public static float4x4 operator %(float4x4 a, float4x4 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2, a.c3 % b.c3);

    [MethodImpl(256 | 512)]
    public static float4x4 operator %(float4x4 a, float b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b, a.c3 % b);

    [MethodImpl(256 | 512)]
    public static float4x4 operator --(float4x4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static float4x4 operator ++(float4x4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float4x4 abs(this float4x4 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs(), a.c3.abs());

    [MethodImpl(256 | 512)]
    public static float4x4 sign(this float4x4 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign(), a.c3.sign());

    [MethodImpl(256 | 512)]
    public static float4x4 min(this float4x4 a, float4x4 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2), a.c3.min(b.c3));

    [MethodImpl(256 | 512)]
    public static float4x4 max(this float4x4 a, float4x4 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2), a.c3.max(b.c3));

    [MethodImpl(256 | 512)]
    public static float4x4 clamp(this float4x4 v, float4x4 min, float4x4 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2), v.c3.clamp(min.c3, max.c3));

    [MethodImpl(256 | 512)]
    public static float4x4 square(this float4x4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float4x4 fma(this float4x4 a, float4x4 b, float4x4 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2), a.c3.fma(b.c3, c.c3));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static float4x4 fms(this float4x4 a, float4x4 b, float4x4 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2), a.c3.fms(b.c3, c.c3));

    [MethodImpl(256 | 512)]
    public static float4 csum(this float4x4 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum(), a.c3.csum());

    [MethodImpl(256 | 512)]
    public static float4 cmin(this float4x4 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin(), a.c3.cmin());

    [MethodImpl(256 | 512)]
    public static float4 cmax(this float4x4 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax(), a.c3.cmax());
}

#endregion // float4x4

#region double2x2

public partial struct double2x2
{
    [MethodImpl(256 | 512)]
    public static double2x2 operator +(double2x2 a) => a;

    [MethodImpl(256 | 512)]
    public static double2x2 operator -(double2x2 a) => 
        new(-a.c0, -a.c1);

    [MethodImpl(256 | 512)]
    public static double2x2 operator +(double2x2 a, double2x2 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1);

    [MethodImpl(256 | 512)]
    public static double2x2 operator -(double2x2 a, double2x2 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1);

    [MethodImpl(256 | 512)]
    public static double2x2 operator *(double2x2 a, double2x2 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1);

    [MethodImpl(256 | 512)]
    public static double2x2 operator *(double2x2 a, double b) => 
        new(a.c0 * b, a.c1 * b);

    [MethodImpl(256 | 512)]
    public static double2x2 operator *(double a, double2x2 b) => 
        new(a * b.c0, a * b.c1);

    [MethodImpl(256 | 512)]
    public static double2x2 operator /(double2x2 a, double2x2 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1);

    [MethodImpl(256 | 512)]
    public static double2x2 operator /(double2x2 a, double b) => 
        new(a.c0 / b, a.c1 / b);

    [MethodImpl(256 | 512)]
    public static double2x2 operator %(double2x2 a, double2x2 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1);

    [MethodImpl(256 | 512)]
    public static double2x2 operator %(double2x2 a, double b) => 
        new(a.c0 % b, a.c1 % b);

    [MethodImpl(256 | 512)]
    public static double2x2 operator --(double2x2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static double2x2 operator ++(double2x2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double2x2 abs(this double2x2 a) => 
        new(a.c0.abs(), a.c1.abs());

    [MethodImpl(256 | 512)]
    public static double2x2 sign(this double2x2 a) => 
        new(a.c0.sign(), a.c1.sign());

    [MethodImpl(256 | 512)]
    public static double2x2 min(this double2x2 a, double2x2 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1));

    [MethodImpl(256 | 512)]
    public static double2x2 max(this double2x2 a, double2x2 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1));

    [MethodImpl(256 | 512)]
    public static double2x2 clamp(this double2x2 v, double2x2 min, double2x2 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1));

    [MethodImpl(256 | 512)]
    public static double2x2 square(this double2x2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double2x2 fma(this double2x2 a, double2x2 b, double2x2 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static double2x2 fms(this double2x2 a, double2x2 b, double2x2 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1));

    [MethodImpl(256 | 512)]
    public static double2 csum(this double2x2 a) => 
        new(a.c0.csum(), a.c1.csum());

    [MethodImpl(256 | 512)]
    public static double2 cmin(this double2x2 a) => 
        new(a.c0.cmin(), a.c1.cmin());

    [MethodImpl(256 | 512)]
    public static double2 cmax(this double2x2 a) => 
        new(a.c0.cmax(), a.c1.cmax());
}

#endregion // double2x2

#region double2x3

public partial struct double2x3
{
    [MethodImpl(256 | 512)]
    public static double2x3 operator +(double2x3 a) => a;

    [MethodImpl(256 | 512)]
    public static double2x3 operator -(double2x3 a) => 
        new(-a.c0, -a.c1, -a.c2);

    [MethodImpl(256 | 512)]
    public static double2x3 operator +(double2x3 a, double2x3 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2);

    [MethodImpl(256 | 512)]
    public static double2x3 operator -(double2x3 a, double2x3 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2);

    [MethodImpl(256 | 512)]
    public static double2x3 operator *(double2x3 a, double2x3 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2);

    [MethodImpl(256 | 512)]
    public static double2x3 operator *(double2x3 a, double b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b);

    [MethodImpl(256 | 512)]
    public static double2x3 operator *(double a, double2x3 b) => 
        new(a * b.c0, a * b.c1, a * b.c2);

    [MethodImpl(256 | 512)]
    public static double2x3 operator /(double2x3 a, double2x3 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2);

    [MethodImpl(256 | 512)]
    public static double2x3 operator /(double2x3 a, double b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b);

    [MethodImpl(256 | 512)]
    public static double2x3 operator %(double2x3 a, double2x3 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2);

    [MethodImpl(256 | 512)]
    public static double2x3 operator %(double2x3 a, double b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b);

    [MethodImpl(256 | 512)]
    public static double2x3 operator --(double2x3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static double2x3 operator ++(double2x3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double2x3 abs(this double2x3 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs());

    [MethodImpl(256 | 512)]
    public static double2x3 sign(this double2x3 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign());

    [MethodImpl(256 | 512)]
    public static double2x3 min(this double2x3 a, double2x3 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2));

    [MethodImpl(256 | 512)]
    public static double2x3 max(this double2x3 a, double2x3 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2));

    [MethodImpl(256 | 512)]
    public static double2x3 clamp(this double2x3 v, double2x3 min, double2x3 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2));

    [MethodImpl(256 | 512)]
    public static double2x3 square(this double2x3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double2x3 fma(this double2x3 a, double2x3 b, double2x3 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static double2x3 fms(this double2x3 a, double2x3 b, double2x3 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2));

    [MethodImpl(256 | 512)]
    public static double3 csum(this double2x3 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum());

    [MethodImpl(256 | 512)]
    public static double3 cmin(this double2x3 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin());

    [MethodImpl(256 | 512)]
    public static double3 cmax(this double2x3 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax());
}

#endregion // double2x3

#region double2x4

public partial struct double2x4
{
    [MethodImpl(256 | 512)]
    public static double2x4 operator +(double2x4 a) => a;

    [MethodImpl(256 | 512)]
    public static double2x4 operator -(double2x4 a) => 
        new(-a.c0, -a.c1, -a.c2, -a.c3);

    [MethodImpl(256 | 512)]
    public static double2x4 operator +(double2x4 a, double2x4 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2, a.c3 + b.c3);

    [MethodImpl(256 | 512)]
    public static double2x4 operator -(double2x4 a, double2x4 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2, a.c3 - b.c3);

    [MethodImpl(256 | 512)]
    public static double2x4 operator *(double2x4 a, double2x4 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2, a.c3 * b.c3);

    [MethodImpl(256 | 512)]
    public static double2x4 operator *(double2x4 a, double b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b, a.c3 * b);

    [MethodImpl(256 | 512)]
    public static double2x4 operator *(double a, double2x4 b) => 
        new(a * b.c0, a * b.c1, a * b.c2, a * b.c3);

    [MethodImpl(256 | 512)]
    public static double2x4 operator /(double2x4 a, double2x4 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2, a.c3 / b.c3);

    [MethodImpl(256 | 512)]
    public static double2x4 operator /(double2x4 a, double b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b, a.c3 / b);

    [MethodImpl(256 | 512)]
    public static double2x4 operator %(double2x4 a, double2x4 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2, a.c3 % b.c3);

    [MethodImpl(256 | 512)]
    public static double2x4 operator %(double2x4 a, double b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b, a.c3 % b);

    [MethodImpl(256 | 512)]
    public static double2x4 operator --(double2x4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static double2x4 operator ++(double2x4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double2x4 abs(this double2x4 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs(), a.c3.abs());

    [MethodImpl(256 | 512)]
    public static double2x4 sign(this double2x4 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign(), a.c3.sign());

    [MethodImpl(256 | 512)]
    public static double2x4 min(this double2x4 a, double2x4 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2), a.c3.min(b.c3));

    [MethodImpl(256 | 512)]
    public static double2x4 max(this double2x4 a, double2x4 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2), a.c3.max(b.c3));

    [MethodImpl(256 | 512)]
    public static double2x4 clamp(this double2x4 v, double2x4 min, double2x4 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2), v.c3.clamp(min.c3, max.c3));

    [MethodImpl(256 | 512)]
    public static double2x4 square(this double2x4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double2x4 fma(this double2x4 a, double2x4 b, double2x4 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2), a.c3.fma(b.c3, c.c3));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static double2x4 fms(this double2x4 a, double2x4 b, double2x4 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2), a.c3.fms(b.c3, c.c3));

    [MethodImpl(256 | 512)]
    public static double4 csum(this double2x4 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum(), a.c3.csum());

    [MethodImpl(256 | 512)]
    public static double4 cmin(this double2x4 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin(), a.c3.cmin());

    [MethodImpl(256 | 512)]
    public static double4 cmax(this double2x4 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax(), a.c3.cmax());
}

#endregion // double2x4

#region double3x2

public partial struct double3x2
{
    [MethodImpl(256 | 512)]
    public static double3x2 operator +(double3x2 a) => a;

    [MethodImpl(256 | 512)]
    public static double3x2 operator -(double3x2 a) => 
        new(-a.c0, -a.c1);

    [MethodImpl(256 | 512)]
    public static double3x2 operator +(double3x2 a, double3x2 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1);

    [MethodImpl(256 | 512)]
    public static double3x2 operator -(double3x2 a, double3x2 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1);

    [MethodImpl(256 | 512)]
    public static double3x2 operator *(double3x2 a, double3x2 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1);

    [MethodImpl(256 | 512)]
    public static double3x2 operator *(double3x2 a, double b) => 
        new(a.c0 * b, a.c1 * b);

    [MethodImpl(256 | 512)]
    public static double3x2 operator *(double a, double3x2 b) => 
        new(a * b.c0, a * b.c1);

    [MethodImpl(256 | 512)]
    public static double3x2 operator /(double3x2 a, double3x2 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1);

    [MethodImpl(256 | 512)]
    public static double3x2 operator /(double3x2 a, double b) => 
        new(a.c0 / b, a.c1 / b);

    [MethodImpl(256 | 512)]
    public static double3x2 operator %(double3x2 a, double3x2 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1);

    [MethodImpl(256 | 512)]
    public static double3x2 operator %(double3x2 a, double b) => 
        new(a.c0 % b, a.c1 % b);

    [MethodImpl(256 | 512)]
    public static double3x2 operator --(double3x2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static double3x2 operator ++(double3x2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double3x2 abs(this double3x2 a) => 
        new(a.c0.abs(), a.c1.abs());

    [MethodImpl(256 | 512)]
    public static double3x2 sign(this double3x2 a) => 
        new(a.c0.sign(), a.c1.sign());

    [MethodImpl(256 | 512)]
    public static double3x2 min(this double3x2 a, double3x2 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1));

    [MethodImpl(256 | 512)]
    public static double3x2 max(this double3x2 a, double3x2 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1));

    [MethodImpl(256 | 512)]
    public static double3x2 clamp(this double3x2 v, double3x2 min, double3x2 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1));

    [MethodImpl(256 | 512)]
    public static double3x2 square(this double3x2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double3x2 fma(this double3x2 a, double3x2 b, double3x2 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static double3x2 fms(this double3x2 a, double3x2 b, double3x2 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1));

    [MethodImpl(256 | 512)]
    public static double2 csum(this double3x2 a) => 
        new(a.c0.csum(), a.c1.csum());

    [MethodImpl(256 | 512)]
    public static double2 cmin(this double3x2 a) => 
        new(a.c0.cmin(), a.c1.cmin());

    [MethodImpl(256 | 512)]
    public static double2 cmax(this double3x2 a) => 
        new(a.c0.cmax(), a.c1.cmax());
}

#endregion // double3x2

#region double3x3

public partial struct double3x3
{
    [MethodImpl(256 | 512)]
    public static double3x3 operator +(double3x3 a) => a;

    [MethodImpl(256 | 512)]
    public static double3x3 operator -(double3x3 a) => 
        new(-a.c0, -a.c1, -a.c2);

    [MethodImpl(256 | 512)]
    public static double3x3 operator +(double3x3 a, double3x3 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2);

    [MethodImpl(256 | 512)]
    public static double3x3 operator -(double3x3 a, double3x3 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2);

    [MethodImpl(256 | 512)]
    public static double3x3 operator *(double3x3 a, double3x3 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2);

    [MethodImpl(256 | 512)]
    public static double3x3 operator *(double3x3 a, double b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b);

    [MethodImpl(256 | 512)]
    public static double3x3 operator *(double a, double3x3 b) => 
        new(a * b.c0, a * b.c1, a * b.c2);

    [MethodImpl(256 | 512)]
    public static double3x3 operator /(double3x3 a, double3x3 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2);

    [MethodImpl(256 | 512)]
    public static double3x3 operator /(double3x3 a, double b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b);

    [MethodImpl(256 | 512)]
    public static double3x3 operator %(double3x3 a, double3x3 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2);

    [MethodImpl(256 | 512)]
    public static double3x3 operator %(double3x3 a, double b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b);

    [MethodImpl(256 | 512)]
    public static double3x3 operator --(double3x3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static double3x3 operator ++(double3x3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double3x3 abs(this double3x3 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs());

    [MethodImpl(256 | 512)]
    public static double3x3 sign(this double3x3 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign());

    [MethodImpl(256 | 512)]
    public static double3x3 min(this double3x3 a, double3x3 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2));

    [MethodImpl(256 | 512)]
    public static double3x3 max(this double3x3 a, double3x3 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2));

    [MethodImpl(256 | 512)]
    public static double3x3 clamp(this double3x3 v, double3x3 min, double3x3 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2));

    [MethodImpl(256 | 512)]
    public static double3x3 square(this double3x3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double3x3 fma(this double3x3 a, double3x3 b, double3x3 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static double3x3 fms(this double3x3 a, double3x3 b, double3x3 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2));

    [MethodImpl(256 | 512)]
    public static double3 csum(this double3x3 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum());

    [MethodImpl(256 | 512)]
    public static double3 cmin(this double3x3 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin());

    [MethodImpl(256 | 512)]
    public static double3 cmax(this double3x3 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax());
}

#endregion // double3x3

#region double3x4

public partial struct double3x4
{
    [MethodImpl(256 | 512)]
    public static double3x4 operator +(double3x4 a) => a;

    [MethodImpl(256 | 512)]
    public static double3x4 operator -(double3x4 a) => 
        new(-a.c0, -a.c1, -a.c2, -a.c3);

    [MethodImpl(256 | 512)]
    public static double3x4 operator +(double3x4 a, double3x4 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2, a.c3 + b.c3);

    [MethodImpl(256 | 512)]
    public static double3x4 operator -(double3x4 a, double3x4 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2, a.c3 - b.c3);

    [MethodImpl(256 | 512)]
    public static double3x4 operator *(double3x4 a, double3x4 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2, a.c3 * b.c3);

    [MethodImpl(256 | 512)]
    public static double3x4 operator *(double3x4 a, double b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b, a.c3 * b);

    [MethodImpl(256 | 512)]
    public static double3x4 operator *(double a, double3x4 b) => 
        new(a * b.c0, a * b.c1, a * b.c2, a * b.c3);

    [MethodImpl(256 | 512)]
    public static double3x4 operator /(double3x4 a, double3x4 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2, a.c3 / b.c3);

    [MethodImpl(256 | 512)]
    public static double3x4 operator /(double3x4 a, double b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b, a.c3 / b);

    [MethodImpl(256 | 512)]
    public static double3x4 operator %(double3x4 a, double3x4 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2, a.c3 % b.c3);

    [MethodImpl(256 | 512)]
    public static double3x4 operator %(double3x4 a, double b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b, a.c3 % b);

    [MethodImpl(256 | 512)]
    public static double3x4 operator --(double3x4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static double3x4 operator ++(double3x4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double3x4 abs(this double3x4 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs(), a.c3.abs());

    [MethodImpl(256 | 512)]
    public static double3x4 sign(this double3x4 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign(), a.c3.sign());

    [MethodImpl(256 | 512)]
    public static double3x4 min(this double3x4 a, double3x4 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2), a.c3.min(b.c3));

    [MethodImpl(256 | 512)]
    public static double3x4 max(this double3x4 a, double3x4 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2), a.c3.max(b.c3));

    [MethodImpl(256 | 512)]
    public static double3x4 clamp(this double3x4 v, double3x4 min, double3x4 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2), v.c3.clamp(min.c3, max.c3));

    [MethodImpl(256 | 512)]
    public static double3x4 square(this double3x4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double3x4 fma(this double3x4 a, double3x4 b, double3x4 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2), a.c3.fma(b.c3, c.c3));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static double3x4 fms(this double3x4 a, double3x4 b, double3x4 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2), a.c3.fms(b.c3, c.c3));

    [MethodImpl(256 | 512)]
    public static double4 csum(this double3x4 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum(), a.c3.csum());

    [MethodImpl(256 | 512)]
    public static double4 cmin(this double3x4 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin(), a.c3.cmin());

    [MethodImpl(256 | 512)]
    public static double4 cmax(this double3x4 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax(), a.c3.cmax());
}

#endregion // double3x4

#region double4x2

public partial struct double4x2
{
    [MethodImpl(256 | 512)]
    public static double4x2 operator +(double4x2 a) => a;

    [MethodImpl(256 | 512)]
    public static double4x2 operator -(double4x2 a) => 
        new(-a.c0, -a.c1);

    [MethodImpl(256 | 512)]
    public static double4x2 operator +(double4x2 a, double4x2 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1);

    [MethodImpl(256 | 512)]
    public static double4x2 operator -(double4x2 a, double4x2 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1);

    [MethodImpl(256 | 512)]
    public static double4x2 operator *(double4x2 a, double4x2 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1);

    [MethodImpl(256 | 512)]
    public static double4x2 operator *(double4x2 a, double b) => 
        new(a.c0 * b, a.c1 * b);

    [MethodImpl(256 | 512)]
    public static double4x2 operator *(double a, double4x2 b) => 
        new(a * b.c0, a * b.c1);

    [MethodImpl(256 | 512)]
    public static double4x2 operator /(double4x2 a, double4x2 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1);

    [MethodImpl(256 | 512)]
    public static double4x2 operator /(double4x2 a, double b) => 
        new(a.c0 / b, a.c1 / b);

    [MethodImpl(256 | 512)]
    public static double4x2 operator %(double4x2 a, double4x2 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1);

    [MethodImpl(256 | 512)]
    public static double4x2 operator %(double4x2 a, double b) => 
        new(a.c0 % b, a.c1 % b);

    [MethodImpl(256 | 512)]
    public static double4x2 operator --(double4x2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static double4x2 operator ++(double4x2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double4x2 abs(this double4x2 a) => 
        new(a.c0.abs(), a.c1.abs());

    [MethodImpl(256 | 512)]
    public static double4x2 sign(this double4x2 a) => 
        new(a.c0.sign(), a.c1.sign());

    [MethodImpl(256 | 512)]
    public static double4x2 min(this double4x2 a, double4x2 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1));

    [MethodImpl(256 | 512)]
    public static double4x2 max(this double4x2 a, double4x2 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1));

    [MethodImpl(256 | 512)]
    public static double4x2 clamp(this double4x2 v, double4x2 min, double4x2 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1));

    [MethodImpl(256 | 512)]
    public static double4x2 square(this double4x2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double4x2 fma(this double4x2 a, double4x2 b, double4x2 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static double4x2 fms(this double4x2 a, double4x2 b, double4x2 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1));

    [MethodImpl(256 | 512)]
    public static double2 csum(this double4x2 a) => 
        new(a.c0.csum(), a.c1.csum());

    [MethodImpl(256 | 512)]
    public static double2 cmin(this double4x2 a) => 
        new(a.c0.cmin(), a.c1.cmin());

    [MethodImpl(256 | 512)]
    public static double2 cmax(this double4x2 a) => 
        new(a.c0.cmax(), a.c1.cmax());
}

#endregion // double4x2

#region double4x3

public partial struct double4x3
{
    [MethodImpl(256 | 512)]
    public static double4x3 operator +(double4x3 a) => a;

    [MethodImpl(256 | 512)]
    public static double4x3 operator -(double4x3 a) => 
        new(-a.c0, -a.c1, -a.c2);

    [MethodImpl(256 | 512)]
    public static double4x3 operator +(double4x3 a, double4x3 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2);

    [MethodImpl(256 | 512)]
    public static double4x3 operator -(double4x3 a, double4x3 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2);

    [MethodImpl(256 | 512)]
    public static double4x3 operator *(double4x3 a, double4x3 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2);

    [MethodImpl(256 | 512)]
    public static double4x3 operator *(double4x3 a, double b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b);

    [MethodImpl(256 | 512)]
    public static double4x3 operator *(double a, double4x3 b) => 
        new(a * b.c0, a * b.c1, a * b.c2);

    [MethodImpl(256 | 512)]
    public static double4x3 operator /(double4x3 a, double4x3 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2);

    [MethodImpl(256 | 512)]
    public static double4x3 operator /(double4x3 a, double b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b);

    [MethodImpl(256 | 512)]
    public static double4x3 operator %(double4x3 a, double4x3 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2);

    [MethodImpl(256 | 512)]
    public static double4x3 operator %(double4x3 a, double b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b);

    [MethodImpl(256 | 512)]
    public static double4x3 operator --(double4x3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static double4x3 operator ++(double4x3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double4x3 abs(this double4x3 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs());

    [MethodImpl(256 | 512)]
    public static double4x3 sign(this double4x3 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign());

    [MethodImpl(256 | 512)]
    public static double4x3 min(this double4x3 a, double4x3 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2));

    [MethodImpl(256 | 512)]
    public static double4x3 max(this double4x3 a, double4x3 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2));

    [MethodImpl(256 | 512)]
    public static double4x3 clamp(this double4x3 v, double4x3 min, double4x3 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2));

    [MethodImpl(256 | 512)]
    public static double4x3 square(this double4x3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double4x3 fma(this double4x3 a, double4x3 b, double4x3 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static double4x3 fms(this double4x3 a, double4x3 b, double4x3 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2));

    [MethodImpl(256 | 512)]
    public static double3 csum(this double4x3 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum());

    [MethodImpl(256 | 512)]
    public static double3 cmin(this double4x3 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin());

    [MethodImpl(256 | 512)]
    public static double3 cmax(this double4x3 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax());
}

#endregion // double4x3

#region double4x4

public partial struct double4x4
{
    [MethodImpl(256 | 512)]
    public static double4x4 operator +(double4x4 a) => a;

    [MethodImpl(256 | 512)]
    public static double4x4 operator -(double4x4 a) => 
        new(-a.c0, -a.c1, -a.c2, -a.c3);

    [MethodImpl(256 | 512)]
    public static double4x4 operator +(double4x4 a, double4x4 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2, a.c3 + b.c3);

    [MethodImpl(256 | 512)]
    public static double4x4 operator -(double4x4 a, double4x4 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2, a.c3 - b.c3);

    [MethodImpl(256 | 512)]
    public static double4x4 operator *(double4x4 a, double4x4 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2, a.c3 * b.c3);

    [MethodImpl(256 | 512)]
    public static double4x4 operator *(double4x4 a, double b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b, a.c3 * b);

    [MethodImpl(256 | 512)]
    public static double4x4 operator *(double a, double4x4 b) => 
        new(a * b.c0, a * b.c1, a * b.c2, a * b.c3);

    [MethodImpl(256 | 512)]
    public static double4x4 operator /(double4x4 a, double4x4 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2, a.c3 / b.c3);

    [MethodImpl(256 | 512)]
    public static double4x4 operator /(double4x4 a, double b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b, a.c3 / b);

    [MethodImpl(256 | 512)]
    public static double4x4 operator %(double4x4 a, double4x4 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2, a.c3 % b.c3);

    [MethodImpl(256 | 512)]
    public static double4x4 operator %(double4x4 a, double b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b, a.c3 % b);

    [MethodImpl(256 | 512)]
    public static double4x4 operator --(double4x4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static double4x4 operator ++(double4x4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double4x4 abs(this double4x4 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs(), a.c3.abs());

    [MethodImpl(256 | 512)]
    public static double4x4 sign(this double4x4 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign(), a.c3.sign());

    [MethodImpl(256 | 512)]
    public static double4x4 min(this double4x4 a, double4x4 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2), a.c3.min(b.c3));

    [MethodImpl(256 | 512)]
    public static double4x4 max(this double4x4 a, double4x4 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2), a.c3.max(b.c3));

    [MethodImpl(256 | 512)]
    public static double4x4 clamp(this double4x4 v, double4x4 min, double4x4 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2), v.c3.clamp(min.c3, max.c3));

    [MethodImpl(256 | 512)]
    public static double4x4 square(this double4x4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double4x4 fma(this double4x4 a, double4x4 b, double4x4 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2), a.c3.fma(b.c3, c.c3));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static double4x4 fms(this double4x4 a, double4x4 b, double4x4 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2), a.c3.fms(b.c3, c.c3));

    [MethodImpl(256 | 512)]
    public static double4 csum(this double4x4 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum(), a.c3.csum());

    [MethodImpl(256 | 512)]
    public static double4 cmin(this double4x4 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin(), a.c3.cmin());

    [MethodImpl(256 | 512)]
    public static double4 cmax(this double4x4 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax(), a.c3.cmax());
}

#endregion // double4x4

#region short2x2

public partial struct short2x2
{
    [MethodImpl(256 | 512)]
    public static short2x2 operator +(short2x2 a) => a;

    [MethodImpl(256 | 512)]
    public static short2x2 operator -(short2x2 a) => 
        new(-a.c0, -a.c1);

    [MethodImpl(256 | 512)]
    public static short2x2 operator +(short2x2 a, short2x2 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1);

    [MethodImpl(256 | 512)]
    public static short2x2 operator -(short2x2 a, short2x2 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1);

    [MethodImpl(256 | 512)]
    public static short2x2 operator *(short2x2 a, short2x2 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1);

    [MethodImpl(256 | 512)]
    public static short2x2 operator *(short2x2 a, short b) => 
        new(a.c0 * b, a.c1 * b);

    [MethodImpl(256 | 512)]
    public static short2x2 operator *(short a, short2x2 b) => 
        new(a * b.c0, a * b.c1);

    [MethodImpl(256 | 512)]
    public static short2x2 operator /(short2x2 a, short2x2 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1);

    [MethodImpl(256 | 512)]
    public static short2x2 operator /(short2x2 a, short b) => 
        new(a.c0 / b, a.c1 / b);

    [MethodImpl(256 | 512)]
    public static short2x2 operator %(short2x2 a, short2x2 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1);

    [MethodImpl(256 | 512)]
    public static short2x2 operator %(short2x2 a, short b) => 
        new(a.c0 % b, a.c1 % b);

    [MethodImpl(256 | 512)]
    public static short2x2 operator --(short2x2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static short2x2 operator ++(short2x2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static short2x2 abs(this short2x2 a) => 
        new(a.c0.abs(), a.c1.abs());

    [MethodImpl(256 | 512)]
    public static short2x2 sign(this short2x2 a) => 
        new(a.c0.sign(), a.c1.sign());

    [MethodImpl(256 | 512)]
    public static short2x2 min(this short2x2 a, short2x2 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1));

    [MethodImpl(256 | 512)]
    public static short2x2 max(this short2x2 a, short2x2 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1));

    [MethodImpl(256 | 512)]
    public static short2x2 clamp(this short2x2 v, short2x2 min, short2x2 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1));

    [MethodImpl(256 | 512)]
    public static short2x2 square(this short2x2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static short2x2 fma(this short2x2 a, short2x2 b, short2x2 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static short2x2 fms(this short2x2 a, short2x2 b, short2x2 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1));

    [MethodImpl(256 | 512)]
    public static short2 csum(this short2x2 a) => 
        new(a.c0.csum(), a.c1.csum());

    [MethodImpl(256 | 512)]
    public static short2 cmin(this short2x2 a) => 
        new(a.c0.cmin(), a.c1.cmin());

    [MethodImpl(256 | 512)]
    public static short2 cmax(this short2x2 a) => 
        new(a.c0.cmax(), a.c1.cmax());
}

#endregion // short2x2

#region short2x3

public partial struct short2x3
{
    [MethodImpl(256 | 512)]
    public static short2x3 operator +(short2x3 a) => a;

    [MethodImpl(256 | 512)]
    public static short2x3 operator -(short2x3 a) => 
        new(-a.c0, -a.c1, -a.c2);

    [MethodImpl(256 | 512)]
    public static short2x3 operator +(short2x3 a, short2x3 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2);

    [MethodImpl(256 | 512)]
    public static short2x3 operator -(short2x3 a, short2x3 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2);

    [MethodImpl(256 | 512)]
    public static short2x3 operator *(short2x3 a, short2x3 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2);

    [MethodImpl(256 | 512)]
    public static short2x3 operator *(short2x3 a, short b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b);

    [MethodImpl(256 | 512)]
    public static short2x3 operator *(short a, short2x3 b) => 
        new(a * b.c0, a * b.c1, a * b.c2);

    [MethodImpl(256 | 512)]
    public static short2x3 operator /(short2x3 a, short2x3 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2);

    [MethodImpl(256 | 512)]
    public static short2x3 operator /(short2x3 a, short b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b);

    [MethodImpl(256 | 512)]
    public static short2x3 operator %(short2x3 a, short2x3 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2);

    [MethodImpl(256 | 512)]
    public static short2x3 operator %(short2x3 a, short b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b);

    [MethodImpl(256 | 512)]
    public static short2x3 operator --(short2x3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static short2x3 operator ++(short2x3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static short2x3 abs(this short2x3 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs());

    [MethodImpl(256 | 512)]
    public static short2x3 sign(this short2x3 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign());

    [MethodImpl(256 | 512)]
    public static short2x3 min(this short2x3 a, short2x3 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2));

    [MethodImpl(256 | 512)]
    public static short2x3 max(this short2x3 a, short2x3 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2));

    [MethodImpl(256 | 512)]
    public static short2x3 clamp(this short2x3 v, short2x3 min, short2x3 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2));

    [MethodImpl(256 | 512)]
    public static short2x3 square(this short2x3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static short2x3 fma(this short2x3 a, short2x3 b, short2x3 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static short2x3 fms(this short2x3 a, short2x3 b, short2x3 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2));

    [MethodImpl(256 | 512)]
    public static short3 csum(this short2x3 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum());

    [MethodImpl(256 | 512)]
    public static short3 cmin(this short2x3 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin());

    [MethodImpl(256 | 512)]
    public static short3 cmax(this short2x3 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax());
}

#endregion // short2x3

#region short2x4

public partial struct short2x4
{
    [MethodImpl(256 | 512)]
    public static short2x4 operator +(short2x4 a) => a;

    [MethodImpl(256 | 512)]
    public static short2x4 operator -(short2x4 a) => 
        new(-a.c0, -a.c1, -a.c2, -a.c3);

    [MethodImpl(256 | 512)]
    public static short2x4 operator +(short2x4 a, short2x4 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2, a.c3 + b.c3);

    [MethodImpl(256 | 512)]
    public static short2x4 operator -(short2x4 a, short2x4 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2, a.c3 - b.c3);

    [MethodImpl(256 | 512)]
    public static short2x4 operator *(short2x4 a, short2x4 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2, a.c3 * b.c3);

    [MethodImpl(256 | 512)]
    public static short2x4 operator *(short2x4 a, short b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b, a.c3 * b);

    [MethodImpl(256 | 512)]
    public static short2x4 operator *(short a, short2x4 b) => 
        new(a * b.c0, a * b.c1, a * b.c2, a * b.c3);

    [MethodImpl(256 | 512)]
    public static short2x4 operator /(short2x4 a, short2x4 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2, a.c3 / b.c3);

    [MethodImpl(256 | 512)]
    public static short2x4 operator /(short2x4 a, short b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b, a.c3 / b);

    [MethodImpl(256 | 512)]
    public static short2x4 operator %(short2x4 a, short2x4 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2, a.c3 % b.c3);

    [MethodImpl(256 | 512)]
    public static short2x4 operator %(short2x4 a, short b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b, a.c3 % b);

    [MethodImpl(256 | 512)]
    public static short2x4 operator --(short2x4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static short2x4 operator ++(short2x4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static short2x4 abs(this short2x4 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs(), a.c3.abs());

    [MethodImpl(256 | 512)]
    public static short2x4 sign(this short2x4 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign(), a.c3.sign());

    [MethodImpl(256 | 512)]
    public static short2x4 min(this short2x4 a, short2x4 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2), a.c3.min(b.c3));

    [MethodImpl(256 | 512)]
    public static short2x4 max(this short2x4 a, short2x4 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2), a.c3.max(b.c3));

    [MethodImpl(256 | 512)]
    public static short2x4 clamp(this short2x4 v, short2x4 min, short2x4 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2), v.c3.clamp(min.c3, max.c3));

    [MethodImpl(256 | 512)]
    public static short2x4 square(this short2x4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static short2x4 fma(this short2x4 a, short2x4 b, short2x4 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2), a.c3.fma(b.c3, c.c3));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static short2x4 fms(this short2x4 a, short2x4 b, short2x4 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2), a.c3.fms(b.c3, c.c3));

    [MethodImpl(256 | 512)]
    public static short4 csum(this short2x4 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum(), a.c3.csum());

    [MethodImpl(256 | 512)]
    public static short4 cmin(this short2x4 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin(), a.c3.cmin());

    [MethodImpl(256 | 512)]
    public static short4 cmax(this short2x4 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax(), a.c3.cmax());
}

#endregion // short2x4

#region short3x2

public partial struct short3x2
{
    [MethodImpl(256 | 512)]
    public static short3x2 operator +(short3x2 a) => a;

    [MethodImpl(256 | 512)]
    public static short3x2 operator -(short3x2 a) => 
        new(-a.c0, -a.c1);

    [MethodImpl(256 | 512)]
    public static short3x2 operator +(short3x2 a, short3x2 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1);

    [MethodImpl(256 | 512)]
    public static short3x2 operator -(short3x2 a, short3x2 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1);

    [MethodImpl(256 | 512)]
    public static short3x2 operator *(short3x2 a, short3x2 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1);

    [MethodImpl(256 | 512)]
    public static short3x2 operator *(short3x2 a, short b) => 
        new(a.c0 * b, a.c1 * b);

    [MethodImpl(256 | 512)]
    public static short3x2 operator *(short a, short3x2 b) => 
        new(a * b.c0, a * b.c1);

    [MethodImpl(256 | 512)]
    public static short3x2 operator /(short3x2 a, short3x2 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1);

    [MethodImpl(256 | 512)]
    public static short3x2 operator /(short3x2 a, short b) => 
        new(a.c0 / b, a.c1 / b);

    [MethodImpl(256 | 512)]
    public static short3x2 operator %(short3x2 a, short3x2 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1);

    [MethodImpl(256 | 512)]
    public static short3x2 operator %(short3x2 a, short b) => 
        new(a.c0 % b, a.c1 % b);

    [MethodImpl(256 | 512)]
    public static short3x2 operator --(short3x2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static short3x2 operator ++(short3x2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static short3x2 abs(this short3x2 a) => 
        new(a.c0.abs(), a.c1.abs());

    [MethodImpl(256 | 512)]
    public static short3x2 sign(this short3x2 a) => 
        new(a.c0.sign(), a.c1.sign());

    [MethodImpl(256 | 512)]
    public static short3x2 min(this short3x2 a, short3x2 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1));

    [MethodImpl(256 | 512)]
    public static short3x2 max(this short3x2 a, short3x2 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1));

    [MethodImpl(256 | 512)]
    public static short3x2 clamp(this short3x2 v, short3x2 min, short3x2 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1));

    [MethodImpl(256 | 512)]
    public static short3x2 square(this short3x2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static short3x2 fma(this short3x2 a, short3x2 b, short3x2 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static short3x2 fms(this short3x2 a, short3x2 b, short3x2 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1));

    [MethodImpl(256 | 512)]
    public static short2 csum(this short3x2 a) => 
        new(a.c0.csum(), a.c1.csum());

    [MethodImpl(256 | 512)]
    public static short2 cmin(this short3x2 a) => 
        new(a.c0.cmin(), a.c1.cmin());

    [MethodImpl(256 | 512)]
    public static short2 cmax(this short3x2 a) => 
        new(a.c0.cmax(), a.c1.cmax());
}

#endregion // short3x2

#region short3x3

public partial struct short3x3
{
    [MethodImpl(256 | 512)]
    public static short3x3 operator +(short3x3 a) => a;

    [MethodImpl(256 | 512)]
    public static short3x3 operator -(short3x3 a) => 
        new(-a.c0, -a.c1, -a.c2);

    [MethodImpl(256 | 512)]
    public static short3x3 operator +(short3x3 a, short3x3 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2);

    [MethodImpl(256 | 512)]
    public static short3x3 operator -(short3x3 a, short3x3 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2);

    [MethodImpl(256 | 512)]
    public static short3x3 operator *(short3x3 a, short3x3 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2);

    [MethodImpl(256 | 512)]
    public static short3x3 operator *(short3x3 a, short b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b);

    [MethodImpl(256 | 512)]
    public static short3x3 operator *(short a, short3x3 b) => 
        new(a * b.c0, a * b.c1, a * b.c2);

    [MethodImpl(256 | 512)]
    public static short3x3 operator /(short3x3 a, short3x3 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2);

    [MethodImpl(256 | 512)]
    public static short3x3 operator /(short3x3 a, short b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b);

    [MethodImpl(256 | 512)]
    public static short3x3 operator %(short3x3 a, short3x3 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2);

    [MethodImpl(256 | 512)]
    public static short3x3 operator %(short3x3 a, short b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b);

    [MethodImpl(256 | 512)]
    public static short3x3 operator --(short3x3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static short3x3 operator ++(short3x3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static short3x3 abs(this short3x3 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs());

    [MethodImpl(256 | 512)]
    public static short3x3 sign(this short3x3 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign());

    [MethodImpl(256 | 512)]
    public static short3x3 min(this short3x3 a, short3x3 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2));

    [MethodImpl(256 | 512)]
    public static short3x3 max(this short3x3 a, short3x3 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2));

    [MethodImpl(256 | 512)]
    public static short3x3 clamp(this short3x3 v, short3x3 min, short3x3 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2));

    [MethodImpl(256 | 512)]
    public static short3x3 square(this short3x3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static short3x3 fma(this short3x3 a, short3x3 b, short3x3 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static short3x3 fms(this short3x3 a, short3x3 b, short3x3 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2));

    [MethodImpl(256 | 512)]
    public static short3 csum(this short3x3 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum());

    [MethodImpl(256 | 512)]
    public static short3 cmin(this short3x3 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin());

    [MethodImpl(256 | 512)]
    public static short3 cmax(this short3x3 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax());
}

#endregion // short3x3

#region short3x4

public partial struct short3x4
{
    [MethodImpl(256 | 512)]
    public static short3x4 operator +(short3x4 a) => a;

    [MethodImpl(256 | 512)]
    public static short3x4 operator -(short3x4 a) => 
        new(-a.c0, -a.c1, -a.c2, -a.c3);

    [MethodImpl(256 | 512)]
    public static short3x4 operator +(short3x4 a, short3x4 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2, a.c3 + b.c3);

    [MethodImpl(256 | 512)]
    public static short3x4 operator -(short3x4 a, short3x4 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2, a.c3 - b.c3);

    [MethodImpl(256 | 512)]
    public static short3x4 operator *(short3x4 a, short3x4 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2, a.c3 * b.c3);

    [MethodImpl(256 | 512)]
    public static short3x4 operator *(short3x4 a, short b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b, a.c3 * b);

    [MethodImpl(256 | 512)]
    public static short3x4 operator *(short a, short3x4 b) => 
        new(a * b.c0, a * b.c1, a * b.c2, a * b.c3);

    [MethodImpl(256 | 512)]
    public static short3x4 operator /(short3x4 a, short3x4 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2, a.c3 / b.c3);

    [MethodImpl(256 | 512)]
    public static short3x4 operator /(short3x4 a, short b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b, a.c3 / b);

    [MethodImpl(256 | 512)]
    public static short3x4 operator %(short3x4 a, short3x4 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2, a.c3 % b.c3);

    [MethodImpl(256 | 512)]
    public static short3x4 operator %(short3x4 a, short b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b, a.c3 % b);

    [MethodImpl(256 | 512)]
    public static short3x4 operator --(short3x4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static short3x4 operator ++(short3x4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static short3x4 abs(this short3x4 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs(), a.c3.abs());

    [MethodImpl(256 | 512)]
    public static short3x4 sign(this short3x4 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign(), a.c3.sign());

    [MethodImpl(256 | 512)]
    public static short3x4 min(this short3x4 a, short3x4 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2), a.c3.min(b.c3));

    [MethodImpl(256 | 512)]
    public static short3x4 max(this short3x4 a, short3x4 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2), a.c3.max(b.c3));

    [MethodImpl(256 | 512)]
    public static short3x4 clamp(this short3x4 v, short3x4 min, short3x4 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2), v.c3.clamp(min.c3, max.c3));

    [MethodImpl(256 | 512)]
    public static short3x4 square(this short3x4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static short3x4 fma(this short3x4 a, short3x4 b, short3x4 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2), a.c3.fma(b.c3, c.c3));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static short3x4 fms(this short3x4 a, short3x4 b, short3x4 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2), a.c3.fms(b.c3, c.c3));

    [MethodImpl(256 | 512)]
    public static short4 csum(this short3x4 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum(), a.c3.csum());

    [MethodImpl(256 | 512)]
    public static short4 cmin(this short3x4 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin(), a.c3.cmin());

    [MethodImpl(256 | 512)]
    public static short4 cmax(this short3x4 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax(), a.c3.cmax());
}

#endregion // short3x4

#region short4x2

public partial struct short4x2
{
    [MethodImpl(256 | 512)]
    public static short4x2 operator +(short4x2 a) => a;

    [MethodImpl(256 | 512)]
    public static short4x2 operator -(short4x2 a) => 
        new(-a.c0, -a.c1);

    [MethodImpl(256 | 512)]
    public static short4x2 operator +(short4x2 a, short4x2 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1);

    [MethodImpl(256 | 512)]
    public static short4x2 operator -(short4x2 a, short4x2 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1);

    [MethodImpl(256 | 512)]
    public static short4x2 operator *(short4x2 a, short4x2 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1);

    [MethodImpl(256 | 512)]
    public static short4x2 operator *(short4x2 a, short b) => 
        new(a.c0 * b, a.c1 * b);

    [MethodImpl(256 | 512)]
    public static short4x2 operator *(short a, short4x2 b) => 
        new(a * b.c0, a * b.c1);

    [MethodImpl(256 | 512)]
    public static short4x2 operator /(short4x2 a, short4x2 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1);

    [MethodImpl(256 | 512)]
    public static short4x2 operator /(short4x2 a, short b) => 
        new(a.c0 / b, a.c1 / b);

    [MethodImpl(256 | 512)]
    public static short4x2 operator %(short4x2 a, short4x2 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1);

    [MethodImpl(256 | 512)]
    public static short4x2 operator %(short4x2 a, short b) => 
        new(a.c0 % b, a.c1 % b);

    [MethodImpl(256 | 512)]
    public static short4x2 operator --(short4x2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static short4x2 operator ++(short4x2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static short4x2 abs(this short4x2 a) => 
        new(a.c0.abs(), a.c1.abs());

    [MethodImpl(256 | 512)]
    public static short4x2 sign(this short4x2 a) => 
        new(a.c0.sign(), a.c1.sign());

    [MethodImpl(256 | 512)]
    public static short4x2 min(this short4x2 a, short4x2 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1));

    [MethodImpl(256 | 512)]
    public static short4x2 max(this short4x2 a, short4x2 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1));

    [MethodImpl(256 | 512)]
    public static short4x2 clamp(this short4x2 v, short4x2 min, short4x2 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1));

    [MethodImpl(256 | 512)]
    public static short4x2 square(this short4x2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static short4x2 fma(this short4x2 a, short4x2 b, short4x2 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static short4x2 fms(this short4x2 a, short4x2 b, short4x2 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1));

    [MethodImpl(256 | 512)]
    public static short2 csum(this short4x2 a) => 
        new(a.c0.csum(), a.c1.csum());

    [MethodImpl(256 | 512)]
    public static short2 cmin(this short4x2 a) => 
        new(a.c0.cmin(), a.c1.cmin());

    [MethodImpl(256 | 512)]
    public static short2 cmax(this short4x2 a) => 
        new(a.c0.cmax(), a.c1.cmax());
}

#endregion // short4x2

#region short4x3

public partial struct short4x3
{
    [MethodImpl(256 | 512)]
    public static short4x3 operator +(short4x3 a) => a;

    [MethodImpl(256 | 512)]
    public static short4x3 operator -(short4x3 a) => 
        new(-a.c0, -a.c1, -a.c2);

    [MethodImpl(256 | 512)]
    public static short4x3 operator +(short4x3 a, short4x3 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2);

    [MethodImpl(256 | 512)]
    public static short4x3 operator -(short4x3 a, short4x3 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2);

    [MethodImpl(256 | 512)]
    public static short4x3 operator *(short4x3 a, short4x3 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2);

    [MethodImpl(256 | 512)]
    public static short4x3 operator *(short4x3 a, short b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b);

    [MethodImpl(256 | 512)]
    public static short4x3 operator *(short a, short4x3 b) => 
        new(a * b.c0, a * b.c1, a * b.c2);

    [MethodImpl(256 | 512)]
    public static short4x3 operator /(short4x3 a, short4x3 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2);

    [MethodImpl(256 | 512)]
    public static short4x3 operator /(short4x3 a, short b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b);

    [MethodImpl(256 | 512)]
    public static short4x3 operator %(short4x3 a, short4x3 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2);

    [MethodImpl(256 | 512)]
    public static short4x3 operator %(short4x3 a, short b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b);

    [MethodImpl(256 | 512)]
    public static short4x3 operator --(short4x3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static short4x3 operator ++(short4x3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static short4x3 abs(this short4x3 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs());

    [MethodImpl(256 | 512)]
    public static short4x3 sign(this short4x3 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign());

    [MethodImpl(256 | 512)]
    public static short4x3 min(this short4x3 a, short4x3 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2));

    [MethodImpl(256 | 512)]
    public static short4x3 max(this short4x3 a, short4x3 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2));

    [MethodImpl(256 | 512)]
    public static short4x3 clamp(this short4x3 v, short4x3 min, short4x3 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2));

    [MethodImpl(256 | 512)]
    public static short4x3 square(this short4x3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static short4x3 fma(this short4x3 a, short4x3 b, short4x3 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static short4x3 fms(this short4x3 a, short4x3 b, short4x3 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2));

    [MethodImpl(256 | 512)]
    public static short3 csum(this short4x3 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum());

    [MethodImpl(256 | 512)]
    public static short3 cmin(this short4x3 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin());

    [MethodImpl(256 | 512)]
    public static short3 cmax(this short4x3 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax());
}

#endregion // short4x3

#region short4x4

public partial struct short4x4
{
    [MethodImpl(256 | 512)]
    public static short4x4 operator +(short4x4 a) => a;

    [MethodImpl(256 | 512)]
    public static short4x4 operator -(short4x4 a) => 
        new(-a.c0, -a.c1, -a.c2, -a.c3);

    [MethodImpl(256 | 512)]
    public static short4x4 operator +(short4x4 a, short4x4 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2, a.c3 + b.c3);

    [MethodImpl(256 | 512)]
    public static short4x4 operator -(short4x4 a, short4x4 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2, a.c3 - b.c3);

    [MethodImpl(256 | 512)]
    public static short4x4 operator *(short4x4 a, short4x4 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2, a.c3 * b.c3);

    [MethodImpl(256 | 512)]
    public static short4x4 operator *(short4x4 a, short b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b, a.c3 * b);

    [MethodImpl(256 | 512)]
    public static short4x4 operator *(short a, short4x4 b) => 
        new(a * b.c0, a * b.c1, a * b.c2, a * b.c3);

    [MethodImpl(256 | 512)]
    public static short4x4 operator /(short4x4 a, short4x4 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2, a.c3 / b.c3);

    [MethodImpl(256 | 512)]
    public static short4x4 operator /(short4x4 a, short b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b, a.c3 / b);

    [MethodImpl(256 | 512)]
    public static short4x4 operator %(short4x4 a, short4x4 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2, a.c3 % b.c3);

    [MethodImpl(256 | 512)]
    public static short4x4 operator %(short4x4 a, short b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b, a.c3 % b);

    [MethodImpl(256 | 512)]
    public static short4x4 operator --(short4x4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static short4x4 operator ++(short4x4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static short4x4 abs(this short4x4 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs(), a.c3.abs());

    [MethodImpl(256 | 512)]
    public static short4x4 sign(this short4x4 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign(), a.c3.sign());

    [MethodImpl(256 | 512)]
    public static short4x4 min(this short4x4 a, short4x4 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2), a.c3.min(b.c3));

    [MethodImpl(256 | 512)]
    public static short4x4 max(this short4x4 a, short4x4 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2), a.c3.max(b.c3));

    [MethodImpl(256 | 512)]
    public static short4x4 clamp(this short4x4 v, short4x4 min, short4x4 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2), v.c3.clamp(min.c3, max.c3));

    [MethodImpl(256 | 512)]
    public static short4x4 square(this short4x4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static short4x4 fma(this short4x4 a, short4x4 b, short4x4 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2), a.c3.fma(b.c3, c.c3));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static short4x4 fms(this short4x4 a, short4x4 b, short4x4 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2), a.c3.fms(b.c3, c.c3));

    [MethodImpl(256 | 512)]
    public static short4 csum(this short4x4 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum(), a.c3.csum());

    [MethodImpl(256 | 512)]
    public static short4 cmin(this short4x4 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin(), a.c3.cmin());

    [MethodImpl(256 | 512)]
    public static short4 cmax(this short4x4 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax(), a.c3.cmax());
}

#endregion // short4x4

#region ushort2x2

public partial struct ushort2x2
{
    [MethodImpl(256 | 512)]
    public static ushort2x2 operator +(ushort2x2 a) => a;

    [MethodImpl(256 | 512)]
    public static ushort2x2 operator +(ushort2x2 a, ushort2x2 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1);

    [MethodImpl(256 | 512)]
    public static ushort2x2 operator -(ushort2x2 a, ushort2x2 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1);

    [MethodImpl(256 | 512)]
    public static ushort2x2 operator *(ushort2x2 a, ushort2x2 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1);

    [MethodImpl(256 | 512)]
    public static ushort2x2 operator *(ushort2x2 a, ushort b) => 
        new(a.c0 * b, a.c1 * b);

    [MethodImpl(256 | 512)]
    public static ushort2x2 operator *(ushort a, ushort2x2 b) => 
        new(a * b.c0, a * b.c1);

    [MethodImpl(256 | 512)]
    public static ushort2x2 operator /(ushort2x2 a, ushort2x2 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1);

    [MethodImpl(256 | 512)]
    public static ushort2x2 operator /(ushort2x2 a, ushort b) => 
        new(a.c0 / b, a.c1 / b);

    [MethodImpl(256 | 512)]
    public static ushort2x2 operator %(ushort2x2 a, ushort2x2 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1);

    [MethodImpl(256 | 512)]
    public static ushort2x2 operator %(ushort2x2 a, ushort b) => 
        new(a.c0 % b, a.c1 % b);

    [MethodImpl(256 | 512)]
    public static ushort2x2 operator --(ushort2x2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ushort2x2 operator ++(ushort2x2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ushort2x2 abs(this ushort2x2 a) => 
        new(a.c0.abs(), a.c1.abs());

    [MethodImpl(256 | 512)]
    public static ushort2x2 sign(this ushort2x2 a) => 
        new(a.c0.sign(), a.c1.sign());

    [MethodImpl(256 | 512)]
    public static ushort2x2 min(this ushort2x2 a, ushort2x2 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1));

    [MethodImpl(256 | 512)]
    public static ushort2x2 max(this ushort2x2 a, ushort2x2 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1));

    [MethodImpl(256 | 512)]
    public static ushort2x2 clamp(this ushort2x2 v, ushort2x2 min, ushort2x2 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1));

    [MethodImpl(256 | 512)]
    public static ushort2x2 square(this ushort2x2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ushort2x2 fma(this ushort2x2 a, ushort2x2 b, ushort2x2 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ushort2x2 fms(this ushort2x2 a, ushort2x2 b, ushort2x2 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1));

    [MethodImpl(256 | 512)]
    public static ushort2 csum(this ushort2x2 a) => 
        new(a.c0.csum(), a.c1.csum());

    [MethodImpl(256 | 512)]
    public static ushort2 cmin(this ushort2x2 a) => 
        new(a.c0.cmin(), a.c1.cmin());

    [MethodImpl(256 | 512)]
    public static ushort2 cmax(this ushort2x2 a) => 
        new(a.c0.cmax(), a.c1.cmax());
}

#endregion // ushort2x2

#region ushort2x3

public partial struct ushort2x3
{
    [MethodImpl(256 | 512)]
    public static ushort2x3 operator +(ushort2x3 a) => a;

    [MethodImpl(256 | 512)]
    public static ushort2x3 operator +(ushort2x3 a, ushort2x3 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2);

    [MethodImpl(256 | 512)]
    public static ushort2x3 operator -(ushort2x3 a, ushort2x3 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2);

    [MethodImpl(256 | 512)]
    public static ushort2x3 operator *(ushort2x3 a, ushort2x3 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2);

    [MethodImpl(256 | 512)]
    public static ushort2x3 operator *(ushort2x3 a, ushort b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b);

    [MethodImpl(256 | 512)]
    public static ushort2x3 operator *(ushort a, ushort2x3 b) => 
        new(a * b.c0, a * b.c1, a * b.c2);

    [MethodImpl(256 | 512)]
    public static ushort2x3 operator /(ushort2x3 a, ushort2x3 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2);

    [MethodImpl(256 | 512)]
    public static ushort2x3 operator /(ushort2x3 a, ushort b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b);

    [MethodImpl(256 | 512)]
    public static ushort2x3 operator %(ushort2x3 a, ushort2x3 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2);

    [MethodImpl(256 | 512)]
    public static ushort2x3 operator %(ushort2x3 a, ushort b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b);

    [MethodImpl(256 | 512)]
    public static ushort2x3 operator --(ushort2x3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ushort2x3 operator ++(ushort2x3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ushort2x3 abs(this ushort2x3 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs());

    [MethodImpl(256 | 512)]
    public static ushort2x3 sign(this ushort2x3 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign());

    [MethodImpl(256 | 512)]
    public static ushort2x3 min(this ushort2x3 a, ushort2x3 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2));

    [MethodImpl(256 | 512)]
    public static ushort2x3 max(this ushort2x3 a, ushort2x3 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2));

    [MethodImpl(256 | 512)]
    public static ushort2x3 clamp(this ushort2x3 v, ushort2x3 min, ushort2x3 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2));

    [MethodImpl(256 | 512)]
    public static ushort2x3 square(this ushort2x3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ushort2x3 fma(this ushort2x3 a, ushort2x3 b, ushort2x3 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ushort2x3 fms(this ushort2x3 a, ushort2x3 b, ushort2x3 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2));

    [MethodImpl(256 | 512)]
    public static ushort3 csum(this ushort2x3 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum());

    [MethodImpl(256 | 512)]
    public static ushort3 cmin(this ushort2x3 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin());

    [MethodImpl(256 | 512)]
    public static ushort3 cmax(this ushort2x3 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax());
}

#endregion // ushort2x3

#region ushort2x4

public partial struct ushort2x4
{
    [MethodImpl(256 | 512)]
    public static ushort2x4 operator +(ushort2x4 a) => a;

    [MethodImpl(256 | 512)]
    public static ushort2x4 operator +(ushort2x4 a, ushort2x4 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2, a.c3 + b.c3);

    [MethodImpl(256 | 512)]
    public static ushort2x4 operator -(ushort2x4 a, ushort2x4 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2, a.c3 - b.c3);

    [MethodImpl(256 | 512)]
    public static ushort2x4 operator *(ushort2x4 a, ushort2x4 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2, a.c3 * b.c3);

    [MethodImpl(256 | 512)]
    public static ushort2x4 operator *(ushort2x4 a, ushort b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b, a.c3 * b);

    [MethodImpl(256 | 512)]
    public static ushort2x4 operator *(ushort a, ushort2x4 b) => 
        new(a * b.c0, a * b.c1, a * b.c2, a * b.c3);

    [MethodImpl(256 | 512)]
    public static ushort2x4 operator /(ushort2x4 a, ushort2x4 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2, a.c3 / b.c3);

    [MethodImpl(256 | 512)]
    public static ushort2x4 operator /(ushort2x4 a, ushort b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b, a.c3 / b);

    [MethodImpl(256 | 512)]
    public static ushort2x4 operator %(ushort2x4 a, ushort2x4 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2, a.c3 % b.c3);

    [MethodImpl(256 | 512)]
    public static ushort2x4 operator %(ushort2x4 a, ushort b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b, a.c3 % b);

    [MethodImpl(256 | 512)]
    public static ushort2x4 operator --(ushort2x4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ushort2x4 operator ++(ushort2x4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ushort2x4 abs(this ushort2x4 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs(), a.c3.abs());

    [MethodImpl(256 | 512)]
    public static ushort2x4 sign(this ushort2x4 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign(), a.c3.sign());

    [MethodImpl(256 | 512)]
    public static ushort2x4 min(this ushort2x4 a, ushort2x4 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2), a.c3.min(b.c3));

    [MethodImpl(256 | 512)]
    public static ushort2x4 max(this ushort2x4 a, ushort2x4 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2), a.c3.max(b.c3));

    [MethodImpl(256 | 512)]
    public static ushort2x4 clamp(this ushort2x4 v, ushort2x4 min, ushort2x4 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2), v.c3.clamp(min.c3, max.c3));

    [MethodImpl(256 | 512)]
    public static ushort2x4 square(this ushort2x4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ushort2x4 fma(this ushort2x4 a, ushort2x4 b, ushort2x4 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2), a.c3.fma(b.c3, c.c3));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ushort2x4 fms(this ushort2x4 a, ushort2x4 b, ushort2x4 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2), a.c3.fms(b.c3, c.c3));

    [MethodImpl(256 | 512)]
    public static ushort4 csum(this ushort2x4 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum(), a.c3.csum());

    [MethodImpl(256 | 512)]
    public static ushort4 cmin(this ushort2x4 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin(), a.c3.cmin());

    [MethodImpl(256 | 512)]
    public static ushort4 cmax(this ushort2x4 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax(), a.c3.cmax());
}

#endregion // ushort2x4

#region ushort3x2

public partial struct ushort3x2
{
    [MethodImpl(256 | 512)]
    public static ushort3x2 operator +(ushort3x2 a) => a;

    [MethodImpl(256 | 512)]
    public static ushort3x2 operator +(ushort3x2 a, ushort3x2 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1);

    [MethodImpl(256 | 512)]
    public static ushort3x2 operator -(ushort3x2 a, ushort3x2 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1);

    [MethodImpl(256 | 512)]
    public static ushort3x2 operator *(ushort3x2 a, ushort3x2 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1);

    [MethodImpl(256 | 512)]
    public static ushort3x2 operator *(ushort3x2 a, ushort b) => 
        new(a.c0 * b, a.c1 * b);

    [MethodImpl(256 | 512)]
    public static ushort3x2 operator *(ushort a, ushort3x2 b) => 
        new(a * b.c0, a * b.c1);

    [MethodImpl(256 | 512)]
    public static ushort3x2 operator /(ushort3x2 a, ushort3x2 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1);

    [MethodImpl(256 | 512)]
    public static ushort3x2 operator /(ushort3x2 a, ushort b) => 
        new(a.c0 / b, a.c1 / b);

    [MethodImpl(256 | 512)]
    public static ushort3x2 operator %(ushort3x2 a, ushort3x2 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1);

    [MethodImpl(256 | 512)]
    public static ushort3x2 operator %(ushort3x2 a, ushort b) => 
        new(a.c0 % b, a.c1 % b);

    [MethodImpl(256 | 512)]
    public static ushort3x2 operator --(ushort3x2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ushort3x2 operator ++(ushort3x2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ushort3x2 abs(this ushort3x2 a) => 
        new(a.c0.abs(), a.c1.abs());

    [MethodImpl(256 | 512)]
    public static ushort3x2 sign(this ushort3x2 a) => 
        new(a.c0.sign(), a.c1.sign());

    [MethodImpl(256 | 512)]
    public static ushort3x2 min(this ushort3x2 a, ushort3x2 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1));

    [MethodImpl(256 | 512)]
    public static ushort3x2 max(this ushort3x2 a, ushort3x2 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1));

    [MethodImpl(256 | 512)]
    public static ushort3x2 clamp(this ushort3x2 v, ushort3x2 min, ushort3x2 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1));

    [MethodImpl(256 | 512)]
    public static ushort3x2 square(this ushort3x2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ushort3x2 fma(this ushort3x2 a, ushort3x2 b, ushort3x2 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ushort3x2 fms(this ushort3x2 a, ushort3x2 b, ushort3x2 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1));

    [MethodImpl(256 | 512)]
    public static ushort2 csum(this ushort3x2 a) => 
        new(a.c0.csum(), a.c1.csum());

    [MethodImpl(256 | 512)]
    public static ushort2 cmin(this ushort3x2 a) => 
        new(a.c0.cmin(), a.c1.cmin());

    [MethodImpl(256 | 512)]
    public static ushort2 cmax(this ushort3x2 a) => 
        new(a.c0.cmax(), a.c1.cmax());
}

#endregion // ushort3x2

#region ushort3x3

public partial struct ushort3x3
{
    [MethodImpl(256 | 512)]
    public static ushort3x3 operator +(ushort3x3 a) => a;

    [MethodImpl(256 | 512)]
    public static ushort3x3 operator +(ushort3x3 a, ushort3x3 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2);

    [MethodImpl(256 | 512)]
    public static ushort3x3 operator -(ushort3x3 a, ushort3x3 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2);

    [MethodImpl(256 | 512)]
    public static ushort3x3 operator *(ushort3x3 a, ushort3x3 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2);

    [MethodImpl(256 | 512)]
    public static ushort3x3 operator *(ushort3x3 a, ushort b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b);

    [MethodImpl(256 | 512)]
    public static ushort3x3 operator *(ushort a, ushort3x3 b) => 
        new(a * b.c0, a * b.c1, a * b.c2);

    [MethodImpl(256 | 512)]
    public static ushort3x3 operator /(ushort3x3 a, ushort3x3 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2);

    [MethodImpl(256 | 512)]
    public static ushort3x3 operator /(ushort3x3 a, ushort b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b);

    [MethodImpl(256 | 512)]
    public static ushort3x3 operator %(ushort3x3 a, ushort3x3 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2);

    [MethodImpl(256 | 512)]
    public static ushort3x3 operator %(ushort3x3 a, ushort b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b);

    [MethodImpl(256 | 512)]
    public static ushort3x3 operator --(ushort3x3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ushort3x3 operator ++(ushort3x3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ushort3x3 abs(this ushort3x3 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs());

    [MethodImpl(256 | 512)]
    public static ushort3x3 sign(this ushort3x3 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign());

    [MethodImpl(256 | 512)]
    public static ushort3x3 min(this ushort3x3 a, ushort3x3 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2));

    [MethodImpl(256 | 512)]
    public static ushort3x3 max(this ushort3x3 a, ushort3x3 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2));

    [MethodImpl(256 | 512)]
    public static ushort3x3 clamp(this ushort3x3 v, ushort3x3 min, ushort3x3 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2));

    [MethodImpl(256 | 512)]
    public static ushort3x3 square(this ushort3x3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ushort3x3 fma(this ushort3x3 a, ushort3x3 b, ushort3x3 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ushort3x3 fms(this ushort3x3 a, ushort3x3 b, ushort3x3 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2));

    [MethodImpl(256 | 512)]
    public static ushort3 csum(this ushort3x3 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum());

    [MethodImpl(256 | 512)]
    public static ushort3 cmin(this ushort3x3 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin());

    [MethodImpl(256 | 512)]
    public static ushort3 cmax(this ushort3x3 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax());
}

#endregion // ushort3x3

#region ushort3x4

public partial struct ushort3x4
{
    [MethodImpl(256 | 512)]
    public static ushort3x4 operator +(ushort3x4 a) => a;

    [MethodImpl(256 | 512)]
    public static ushort3x4 operator +(ushort3x4 a, ushort3x4 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2, a.c3 + b.c3);

    [MethodImpl(256 | 512)]
    public static ushort3x4 operator -(ushort3x4 a, ushort3x4 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2, a.c3 - b.c3);

    [MethodImpl(256 | 512)]
    public static ushort3x4 operator *(ushort3x4 a, ushort3x4 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2, a.c3 * b.c3);

    [MethodImpl(256 | 512)]
    public static ushort3x4 operator *(ushort3x4 a, ushort b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b, a.c3 * b);

    [MethodImpl(256 | 512)]
    public static ushort3x4 operator *(ushort a, ushort3x4 b) => 
        new(a * b.c0, a * b.c1, a * b.c2, a * b.c3);

    [MethodImpl(256 | 512)]
    public static ushort3x4 operator /(ushort3x4 a, ushort3x4 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2, a.c3 / b.c3);

    [MethodImpl(256 | 512)]
    public static ushort3x4 operator /(ushort3x4 a, ushort b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b, a.c3 / b);

    [MethodImpl(256 | 512)]
    public static ushort3x4 operator %(ushort3x4 a, ushort3x4 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2, a.c3 % b.c3);

    [MethodImpl(256 | 512)]
    public static ushort3x4 operator %(ushort3x4 a, ushort b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b, a.c3 % b);

    [MethodImpl(256 | 512)]
    public static ushort3x4 operator --(ushort3x4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ushort3x4 operator ++(ushort3x4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ushort3x4 abs(this ushort3x4 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs(), a.c3.abs());

    [MethodImpl(256 | 512)]
    public static ushort3x4 sign(this ushort3x4 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign(), a.c3.sign());

    [MethodImpl(256 | 512)]
    public static ushort3x4 min(this ushort3x4 a, ushort3x4 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2), a.c3.min(b.c3));

    [MethodImpl(256 | 512)]
    public static ushort3x4 max(this ushort3x4 a, ushort3x4 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2), a.c3.max(b.c3));

    [MethodImpl(256 | 512)]
    public static ushort3x4 clamp(this ushort3x4 v, ushort3x4 min, ushort3x4 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2), v.c3.clamp(min.c3, max.c3));

    [MethodImpl(256 | 512)]
    public static ushort3x4 square(this ushort3x4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ushort3x4 fma(this ushort3x4 a, ushort3x4 b, ushort3x4 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2), a.c3.fma(b.c3, c.c3));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ushort3x4 fms(this ushort3x4 a, ushort3x4 b, ushort3x4 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2), a.c3.fms(b.c3, c.c3));

    [MethodImpl(256 | 512)]
    public static ushort4 csum(this ushort3x4 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum(), a.c3.csum());

    [MethodImpl(256 | 512)]
    public static ushort4 cmin(this ushort3x4 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin(), a.c3.cmin());

    [MethodImpl(256 | 512)]
    public static ushort4 cmax(this ushort3x4 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax(), a.c3.cmax());
}

#endregion // ushort3x4

#region ushort4x2

public partial struct ushort4x2
{
    [MethodImpl(256 | 512)]
    public static ushort4x2 operator +(ushort4x2 a) => a;

    [MethodImpl(256 | 512)]
    public static ushort4x2 operator +(ushort4x2 a, ushort4x2 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1);

    [MethodImpl(256 | 512)]
    public static ushort4x2 operator -(ushort4x2 a, ushort4x2 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1);

    [MethodImpl(256 | 512)]
    public static ushort4x2 operator *(ushort4x2 a, ushort4x2 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1);

    [MethodImpl(256 | 512)]
    public static ushort4x2 operator *(ushort4x2 a, ushort b) => 
        new(a.c0 * b, a.c1 * b);

    [MethodImpl(256 | 512)]
    public static ushort4x2 operator *(ushort a, ushort4x2 b) => 
        new(a * b.c0, a * b.c1);

    [MethodImpl(256 | 512)]
    public static ushort4x2 operator /(ushort4x2 a, ushort4x2 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1);

    [MethodImpl(256 | 512)]
    public static ushort4x2 operator /(ushort4x2 a, ushort b) => 
        new(a.c0 / b, a.c1 / b);

    [MethodImpl(256 | 512)]
    public static ushort4x2 operator %(ushort4x2 a, ushort4x2 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1);

    [MethodImpl(256 | 512)]
    public static ushort4x2 operator %(ushort4x2 a, ushort b) => 
        new(a.c0 % b, a.c1 % b);

    [MethodImpl(256 | 512)]
    public static ushort4x2 operator --(ushort4x2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ushort4x2 operator ++(ushort4x2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ushort4x2 abs(this ushort4x2 a) => 
        new(a.c0.abs(), a.c1.abs());

    [MethodImpl(256 | 512)]
    public static ushort4x2 sign(this ushort4x2 a) => 
        new(a.c0.sign(), a.c1.sign());

    [MethodImpl(256 | 512)]
    public static ushort4x2 min(this ushort4x2 a, ushort4x2 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1));

    [MethodImpl(256 | 512)]
    public static ushort4x2 max(this ushort4x2 a, ushort4x2 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1));

    [MethodImpl(256 | 512)]
    public static ushort4x2 clamp(this ushort4x2 v, ushort4x2 min, ushort4x2 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1));

    [MethodImpl(256 | 512)]
    public static ushort4x2 square(this ushort4x2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ushort4x2 fma(this ushort4x2 a, ushort4x2 b, ushort4x2 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ushort4x2 fms(this ushort4x2 a, ushort4x2 b, ushort4x2 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1));

    [MethodImpl(256 | 512)]
    public static ushort2 csum(this ushort4x2 a) => 
        new(a.c0.csum(), a.c1.csum());

    [MethodImpl(256 | 512)]
    public static ushort2 cmin(this ushort4x2 a) => 
        new(a.c0.cmin(), a.c1.cmin());

    [MethodImpl(256 | 512)]
    public static ushort2 cmax(this ushort4x2 a) => 
        new(a.c0.cmax(), a.c1.cmax());
}

#endregion // ushort4x2

#region ushort4x3

public partial struct ushort4x3
{
    [MethodImpl(256 | 512)]
    public static ushort4x3 operator +(ushort4x3 a) => a;

    [MethodImpl(256 | 512)]
    public static ushort4x3 operator +(ushort4x3 a, ushort4x3 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2);

    [MethodImpl(256 | 512)]
    public static ushort4x3 operator -(ushort4x3 a, ushort4x3 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2);

    [MethodImpl(256 | 512)]
    public static ushort4x3 operator *(ushort4x3 a, ushort4x3 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2);

    [MethodImpl(256 | 512)]
    public static ushort4x3 operator *(ushort4x3 a, ushort b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b);

    [MethodImpl(256 | 512)]
    public static ushort4x3 operator *(ushort a, ushort4x3 b) => 
        new(a * b.c0, a * b.c1, a * b.c2);

    [MethodImpl(256 | 512)]
    public static ushort4x3 operator /(ushort4x3 a, ushort4x3 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2);

    [MethodImpl(256 | 512)]
    public static ushort4x3 operator /(ushort4x3 a, ushort b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b);

    [MethodImpl(256 | 512)]
    public static ushort4x3 operator %(ushort4x3 a, ushort4x3 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2);

    [MethodImpl(256 | 512)]
    public static ushort4x3 operator %(ushort4x3 a, ushort b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b);

    [MethodImpl(256 | 512)]
    public static ushort4x3 operator --(ushort4x3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ushort4x3 operator ++(ushort4x3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ushort4x3 abs(this ushort4x3 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs());

    [MethodImpl(256 | 512)]
    public static ushort4x3 sign(this ushort4x3 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign());

    [MethodImpl(256 | 512)]
    public static ushort4x3 min(this ushort4x3 a, ushort4x3 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2));

    [MethodImpl(256 | 512)]
    public static ushort4x3 max(this ushort4x3 a, ushort4x3 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2));

    [MethodImpl(256 | 512)]
    public static ushort4x3 clamp(this ushort4x3 v, ushort4x3 min, ushort4x3 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2));

    [MethodImpl(256 | 512)]
    public static ushort4x3 square(this ushort4x3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ushort4x3 fma(this ushort4x3 a, ushort4x3 b, ushort4x3 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ushort4x3 fms(this ushort4x3 a, ushort4x3 b, ushort4x3 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2));

    [MethodImpl(256 | 512)]
    public static ushort3 csum(this ushort4x3 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum());

    [MethodImpl(256 | 512)]
    public static ushort3 cmin(this ushort4x3 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin());

    [MethodImpl(256 | 512)]
    public static ushort3 cmax(this ushort4x3 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax());
}

#endregion // ushort4x3

#region ushort4x4

public partial struct ushort4x4
{
    [MethodImpl(256 | 512)]
    public static ushort4x4 operator +(ushort4x4 a) => a;

    [MethodImpl(256 | 512)]
    public static ushort4x4 operator +(ushort4x4 a, ushort4x4 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2, a.c3 + b.c3);

    [MethodImpl(256 | 512)]
    public static ushort4x4 operator -(ushort4x4 a, ushort4x4 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2, a.c3 - b.c3);

    [MethodImpl(256 | 512)]
    public static ushort4x4 operator *(ushort4x4 a, ushort4x4 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2, a.c3 * b.c3);

    [MethodImpl(256 | 512)]
    public static ushort4x4 operator *(ushort4x4 a, ushort b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b, a.c3 * b);

    [MethodImpl(256 | 512)]
    public static ushort4x4 operator *(ushort a, ushort4x4 b) => 
        new(a * b.c0, a * b.c1, a * b.c2, a * b.c3);

    [MethodImpl(256 | 512)]
    public static ushort4x4 operator /(ushort4x4 a, ushort4x4 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2, a.c3 / b.c3);

    [MethodImpl(256 | 512)]
    public static ushort4x4 operator /(ushort4x4 a, ushort b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b, a.c3 / b);

    [MethodImpl(256 | 512)]
    public static ushort4x4 operator %(ushort4x4 a, ushort4x4 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2, a.c3 % b.c3);

    [MethodImpl(256 | 512)]
    public static ushort4x4 operator %(ushort4x4 a, ushort b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b, a.c3 % b);

    [MethodImpl(256 | 512)]
    public static ushort4x4 operator --(ushort4x4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ushort4x4 operator ++(ushort4x4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ushort4x4 abs(this ushort4x4 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs(), a.c3.abs());

    [MethodImpl(256 | 512)]
    public static ushort4x4 sign(this ushort4x4 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign(), a.c3.sign());

    [MethodImpl(256 | 512)]
    public static ushort4x4 min(this ushort4x4 a, ushort4x4 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2), a.c3.min(b.c3));

    [MethodImpl(256 | 512)]
    public static ushort4x4 max(this ushort4x4 a, ushort4x4 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2), a.c3.max(b.c3));

    [MethodImpl(256 | 512)]
    public static ushort4x4 clamp(this ushort4x4 v, ushort4x4 min, ushort4x4 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2), v.c3.clamp(min.c3, max.c3));

    [MethodImpl(256 | 512)]
    public static ushort4x4 square(this ushort4x4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ushort4x4 fma(this ushort4x4 a, ushort4x4 b, ushort4x4 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2), a.c3.fma(b.c3, c.c3));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ushort4x4 fms(this ushort4x4 a, ushort4x4 b, ushort4x4 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2), a.c3.fms(b.c3, c.c3));

    [MethodImpl(256 | 512)]
    public static ushort4 csum(this ushort4x4 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum(), a.c3.csum());

    [MethodImpl(256 | 512)]
    public static ushort4 cmin(this ushort4x4 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin(), a.c3.cmin());

    [MethodImpl(256 | 512)]
    public static ushort4 cmax(this ushort4x4 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax(), a.c3.cmax());
}

#endregion // ushort4x4

#region int2x2

public partial struct int2x2
{
    [MethodImpl(256 | 512)]
    public static int2x2 operator +(int2x2 a) => a;

    [MethodImpl(256 | 512)]
    public static int2x2 operator -(int2x2 a) => 
        new(-a.c0, -a.c1);

    [MethodImpl(256 | 512)]
    public static int2x2 operator +(int2x2 a, int2x2 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1);

    [MethodImpl(256 | 512)]
    public static int2x2 operator -(int2x2 a, int2x2 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1);

    [MethodImpl(256 | 512)]
    public static int2x2 operator *(int2x2 a, int2x2 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1);

    [MethodImpl(256 | 512)]
    public static int2x2 operator *(int2x2 a, int b) => 
        new(a.c0 * b, a.c1 * b);

    [MethodImpl(256 | 512)]
    public static int2x2 operator *(int a, int2x2 b) => 
        new(a * b.c0, a * b.c1);

    [MethodImpl(256 | 512)]
    public static int2x2 operator /(int2x2 a, int2x2 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1);

    [MethodImpl(256 | 512)]
    public static int2x2 operator /(int2x2 a, int b) => 
        new(a.c0 / b, a.c1 / b);

    [MethodImpl(256 | 512)]
    public static int2x2 operator %(int2x2 a, int2x2 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1);

    [MethodImpl(256 | 512)]
    public static int2x2 operator %(int2x2 a, int b) => 
        new(a.c0 % b, a.c1 % b);

    [MethodImpl(256 | 512)]
    public static int2x2 operator --(int2x2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static int2x2 operator ++(int2x2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int2x2 abs(this int2x2 a) => 
        new(a.c0.abs(), a.c1.abs());

    [MethodImpl(256 | 512)]
    public static int2x2 sign(this int2x2 a) => 
        new(a.c0.sign(), a.c1.sign());

    [MethodImpl(256 | 512)]
    public static int2x2 min(this int2x2 a, int2x2 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1));

    [MethodImpl(256 | 512)]
    public static int2x2 max(this int2x2 a, int2x2 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1));

    [MethodImpl(256 | 512)]
    public static int2x2 clamp(this int2x2 v, int2x2 min, int2x2 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1));

    [MethodImpl(256 | 512)]
    public static int2x2 square(this int2x2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int2x2 fma(this int2x2 a, int2x2 b, int2x2 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static int2x2 fms(this int2x2 a, int2x2 b, int2x2 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1));

    [MethodImpl(256 | 512)]
    public static int2 csum(this int2x2 a) => 
        new(a.c0.csum(), a.c1.csum());

    [MethodImpl(256 | 512)]
    public static int2 cmin(this int2x2 a) => 
        new(a.c0.cmin(), a.c1.cmin());

    [MethodImpl(256 | 512)]
    public static int2 cmax(this int2x2 a) => 
        new(a.c0.cmax(), a.c1.cmax());
}

#endregion // int2x2

#region int2x3

public partial struct int2x3
{
    [MethodImpl(256 | 512)]
    public static int2x3 operator +(int2x3 a) => a;

    [MethodImpl(256 | 512)]
    public static int2x3 operator -(int2x3 a) => 
        new(-a.c0, -a.c1, -a.c2);

    [MethodImpl(256 | 512)]
    public static int2x3 operator +(int2x3 a, int2x3 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2);

    [MethodImpl(256 | 512)]
    public static int2x3 operator -(int2x3 a, int2x3 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2);

    [MethodImpl(256 | 512)]
    public static int2x3 operator *(int2x3 a, int2x3 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2);

    [MethodImpl(256 | 512)]
    public static int2x3 operator *(int2x3 a, int b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b);

    [MethodImpl(256 | 512)]
    public static int2x3 operator *(int a, int2x3 b) => 
        new(a * b.c0, a * b.c1, a * b.c2);

    [MethodImpl(256 | 512)]
    public static int2x3 operator /(int2x3 a, int2x3 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2);

    [MethodImpl(256 | 512)]
    public static int2x3 operator /(int2x3 a, int b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b);

    [MethodImpl(256 | 512)]
    public static int2x3 operator %(int2x3 a, int2x3 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2);

    [MethodImpl(256 | 512)]
    public static int2x3 operator %(int2x3 a, int b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b);

    [MethodImpl(256 | 512)]
    public static int2x3 operator --(int2x3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static int2x3 operator ++(int2x3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int2x3 abs(this int2x3 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs());

    [MethodImpl(256 | 512)]
    public static int2x3 sign(this int2x3 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign());

    [MethodImpl(256 | 512)]
    public static int2x3 min(this int2x3 a, int2x3 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2));

    [MethodImpl(256 | 512)]
    public static int2x3 max(this int2x3 a, int2x3 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2));

    [MethodImpl(256 | 512)]
    public static int2x3 clamp(this int2x3 v, int2x3 min, int2x3 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2));

    [MethodImpl(256 | 512)]
    public static int2x3 square(this int2x3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int2x3 fma(this int2x3 a, int2x3 b, int2x3 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static int2x3 fms(this int2x3 a, int2x3 b, int2x3 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2));

    [MethodImpl(256 | 512)]
    public static int3 csum(this int2x3 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum());

    [MethodImpl(256 | 512)]
    public static int3 cmin(this int2x3 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin());

    [MethodImpl(256 | 512)]
    public static int3 cmax(this int2x3 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax());
}

#endregion // int2x3

#region int2x4

public partial struct int2x4
{
    [MethodImpl(256 | 512)]
    public static int2x4 operator +(int2x4 a) => a;

    [MethodImpl(256 | 512)]
    public static int2x4 operator -(int2x4 a) => 
        new(-a.c0, -a.c1, -a.c2, -a.c3);

    [MethodImpl(256 | 512)]
    public static int2x4 operator +(int2x4 a, int2x4 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2, a.c3 + b.c3);

    [MethodImpl(256 | 512)]
    public static int2x4 operator -(int2x4 a, int2x4 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2, a.c3 - b.c3);

    [MethodImpl(256 | 512)]
    public static int2x4 operator *(int2x4 a, int2x4 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2, a.c3 * b.c3);

    [MethodImpl(256 | 512)]
    public static int2x4 operator *(int2x4 a, int b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b, a.c3 * b);

    [MethodImpl(256 | 512)]
    public static int2x4 operator *(int a, int2x4 b) => 
        new(a * b.c0, a * b.c1, a * b.c2, a * b.c3);

    [MethodImpl(256 | 512)]
    public static int2x4 operator /(int2x4 a, int2x4 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2, a.c3 / b.c3);

    [MethodImpl(256 | 512)]
    public static int2x4 operator /(int2x4 a, int b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b, a.c3 / b);

    [MethodImpl(256 | 512)]
    public static int2x4 operator %(int2x4 a, int2x4 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2, a.c3 % b.c3);

    [MethodImpl(256 | 512)]
    public static int2x4 operator %(int2x4 a, int b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b, a.c3 % b);

    [MethodImpl(256 | 512)]
    public static int2x4 operator --(int2x4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static int2x4 operator ++(int2x4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int2x4 abs(this int2x4 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs(), a.c3.abs());

    [MethodImpl(256 | 512)]
    public static int2x4 sign(this int2x4 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign(), a.c3.sign());

    [MethodImpl(256 | 512)]
    public static int2x4 min(this int2x4 a, int2x4 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2), a.c3.min(b.c3));

    [MethodImpl(256 | 512)]
    public static int2x4 max(this int2x4 a, int2x4 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2), a.c3.max(b.c3));

    [MethodImpl(256 | 512)]
    public static int2x4 clamp(this int2x4 v, int2x4 min, int2x4 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2), v.c3.clamp(min.c3, max.c3));

    [MethodImpl(256 | 512)]
    public static int2x4 square(this int2x4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int2x4 fma(this int2x4 a, int2x4 b, int2x4 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2), a.c3.fma(b.c3, c.c3));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static int2x4 fms(this int2x4 a, int2x4 b, int2x4 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2), a.c3.fms(b.c3, c.c3));

    [MethodImpl(256 | 512)]
    public static int4 csum(this int2x4 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum(), a.c3.csum());

    [MethodImpl(256 | 512)]
    public static int4 cmin(this int2x4 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin(), a.c3.cmin());

    [MethodImpl(256 | 512)]
    public static int4 cmax(this int2x4 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax(), a.c3.cmax());
}

#endregion // int2x4

#region int3x2

public partial struct int3x2
{
    [MethodImpl(256 | 512)]
    public static int3x2 operator +(int3x2 a) => a;

    [MethodImpl(256 | 512)]
    public static int3x2 operator -(int3x2 a) => 
        new(-a.c0, -a.c1);

    [MethodImpl(256 | 512)]
    public static int3x2 operator +(int3x2 a, int3x2 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1);

    [MethodImpl(256 | 512)]
    public static int3x2 operator -(int3x2 a, int3x2 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1);

    [MethodImpl(256 | 512)]
    public static int3x2 operator *(int3x2 a, int3x2 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1);

    [MethodImpl(256 | 512)]
    public static int3x2 operator *(int3x2 a, int b) => 
        new(a.c0 * b, a.c1 * b);

    [MethodImpl(256 | 512)]
    public static int3x2 operator *(int a, int3x2 b) => 
        new(a * b.c0, a * b.c1);

    [MethodImpl(256 | 512)]
    public static int3x2 operator /(int3x2 a, int3x2 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1);

    [MethodImpl(256 | 512)]
    public static int3x2 operator /(int3x2 a, int b) => 
        new(a.c0 / b, a.c1 / b);

    [MethodImpl(256 | 512)]
    public static int3x2 operator %(int3x2 a, int3x2 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1);

    [MethodImpl(256 | 512)]
    public static int3x2 operator %(int3x2 a, int b) => 
        new(a.c0 % b, a.c1 % b);

    [MethodImpl(256 | 512)]
    public static int3x2 operator --(int3x2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static int3x2 operator ++(int3x2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int3x2 abs(this int3x2 a) => 
        new(a.c0.abs(), a.c1.abs());

    [MethodImpl(256 | 512)]
    public static int3x2 sign(this int3x2 a) => 
        new(a.c0.sign(), a.c1.sign());

    [MethodImpl(256 | 512)]
    public static int3x2 min(this int3x2 a, int3x2 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1));

    [MethodImpl(256 | 512)]
    public static int3x2 max(this int3x2 a, int3x2 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1));

    [MethodImpl(256 | 512)]
    public static int3x2 clamp(this int3x2 v, int3x2 min, int3x2 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1));

    [MethodImpl(256 | 512)]
    public static int3x2 square(this int3x2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int3x2 fma(this int3x2 a, int3x2 b, int3x2 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static int3x2 fms(this int3x2 a, int3x2 b, int3x2 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1));

    [MethodImpl(256 | 512)]
    public static int2 csum(this int3x2 a) => 
        new(a.c0.csum(), a.c1.csum());

    [MethodImpl(256 | 512)]
    public static int2 cmin(this int3x2 a) => 
        new(a.c0.cmin(), a.c1.cmin());

    [MethodImpl(256 | 512)]
    public static int2 cmax(this int3x2 a) => 
        new(a.c0.cmax(), a.c1.cmax());
}

#endregion // int3x2

#region int3x3

public partial struct int3x3
{
    [MethodImpl(256 | 512)]
    public static int3x3 operator +(int3x3 a) => a;

    [MethodImpl(256 | 512)]
    public static int3x3 operator -(int3x3 a) => 
        new(-a.c0, -a.c1, -a.c2);

    [MethodImpl(256 | 512)]
    public static int3x3 operator +(int3x3 a, int3x3 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2);

    [MethodImpl(256 | 512)]
    public static int3x3 operator -(int3x3 a, int3x3 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2);

    [MethodImpl(256 | 512)]
    public static int3x3 operator *(int3x3 a, int3x3 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2);

    [MethodImpl(256 | 512)]
    public static int3x3 operator *(int3x3 a, int b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b);

    [MethodImpl(256 | 512)]
    public static int3x3 operator *(int a, int3x3 b) => 
        new(a * b.c0, a * b.c1, a * b.c2);

    [MethodImpl(256 | 512)]
    public static int3x3 operator /(int3x3 a, int3x3 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2);

    [MethodImpl(256 | 512)]
    public static int3x3 operator /(int3x3 a, int b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b);

    [MethodImpl(256 | 512)]
    public static int3x3 operator %(int3x3 a, int3x3 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2);

    [MethodImpl(256 | 512)]
    public static int3x3 operator %(int3x3 a, int b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b);

    [MethodImpl(256 | 512)]
    public static int3x3 operator --(int3x3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static int3x3 operator ++(int3x3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int3x3 abs(this int3x3 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs());

    [MethodImpl(256 | 512)]
    public static int3x3 sign(this int3x3 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign());

    [MethodImpl(256 | 512)]
    public static int3x3 min(this int3x3 a, int3x3 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2));

    [MethodImpl(256 | 512)]
    public static int3x3 max(this int3x3 a, int3x3 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2));

    [MethodImpl(256 | 512)]
    public static int3x3 clamp(this int3x3 v, int3x3 min, int3x3 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2));

    [MethodImpl(256 | 512)]
    public static int3x3 square(this int3x3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int3x3 fma(this int3x3 a, int3x3 b, int3x3 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static int3x3 fms(this int3x3 a, int3x3 b, int3x3 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2));

    [MethodImpl(256 | 512)]
    public static int3 csum(this int3x3 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum());

    [MethodImpl(256 | 512)]
    public static int3 cmin(this int3x3 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin());

    [MethodImpl(256 | 512)]
    public static int3 cmax(this int3x3 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax());
}

#endregion // int3x3

#region int3x4

public partial struct int3x4
{
    [MethodImpl(256 | 512)]
    public static int3x4 operator +(int3x4 a) => a;

    [MethodImpl(256 | 512)]
    public static int3x4 operator -(int3x4 a) => 
        new(-a.c0, -a.c1, -a.c2, -a.c3);

    [MethodImpl(256 | 512)]
    public static int3x4 operator +(int3x4 a, int3x4 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2, a.c3 + b.c3);

    [MethodImpl(256 | 512)]
    public static int3x4 operator -(int3x4 a, int3x4 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2, a.c3 - b.c3);

    [MethodImpl(256 | 512)]
    public static int3x4 operator *(int3x4 a, int3x4 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2, a.c3 * b.c3);

    [MethodImpl(256 | 512)]
    public static int3x4 operator *(int3x4 a, int b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b, a.c3 * b);

    [MethodImpl(256 | 512)]
    public static int3x4 operator *(int a, int3x4 b) => 
        new(a * b.c0, a * b.c1, a * b.c2, a * b.c3);

    [MethodImpl(256 | 512)]
    public static int3x4 operator /(int3x4 a, int3x4 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2, a.c3 / b.c3);

    [MethodImpl(256 | 512)]
    public static int3x4 operator /(int3x4 a, int b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b, a.c3 / b);

    [MethodImpl(256 | 512)]
    public static int3x4 operator %(int3x4 a, int3x4 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2, a.c3 % b.c3);

    [MethodImpl(256 | 512)]
    public static int3x4 operator %(int3x4 a, int b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b, a.c3 % b);

    [MethodImpl(256 | 512)]
    public static int3x4 operator --(int3x4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static int3x4 operator ++(int3x4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int3x4 abs(this int3x4 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs(), a.c3.abs());

    [MethodImpl(256 | 512)]
    public static int3x4 sign(this int3x4 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign(), a.c3.sign());

    [MethodImpl(256 | 512)]
    public static int3x4 min(this int3x4 a, int3x4 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2), a.c3.min(b.c3));

    [MethodImpl(256 | 512)]
    public static int3x4 max(this int3x4 a, int3x4 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2), a.c3.max(b.c3));

    [MethodImpl(256 | 512)]
    public static int3x4 clamp(this int3x4 v, int3x4 min, int3x4 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2), v.c3.clamp(min.c3, max.c3));

    [MethodImpl(256 | 512)]
    public static int3x4 square(this int3x4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int3x4 fma(this int3x4 a, int3x4 b, int3x4 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2), a.c3.fma(b.c3, c.c3));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static int3x4 fms(this int3x4 a, int3x4 b, int3x4 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2), a.c3.fms(b.c3, c.c3));

    [MethodImpl(256 | 512)]
    public static int4 csum(this int3x4 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum(), a.c3.csum());

    [MethodImpl(256 | 512)]
    public static int4 cmin(this int3x4 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin(), a.c3.cmin());

    [MethodImpl(256 | 512)]
    public static int4 cmax(this int3x4 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax(), a.c3.cmax());
}

#endregion // int3x4

#region int4x2

public partial struct int4x2
{
    [MethodImpl(256 | 512)]
    public static int4x2 operator +(int4x2 a) => a;

    [MethodImpl(256 | 512)]
    public static int4x2 operator -(int4x2 a) => 
        new(-a.c0, -a.c1);

    [MethodImpl(256 | 512)]
    public static int4x2 operator +(int4x2 a, int4x2 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1);

    [MethodImpl(256 | 512)]
    public static int4x2 operator -(int4x2 a, int4x2 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1);

    [MethodImpl(256 | 512)]
    public static int4x2 operator *(int4x2 a, int4x2 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1);

    [MethodImpl(256 | 512)]
    public static int4x2 operator *(int4x2 a, int b) => 
        new(a.c0 * b, a.c1 * b);

    [MethodImpl(256 | 512)]
    public static int4x2 operator *(int a, int4x2 b) => 
        new(a * b.c0, a * b.c1);

    [MethodImpl(256 | 512)]
    public static int4x2 operator /(int4x2 a, int4x2 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1);

    [MethodImpl(256 | 512)]
    public static int4x2 operator /(int4x2 a, int b) => 
        new(a.c0 / b, a.c1 / b);

    [MethodImpl(256 | 512)]
    public static int4x2 operator %(int4x2 a, int4x2 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1);

    [MethodImpl(256 | 512)]
    public static int4x2 operator %(int4x2 a, int b) => 
        new(a.c0 % b, a.c1 % b);

    [MethodImpl(256 | 512)]
    public static int4x2 operator --(int4x2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static int4x2 operator ++(int4x2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int4x2 abs(this int4x2 a) => 
        new(a.c0.abs(), a.c1.abs());

    [MethodImpl(256 | 512)]
    public static int4x2 sign(this int4x2 a) => 
        new(a.c0.sign(), a.c1.sign());

    [MethodImpl(256 | 512)]
    public static int4x2 min(this int4x2 a, int4x2 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1));

    [MethodImpl(256 | 512)]
    public static int4x2 max(this int4x2 a, int4x2 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1));

    [MethodImpl(256 | 512)]
    public static int4x2 clamp(this int4x2 v, int4x2 min, int4x2 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1));

    [MethodImpl(256 | 512)]
    public static int4x2 square(this int4x2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int4x2 fma(this int4x2 a, int4x2 b, int4x2 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static int4x2 fms(this int4x2 a, int4x2 b, int4x2 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1));

    [MethodImpl(256 | 512)]
    public static int2 csum(this int4x2 a) => 
        new(a.c0.csum(), a.c1.csum());

    [MethodImpl(256 | 512)]
    public static int2 cmin(this int4x2 a) => 
        new(a.c0.cmin(), a.c1.cmin());

    [MethodImpl(256 | 512)]
    public static int2 cmax(this int4x2 a) => 
        new(a.c0.cmax(), a.c1.cmax());
}

#endregion // int4x2

#region int4x3

public partial struct int4x3
{
    [MethodImpl(256 | 512)]
    public static int4x3 operator +(int4x3 a) => a;

    [MethodImpl(256 | 512)]
    public static int4x3 operator -(int4x3 a) => 
        new(-a.c0, -a.c1, -a.c2);

    [MethodImpl(256 | 512)]
    public static int4x3 operator +(int4x3 a, int4x3 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2);

    [MethodImpl(256 | 512)]
    public static int4x3 operator -(int4x3 a, int4x3 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2);

    [MethodImpl(256 | 512)]
    public static int4x3 operator *(int4x3 a, int4x3 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2);

    [MethodImpl(256 | 512)]
    public static int4x3 operator *(int4x3 a, int b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b);

    [MethodImpl(256 | 512)]
    public static int4x3 operator *(int a, int4x3 b) => 
        new(a * b.c0, a * b.c1, a * b.c2);

    [MethodImpl(256 | 512)]
    public static int4x3 operator /(int4x3 a, int4x3 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2);

    [MethodImpl(256 | 512)]
    public static int4x3 operator /(int4x3 a, int b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b);

    [MethodImpl(256 | 512)]
    public static int4x3 operator %(int4x3 a, int4x3 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2);

    [MethodImpl(256 | 512)]
    public static int4x3 operator %(int4x3 a, int b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b);

    [MethodImpl(256 | 512)]
    public static int4x3 operator --(int4x3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static int4x3 operator ++(int4x3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int4x3 abs(this int4x3 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs());

    [MethodImpl(256 | 512)]
    public static int4x3 sign(this int4x3 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign());

    [MethodImpl(256 | 512)]
    public static int4x3 min(this int4x3 a, int4x3 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2));

    [MethodImpl(256 | 512)]
    public static int4x3 max(this int4x3 a, int4x3 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2));

    [MethodImpl(256 | 512)]
    public static int4x3 clamp(this int4x3 v, int4x3 min, int4x3 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2));

    [MethodImpl(256 | 512)]
    public static int4x3 square(this int4x3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int4x3 fma(this int4x3 a, int4x3 b, int4x3 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static int4x3 fms(this int4x3 a, int4x3 b, int4x3 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2));

    [MethodImpl(256 | 512)]
    public static int3 csum(this int4x3 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum());

    [MethodImpl(256 | 512)]
    public static int3 cmin(this int4x3 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin());

    [MethodImpl(256 | 512)]
    public static int3 cmax(this int4x3 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax());
}

#endregion // int4x3

#region int4x4

public partial struct int4x4
{
    [MethodImpl(256 | 512)]
    public static int4x4 operator +(int4x4 a) => a;

    [MethodImpl(256 | 512)]
    public static int4x4 operator -(int4x4 a) => 
        new(-a.c0, -a.c1, -a.c2, -a.c3);

    [MethodImpl(256 | 512)]
    public static int4x4 operator +(int4x4 a, int4x4 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2, a.c3 + b.c3);

    [MethodImpl(256 | 512)]
    public static int4x4 operator -(int4x4 a, int4x4 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2, a.c3 - b.c3);

    [MethodImpl(256 | 512)]
    public static int4x4 operator *(int4x4 a, int4x4 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2, a.c3 * b.c3);

    [MethodImpl(256 | 512)]
    public static int4x4 operator *(int4x4 a, int b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b, a.c3 * b);

    [MethodImpl(256 | 512)]
    public static int4x4 operator *(int a, int4x4 b) => 
        new(a * b.c0, a * b.c1, a * b.c2, a * b.c3);

    [MethodImpl(256 | 512)]
    public static int4x4 operator /(int4x4 a, int4x4 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2, a.c3 / b.c3);

    [MethodImpl(256 | 512)]
    public static int4x4 operator /(int4x4 a, int b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b, a.c3 / b);

    [MethodImpl(256 | 512)]
    public static int4x4 operator %(int4x4 a, int4x4 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2, a.c3 % b.c3);

    [MethodImpl(256 | 512)]
    public static int4x4 operator %(int4x4 a, int b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b, a.c3 % b);

    [MethodImpl(256 | 512)]
    public static int4x4 operator --(int4x4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static int4x4 operator ++(int4x4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int4x4 abs(this int4x4 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs(), a.c3.abs());

    [MethodImpl(256 | 512)]
    public static int4x4 sign(this int4x4 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign(), a.c3.sign());

    [MethodImpl(256 | 512)]
    public static int4x4 min(this int4x4 a, int4x4 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2), a.c3.min(b.c3));

    [MethodImpl(256 | 512)]
    public static int4x4 max(this int4x4 a, int4x4 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2), a.c3.max(b.c3));

    [MethodImpl(256 | 512)]
    public static int4x4 clamp(this int4x4 v, int4x4 min, int4x4 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2), v.c3.clamp(min.c3, max.c3));

    [MethodImpl(256 | 512)]
    public static int4x4 square(this int4x4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int4x4 fma(this int4x4 a, int4x4 b, int4x4 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2), a.c3.fma(b.c3, c.c3));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static int4x4 fms(this int4x4 a, int4x4 b, int4x4 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2), a.c3.fms(b.c3, c.c3));

    [MethodImpl(256 | 512)]
    public static int4 csum(this int4x4 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum(), a.c3.csum());

    [MethodImpl(256 | 512)]
    public static int4 cmin(this int4x4 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin(), a.c3.cmin());

    [MethodImpl(256 | 512)]
    public static int4 cmax(this int4x4 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax(), a.c3.cmax());
}

#endregion // int4x4

#region uint2x2

public partial struct uint2x2
{
    [MethodImpl(256 | 512)]
    public static uint2x2 operator +(uint2x2 a) => a;

    [MethodImpl(256 | 512)]
    public static uint2x2 operator +(uint2x2 a, uint2x2 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1);

    [MethodImpl(256 | 512)]
    public static uint2x2 operator -(uint2x2 a, uint2x2 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1);

    [MethodImpl(256 | 512)]
    public static uint2x2 operator *(uint2x2 a, uint2x2 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1);

    [MethodImpl(256 | 512)]
    public static uint2x2 operator *(uint2x2 a, uint b) => 
        new(a.c0 * b, a.c1 * b);

    [MethodImpl(256 | 512)]
    public static uint2x2 operator *(uint a, uint2x2 b) => 
        new(a * b.c0, a * b.c1);

    [MethodImpl(256 | 512)]
    public static uint2x2 operator /(uint2x2 a, uint2x2 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1);

    [MethodImpl(256 | 512)]
    public static uint2x2 operator /(uint2x2 a, uint b) => 
        new(a.c0 / b, a.c1 / b);

    [MethodImpl(256 | 512)]
    public static uint2x2 operator %(uint2x2 a, uint2x2 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1);

    [MethodImpl(256 | 512)]
    public static uint2x2 operator %(uint2x2 a, uint b) => 
        new(a.c0 % b, a.c1 % b);

    [MethodImpl(256 | 512)]
    public static uint2x2 operator --(uint2x2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static uint2x2 operator ++(uint2x2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint2x2 abs(this uint2x2 a) => 
        new(a.c0.abs(), a.c1.abs());

    [MethodImpl(256 | 512)]
    public static uint2x2 sign(this uint2x2 a) => 
        new(a.c0.sign(), a.c1.sign());

    [MethodImpl(256 | 512)]
    public static uint2x2 min(this uint2x2 a, uint2x2 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1));

    [MethodImpl(256 | 512)]
    public static uint2x2 max(this uint2x2 a, uint2x2 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1));

    [MethodImpl(256 | 512)]
    public static uint2x2 clamp(this uint2x2 v, uint2x2 min, uint2x2 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1));

    [MethodImpl(256 | 512)]
    public static uint2x2 square(this uint2x2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint2x2 fma(this uint2x2 a, uint2x2 b, uint2x2 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static uint2x2 fms(this uint2x2 a, uint2x2 b, uint2x2 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1));

    [MethodImpl(256 | 512)]
    public static uint2 csum(this uint2x2 a) => 
        new(a.c0.csum(), a.c1.csum());

    [MethodImpl(256 | 512)]
    public static uint2 cmin(this uint2x2 a) => 
        new(a.c0.cmin(), a.c1.cmin());

    [MethodImpl(256 | 512)]
    public static uint2 cmax(this uint2x2 a) => 
        new(a.c0.cmax(), a.c1.cmax());
}

#endregion // uint2x2

#region uint2x3

public partial struct uint2x3
{
    [MethodImpl(256 | 512)]
    public static uint2x3 operator +(uint2x3 a) => a;

    [MethodImpl(256 | 512)]
    public static uint2x3 operator +(uint2x3 a, uint2x3 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2);

    [MethodImpl(256 | 512)]
    public static uint2x3 operator -(uint2x3 a, uint2x3 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2);

    [MethodImpl(256 | 512)]
    public static uint2x3 operator *(uint2x3 a, uint2x3 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2);

    [MethodImpl(256 | 512)]
    public static uint2x3 operator *(uint2x3 a, uint b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b);

    [MethodImpl(256 | 512)]
    public static uint2x3 operator *(uint a, uint2x3 b) => 
        new(a * b.c0, a * b.c1, a * b.c2);

    [MethodImpl(256 | 512)]
    public static uint2x3 operator /(uint2x3 a, uint2x3 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2);

    [MethodImpl(256 | 512)]
    public static uint2x3 operator /(uint2x3 a, uint b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b);

    [MethodImpl(256 | 512)]
    public static uint2x3 operator %(uint2x3 a, uint2x3 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2);

    [MethodImpl(256 | 512)]
    public static uint2x3 operator %(uint2x3 a, uint b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b);

    [MethodImpl(256 | 512)]
    public static uint2x3 operator --(uint2x3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static uint2x3 operator ++(uint2x3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint2x3 abs(this uint2x3 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs());

    [MethodImpl(256 | 512)]
    public static uint2x3 sign(this uint2x3 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign());

    [MethodImpl(256 | 512)]
    public static uint2x3 min(this uint2x3 a, uint2x3 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2));

    [MethodImpl(256 | 512)]
    public static uint2x3 max(this uint2x3 a, uint2x3 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2));

    [MethodImpl(256 | 512)]
    public static uint2x3 clamp(this uint2x3 v, uint2x3 min, uint2x3 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2));

    [MethodImpl(256 | 512)]
    public static uint2x3 square(this uint2x3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint2x3 fma(this uint2x3 a, uint2x3 b, uint2x3 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static uint2x3 fms(this uint2x3 a, uint2x3 b, uint2x3 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2));

    [MethodImpl(256 | 512)]
    public static uint3 csum(this uint2x3 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum());

    [MethodImpl(256 | 512)]
    public static uint3 cmin(this uint2x3 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin());

    [MethodImpl(256 | 512)]
    public static uint3 cmax(this uint2x3 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax());
}

#endregion // uint2x3

#region uint2x4

public partial struct uint2x4
{
    [MethodImpl(256 | 512)]
    public static uint2x4 operator +(uint2x4 a) => a;

    [MethodImpl(256 | 512)]
    public static uint2x4 operator +(uint2x4 a, uint2x4 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2, a.c3 + b.c3);

    [MethodImpl(256 | 512)]
    public static uint2x4 operator -(uint2x4 a, uint2x4 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2, a.c3 - b.c3);

    [MethodImpl(256 | 512)]
    public static uint2x4 operator *(uint2x4 a, uint2x4 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2, a.c3 * b.c3);

    [MethodImpl(256 | 512)]
    public static uint2x4 operator *(uint2x4 a, uint b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b, a.c3 * b);

    [MethodImpl(256 | 512)]
    public static uint2x4 operator *(uint a, uint2x4 b) => 
        new(a * b.c0, a * b.c1, a * b.c2, a * b.c3);

    [MethodImpl(256 | 512)]
    public static uint2x4 operator /(uint2x4 a, uint2x4 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2, a.c3 / b.c3);

    [MethodImpl(256 | 512)]
    public static uint2x4 operator /(uint2x4 a, uint b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b, a.c3 / b);

    [MethodImpl(256 | 512)]
    public static uint2x4 operator %(uint2x4 a, uint2x4 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2, a.c3 % b.c3);

    [MethodImpl(256 | 512)]
    public static uint2x4 operator %(uint2x4 a, uint b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b, a.c3 % b);

    [MethodImpl(256 | 512)]
    public static uint2x4 operator --(uint2x4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static uint2x4 operator ++(uint2x4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint2x4 abs(this uint2x4 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs(), a.c3.abs());

    [MethodImpl(256 | 512)]
    public static uint2x4 sign(this uint2x4 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign(), a.c3.sign());

    [MethodImpl(256 | 512)]
    public static uint2x4 min(this uint2x4 a, uint2x4 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2), a.c3.min(b.c3));

    [MethodImpl(256 | 512)]
    public static uint2x4 max(this uint2x4 a, uint2x4 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2), a.c3.max(b.c3));

    [MethodImpl(256 | 512)]
    public static uint2x4 clamp(this uint2x4 v, uint2x4 min, uint2x4 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2), v.c3.clamp(min.c3, max.c3));

    [MethodImpl(256 | 512)]
    public static uint2x4 square(this uint2x4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint2x4 fma(this uint2x4 a, uint2x4 b, uint2x4 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2), a.c3.fma(b.c3, c.c3));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static uint2x4 fms(this uint2x4 a, uint2x4 b, uint2x4 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2), a.c3.fms(b.c3, c.c3));

    [MethodImpl(256 | 512)]
    public static uint4 csum(this uint2x4 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum(), a.c3.csum());

    [MethodImpl(256 | 512)]
    public static uint4 cmin(this uint2x4 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin(), a.c3.cmin());

    [MethodImpl(256 | 512)]
    public static uint4 cmax(this uint2x4 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax(), a.c3.cmax());
}

#endregion // uint2x4

#region uint3x2

public partial struct uint3x2
{
    [MethodImpl(256 | 512)]
    public static uint3x2 operator +(uint3x2 a) => a;

    [MethodImpl(256 | 512)]
    public static uint3x2 operator +(uint3x2 a, uint3x2 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1);

    [MethodImpl(256 | 512)]
    public static uint3x2 operator -(uint3x2 a, uint3x2 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1);

    [MethodImpl(256 | 512)]
    public static uint3x2 operator *(uint3x2 a, uint3x2 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1);

    [MethodImpl(256 | 512)]
    public static uint3x2 operator *(uint3x2 a, uint b) => 
        new(a.c0 * b, a.c1 * b);

    [MethodImpl(256 | 512)]
    public static uint3x2 operator *(uint a, uint3x2 b) => 
        new(a * b.c0, a * b.c1);

    [MethodImpl(256 | 512)]
    public static uint3x2 operator /(uint3x2 a, uint3x2 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1);

    [MethodImpl(256 | 512)]
    public static uint3x2 operator /(uint3x2 a, uint b) => 
        new(a.c0 / b, a.c1 / b);

    [MethodImpl(256 | 512)]
    public static uint3x2 operator %(uint3x2 a, uint3x2 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1);

    [MethodImpl(256 | 512)]
    public static uint3x2 operator %(uint3x2 a, uint b) => 
        new(a.c0 % b, a.c1 % b);

    [MethodImpl(256 | 512)]
    public static uint3x2 operator --(uint3x2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static uint3x2 operator ++(uint3x2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint3x2 abs(this uint3x2 a) => 
        new(a.c0.abs(), a.c1.abs());

    [MethodImpl(256 | 512)]
    public static uint3x2 sign(this uint3x2 a) => 
        new(a.c0.sign(), a.c1.sign());

    [MethodImpl(256 | 512)]
    public static uint3x2 min(this uint3x2 a, uint3x2 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1));

    [MethodImpl(256 | 512)]
    public static uint3x2 max(this uint3x2 a, uint3x2 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1));

    [MethodImpl(256 | 512)]
    public static uint3x2 clamp(this uint3x2 v, uint3x2 min, uint3x2 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1));

    [MethodImpl(256 | 512)]
    public static uint3x2 square(this uint3x2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint3x2 fma(this uint3x2 a, uint3x2 b, uint3x2 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static uint3x2 fms(this uint3x2 a, uint3x2 b, uint3x2 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1));

    [MethodImpl(256 | 512)]
    public static uint2 csum(this uint3x2 a) => 
        new(a.c0.csum(), a.c1.csum());

    [MethodImpl(256 | 512)]
    public static uint2 cmin(this uint3x2 a) => 
        new(a.c0.cmin(), a.c1.cmin());

    [MethodImpl(256 | 512)]
    public static uint2 cmax(this uint3x2 a) => 
        new(a.c0.cmax(), a.c1.cmax());
}

#endregion // uint3x2

#region uint3x3

public partial struct uint3x3
{
    [MethodImpl(256 | 512)]
    public static uint3x3 operator +(uint3x3 a) => a;

    [MethodImpl(256 | 512)]
    public static uint3x3 operator +(uint3x3 a, uint3x3 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2);

    [MethodImpl(256 | 512)]
    public static uint3x3 operator -(uint3x3 a, uint3x3 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2);

    [MethodImpl(256 | 512)]
    public static uint3x3 operator *(uint3x3 a, uint3x3 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2);

    [MethodImpl(256 | 512)]
    public static uint3x3 operator *(uint3x3 a, uint b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b);

    [MethodImpl(256 | 512)]
    public static uint3x3 operator *(uint a, uint3x3 b) => 
        new(a * b.c0, a * b.c1, a * b.c2);

    [MethodImpl(256 | 512)]
    public static uint3x3 operator /(uint3x3 a, uint3x3 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2);

    [MethodImpl(256 | 512)]
    public static uint3x3 operator /(uint3x3 a, uint b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b);

    [MethodImpl(256 | 512)]
    public static uint3x3 operator %(uint3x3 a, uint3x3 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2);

    [MethodImpl(256 | 512)]
    public static uint3x3 operator %(uint3x3 a, uint b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b);

    [MethodImpl(256 | 512)]
    public static uint3x3 operator --(uint3x3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static uint3x3 operator ++(uint3x3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint3x3 abs(this uint3x3 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs());

    [MethodImpl(256 | 512)]
    public static uint3x3 sign(this uint3x3 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign());

    [MethodImpl(256 | 512)]
    public static uint3x3 min(this uint3x3 a, uint3x3 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2));

    [MethodImpl(256 | 512)]
    public static uint3x3 max(this uint3x3 a, uint3x3 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2));

    [MethodImpl(256 | 512)]
    public static uint3x3 clamp(this uint3x3 v, uint3x3 min, uint3x3 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2));

    [MethodImpl(256 | 512)]
    public static uint3x3 square(this uint3x3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint3x3 fma(this uint3x3 a, uint3x3 b, uint3x3 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static uint3x3 fms(this uint3x3 a, uint3x3 b, uint3x3 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2));

    [MethodImpl(256 | 512)]
    public static uint3 csum(this uint3x3 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum());

    [MethodImpl(256 | 512)]
    public static uint3 cmin(this uint3x3 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin());

    [MethodImpl(256 | 512)]
    public static uint3 cmax(this uint3x3 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax());
}

#endregion // uint3x3

#region uint3x4

public partial struct uint3x4
{
    [MethodImpl(256 | 512)]
    public static uint3x4 operator +(uint3x4 a) => a;

    [MethodImpl(256 | 512)]
    public static uint3x4 operator +(uint3x4 a, uint3x4 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2, a.c3 + b.c3);

    [MethodImpl(256 | 512)]
    public static uint3x4 operator -(uint3x4 a, uint3x4 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2, a.c3 - b.c3);

    [MethodImpl(256 | 512)]
    public static uint3x4 operator *(uint3x4 a, uint3x4 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2, a.c3 * b.c3);

    [MethodImpl(256 | 512)]
    public static uint3x4 operator *(uint3x4 a, uint b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b, a.c3 * b);

    [MethodImpl(256 | 512)]
    public static uint3x4 operator *(uint a, uint3x4 b) => 
        new(a * b.c0, a * b.c1, a * b.c2, a * b.c3);

    [MethodImpl(256 | 512)]
    public static uint3x4 operator /(uint3x4 a, uint3x4 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2, a.c3 / b.c3);

    [MethodImpl(256 | 512)]
    public static uint3x4 operator /(uint3x4 a, uint b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b, a.c3 / b);

    [MethodImpl(256 | 512)]
    public static uint3x4 operator %(uint3x4 a, uint3x4 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2, a.c3 % b.c3);

    [MethodImpl(256 | 512)]
    public static uint3x4 operator %(uint3x4 a, uint b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b, a.c3 % b);

    [MethodImpl(256 | 512)]
    public static uint3x4 operator --(uint3x4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static uint3x4 operator ++(uint3x4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint3x4 abs(this uint3x4 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs(), a.c3.abs());

    [MethodImpl(256 | 512)]
    public static uint3x4 sign(this uint3x4 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign(), a.c3.sign());

    [MethodImpl(256 | 512)]
    public static uint3x4 min(this uint3x4 a, uint3x4 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2), a.c3.min(b.c3));

    [MethodImpl(256 | 512)]
    public static uint3x4 max(this uint3x4 a, uint3x4 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2), a.c3.max(b.c3));

    [MethodImpl(256 | 512)]
    public static uint3x4 clamp(this uint3x4 v, uint3x4 min, uint3x4 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2), v.c3.clamp(min.c3, max.c3));

    [MethodImpl(256 | 512)]
    public static uint3x4 square(this uint3x4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint3x4 fma(this uint3x4 a, uint3x4 b, uint3x4 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2), a.c3.fma(b.c3, c.c3));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static uint3x4 fms(this uint3x4 a, uint3x4 b, uint3x4 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2), a.c3.fms(b.c3, c.c3));

    [MethodImpl(256 | 512)]
    public static uint4 csum(this uint3x4 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum(), a.c3.csum());

    [MethodImpl(256 | 512)]
    public static uint4 cmin(this uint3x4 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin(), a.c3.cmin());

    [MethodImpl(256 | 512)]
    public static uint4 cmax(this uint3x4 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax(), a.c3.cmax());
}

#endregion // uint3x4

#region uint4x2

public partial struct uint4x2
{
    [MethodImpl(256 | 512)]
    public static uint4x2 operator +(uint4x2 a) => a;

    [MethodImpl(256 | 512)]
    public static uint4x2 operator +(uint4x2 a, uint4x2 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1);

    [MethodImpl(256 | 512)]
    public static uint4x2 operator -(uint4x2 a, uint4x2 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1);

    [MethodImpl(256 | 512)]
    public static uint4x2 operator *(uint4x2 a, uint4x2 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1);

    [MethodImpl(256 | 512)]
    public static uint4x2 operator *(uint4x2 a, uint b) => 
        new(a.c0 * b, a.c1 * b);

    [MethodImpl(256 | 512)]
    public static uint4x2 operator *(uint a, uint4x2 b) => 
        new(a * b.c0, a * b.c1);

    [MethodImpl(256 | 512)]
    public static uint4x2 operator /(uint4x2 a, uint4x2 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1);

    [MethodImpl(256 | 512)]
    public static uint4x2 operator /(uint4x2 a, uint b) => 
        new(a.c0 / b, a.c1 / b);

    [MethodImpl(256 | 512)]
    public static uint4x2 operator %(uint4x2 a, uint4x2 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1);

    [MethodImpl(256 | 512)]
    public static uint4x2 operator %(uint4x2 a, uint b) => 
        new(a.c0 % b, a.c1 % b);

    [MethodImpl(256 | 512)]
    public static uint4x2 operator --(uint4x2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static uint4x2 operator ++(uint4x2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint4x2 abs(this uint4x2 a) => 
        new(a.c0.abs(), a.c1.abs());

    [MethodImpl(256 | 512)]
    public static uint4x2 sign(this uint4x2 a) => 
        new(a.c0.sign(), a.c1.sign());

    [MethodImpl(256 | 512)]
    public static uint4x2 min(this uint4x2 a, uint4x2 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1));

    [MethodImpl(256 | 512)]
    public static uint4x2 max(this uint4x2 a, uint4x2 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1));

    [MethodImpl(256 | 512)]
    public static uint4x2 clamp(this uint4x2 v, uint4x2 min, uint4x2 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1));

    [MethodImpl(256 | 512)]
    public static uint4x2 square(this uint4x2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint4x2 fma(this uint4x2 a, uint4x2 b, uint4x2 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static uint4x2 fms(this uint4x2 a, uint4x2 b, uint4x2 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1));

    [MethodImpl(256 | 512)]
    public static uint2 csum(this uint4x2 a) => 
        new(a.c0.csum(), a.c1.csum());

    [MethodImpl(256 | 512)]
    public static uint2 cmin(this uint4x2 a) => 
        new(a.c0.cmin(), a.c1.cmin());

    [MethodImpl(256 | 512)]
    public static uint2 cmax(this uint4x2 a) => 
        new(a.c0.cmax(), a.c1.cmax());
}

#endregion // uint4x2

#region uint4x3

public partial struct uint4x3
{
    [MethodImpl(256 | 512)]
    public static uint4x3 operator +(uint4x3 a) => a;

    [MethodImpl(256 | 512)]
    public static uint4x3 operator +(uint4x3 a, uint4x3 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2);

    [MethodImpl(256 | 512)]
    public static uint4x3 operator -(uint4x3 a, uint4x3 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2);

    [MethodImpl(256 | 512)]
    public static uint4x3 operator *(uint4x3 a, uint4x3 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2);

    [MethodImpl(256 | 512)]
    public static uint4x3 operator *(uint4x3 a, uint b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b);

    [MethodImpl(256 | 512)]
    public static uint4x3 operator *(uint a, uint4x3 b) => 
        new(a * b.c0, a * b.c1, a * b.c2);

    [MethodImpl(256 | 512)]
    public static uint4x3 operator /(uint4x3 a, uint4x3 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2);

    [MethodImpl(256 | 512)]
    public static uint4x3 operator /(uint4x3 a, uint b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b);

    [MethodImpl(256 | 512)]
    public static uint4x3 operator %(uint4x3 a, uint4x3 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2);

    [MethodImpl(256 | 512)]
    public static uint4x3 operator %(uint4x3 a, uint b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b);

    [MethodImpl(256 | 512)]
    public static uint4x3 operator --(uint4x3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static uint4x3 operator ++(uint4x3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint4x3 abs(this uint4x3 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs());

    [MethodImpl(256 | 512)]
    public static uint4x3 sign(this uint4x3 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign());

    [MethodImpl(256 | 512)]
    public static uint4x3 min(this uint4x3 a, uint4x3 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2));

    [MethodImpl(256 | 512)]
    public static uint4x3 max(this uint4x3 a, uint4x3 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2));

    [MethodImpl(256 | 512)]
    public static uint4x3 clamp(this uint4x3 v, uint4x3 min, uint4x3 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2));

    [MethodImpl(256 | 512)]
    public static uint4x3 square(this uint4x3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint4x3 fma(this uint4x3 a, uint4x3 b, uint4x3 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static uint4x3 fms(this uint4x3 a, uint4x3 b, uint4x3 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2));

    [MethodImpl(256 | 512)]
    public static uint3 csum(this uint4x3 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum());

    [MethodImpl(256 | 512)]
    public static uint3 cmin(this uint4x3 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin());

    [MethodImpl(256 | 512)]
    public static uint3 cmax(this uint4x3 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax());
}

#endregion // uint4x3

#region uint4x4

public partial struct uint4x4
{
    [MethodImpl(256 | 512)]
    public static uint4x4 operator +(uint4x4 a) => a;

    [MethodImpl(256 | 512)]
    public static uint4x4 operator +(uint4x4 a, uint4x4 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2, a.c3 + b.c3);

    [MethodImpl(256 | 512)]
    public static uint4x4 operator -(uint4x4 a, uint4x4 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2, a.c3 - b.c3);

    [MethodImpl(256 | 512)]
    public static uint4x4 operator *(uint4x4 a, uint4x4 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2, a.c3 * b.c3);

    [MethodImpl(256 | 512)]
    public static uint4x4 operator *(uint4x4 a, uint b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b, a.c3 * b);

    [MethodImpl(256 | 512)]
    public static uint4x4 operator *(uint a, uint4x4 b) => 
        new(a * b.c0, a * b.c1, a * b.c2, a * b.c3);

    [MethodImpl(256 | 512)]
    public static uint4x4 operator /(uint4x4 a, uint4x4 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2, a.c3 / b.c3);

    [MethodImpl(256 | 512)]
    public static uint4x4 operator /(uint4x4 a, uint b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b, a.c3 / b);

    [MethodImpl(256 | 512)]
    public static uint4x4 operator %(uint4x4 a, uint4x4 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2, a.c3 % b.c3);

    [MethodImpl(256 | 512)]
    public static uint4x4 operator %(uint4x4 a, uint b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b, a.c3 % b);

    [MethodImpl(256 | 512)]
    public static uint4x4 operator --(uint4x4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static uint4x4 operator ++(uint4x4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint4x4 abs(this uint4x4 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs(), a.c3.abs());

    [MethodImpl(256 | 512)]
    public static uint4x4 sign(this uint4x4 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign(), a.c3.sign());

    [MethodImpl(256 | 512)]
    public static uint4x4 min(this uint4x4 a, uint4x4 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2), a.c3.min(b.c3));

    [MethodImpl(256 | 512)]
    public static uint4x4 max(this uint4x4 a, uint4x4 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2), a.c3.max(b.c3));

    [MethodImpl(256 | 512)]
    public static uint4x4 clamp(this uint4x4 v, uint4x4 min, uint4x4 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2), v.c3.clamp(min.c3, max.c3));

    [MethodImpl(256 | 512)]
    public static uint4x4 square(this uint4x4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint4x4 fma(this uint4x4 a, uint4x4 b, uint4x4 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2), a.c3.fma(b.c3, c.c3));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static uint4x4 fms(this uint4x4 a, uint4x4 b, uint4x4 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2), a.c3.fms(b.c3, c.c3));

    [MethodImpl(256 | 512)]
    public static uint4 csum(this uint4x4 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum(), a.c3.csum());

    [MethodImpl(256 | 512)]
    public static uint4 cmin(this uint4x4 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin(), a.c3.cmin());

    [MethodImpl(256 | 512)]
    public static uint4 cmax(this uint4x4 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax(), a.c3.cmax());
}

#endregion // uint4x4

#region long2x2

public partial struct long2x2
{
    [MethodImpl(256 | 512)]
    public static long2x2 operator +(long2x2 a) => a;

    [MethodImpl(256 | 512)]
    public static long2x2 operator -(long2x2 a) => 
        new(-a.c0, -a.c1);

    [MethodImpl(256 | 512)]
    public static long2x2 operator +(long2x2 a, long2x2 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1);

    [MethodImpl(256 | 512)]
    public static long2x2 operator -(long2x2 a, long2x2 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1);

    [MethodImpl(256 | 512)]
    public static long2x2 operator *(long2x2 a, long2x2 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1);

    [MethodImpl(256 | 512)]
    public static long2x2 operator *(long2x2 a, long b) => 
        new(a.c0 * b, a.c1 * b);

    [MethodImpl(256 | 512)]
    public static long2x2 operator *(long a, long2x2 b) => 
        new(a * b.c0, a * b.c1);

    [MethodImpl(256 | 512)]
    public static long2x2 operator /(long2x2 a, long2x2 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1);

    [MethodImpl(256 | 512)]
    public static long2x2 operator /(long2x2 a, long b) => 
        new(a.c0 / b, a.c1 / b);

    [MethodImpl(256 | 512)]
    public static long2x2 operator %(long2x2 a, long2x2 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1);

    [MethodImpl(256 | 512)]
    public static long2x2 operator %(long2x2 a, long b) => 
        new(a.c0 % b, a.c1 % b);

    [MethodImpl(256 | 512)]
    public static long2x2 operator --(long2x2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static long2x2 operator ++(long2x2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long2x2 abs(this long2x2 a) => 
        new(a.c0.abs(), a.c1.abs());

    [MethodImpl(256 | 512)]
    public static long2x2 sign(this long2x2 a) => 
        new(a.c0.sign(), a.c1.sign());

    [MethodImpl(256 | 512)]
    public static long2x2 min(this long2x2 a, long2x2 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1));

    [MethodImpl(256 | 512)]
    public static long2x2 max(this long2x2 a, long2x2 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1));

    [MethodImpl(256 | 512)]
    public static long2x2 clamp(this long2x2 v, long2x2 min, long2x2 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1));

    [MethodImpl(256 | 512)]
    public static long2x2 square(this long2x2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long2x2 fma(this long2x2 a, long2x2 b, long2x2 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static long2x2 fms(this long2x2 a, long2x2 b, long2x2 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1));

    [MethodImpl(256 | 512)]
    public static long2 csum(this long2x2 a) => 
        new(a.c0.csum(), a.c1.csum());

    [MethodImpl(256 | 512)]
    public static long2 cmin(this long2x2 a) => 
        new(a.c0.cmin(), a.c1.cmin());

    [MethodImpl(256 | 512)]
    public static long2 cmax(this long2x2 a) => 
        new(a.c0.cmax(), a.c1.cmax());
}

#endregion // long2x2

#region long2x3

public partial struct long2x3
{
    [MethodImpl(256 | 512)]
    public static long2x3 operator +(long2x3 a) => a;

    [MethodImpl(256 | 512)]
    public static long2x3 operator -(long2x3 a) => 
        new(-a.c0, -a.c1, -a.c2);

    [MethodImpl(256 | 512)]
    public static long2x3 operator +(long2x3 a, long2x3 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2);

    [MethodImpl(256 | 512)]
    public static long2x3 operator -(long2x3 a, long2x3 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2);

    [MethodImpl(256 | 512)]
    public static long2x3 operator *(long2x3 a, long2x3 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2);

    [MethodImpl(256 | 512)]
    public static long2x3 operator *(long2x3 a, long b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b);

    [MethodImpl(256 | 512)]
    public static long2x3 operator *(long a, long2x3 b) => 
        new(a * b.c0, a * b.c1, a * b.c2);

    [MethodImpl(256 | 512)]
    public static long2x3 operator /(long2x3 a, long2x3 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2);

    [MethodImpl(256 | 512)]
    public static long2x3 operator /(long2x3 a, long b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b);

    [MethodImpl(256 | 512)]
    public static long2x3 operator %(long2x3 a, long2x3 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2);

    [MethodImpl(256 | 512)]
    public static long2x3 operator %(long2x3 a, long b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b);

    [MethodImpl(256 | 512)]
    public static long2x3 operator --(long2x3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static long2x3 operator ++(long2x3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long2x3 abs(this long2x3 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs());

    [MethodImpl(256 | 512)]
    public static long2x3 sign(this long2x3 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign());

    [MethodImpl(256 | 512)]
    public static long2x3 min(this long2x3 a, long2x3 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2));

    [MethodImpl(256 | 512)]
    public static long2x3 max(this long2x3 a, long2x3 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2));

    [MethodImpl(256 | 512)]
    public static long2x3 clamp(this long2x3 v, long2x3 min, long2x3 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2));

    [MethodImpl(256 | 512)]
    public static long2x3 square(this long2x3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long2x3 fma(this long2x3 a, long2x3 b, long2x3 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static long2x3 fms(this long2x3 a, long2x3 b, long2x3 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2));

    [MethodImpl(256 | 512)]
    public static long3 csum(this long2x3 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum());

    [MethodImpl(256 | 512)]
    public static long3 cmin(this long2x3 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin());

    [MethodImpl(256 | 512)]
    public static long3 cmax(this long2x3 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax());
}

#endregion // long2x3

#region long2x4

public partial struct long2x4
{
    [MethodImpl(256 | 512)]
    public static long2x4 operator +(long2x4 a) => a;

    [MethodImpl(256 | 512)]
    public static long2x4 operator -(long2x4 a) => 
        new(-a.c0, -a.c1, -a.c2, -a.c3);

    [MethodImpl(256 | 512)]
    public static long2x4 operator +(long2x4 a, long2x4 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2, a.c3 + b.c3);

    [MethodImpl(256 | 512)]
    public static long2x4 operator -(long2x4 a, long2x4 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2, a.c3 - b.c3);

    [MethodImpl(256 | 512)]
    public static long2x4 operator *(long2x4 a, long2x4 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2, a.c3 * b.c3);

    [MethodImpl(256 | 512)]
    public static long2x4 operator *(long2x4 a, long b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b, a.c3 * b);

    [MethodImpl(256 | 512)]
    public static long2x4 operator *(long a, long2x4 b) => 
        new(a * b.c0, a * b.c1, a * b.c2, a * b.c3);

    [MethodImpl(256 | 512)]
    public static long2x4 operator /(long2x4 a, long2x4 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2, a.c3 / b.c3);

    [MethodImpl(256 | 512)]
    public static long2x4 operator /(long2x4 a, long b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b, a.c3 / b);

    [MethodImpl(256 | 512)]
    public static long2x4 operator %(long2x4 a, long2x4 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2, a.c3 % b.c3);

    [MethodImpl(256 | 512)]
    public static long2x4 operator %(long2x4 a, long b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b, a.c3 % b);

    [MethodImpl(256 | 512)]
    public static long2x4 operator --(long2x4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static long2x4 operator ++(long2x4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long2x4 abs(this long2x4 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs(), a.c3.abs());

    [MethodImpl(256 | 512)]
    public static long2x4 sign(this long2x4 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign(), a.c3.sign());

    [MethodImpl(256 | 512)]
    public static long2x4 min(this long2x4 a, long2x4 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2), a.c3.min(b.c3));

    [MethodImpl(256 | 512)]
    public static long2x4 max(this long2x4 a, long2x4 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2), a.c3.max(b.c3));

    [MethodImpl(256 | 512)]
    public static long2x4 clamp(this long2x4 v, long2x4 min, long2x4 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2), v.c3.clamp(min.c3, max.c3));

    [MethodImpl(256 | 512)]
    public static long2x4 square(this long2x4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long2x4 fma(this long2x4 a, long2x4 b, long2x4 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2), a.c3.fma(b.c3, c.c3));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static long2x4 fms(this long2x4 a, long2x4 b, long2x4 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2), a.c3.fms(b.c3, c.c3));

    [MethodImpl(256 | 512)]
    public static long4 csum(this long2x4 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum(), a.c3.csum());

    [MethodImpl(256 | 512)]
    public static long4 cmin(this long2x4 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin(), a.c3.cmin());

    [MethodImpl(256 | 512)]
    public static long4 cmax(this long2x4 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax(), a.c3.cmax());
}

#endregion // long2x4

#region long3x2

public partial struct long3x2
{
    [MethodImpl(256 | 512)]
    public static long3x2 operator +(long3x2 a) => a;

    [MethodImpl(256 | 512)]
    public static long3x2 operator -(long3x2 a) => 
        new(-a.c0, -a.c1);

    [MethodImpl(256 | 512)]
    public static long3x2 operator +(long3x2 a, long3x2 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1);

    [MethodImpl(256 | 512)]
    public static long3x2 operator -(long3x2 a, long3x2 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1);

    [MethodImpl(256 | 512)]
    public static long3x2 operator *(long3x2 a, long3x2 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1);

    [MethodImpl(256 | 512)]
    public static long3x2 operator *(long3x2 a, long b) => 
        new(a.c0 * b, a.c1 * b);

    [MethodImpl(256 | 512)]
    public static long3x2 operator *(long a, long3x2 b) => 
        new(a * b.c0, a * b.c1);

    [MethodImpl(256 | 512)]
    public static long3x2 operator /(long3x2 a, long3x2 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1);

    [MethodImpl(256 | 512)]
    public static long3x2 operator /(long3x2 a, long b) => 
        new(a.c0 / b, a.c1 / b);

    [MethodImpl(256 | 512)]
    public static long3x2 operator %(long3x2 a, long3x2 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1);

    [MethodImpl(256 | 512)]
    public static long3x2 operator %(long3x2 a, long b) => 
        new(a.c0 % b, a.c1 % b);

    [MethodImpl(256 | 512)]
    public static long3x2 operator --(long3x2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static long3x2 operator ++(long3x2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long3x2 abs(this long3x2 a) => 
        new(a.c0.abs(), a.c1.abs());

    [MethodImpl(256 | 512)]
    public static long3x2 sign(this long3x2 a) => 
        new(a.c0.sign(), a.c1.sign());

    [MethodImpl(256 | 512)]
    public static long3x2 min(this long3x2 a, long3x2 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1));

    [MethodImpl(256 | 512)]
    public static long3x2 max(this long3x2 a, long3x2 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1));

    [MethodImpl(256 | 512)]
    public static long3x2 clamp(this long3x2 v, long3x2 min, long3x2 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1));

    [MethodImpl(256 | 512)]
    public static long3x2 square(this long3x2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long3x2 fma(this long3x2 a, long3x2 b, long3x2 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static long3x2 fms(this long3x2 a, long3x2 b, long3x2 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1));

    [MethodImpl(256 | 512)]
    public static long2 csum(this long3x2 a) => 
        new(a.c0.csum(), a.c1.csum());

    [MethodImpl(256 | 512)]
    public static long2 cmin(this long3x2 a) => 
        new(a.c0.cmin(), a.c1.cmin());

    [MethodImpl(256 | 512)]
    public static long2 cmax(this long3x2 a) => 
        new(a.c0.cmax(), a.c1.cmax());
}

#endregion // long3x2

#region long3x3

public partial struct long3x3
{
    [MethodImpl(256 | 512)]
    public static long3x3 operator +(long3x3 a) => a;

    [MethodImpl(256 | 512)]
    public static long3x3 operator -(long3x3 a) => 
        new(-a.c0, -a.c1, -a.c2);

    [MethodImpl(256 | 512)]
    public static long3x3 operator +(long3x3 a, long3x3 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2);

    [MethodImpl(256 | 512)]
    public static long3x3 operator -(long3x3 a, long3x3 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2);

    [MethodImpl(256 | 512)]
    public static long3x3 operator *(long3x3 a, long3x3 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2);

    [MethodImpl(256 | 512)]
    public static long3x3 operator *(long3x3 a, long b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b);

    [MethodImpl(256 | 512)]
    public static long3x3 operator *(long a, long3x3 b) => 
        new(a * b.c0, a * b.c1, a * b.c2);

    [MethodImpl(256 | 512)]
    public static long3x3 operator /(long3x3 a, long3x3 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2);

    [MethodImpl(256 | 512)]
    public static long3x3 operator /(long3x3 a, long b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b);

    [MethodImpl(256 | 512)]
    public static long3x3 operator %(long3x3 a, long3x3 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2);

    [MethodImpl(256 | 512)]
    public static long3x3 operator %(long3x3 a, long b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b);

    [MethodImpl(256 | 512)]
    public static long3x3 operator --(long3x3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static long3x3 operator ++(long3x3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long3x3 abs(this long3x3 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs());

    [MethodImpl(256 | 512)]
    public static long3x3 sign(this long3x3 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign());

    [MethodImpl(256 | 512)]
    public static long3x3 min(this long3x3 a, long3x3 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2));

    [MethodImpl(256 | 512)]
    public static long3x3 max(this long3x3 a, long3x3 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2));

    [MethodImpl(256 | 512)]
    public static long3x3 clamp(this long3x3 v, long3x3 min, long3x3 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2));

    [MethodImpl(256 | 512)]
    public static long3x3 square(this long3x3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long3x3 fma(this long3x3 a, long3x3 b, long3x3 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static long3x3 fms(this long3x3 a, long3x3 b, long3x3 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2));

    [MethodImpl(256 | 512)]
    public static long3 csum(this long3x3 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum());

    [MethodImpl(256 | 512)]
    public static long3 cmin(this long3x3 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin());

    [MethodImpl(256 | 512)]
    public static long3 cmax(this long3x3 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax());
}

#endregion // long3x3

#region long3x4

public partial struct long3x4
{
    [MethodImpl(256 | 512)]
    public static long3x4 operator +(long3x4 a) => a;

    [MethodImpl(256 | 512)]
    public static long3x4 operator -(long3x4 a) => 
        new(-a.c0, -a.c1, -a.c2, -a.c3);

    [MethodImpl(256 | 512)]
    public static long3x4 operator +(long3x4 a, long3x4 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2, a.c3 + b.c3);

    [MethodImpl(256 | 512)]
    public static long3x4 operator -(long3x4 a, long3x4 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2, a.c3 - b.c3);

    [MethodImpl(256 | 512)]
    public static long3x4 operator *(long3x4 a, long3x4 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2, a.c3 * b.c3);

    [MethodImpl(256 | 512)]
    public static long3x4 operator *(long3x4 a, long b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b, a.c3 * b);

    [MethodImpl(256 | 512)]
    public static long3x4 operator *(long a, long3x4 b) => 
        new(a * b.c0, a * b.c1, a * b.c2, a * b.c3);

    [MethodImpl(256 | 512)]
    public static long3x4 operator /(long3x4 a, long3x4 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2, a.c3 / b.c3);

    [MethodImpl(256 | 512)]
    public static long3x4 operator /(long3x4 a, long b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b, a.c3 / b);

    [MethodImpl(256 | 512)]
    public static long3x4 operator %(long3x4 a, long3x4 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2, a.c3 % b.c3);

    [MethodImpl(256 | 512)]
    public static long3x4 operator %(long3x4 a, long b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b, a.c3 % b);

    [MethodImpl(256 | 512)]
    public static long3x4 operator --(long3x4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static long3x4 operator ++(long3x4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long3x4 abs(this long3x4 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs(), a.c3.abs());

    [MethodImpl(256 | 512)]
    public static long3x4 sign(this long3x4 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign(), a.c3.sign());

    [MethodImpl(256 | 512)]
    public static long3x4 min(this long3x4 a, long3x4 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2), a.c3.min(b.c3));

    [MethodImpl(256 | 512)]
    public static long3x4 max(this long3x4 a, long3x4 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2), a.c3.max(b.c3));

    [MethodImpl(256 | 512)]
    public static long3x4 clamp(this long3x4 v, long3x4 min, long3x4 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2), v.c3.clamp(min.c3, max.c3));

    [MethodImpl(256 | 512)]
    public static long3x4 square(this long3x4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long3x4 fma(this long3x4 a, long3x4 b, long3x4 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2), a.c3.fma(b.c3, c.c3));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static long3x4 fms(this long3x4 a, long3x4 b, long3x4 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2), a.c3.fms(b.c3, c.c3));

    [MethodImpl(256 | 512)]
    public static long4 csum(this long3x4 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum(), a.c3.csum());

    [MethodImpl(256 | 512)]
    public static long4 cmin(this long3x4 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin(), a.c3.cmin());

    [MethodImpl(256 | 512)]
    public static long4 cmax(this long3x4 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax(), a.c3.cmax());
}

#endregion // long3x4

#region long4x2

public partial struct long4x2
{
    [MethodImpl(256 | 512)]
    public static long4x2 operator +(long4x2 a) => a;

    [MethodImpl(256 | 512)]
    public static long4x2 operator -(long4x2 a) => 
        new(-a.c0, -a.c1);

    [MethodImpl(256 | 512)]
    public static long4x2 operator +(long4x2 a, long4x2 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1);

    [MethodImpl(256 | 512)]
    public static long4x2 operator -(long4x2 a, long4x2 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1);

    [MethodImpl(256 | 512)]
    public static long4x2 operator *(long4x2 a, long4x2 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1);

    [MethodImpl(256 | 512)]
    public static long4x2 operator *(long4x2 a, long b) => 
        new(a.c0 * b, a.c1 * b);

    [MethodImpl(256 | 512)]
    public static long4x2 operator *(long a, long4x2 b) => 
        new(a * b.c0, a * b.c1);

    [MethodImpl(256 | 512)]
    public static long4x2 operator /(long4x2 a, long4x2 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1);

    [MethodImpl(256 | 512)]
    public static long4x2 operator /(long4x2 a, long b) => 
        new(a.c0 / b, a.c1 / b);

    [MethodImpl(256 | 512)]
    public static long4x2 operator %(long4x2 a, long4x2 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1);

    [MethodImpl(256 | 512)]
    public static long4x2 operator %(long4x2 a, long b) => 
        new(a.c0 % b, a.c1 % b);

    [MethodImpl(256 | 512)]
    public static long4x2 operator --(long4x2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static long4x2 operator ++(long4x2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long4x2 abs(this long4x2 a) => 
        new(a.c0.abs(), a.c1.abs());

    [MethodImpl(256 | 512)]
    public static long4x2 sign(this long4x2 a) => 
        new(a.c0.sign(), a.c1.sign());

    [MethodImpl(256 | 512)]
    public static long4x2 min(this long4x2 a, long4x2 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1));

    [MethodImpl(256 | 512)]
    public static long4x2 max(this long4x2 a, long4x2 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1));

    [MethodImpl(256 | 512)]
    public static long4x2 clamp(this long4x2 v, long4x2 min, long4x2 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1));

    [MethodImpl(256 | 512)]
    public static long4x2 square(this long4x2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long4x2 fma(this long4x2 a, long4x2 b, long4x2 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static long4x2 fms(this long4x2 a, long4x2 b, long4x2 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1));

    [MethodImpl(256 | 512)]
    public static long2 csum(this long4x2 a) => 
        new(a.c0.csum(), a.c1.csum());

    [MethodImpl(256 | 512)]
    public static long2 cmin(this long4x2 a) => 
        new(a.c0.cmin(), a.c1.cmin());

    [MethodImpl(256 | 512)]
    public static long2 cmax(this long4x2 a) => 
        new(a.c0.cmax(), a.c1.cmax());
}

#endregion // long4x2

#region long4x3

public partial struct long4x3
{
    [MethodImpl(256 | 512)]
    public static long4x3 operator +(long4x3 a) => a;

    [MethodImpl(256 | 512)]
    public static long4x3 operator -(long4x3 a) => 
        new(-a.c0, -a.c1, -a.c2);

    [MethodImpl(256 | 512)]
    public static long4x3 operator +(long4x3 a, long4x3 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2);

    [MethodImpl(256 | 512)]
    public static long4x3 operator -(long4x3 a, long4x3 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2);

    [MethodImpl(256 | 512)]
    public static long4x3 operator *(long4x3 a, long4x3 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2);

    [MethodImpl(256 | 512)]
    public static long4x3 operator *(long4x3 a, long b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b);

    [MethodImpl(256 | 512)]
    public static long4x3 operator *(long a, long4x3 b) => 
        new(a * b.c0, a * b.c1, a * b.c2);

    [MethodImpl(256 | 512)]
    public static long4x3 operator /(long4x3 a, long4x3 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2);

    [MethodImpl(256 | 512)]
    public static long4x3 operator /(long4x3 a, long b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b);

    [MethodImpl(256 | 512)]
    public static long4x3 operator %(long4x3 a, long4x3 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2);

    [MethodImpl(256 | 512)]
    public static long4x3 operator %(long4x3 a, long b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b);

    [MethodImpl(256 | 512)]
    public static long4x3 operator --(long4x3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static long4x3 operator ++(long4x3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long4x3 abs(this long4x3 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs());

    [MethodImpl(256 | 512)]
    public static long4x3 sign(this long4x3 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign());

    [MethodImpl(256 | 512)]
    public static long4x3 min(this long4x3 a, long4x3 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2));

    [MethodImpl(256 | 512)]
    public static long4x3 max(this long4x3 a, long4x3 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2));

    [MethodImpl(256 | 512)]
    public static long4x3 clamp(this long4x3 v, long4x3 min, long4x3 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2));

    [MethodImpl(256 | 512)]
    public static long4x3 square(this long4x3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long4x3 fma(this long4x3 a, long4x3 b, long4x3 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static long4x3 fms(this long4x3 a, long4x3 b, long4x3 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2));

    [MethodImpl(256 | 512)]
    public static long3 csum(this long4x3 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum());

    [MethodImpl(256 | 512)]
    public static long3 cmin(this long4x3 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin());

    [MethodImpl(256 | 512)]
    public static long3 cmax(this long4x3 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax());
}

#endregion // long4x3

#region long4x4

public partial struct long4x4
{
    [MethodImpl(256 | 512)]
    public static long4x4 operator +(long4x4 a) => a;

    [MethodImpl(256 | 512)]
    public static long4x4 operator -(long4x4 a) => 
        new(-a.c0, -a.c1, -a.c2, -a.c3);

    [MethodImpl(256 | 512)]
    public static long4x4 operator +(long4x4 a, long4x4 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2, a.c3 + b.c3);

    [MethodImpl(256 | 512)]
    public static long4x4 operator -(long4x4 a, long4x4 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2, a.c3 - b.c3);

    [MethodImpl(256 | 512)]
    public static long4x4 operator *(long4x4 a, long4x4 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2, a.c3 * b.c3);

    [MethodImpl(256 | 512)]
    public static long4x4 operator *(long4x4 a, long b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b, a.c3 * b);

    [MethodImpl(256 | 512)]
    public static long4x4 operator *(long a, long4x4 b) => 
        new(a * b.c0, a * b.c1, a * b.c2, a * b.c3);

    [MethodImpl(256 | 512)]
    public static long4x4 operator /(long4x4 a, long4x4 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2, a.c3 / b.c3);

    [MethodImpl(256 | 512)]
    public static long4x4 operator /(long4x4 a, long b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b, a.c3 / b);

    [MethodImpl(256 | 512)]
    public static long4x4 operator %(long4x4 a, long4x4 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2, a.c3 % b.c3);

    [MethodImpl(256 | 512)]
    public static long4x4 operator %(long4x4 a, long b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b, a.c3 % b);

    [MethodImpl(256 | 512)]
    public static long4x4 operator --(long4x4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static long4x4 operator ++(long4x4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long4x4 abs(this long4x4 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs(), a.c3.abs());

    [MethodImpl(256 | 512)]
    public static long4x4 sign(this long4x4 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign(), a.c3.sign());

    [MethodImpl(256 | 512)]
    public static long4x4 min(this long4x4 a, long4x4 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2), a.c3.min(b.c3));

    [MethodImpl(256 | 512)]
    public static long4x4 max(this long4x4 a, long4x4 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2), a.c3.max(b.c3));

    [MethodImpl(256 | 512)]
    public static long4x4 clamp(this long4x4 v, long4x4 min, long4x4 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2), v.c3.clamp(min.c3, max.c3));

    [MethodImpl(256 | 512)]
    public static long4x4 square(this long4x4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long4x4 fma(this long4x4 a, long4x4 b, long4x4 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2), a.c3.fma(b.c3, c.c3));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static long4x4 fms(this long4x4 a, long4x4 b, long4x4 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2), a.c3.fms(b.c3, c.c3));

    [MethodImpl(256 | 512)]
    public static long4 csum(this long4x4 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum(), a.c3.csum());

    [MethodImpl(256 | 512)]
    public static long4 cmin(this long4x4 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin(), a.c3.cmin());

    [MethodImpl(256 | 512)]
    public static long4 cmax(this long4x4 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax(), a.c3.cmax());
}

#endregion // long4x4

#region ulong2x2

public partial struct ulong2x2
{
    [MethodImpl(256 | 512)]
    public static ulong2x2 operator +(ulong2x2 a) => a;

    [MethodImpl(256 | 512)]
    public static ulong2x2 operator +(ulong2x2 a, ulong2x2 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1);

    [MethodImpl(256 | 512)]
    public static ulong2x2 operator -(ulong2x2 a, ulong2x2 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1);

    [MethodImpl(256 | 512)]
    public static ulong2x2 operator *(ulong2x2 a, ulong2x2 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1);

    [MethodImpl(256 | 512)]
    public static ulong2x2 operator *(ulong2x2 a, ulong b) => 
        new(a.c0 * b, a.c1 * b);

    [MethodImpl(256 | 512)]
    public static ulong2x2 operator *(ulong a, ulong2x2 b) => 
        new(a * b.c0, a * b.c1);

    [MethodImpl(256 | 512)]
    public static ulong2x2 operator /(ulong2x2 a, ulong2x2 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1);

    [MethodImpl(256 | 512)]
    public static ulong2x2 operator /(ulong2x2 a, ulong b) => 
        new(a.c0 / b, a.c1 / b);

    [MethodImpl(256 | 512)]
    public static ulong2x2 operator %(ulong2x2 a, ulong2x2 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1);

    [MethodImpl(256 | 512)]
    public static ulong2x2 operator %(ulong2x2 a, ulong b) => 
        new(a.c0 % b, a.c1 % b);

    [MethodImpl(256 | 512)]
    public static ulong2x2 operator --(ulong2x2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ulong2x2 operator ++(ulong2x2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong2x2 abs(this ulong2x2 a) => 
        new(a.c0.abs(), a.c1.abs());

    [MethodImpl(256 | 512)]
    public static ulong2x2 sign(this ulong2x2 a) => 
        new(a.c0.sign(), a.c1.sign());

    [MethodImpl(256 | 512)]
    public static ulong2x2 min(this ulong2x2 a, ulong2x2 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1));

    [MethodImpl(256 | 512)]
    public static ulong2x2 max(this ulong2x2 a, ulong2x2 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1));

    [MethodImpl(256 | 512)]
    public static ulong2x2 clamp(this ulong2x2 v, ulong2x2 min, ulong2x2 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1));

    [MethodImpl(256 | 512)]
    public static ulong2x2 square(this ulong2x2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong2x2 fma(this ulong2x2 a, ulong2x2 b, ulong2x2 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ulong2x2 fms(this ulong2x2 a, ulong2x2 b, ulong2x2 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1));

    [MethodImpl(256 | 512)]
    public static ulong2 csum(this ulong2x2 a) => 
        new(a.c0.csum(), a.c1.csum());

    [MethodImpl(256 | 512)]
    public static ulong2 cmin(this ulong2x2 a) => 
        new(a.c0.cmin(), a.c1.cmin());

    [MethodImpl(256 | 512)]
    public static ulong2 cmax(this ulong2x2 a) => 
        new(a.c0.cmax(), a.c1.cmax());
}

#endregion // ulong2x2

#region ulong2x3

public partial struct ulong2x3
{
    [MethodImpl(256 | 512)]
    public static ulong2x3 operator +(ulong2x3 a) => a;

    [MethodImpl(256 | 512)]
    public static ulong2x3 operator +(ulong2x3 a, ulong2x3 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2);

    [MethodImpl(256 | 512)]
    public static ulong2x3 operator -(ulong2x3 a, ulong2x3 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2);

    [MethodImpl(256 | 512)]
    public static ulong2x3 operator *(ulong2x3 a, ulong2x3 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2);

    [MethodImpl(256 | 512)]
    public static ulong2x3 operator *(ulong2x3 a, ulong b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b);

    [MethodImpl(256 | 512)]
    public static ulong2x3 operator *(ulong a, ulong2x3 b) => 
        new(a * b.c0, a * b.c1, a * b.c2);

    [MethodImpl(256 | 512)]
    public static ulong2x3 operator /(ulong2x3 a, ulong2x3 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2);

    [MethodImpl(256 | 512)]
    public static ulong2x3 operator /(ulong2x3 a, ulong b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b);

    [MethodImpl(256 | 512)]
    public static ulong2x3 operator %(ulong2x3 a, ulong2x3 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2);

    [MethodImpl(256 | 512)]
    public static ulong2x3 operator %(ulong2x3 a, ulong b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b);

    [MethodImpl(256 | 512)]
    public static ulong2x3 operator --(ulong2x3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ulong2x3 operator ++(ulong2x3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong2x3 abs(this ulong2x3 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs());

    [MethodImpl(256 | 512)]
    public static ulong2x3 sign(this ulong2x3 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign());

    [MethodImpl(256 | 512)]
    public static ulong2x3 min(this ulong2x3 a, ulong2x3 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2));

    [MethodImpl(256 | 512)]
    public static ulong2x3 max(this ulong2x3 a, ulong2x3 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2));

    [MethodImpl(256 | 512)]
    public static ulong2x3 clamp(this ulong2x3 v, ulong2x3 min, ulong2x3 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2));

    [MethodImpl(256 | 512)]
    public static ulong2x3 square(this ulong2x3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong2x3 fma(this ulong2x3 a, ulong2x3 b, ulong2x3 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ulong2x3 fms(this ulong2x3 a, ulong2x3 b, ulong2x3 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2));

    [MethodImpl(256 | 512)]
    public static ulong3 csum(this ulong2x3 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum());

    [MethodImpl(256 | 512)]
    public static ulong3 cmin(this ulong2x3 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin());

    [MethodImpl(256 | 512)]
    public static ulong3 cmax(this ulong2x3 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax());
}

#endregion // ulong2x3

#region ulong2x4

public partial struct ulong2x4
{
    [MethodImpl(256 | 512)]
    public static ulong2x4 operator +(ulong2x4 a) => a;

    [MethodImpl(256 | 512)]
    public static ulong2x4 operator +(ulong2x4 a, ulong2x4 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2, a.c3 + b.c3);

    [MethodImpl(256 | 512)]
    public static ulong2x4 operator -(ulong2x4 a, ulong2x4 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2, a.c3 - b.c3);

    [MethodImpl(256 | 512)]
    public static ulong2x4 operator *(ulong2x4 a, ulong2x4 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2, a.c3 * b.c3);

    [MethodImpl(256 | 512)]
    public static ulong2x4 operator *(ulong2x4 a, ulong b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b, a.c3 * b);

    [MethodImpl(256 | 512)]
    public static ulong2x4 operator *(ulong a, ulong2x4 b) => 
        new(a * b.c0, a * b.c1, a * b.c2, a * b.c3);

    [MethodImpl(256 | 512)]
    public static ulong2x4 operator /(ulong2x4 a, ulong2x4 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2, a.c3 / b.c3);

    [MethodImpl(256 | 512)]
    public static ulong2x4 operator /(ulong2x4 a, ulong b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b, a.c3 / b);

    [MethodImpl(256 | 512)]
    public static ulong2x4 operator %(ulong2x4 a, ulong2x4 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2, a.c3 % b.c3);

    [MethodImpl(256 | 512)]
    public static ulong2x4 operator %(ulong2x4 a, ulong b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b, a.c3 % b);

    [MethodImpl(256 | 512)]
    public static ulong2x4 operator --(ulong2x4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ulong2x4 operator ++(ulong2x4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong2x4 abs(this ulong2x4 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs(), a.c3.abs());

    [MethodImpl(256 | 512)]
    public static ulong2x4 sign(this ulong2x4 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign(), a.c3.sign());

    [MethodImpl(256 | 512)]
    public static ulong2x4 min(this ulong2x4 a, ulong2x4 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2), a.c3.min(b.c3));

    [MethodImpl(256 | 512)]
    public static ulong2x4 max(this ulong2x4 a, ulong2x4 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2), a.c3.max(b.c3));

    [MethodImpl(256 | 512)]
    public static ulong2x4 clamp(this ulong2x4 v, ulong2x4 min, ulong2x4 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2), v.c3.clamp(min.c3, max.c3));

    [MethodImpl(256 | 512)]
    public static ulong2x4 square(this ulong2x4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong2x4 fma(this ulong2x4 a, ulong2x4 b, ulong2x4 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2), a.c3.fma(b.c3, c.c3));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ulong2x4 fms(this ulong2x4 a, ulong2x4 b, ulong2x4 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2), a.c3.fms(b.c3, c.c3));

    [MethodImpl(256 | 512)]
    public static ulong4 csum(this ulong2x4 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum(), a.c3.csum());

    [MethodImpl(256 | 512)]
    public static ulong4 cmin(this ulong2x4 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin(), a.c3.cmin());

    [MethodImpl(256 | 512)]
    public static ulong4 cmax(this ulong2x4 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax(), a.c3.cmax());
}

#endregion // ulong2x4

#region ulong3x2

public partial struct ulong3x2
{
    [MethodImpl(256 | 512)]
    public static ulong3x2 operator +(ulong3x2 a) => a;

    [MethodImpl(256 | 512)]
    public static ulong3x2 operator +(ulong3x2 a, ulong3x2 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1);

    [MethodImpl(256 | 512)]
    public static ulong3x2 operator -(ulong3x2 a, ulong3x2 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1);

    [MethodImpl(256 | 512)]
    public static ulong3x2 operator *(ulong3x2 a, ulong3x2 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1);

    [MethodImpl(256 | 512)]
    public static ulong3x2 operator *(ulong3x2 a, ulong b) => 
        new(a.c0 * b, a.c1 * b);

    [MethodImpl(256 | 512)]
    public static ulong3x2 operator *(ulong a, ulong3x2 b) => 
        new(a * b.c0, a * b.c1);

    [MethodImpl(256 | 512)]
    public static ulong3x2 operator /(ulong3x2 a, ulong3x2 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1);

    [MethodImpl(256 | 512)]
    public static ulong3x2 operator /(ulong3x2 a, ulong b) => 
        new(a.c0 / b, a.c1 / b);

    [MethodImpl(256 | 512)]
    public static ulong3x2 operator %(ulong3x2 a, ulong3x2 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1);

    [MethodImpl(256 | 512)]
    public static ulong3x2 operator %(ulong3x2 a, ulong b) => 
        new(a.c0 % b, a.c1 % b);

    [MethodImpl(256 | 512)]
    public static ulong3x2 operator --(ulong3x2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ulong3x2 operator ++(ulong3x2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong3x2 abs(this ulong3x2 a) => 
        new(a.c0.abs(), a.c1.abs());

    [MethodImpl(256 | 512)]
    public static ulong3x2 sign(this ulong3x2 a) => 
        new(a.c0.sign(), a.c1.sign());

    [MethodImpl(256 | 512)]
    public static ulong3x2 min(this ulong3x2 a, ulong3x2 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1));

    [MethodImpl(256 | 512)]
    public static ulong3x2 max(this ulong3x2 a, ulong3x2 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1));

    [MethodImpl(256 | 512)]
    public static ulong3x2 clamp(this ulong3x2 v, ulong3x2 min, ulong3x2 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1));

    [MethodImpl(256 | 512)]
    public static ulong3x2 square(this ulong3x2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong3x2 fma(this ulong3x2 a, ulong3x2 b, ulong3x2 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ulong3x2 fms(this ulong3x2 a, ulong3x2 b, ulong3x2 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1));

    [MethodImpl(256 | 512)]
    public static ulong2 csum(this ulong3x2 a) => 
        new(a.c0.csum(), a.c1.csum());

    [MethodImpl(256 | 512)]
    public static ulong2 cmin(this ulong3x2 a) => 
        new(a.c0.cmin(), a.c1.cmin());

    [MethodImpl(256 | 512)]
    public static ulong2 cmax(this ulong3x2 a) => 
        new(a.c0.cmax(), a.c1.cmax());
}

#endregion // ulong3x2

#region ulong3x3

public partial struct ulong3x3
{
    [MethodImpl(256 | 512)]
    public static ulong3x3 operator +(ulong3x3 a) => a;

    [MethodImpl(256 | 512)]
    public static ulong3x3 operator +(ulong3x3 a, ulong3x3 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2);

    [MethodImpl(256 | 512)]
    public static ulong3x3 operator -(ulong3x3 a, ulong3x3 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2);

    [MethodImpl(256 | 512)]
    public static ulong3x3 operator *(ulong3x3 a, ulong3x3 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2);

    [MethodImpl(256 | 512)]
    public static ulong3x3 operator *(ulong3x3 a, ulong b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b);

    [MethodImpl(256 | 512)]
    public static ulong3x3 operator *(ulong a, ulong3x3 b) => 
        new(a * b.c0, a * b.c1, a * b.c2);

    [MethodImpl(256 | 512)]
    public static ulong3x3 operator /(ulong3x3 a, ulong3x3 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2);

    [MethodImpl(256 | 512)]
    public static ulong3x3 operator /(ulong3x3 a, ulong b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b);

    [MethodImpl(256 | 512)]
    public static ulong3x3 operator %(ulong3x3 a, ulong3x3 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2);

    [MethodImpl(256 | 512)]
    public static ulong3x3 operator %(ulong3x3 a, ulong b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b);

    [MethodImpl(256 | 512)]
    public static ulong3x3 operator --(ulong3x3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ulong3x3 operator ++(ulong3x3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong3x3 abs(this ulong3x3 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs());

    [MethodImpl(256 | 512)]
    public static ulong3x3 sign(this ulong3x3 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign());

    [MethodImpl(256 | 512)]
    public static ulong3x3 min(this ulong3x3 a, ulong3x3 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2));

    [MethodImpl(256 | 512)]
    public static ulong3x3 max(this ulong3x3 a, ulong3x3 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2));

    [MethodImpl(256 | 512)]
    public static ulong3x3 clamp(this ulong3x3 v, ulong3x3 min, ulong3x3 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2));

    [MethodImpl(256 | 512)]
    public static ulong3x3 square(this ulong3x3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong3x3 fma(this ulong3x3 a, ulong3x3 b, ulong3x3 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ulong3x3 fms(this ulong3x3 a, ulong3x3 b, ulong3x3 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2));

    [MethodImpl(256 | 512)]
    public static ulong3 csum(this ulong3x3 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum());

    [MethodImpl(256 | 512)]
    public static ulong3 cmin(this ulong3x3 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin());

    [MethodImpl(256 | 512)]
    public static ulong3 cmax(this ulong3x3 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax());
}

#endregion // ulong3x3

#region ulong3x4

public partial struct ulong3x4
{
    [MethodImpl(256 | 512)]
    public static ulong3x4 operator +(ulong3x4 a) => a;

    [MethodImpl(256 | 512)]
    public static ulong3x4 operator +(ulong3x4 a, ulong3x4 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2, a.c3 + b.c3);

    [MethodImpl(256 | 512)]
    public static ulong3x4 operator -(ulong3x4 a, ulong3x4 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2, a.c3 - b.c3);

    [MethodImpl(256 | 512)]
    public static ulong3x4 operator *(ulong3x4 a, ulong3x4 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2, a.c3 * b.c3);

    [MethodImpl(256 | 512)]
    public static ulong3x4 operator *(ulong3x4 a, ulong b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b, a.c3 * b);

    [MethodImpl(256 | 512)]
    public static ulong3x4 operator *(ulong a, ulong3x4 b) => 
        new(a * b.c0, a * b.c1, a * b.c2, a * b.c3);

    [MethodImpl(256 | 512)]
    public static ulong3x4 operator /(ulong3x4 a, ulong3x4 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2, a.c3 / b.c3);

    [MethodImpl(256 | 512)]
    public static ulong3x4 operator /(ulong3x4 a, ulong b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b, a.c3 / b);

    [MethodImpl(256 | 512)]
    public static ulong3x4 operator %(ulong3x4 a, ulong3x4 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2, a.c3 % b.c3);

    [MethodImpl(256 | 512)]
    public static ulong3x4 operator %(ulong3x4 a, ulong b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b, a.c3 % b);

    [MethodImpl(256 | 512)]
    public static ulong3x4 operator --(ulong3x4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ulong3x4 operator ++(ulong3x4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong3x4 abs(this ulong3x4 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs(), a.c3.abs());

    [MethodImpl(256 | 512)]
    public static ulong3x4 sign(this ulong3x4 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign(), a.c3.sign());

    [MethodImpl(256 | 512)]
    public static ulong3x4 min(this ulong3x4 a, ulong3x4 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2), a.c3.min(b.c3));

    [MethodImpl(256 | 512)]
    public static ulong3x4 max(this ulong3x4 a, ulong3x4 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2), a.c3.max(b.c3));

    [MethodImpl(256 | 512)]
    public static ulong3x4 clamp(this ulong3x4 v, ulong3x4 min, ulong3x4 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2), v.c3.clamp(min.c3, max.c3));

    [MethodImpl(256 | 512)]
    public static ulong3x4 square(this ulong3x4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong3x4 fma(this ulong3x4 a, ulong3x4 b, ulong3x4 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2), a.c3.fma(b.c3, c.c3));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ulong3x4 fms(this ulong3x4 a, ulong3x4 b, ulong3x4 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2), a.c3.fms(b.c3, c.c3));

    [MethodImpl(256 | 512)]
    public static ulong4 csum(this ulong3x4 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum(), a.c3.csum());

    [MethodImpl(256 | 512)]
    public static ulong4 cmin(this ulong3x4 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin(), a.c3.cmin());

    [MethodImpl(256 | 512)]
    public static ulong4 cmax(this ulong3x4 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax(), a.c3.cmax());
}

#endregion // ulong3x4

#region ulong4x2

public partial struct ulong4x2
{
    [MethodImpl(256 | 512)]
    public static ulong4x2 operator +(ulong4x2 a) => a;

    [MethodImpl(256 | 512)]
    public static ulong4x2 operator +(ulong4x2 a, ulong4x2 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1);

    [MethodImpl(256 | 512)]
    public static ulong4x2 operator -(ulong4x2 a, ulong4x2 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1);

    [MethodImpl(256 | 512)]
    public static ulong4x2 operator *(ulong4x2 a, ulong4x2 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1);

    [MethodImpl(256 | 512)]
    public static ulong4x2 operator *(ulong4x2 a, ulong b) => 
        new(a.c0 * b, a.c1 * b);

    [MethodImpl(256 | 512)]
    public static ulong4x2 operator *(ulong a, ulong4x2 b) => 
        new(a * b.c0, a * b.c1);

    [MethodImpl(256 | 512)]
    public static ulong4x2 operator /(ulong4x2 a, ulong4x2 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1);

    [MethodImpl(256 | 512)]
    public static ulong4x2 operator /(ulong4x2 a, ulong b) => 
        new(a.c0 / b, a.c1 / b);

    [MethodImpl(256 | 512)]
    public static ulong4x2 operator %(ulong4x2 a, ulong4x2 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1);

    [MethodImpl(256 | 512)]
    public static ulong4x2 operator %(ulong4x2 a, ulong b) => 
        new(a.c0 % b, a.c1 % b);

    [MethodImpl(256 | 512)]
    public static ulong4x2 operator --(ulong4x2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ulong4x2 operator ++(ulong4x2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong4x2 abs(this ulong4x2 a) => 
        new(a.c0.abs(), a.c1.abs());

    [MethodImpl(256 | 512)]
    public static ulong4x2 sign(this ulong4x2 a) => 
        new(a.c0.sign(), a.c1.sign());

    [MethodImpl(256 | 512)]
    public static ulong4x2 min(this ulong4x2 a, ulong4x2 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1));

    [MethodImpl(256 | 512)]
    public static ulong4x2 max(this ulong4x2 a, ulong4x2 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1));

    [MethodImpl(256 | 512)]
    public static ulong4x2 clamp(this ulong4x2 v, ulong4x2 min, ulong4x2 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1));

    [MethodImpl(256 | 512)]
    public static ulong4x2 square(this ulong4x2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong4x2 fma(this ulong4x2 a, ulong4x2 b, ulong4x2 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ulong4x2 fms(this ulong4x2 a, ulong4x2 b, ulong4x2 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1));

    [MethodImpl(256 | 512)]
    public static ulong2 csum(this ulong4x2 a) => 
        new(a.c0.csum(), a.c1.csum());

    [MethodImpl(256 | 512)]
    public static ulong2 cmin(this ulong4x2 a) => 
        new(a.c0.cmin(), a.c1.cmin());

    [MethodImpl(256 | 512)]
    public static ulong2 cmax(this ulong4x2 a) => 
        new(a.c0.cmax(), a.c1.cmax());
}

#endregion // ulong4x2

#region ulong4x3

public partial struct ulong4x3
{
    [MethodImpl(256 | 512)]
    public static ulong4x3 operator +(ulong4x3 a) => a;

    [MethodImpl(256 | 512)]
    public static ulong4x3 operator +(ulong4x3 a, ulong4x3 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2);

    [MethodImpl(256 | 512)]
    public static ulong4x3 operator -(ulong4x3 a, ulong4x3 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2);

    [MethodImpl(256 | 512)]
    public static ulong4x3 operator *(ulong4x3 a, ulong4x3 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2);

    [MethodImpl(256 | 512)]
    public static ulong4x3 operator *(ulong4x3 a, ulong b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b);

    [MethodImpl(256 | 512)]
    public static ulong4x3 operator *(ulong a, ulong4x3 b) => 
        new(a * b.c0, a * b.c1, a * b.c2);

    [MethodImpl(256 | 512)]
    public static ulong4x3 operator /(ulong4x3 a, ulong4x3 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2);

    [MethodImpl(256 | 512)]
    public static ulong4x3 operator /(ulong4x3 a, ulong b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b);

    [MethodImpl(256 | 512)]
    public static ulong4x3 operator %(ulong4x3 a, ulong4x3 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2);

    [MethodImpl(256 | 512)]
    public static ulong4x3 operator %(ulong4x3 a, ulong b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b);

    [MethodImpl(256 | 512)]
    public static ulong4x3 operator --(ulong4x3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ulong4x3 operator ++(ulong4x3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong4x3 abs(this ulong4x3 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs());

    [MethodImpl(256 | 512)]
    public static ulong4x3 sign(this ulong4x3 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign());

    [MethodImpl(256 | 512)]
    public static ulong4x3 min(this ulong4x3 a, ulong4x3 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2));

    [MethodImpl(256 | 512)]
    public static ulong4x3 max(this ulong4x3 a, ulong4x3 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2));

    [MethodImpl(256 | 512)]
    public static ulong4x3 clamp(this ulong4x3 v, ulong4x3 min, ulong4x3 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2));

    [MethodImpl(256 | 512)]
    public static ulong4x3 square(this ulong4x3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong4x3 fma(this ulong4x3 a, ulong4x3 b, ulong4x3 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ulong4x3 fms(this ulong4x3 a, ulong4x3 b, ulong4x3 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2));

    [MethodImpl(256 | 512)]
    public static ulong3 csum(this ulong4x3 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum());

    [MethodImpl(256 | 512)]
    public static ulong3 cmin(this ulong4x3 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin());

    [MethodImpl(256 | 512)]
    public static ulong3 cmax(this ulong4x3 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax());
}

#endregion // ulong4x3

#region ulong4x4

public partial struct ulong4x4
{
    [MethodImpl(256 | 512)]
    public static ulong4x4 operator +(ulong4x4 a) => a;

    [MethodImpl(256 | 512)]
    public static ulong4x4 operator +(ulong4x4 a, ulong4x4 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2, a.c3 + b.c3);

    [MethodImpl(256 | 512)]
    public static ulong4x4 operator -(ulong4x4 a, ulong4x4 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2, a.c3 - b.c3);

    [MethodImpl(256 | 512)]
    public static ulong4x4 operator *(ulong4x4 a, ulong4x4 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2, a.c3 * b.c3);

    [MethodImpl(256 | 512)]
    public static ulong4x4 operator *(ulong4x4 a, ulong b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b, a.c3 * b);

    [MethodImpl(256 | 512)]
    public static ulong4x4 operator *(ulong a, ulong4x4 b) => 
        new(a * b.c0, a * b.c1, a * b.c2, a * b.c3);

    [MethodImpl(256 | 512)]
    public static ulong4x4 operator /(ulong4x4 a, ulong4x4 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2, a.c3 / b.c3);

    [MethodImpl(256 | 512)]
    public static ulong4x4 operator /(ulong4x4 a, ulong b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b, a.c3 / b);

    [MethodImpl(256 | 512)]
    public static ulong4x4 operator %(ulong4x4 a, ulong4x4 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2, a.c3 % b.c3);

    [MethodImpl(256 | 512)]
    public static ulong4x4 operator %(ulong4x4 a, ulong b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b, a.c3 % b);

    [MethodImpl(256 | 512)]
    public static ulong4x4 operator --(ulong4x4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ulong4x4 operator ++(ulong4x4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong4x4 abs(this ulong4x4 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs(), a.c3.abs());

    [MethodImpl(256 | 512)]
    public static ulong4x4 sign(this ulong4x4 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign(), a.c3.sign());

    [MethodImpl(256 | 512)]
    public static ulong4x4 min(this ulong4x4 a, ulong4x4 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2), a.c3.min(b.c3));

    [MethodImpl(256 | 512)]
    public static ulong4x4 max(this ulong4x4 a, ulong4x4 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2), a.c3.max(b.c3));

    [MethodImpl(256 | 512)]
    public static ulong4x4 clamp(this ulong4x4 v, ulong4x4 min, ulong4x4 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2), v.c3.clamp(min.c3, max.c3));

    [MethodImpl(256 | 512)]
    public static ulong4x4 square(this ulong4x4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong4x4 fma(this ulong4x4 a, ulong4x4 b, ulong4x4 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2), a.c3.fma(b.c3, c.c3));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ulong4x4 fms(this ulong4x4 a, ulong4x4 b, ulong4x4 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2), a.c3.fms(b.c3, c.c3));

    [MethodImpl(256 | 512)]
    public static ulong4 csum(this ulong4x4 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum(), a.c3.csum());

    [MethodImpl(256 | 512)]
    public static ulong4 cmin(this ulong4x4 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin(), a.c3.cmin());

    [MethodImpl(256 | 512)]
    public static ulong4 cmax(this ulong4x4 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax(), a.c3.cmax());
}

#endregion // ulong4x4

#region decimal2x2

public partial struct decimal2x2
{
    [MethodImpl(256 | 512)]
    public static decimal2x2 operator +(decimal2x2 a) => a;

    [MethodImpl(256 | 512)]
    public static decimal2x2 operator -(decimal2x2 a) => 
        new(-a.c0, -a.c1);

    [MethodImpl(256 | 512)]
    public static decimal2x2 operator +(decimal2x2 a, decimal2x2 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1);

    [MethodImpl(256 | 512)]
    public static decimal2x2 operator -(decimal2x2 a, decimal2x2 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1);

    [MethodImpl(256 | 512)]
    public static decimal2x2 operator *(decimal2x2 a, decimal2x2 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1);

    [MethodImpl(256 | 512)]
    public static decimal2x2 operator *(decimal2x2 a, decimal b) => 
        new(a.c0 * b, a.c1 * b);

    [MethodImpl(256 | 512)]
    public static decimal2x2 operator *(decimal a, decimal2x2 b) => 
        new(a * b.c0, a * b.c1);

    [MethodImpl(256 | 512)]
    public static decimal2x2 operator /(decimal2x2 a, decimal2x2 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1);

    [MethodImpl(256 | 512)]
    public static decimal2x2 operator /(decimal2x2 a, decimal b) => 
        new(a.c0 / b, a.c1 / b);

    [MethodImpl(256 | 512)]
    public static decimal2x2 operator %(decimal2x2 a, decimal2x2 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1);

    [MethodImpl(256 | 512)]
    public static decimal2x2 operator %(decimal2x2 a, decimal b) => 
        new(a.c0 % b, a.c1 % b);

    [MethodImpl(256 | 512)]
    public static decimal2x2 operator --(decimal2x2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static decimal2x2 operator ++(decimal2x2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static decimal2x2 abs(this decimal2x2 a) => 
        new(a.c0.abs(), a.c1.abs());

    [MethodImpl(256 | 512)]
    public static decimal2x2 sign(this decimal2x2 a) => 
        new(a.c0.sign(), a.c1.sign());

    [MethodImpl(256 | 512)]
    public static decimal2x2 min(this decimal2x2 a, decimal2x2 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1));

    [MethodImpl(256 | 512)]
    public static decimal2x2 max(this decimal2x2 a, decimal2x2 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1));

    [MethodImpl(256 | 512)]
    public static decimal2x2 clamp(this decimal2x2 v, decimal2x2 min, decimal2x2 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1));

    [MethodImpl(256 | 512)]
    public static decimal2x2 square(this decimal2x2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static decimal2x2 fma(this decimal2x2 a, decimal2x2 b, decimal2x2 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static decimal2x2 fms(this decimal2x2 a, decimal2x2 b, decimal2x2 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1));

    [MethodImpl(256 | 512)]
    public static decimal2 csum(this decimal2x2 a) => 
        new(a.c0.csum(), a.c1.csum());

    [MethodImpl(256 | 512)]
    public static decimal2 cmin(this decimal2x2 a) => 
        new(a.c0.cmin(), a.c1.cmin());

    [MethodImpl(256 | 512)]
    public static decimal2 cmax(this decimal2x2 a) => 
        new(a.c0.cmax(), a.c1.cmax());
}

#endregion // decimal2x2

#region decimal2x3

public partial struct decimal2x3
{
    [MethodImpl(256 | 512)]
    public static decimal2x3 operator +(decimal2x3 a) => a;

    [MethodImpl(256 | 512)]
    public static decimal2x3 operator -(decimal2x3 a) => 
        new(-a.c0, -a.c1, -a.c2);

    [MethodImpl(256 | 512)]
    public static decimal2x3 operator +(decimal2x3 a, decimal2x3 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2);

    [MethodImpl(256 | 512)]
    public static decimal2x3 operator -(decimal2x3 a, decimal2x3 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2);

    [MethodImpl(256 | 512)]
    public static decimal2x3 operator *(decimal2x3 a, decimal2x3 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2);

    [MethodImpl(256 | 512)]
    public static decimal2x3 operator *(decimal2x3 a, decimal b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b);

    [MethodImpl(256 | 512)]
    public static decimal2x3 operator *(decimal a, decimal2x3 b) => 
        new(a * b.c0, a * b.c1, a * b.c2);

    [MethodImpl(256 | 512)]
    public static decimal2x3 operator /(decimal2x3 a, decimal2x3 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2);

    [MethodImpl(256 | 512)]
    public static decimal2x3 operator /(decimal2x3 a, decimal b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b);

    [MethodImpl(256 | 512)]
    public static decimal2x3 operator %(decimal2x3 a, decimal2x3 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2);

    [MethodImpl(256 | 512)]
    public static decimal2x3 operator %(decimal2x3 a, decimal b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b);

    [MethodImpl(256 | 512)]
    public static decimal2x3 operator --(decimal2x3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static decimal2x3 operator ++(decimal2x3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static decimal2x3 abs(this decimal2x3 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs());

    [MethodImpl(256 | 512)]
    public static decimal2x3 sign(this decimal2x3 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign());

    [MethodImpl(256 | 512)]
    public static decimal2x3 min(this decimal2x3 a, decimal2x3 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2));

    [MethodImpl(256 | 512)]
    public static decimal2x3 max(this decimal2x3 a, decimal2x3 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2));

    [MethodImpl(256 | 512)]
    public static decimal2x3 clamp(this decimal2x3 v, decimal2x3 min, decimal2x3 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2));

    [MethodImpl(256 | 512)]
    public static decimal2x3 square(this decimal2x3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static decimal2x3 fma(this decimal2x3 a, decimal2x3 b, decimal2x3 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static decimal2x3 fms(this decimal2x3 a, decimal2x3 b, decimal2x3 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2));

    [MethodImpl(256 | 512)]
    public static decimal3 csum(this decimal2x3 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum());

    [MethodImpl(256 | 512)]
    public static decimal3 cmin(this decimal2x3 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin());

    [MethodImpl(256 | 512)]
    public static decimal3 cmax(this decimal2x3 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax());
}

#endregion // decimal2x3

#region decimal2x4

public partial struct decimal2x4
{
    [MethodImpl(256 | 512)]
    public static decimal2x4 operator +(decimal2x4 a) => a;

    [MethodImpl(256 | 512)]
    public static decimal2x4 operator -(decimal2x4 a) => 
        new(-a.c0, -a.c1, -a.c2, -a.c3);

    [MethodImpl(256 | 512)]
    public static decimal2x4 operator +(decimal2x4 a, decimal2x4 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2, a.c3 + b.c3);

    [MethodImpl(256 | 512)]
    public static decimal2x4 operator -(decimal2x4 a, decimal2x4 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2, a.c3 - b.c3);

    [MethodImpl(256 | 512)]
    public static decimal2x4 operator *(decimal2x4 a, decimal2x4 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2, a.c3 * b.c3);

    [MethodImpl(256 | 512)]
    public static decimal2x4 operator *(decimal2x4 a, decimal b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b, a.c3 * b);

    [MethodImpl(256 | 512)]
    public static decimal2x4 operator *(decimal a, decimal2x4 b) => 
        new(a * b.c0, a * b.c1, a * b.c2, a * b.c3);

    [MethodImpl(256 | 512)]
    public static decimal2x4 operator /(decimal2x4 a, decimal2x4 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2, a.c3 / b.c3);

    [MethodImpl(256 | 512)]
    public static decimal2x4 operator /(decimal2x4 a, decimal b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b, a.c3 / b);

    [MethodImpl(256 | 512)]
    public static decimal2x4 operator %(decimal2x4 a, decimal2x4 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2, a.c3 % b.c3);

    [MethodImpl(256 | 512)]
    public static decimal2x4 operator %(decimal2x4 a, decimal b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b, a.c3 % b);

    [MethodImpl(256 | 512)]
    public static decimal2x4 operator --(decimal2x4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static decimal2x4 operator ++(decimal2x4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static decimal2x4 abs(this decimal2x4 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs(), a.c3.abs());

    [MethodImpl(256 | 512)]
    public static decimal2x4 sign(this decimal2x4 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign(), a.c3.sign());

    [MethodImpl(256 | 512)]
    public static decimal2x4 min(this decimal2x4 a, decimal2x4 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2), a.c3.min(b.c3));

    [MethodImpl(256 | 512)]
    public static decimal2x4 max(this decimal2x4 a, decimal2x4 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2), a.c3.max(b.c3));

    [MethodImpl(256 | 512)]
    public static decimal2x4 clamp(this decimal2x4 v, decimal2x4 min, decimal2x4 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2), v.c3.clamp(min.c3, max.c3));

    [MethodImpl(256 | 512)]
    public static decimal2x4 square(this decimal2x4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static decimal2x4 fma(this decimal2x4 a, decimal2x4 b, decimal2x4 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2), a.c3.fma(b.c3, c.c3));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static decimal2x4 fms(this decimal2x4 a, decimal2x4 b, decimal2x4 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2), a.c3.fms(b.c3, c.c3));

    [MethodImpl(256 | 512)]
    public static decimal4 csum(this decimal2x4 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum(), a.c3.csum());

    [MethodImpl(256 | 512)]
    public static decimal4 cmin(this decimal2x4 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin(), a.c3.cmin());

    [MethodImpl(256 | 512)]
    public static decimal4 cmax(this decimal2x4 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax(), a.c3.cmax());
}

#endregion // decimal2x4

#region decimal3x2

public partial struct decimal3x2
{
    [MethodImpl(256 | 512)]
    public static decimal3x2 operator +(decimal3x2 a) => a;

    [MethodImpl(256 | 512)]
    public static decimal3x2 operator -(decimal3x2 a) => 
        new(-a.c0, -a.c1);

    [MethodImpl(256 | 512)]
    public static decimal3x2 operator +(decimal3x2 a, decimal3x2 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1);

    [MethodImpl(256 | 512)]
    public static decimal3x2 operator -(decimal3x2 a, decimal3x2 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1);

    [MethodImpl(256 | 512)]
    public static decimal3x2 operator *(decimal3x2 a, decimal3x2 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1);

    [MethodImpl(256 | 512)]
    public static decimal3x2 operator *(decimal3x2 a, decimal b) => 
        new(a.c0 * b, a.c1 * b);

    [MethodImpl(256 | 512)]
    public static decimal3x2 operator *(decimal a, decimal3x2 b) => 
        new(a * b.c0, a * b.c1);

    [MethodImpl(256 | 512)]
    public static decimal3x2 operator /(decimal3x2 a, decimal3x2 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1);

    [MethodImpl(256 | 512)]
    public static decimal3x2 operator /(decimal3x2 a, decimal b) => 
        new(a.c0 / b, a.c1 / b);

    [MethodImpl(256 | 512)]
    public static decimal3x2 operator %(decimal3x2 a, decimal3x2 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1);

    [MethodImpl(256 | 512)]
    public static decimal3x2 operator %(decimal3x2 a, decimal b) => 
        new(a.c0 % b, a.c1 % b);

    [MethodImpl(256 | 512)]
    public static decimal3x2 operator --(decimal3x2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static decimal3x2 operator ++(decimal3x2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static decimal3x2 abs(this decimal3x2 a) => 
        new(a.c0.abs(), a.c1.abs());

    [MethodImpl(256 | 512)]
    public static decimal3x2 sign(this decimal3x2 a) => 
        new(a.c0.sign(), a.c1.sign());

    [MethodImpl(256 | 512)]
    public static decimal3x2 min(this decimal3x2 a, decimal3x2 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1));

    [MethodImpl(256 | 512)]
    public static decimal3x2 max(this decimal3x2 a, decimal3x2 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1));

    [MethodImpl(256 | 512)]
    public static decimal3x2 clamp(this decimal3x2 v, decimal3x2 min, decimal3x2 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1));

    [MethodImpl(256 | 512)]
    public static decimal3x2 square(this decimal3x2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static decimal3x2 fma(this decimal3x2 a, decimal3x2 b, decimal3x2 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static decimal3x2 fms(this decimal3x2 a, decimal3x2 b, decimal3x2 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1));

    [MethodImpl(256 | 512)]
    public static decimal2 csum(this decimal3x2 a) => 
        new(a.c0.csum(), a.c1.csum());

    [MethodImpl(256 | 512)]
    public static decimal2 cmin(this decimal3x2 a) => 
        new(a.c0.cmin(), a.c1.cmin());

    [MethodImpl(256 | 512)]
    public static decimal2 cmax(this decimal3x2 a) => 
        new(a.c0.cmax(), a.c1.cmax());
}

#endregion // decimal3x2

#region decimal3x3

public partial struct decimal3x3
{
    [MethodImpl(256 | 512)]
    public static decimal3x3 operator +(decimal3x3 a) => a;

    [MethodImpl(256 | 512)]
    public static decimal3x3 operator -(decimal3x3 a) => 
        new(-a.c0, -a.c1, -a.c2);

    [MethodImpl(256 | 512)]
    public static decimal3x3 operator +(decimal3x3 a, decimal3x3 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2);

    [MethodImpl(256 | 512)]
    public static decimal3x3 operator -(decimal3x3 a, decimal3x3 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2);

    [MethodImpl(256 | 512)]
    public static decimal3x3 operator *(decimal3x3 a, decimal3x3 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2);

    [MethodImpl(256 | 512)]
    public static decimal3x3 operator *(decimal3x3 a, decimal b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b);

    [MethodImpl(256 | 512)]
    public static decimal3x3 operator *(decimal a, decimal3x3 b) => 
        new(a * b.c0, a * b.c1, a * b.c2);

    [MethodImpl(256 | 512)]
    public static decimal3x3 operator /(decimal3x3 a, decimal3x3 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2);

    [MethodImpl(256 | 512)]
    public static decimal3x3 operator /(decimal3x3 a, decimal b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b);

    [MethodImpl(256 | 512)]
    public static decimal3x3 operator %(decimal3x3 a, decimal3x3 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2);

    [MethodImpl(256 | 512)]
    public static decimal3x3 operator %(decimal3x3 a, decimal b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b);

    [MethodImpl(256 | 512)]
    public static decimal3x3 operator --(decimal3x3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static decimal3x3 operator ++(decimal3x3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static decimal3x3 abs(this decimal3x3 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs());

    [MethodImpl(256 | 512)]
    public static decimal3x3 sign(this decimal3x3 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign());

    [MethodImpl(256 | 512)]
    public static decimal3x3 min(this decimal3x3 a, decimal3x3 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2));

    [MethodImpl(256 | 512)]
    public static decimal3x3 max(this decimal3x3 a, decimal3x3 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2));

    [MethodImpl(256 | 512)]
    public static decimal3x3 clamp(this decimal3x3 v, decimal3x3 min, decimal3x3 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2));

    [MethodImpl(256 | 512)]
    public static decimal3x3 square(this decimal3x3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static decimal3x3 fma(this decimal3x3 a, decimal3x3 b, decimal3x3 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static decimal3x3 fms(this decimal3x3 a, decimal3x3 b, decimal3x3 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2));

    [MethodImpl(256 | 512)]
    public static decimal3 csum(this decimal3x3 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum());

    [MethodImpl(256 | 512)]
    public static decimal3 cmin(this decimal3x3 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin());

    [MethodImpl(256 | 512)]
    public static decimal3 cmax(this decimal3x3 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax());
}

#endregion // decimal3x3

#region decimal3x4

public partial struct decimal3x4
{
    [MethodImpl(256 | 512)]
    public static decimal3x4 operator +(decimal3x4 a) => a;

    [MethodImpl(256 | 512)]
    public static decimal3x4 operator -(decimal3x4 a) => 
        new(-a.c0, -a.c1, -a.c2, -a.c3);

    [MethodImpl(256 | 512)]
    public static decimal3x4 operator +(decimal3x4 a, decimal3x4 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2, a.c3 + b.c3);

    [MethodImpl(256 | 512)]
    public static decimal3x4 operator -(decimal3x4 a, decimal3x4 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2, a.c3 - b.c3);

    [MethodImpl(256 | 512)]
    public static decimal3x4 operator *(decimal3x4 a, decimal3x4 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2, a.c3 * b.c3);

    [MethodImpl(256 | 512)]
    public static decimal3x4 operator *(decimal3x4 a, decimal b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b, a.c3 * b);

    [MethodImpl(256 | 512)]
    public static decimal3x4 operator *(decimal a, decimal3x4 b) => 
        new(a * b.c0, a * b.c1, a * b.c2, a * b.c3);

    [MethodImpl(256 | 512)]
    public static decimal3x4 operator /(decimal3x4 a, decimal3x4 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2, a.c3 / b.c3);

    [MethodImpl(256 | 512)]
    public static decimal3x4 operator /(decimal3x4 a, decimal b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b, a.c3 / b);

    [MethodImpl(256 | 512)]
    public static decimal3x4 operator %(decimal3x4 a, decimal3x4 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2, a.c3 % b.c3);

    [MethodImpl(256 | 512)]
    public static decimal3x4 operator %(decimal3x4 a, decimal b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b, a.c3 % b);

    [MethodImpl(256 | 512)]
    public static decimal3x4 operator --(decimal3x4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static decimal3x4 operator ++(decimal3x4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static decimal3x4 abs(this decimal3x4 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs(), a.c3.abs());

    [MethodImpl(256 | 512)]
    public static decimal3x4 sign(this decimal3x4 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign(), a.c3.sign());

    [MethodImpl(256 | 512)]
    public static decimal3x4 min(this decimal3x4 a, decimal3x4 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2), a.c3.min(b.c3));

    [MethodImpl(256 | 512)]
    public static decimal3x4 max(this decimal3x4 a, decimal3x4 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2), a.c3.max(b.c3));

    [MethodImpl(256 | 512)]
    public static decimal3x4 clamp(this decimal3x4 v, decimal3x4 min, decimal3x4 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2), v.c3.clamp(min.c3, max.c3));

    [MethodImpl(256 | 512)]
    public static decimal3x4 square(this decimal3x4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static decimal3x4 fma(this decimal3x4 a, decimal3x4 b, decimal3x4 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2), a.c3.fma(b.c3, c.c3));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static decimal3x4 fms(this decimal3x4 a, decimal3x4 b, decimal3x4 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2), a.c3.fms(b.c3, c.c3));

    [MethodImpl(256 | 512)]
    public static decimal4 csum(this decimal3x4 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum(), a.c3.csum());

    [MethodImpl(256 | 512)]
    public static decimal4 cmin(this decimal3x4 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin(), a.c3.cmin());

    [MethodImpl(256 | 512)]
    public static decimal4 cmax(this decimal3x4 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax(), a.c3.cmax());
}

#endregion // decimal3x4

#region decimal4x2

public partial struct decimal4x2
{
    [MethodImpl(256 | 512)]
    public static decimal4x2 operator +(decimal4x2 a) => a;

    [MethodImpl(256 | 512)]
    public static decimal4x2 operator -(decimal4x2 a) => 
        new(-a.c0, -a.c1);

    [MethodImpl(256 | 512)]
    public static decimal4x2 operator +(decimal4x2 a, decimal4x2 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1);

    [MethodImpl(256 | 512)]
    public static decimal4x2 operator -(decimal4x2 a, decimal4x2 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1);

    [MethodImpl(256 | 512)]
    public static decimal4x2 operator *(decimal4x2 a, decimal4x2 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1);

    [MethodImpl(256 | 512)]
    public static decimal4x2 operator *(decimal4x2 a, decimal b) => 
        new(a.c0 * b, a.c1 * b);

    [MethodImpl(256 | 512)]
    public static decimal4x2 operator *(decimal a, decimal4x2 b) => 
        new(a * b.c0, a * b.c1);

    [MethodImpl(256 | 512)]
    public static decimal4x2 operator /(decimal4x2 a, decimal4x2 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1);

    [MethodImpl(256 | 512)]
    public static decimal4x2 operator /(decimal4x2 a, decimal b) => 
        new(a.c0 / b, a.c1 / b);

    [MethodImpl(256 | 512)]
    public static decimal4x2 operator %(decimal4x2 a, decimal4x2 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1);

    [MethodImpl(256 | 512)]
    public static decimal4x2 operator %(decimal4x2 a, decimal b) => 
        new(a.c0 % b, a.c1 % b);

    [MethodImpl(256 | 512)]
    public static decimal4x2 operator --(decimal4x2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static decimal4x2 operator ++(decimal4x2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static decimal4x2 abs(this decimal4x2 a) => 
        new(a.c0.abs(), a.c1.abs());

    [MethodImpl(256 | 512)]
    public static decimal4x2 sign(this decimal4x2 a) => 
        new(a.c0.sign(), a.c1.sign());

    [MethodImpl(256 | 512)]
    public static decimal4x2 min(this decimal4x2 a, decimal4x2 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1));

    [MethodImpl(256 | 512)]
    public static decimal4x2 max(this decimal4x2 a, decimal4x2 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1));

    [MethodImpl(256 | 512)]
    public static decimal4x2 clamp(this decimal4x2 v, decimal4x2 min, decimal4x2 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1));

    [MethodImpl(256 | 512)]
    public static decimal4x2 square(this decimal4x2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static decimal4x2 fma(this decimal4x2 a, decimal4x2 b, decimal4x2 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static decimal4x2 fms(this decimal4x2 a, decimal4x2 b, decimal4x2 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1));

    [MethodImpl(256 | 512)]
    public static decimal2 csum(this decimal4x2 a) => 
        new(a.c0.csum(), a.c1.csum());

    [MethodImpl(256 | 512)]
    public static decimal2 cmin(this decimal4x2 a) => 
        new(a.c0.cmin(), a.c1.cmin());

    [MethodImpl(256 | 512)]
    public static decimal2 cmax(this decimal4x2 a) => 
        new(a.c0.cmax(), a.c1.cmax());
}

#endregion // decimal4x2

#region decimal4x3

public partial struct decimal4x3
{
    [MethodImpl(256 | 512)]
    public static decimal4x3 operator +(decimal4x3 a) => a;

    [MethodImpl(256 | 512)]
    public static decimal4x3 operator -(decimal4x3 a) => 
        new(-a.c0, -a.c1, -a.c2);

    [MethodImpl(256 | 512)]
    public static decimal4x3 operator +(decimal4x3 a, decimal4x3 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2);

    [MethodImpl(256 | 512)]
    public static decimal4x3 operator -(decimal4x3 a, decimal4x3 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2);

    [MethodImpl(256 | 512)]
    public static decimal4x3 operator *(decimal4x3 a, decimal4x3 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2);

    [MethodImpl(256 | 512)]
    public static decimal4x3 operator *(decimal4x3 a, decimal b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b);

    [MethodImpl(256 | 512)]
    public static decimal4x3 operator *(decimal a, decimal4x3 b) => 
        new(a * b.c0, a * b.c1, a * b.c2);

    [MethodImpl(256 | 512)]
    public static decimal4x3 operator /(decimal4x3 a, decimal4x3 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2);

    [MethodImpl(256 | 512)]
    public static decimal4x3 operator /(decimal4x3 a, decimal b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b);

    [MethodImpl(256 | 512)]
    public static decimal4x3 operator %(decimal4x3 a, decimal4x3 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2);

    [MethodImpl(256 | 512)]
    public static decimal4x3 operator %(decimal4x3 a, decimal b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b);

    [MethodImpl(256 | 512)]
    public static decimal4x3 operator --(decimal4x3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static decimal4x3 operator ++(decimal4x3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static decimal4x3 abs(this decimal4x3 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs());

    [MethodImpl(256 | 512)]
    public static decimal4x3 sign(this decimal4x3 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign());

    [MethodImpl(256 | 512)]
    public static decimal4x3 min(this decimal4x3 a, decimal4x3 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2));

    [MethodImpl(256 | 512)]
    public static decimal4x3 max(this decimal4x3 a, decimal4x3 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2));

    [MethodImpl(256 | 512)]
    public static decimal4x3 clamp(this decimal4x3 v, decimal4x3 min, decimal4x3 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2));

    [MethodImpl(256 | 512)]
    public static decimal4x3 square(this decimal4x3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static decimal4x3 fma(this decimal4x3 a, decimal4x3 b, decimal4x3 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static decimal4x3 fms(this decimal4x3 a, decimal4x3 b, decimal4x3 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2));

    [MethodImpl(256 | 512)]
    public static decimal3 csum(this decimal4x3 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum());

    [MethodImpl(256 | 512)]
    public static decimal3 cmin(this decimal4x3 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin());

    [MethodImpl(256 | 512)]
    public static decimal3 cmax(this decimal4x3 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax());
}

#endregion // decimal4x3

#region decimal4x4

public partial struct decimal4x4
{
    [MethodImpl(256 | 512)]
    public static decimal4x4 operator +(decimal4x4 a) => a;

    [MethodImpl(256 | 512)]
    public static decimal4x4 operator -(decimal4x4 a) => 
        new(-a.c0, -a.c1, -a.c2, -a.c3);

    [MethodImpl(256 | 512)]
    public static decimal4x4 operator +(decimal4x4 a, decimal4x4 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2, a.c3 + b.c3);

    [MethodImpl(256 | 512)]
    public static decimal4x4 operator -(decimal4x4 a, decimal4x4 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2, a.c3 - b.c3);

    [MethodImpl(256 | 512)]
    public static decimal4x4 operator *(decimal4x4 a, decimal4x4 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2, a.c3 * b.c3);

    [MethodImpl(256 | 512)]
    public static decimal4x4 operator *(decimal4x4 a, decimal b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b, a.c3 * b);

    [MethodImpl(256 | 512)]
    public static decimal4x4 operator *(decimal a, decimal4x4 b) => 
        new(a * b.c0, a * b.c1, a * b.c2, a * b.c3);

    [MethodImpl(256 | 512)]
    public static decimal4x4 operator /(decimal4x4 a, decimal4x4 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2, a.c3 / b.c3);

    [MethodImpl(256 | 512)]
    public static decimal4x4 operator /(decimal4x4 a, decimal b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b, a.c3 / b);

    [MethodImpl(256 | 512)]
    public static decimal4x4 operator %(decimal4x4 a, decimal4x4 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2, a.c3 % b.c3);

    [MethodImpl(256 | 512)]
    public static decimal4x4 operator %(decimal4x4 a, decimal b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b, a.c3 % b);

    [MethodImpl(256 | 512)]
    public static decimal4x4 operator --(decimal4x4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static decimal4x4 operator ++(decimal4x4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static decimal4x4 abs(this decimal4x4 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs(), a.c3.abs());

    [MethodImpl(256 | 512)]
    public static decimal4x4 sign(this decimal4x4 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign(), a.c3.sign());

    [MethodImpl(256 | 512)]
    public static decimal4x4 min(this decimal4x4 a, decimal4x4 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2), a.c3.min(b.c3));

    [MethodImpl(256 | 512)]
    public static decimal4x4 max(this decimal4x4 a, decimal4x4 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2), a.c3.max(b.c3));

    [MethodImpl(256 | 512)]
    public static decimal4x4 clamp(this decimal4x4 v, decimal4x4 min, decimal4x4 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2), v.c3.clamp(min.c3, max.c3));

    [MethodImpl(256 | 512)]
    public static decimal4x4 square(this decimal4x4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static decimal4x4 fma(this decimal4x4 a, decimal4x4 b, decimal4x4 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2), a.c3.fma(b.c3, c.c3));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static decimal4x4 fms(this decimal4x4 a, decimal4x4 b, decimal4x4 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2), a.c3.fms(b.c3, c.c3));

    [MethodImpl(256 | 512)]
    public static decimal4 csum(this decimal4x4 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum(), a.c3.csum());

    [MethodImpl(256 | 512)]
    public static decimal4 cmin(this decimal4x4 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin(), a.c3.cmin());

    [MethodImpl(256 | 512)]
    public static decimal4 cmax(this decimal4x4 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax(), a.c3.cmax());
}

#endregion // decimal4x4

#region half2x2

public partial struct half2x2
{
    [MethodImpl(256 | 512)]
    public static half2x2 operator +(half2x2 a) => a;

    [MethodImpl(256 | 512)]
    public static half2x2 operator -(half2x2 a) => 
        new(-a.c0, -a.c1);

    [MethodImpl(256 | 512)]
    public static half2x2 operator +(half2x2 a, half2x2 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1);

    [MethodImpl(256 | 512)]
    public static half2x2 operator -(half2x2 a, half2x2 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1);

    [MethodImpl(256 | 512)]
    public static half2x2 operator *(half2x2 a, half2x2 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1);

    [MethodImpl(256 | 512)]
    public static half2x2 operator *(half2x2 a, half b) => 
        new(a.c0 * b, a.c1 * b);

    [MethodImpl(256 | 512)]
    public static half2x2 operator *(half a, half2x2 b) => 
        new(a * b.c0, a * b.c1);

    [MethodImpl(256 | 512)]
    public static half2x2 operator /(half2x2 a, half2x2 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1);

    [MethodImpl(256 | 512)]
    public static half2x2 operator /(half2x2 a, half b) => 
        new(a.c0 / b, a.c1 / b);

    [MethodImpl(256 | 512)]
    public static half2x2 operator %(half2x2 a, half2x2 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1);

    [MethodImpl(256 | 512)]
    public static half2x2 operator %(half2x2 a, half b) => 
        new(a.c0 % b, a.c1 % b);

    [MethodImpl(256 | 512)]
    public static half2x2 operator --(half2x2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static half2x2 operator ++(half2x2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half2x2 abs(this half2x2 a) => 
        new(a.c0.abs(), a.c1.abs());

    [MethodImpl(256 | 512)]
    public static half2x2 sign(this half2x2 a) => 
        new(a.c0.sign(), a.c1.sign());

    [MethodImpl(256 | 512)]
    public static half2x2 min(this half2x2 a, half2x2 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1));

    [MethodImpl(256 | 512)]
    public static half2x2 max(this half2x2 a, half2x2 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1));

    [MethodImpl(256 | 512)]
    public static half2x2 clamp(this half2x2 v, half2x2 min, half2x2 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1));

    [MethodImpl(256 | 512)]
    public static half2x2 square(this half2x2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static half2x2 fma(this half2x2 a, half2x2 b, half2x2 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static half2x2 fms(this half2x2 a, half2x2 b, half2x2 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1));

    [MethodImpl(256 | 512)]
    public static half2 csum(this half2x2 a) => 
        new(a.c0.csum(), a.c1.csum());

    [MethodImpl(256 | 512)]
    public static half2 cmin(this half2x2 a) => 
        new(a.c0.cmin(), a.c1.cmin());

    [MethodImpl(256 | 512)]
    public static half2 cmax(this half2x2 a) => 
        new(a.c0.cmax(), a.c1.cmax());
}

#endregion // half2x2

#region half2x3

public partial struct half2x3
{
    [MethodImpl(256 | 512)]
    public static half2x3 operator +(half2x3 a) => a;

    [MethodImpl(256 | 512)]
    public static half2x3 operator -(half2x3 a) => 
        new(-a.c0, -a.c1, -a.c2);

    [MethodImpl(256 | 512)]
    public static half2x3 operator +(half2x3 a, half2x3 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2);

    [MethodImpl(256 | 512)]
    public static half2x3 operator -(half2x3 a, half2x3 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2);

    [MethodImpl(256 | 512)]
    public static half2x3 operator *(half2x3 a, half2x3 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2);

    [MethodImpl(256 | 512)]
    public static half2x3 operator *(half2x3 a, half b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b);

    [MethodImpl(256 | 512)]
    public static half2x3 operator *(half a, half2x3 b) => 
        new(a * b.c0, a * b.c1, a * b.c2);

    [MethodImpl(256 | 512)]
    public static half2x3 operator /(half2x3 a, half2x3 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2);

    [MethodImpl(256 | 512)]
    public static half2x3 operator /(half2x3 a, half b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b);

    [MethodImpl(256 | 512)]
    public static half2x3 operator %(half2x3 a, half2x3 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2);

    [MethodImpl(256 | 512)]
    public static half2x3 operator %(half2x3 a, half b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b);

    [MethodImpl(256 | 512)]
    public static half2x3 operator --(half2x3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static half2x3 operator ++(half2x3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half2x3 abs(this half2x3 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs());

    [MethodImpl(256 | 512)]
    public static half2x3 sign(this half2x3 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign());

    [MethodImpl(256 | 512)]
    public static half2x3 min(this half2x3 a, half2x3 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2));

    [MethodImpl(256 | 512)]
    public static half2x3 max(this half2x3 a, half2x3 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2));

    [MethodImpl(256 | 512)]
    public static half2x3 clamp(this half2x3 v, half2x3 min, half2x3 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2));

    [MethodImpl(256 | 512)]
    public static half2x3 square(this half2x3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static half2x3 fma(this half2x3 a, half2x3 b, half2x3 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static half2x3 fms(this half2x3 a, half2x3 b, half2x3 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2));

    [MethodImpl(256 | 512)]
    public static half3 csum(this half2x3 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum());

    [MethodImpl(256 | 512)]
    public static half3 cmin(this half2x3 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin());

    [MethodImpl(256 | 512)]
    public static half3 cmax(this half2x3 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax());
}

#endregion // half2x3

#region half2x4

public partial struct half2x4
{
    [MethodImpl(256 | 512)]
    public static half2x4 operator +(half2x4 a) => a;

    [MethodImpl(256 | 512)]
    public static half2x4 operator -(half2x4 a) => 
        new(-a.c0, -a.c1, -a.c2, -a.c3);

    [MethodImpl(256 | 512)]
    public static half2x4 operator +(half2x4 a, half2x4 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2, a.c3 + b.c3);

    [MethodImpl(256 | 512)]
    public static half2x4 operator -(half2x4 a, half2x4 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2, a.c3 - b.c3);

    [MethodImpl(256 | 512)]
    public static half2x4 operator *(half2x4 a, half2x4 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2, a.c3 * b.c3);

    [MethodImpl(256 | 512)]
    public static half2x4 operator *(half2x4 a, half b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b, a.c3 * b);

    [MethodImpl(256 | 512)]
    public static half2x4 operator *(half a, half2x4 b) => 
        new(a * b.c0, a * b.c1, a * b.c2, a * b.c3);

    [MethodImpl(256 | 512)]
    public static half2x4 operator /(half2x4 a, half2x4 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2, a.c3 / b.c3);

    [MethodImpl(256 | 512)]
    public static half2x4 operator /(half2x4 a, half b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b, a.c3 / b);

    [MethodImpl(256 | 512)]
    public static half2x4 operator %(half2x4 a, half2x4 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2, a.c3 % b.c3);

    [MethodImpl(256 | 512)]
    public static half2x4 operator %(half2x4 a, half b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b, a.c3 % b);

    [MethodImpl(256 | 512)]
    public static half2x4 operator --(half2x4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static half2x4 operator ++(half2x4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half2x4 abs(this half2x4 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs(), a.c3.abs());

    [MethodImpl(256 | 512)]
    public static half2x4 sign(this half2x4 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign(), a.c3.sign());

    [MethodImpl(256 | 512)]
    public static half2x4 min(this half2x4 a, half2x4 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2), a.c3.min(b.c3));

    [MethodImpl(256 | 512)]
    public static half2x4 max(this half2x4 a, half2x4 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2), a.c3.max(b.c3));

    [MethodImpl(256 | 512)]
    public static half2x4 clamp(this half2x4 v, half2x4 min, half2x4 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2), v.c3.clamp(min.c3, max.c3));

    [MethodImpl(256 | 512)]
    public static half2x4 square(this half2x4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static half2x4 fma(this half2x4 a, half2x4 b, half2x4 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2), a.c3.fma(b.c3, c.c3));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static half2x4 fms(this half2x4 a, half2x4 b, half2x4 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2), a.c3.fms(b.c3, c.c3));

    [MethodImpl(256 | 512)]
    public static half4 csum(this half2x4 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum(), a.c3.csum());

    [MethodImpl(256 | 512)]
    public static half4 cmin(this half2x4 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin(), a.c3.cmin());

    [MethodImpl(256 | 512)]
    public static half4 cmax(this half2x4 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax(), a.c3.cmax());
}

#endregion // half2x4

#region half3x2

public partial struct half3x2
{
    [MethodImpl(256 | 512)]
    public static half3x2 operator +(half3x2 a) => a;

    [MethodImpl(256 | 512)]
    public static half3x2 operator -(half3x2 a) => 
        new(-a.c0, -a.c1);

    [MethodImpl(256 | 512)]
    public static half3x2 operator +(half3x2 a, half3x2 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1);

    [MethodImpl(256 | 512)]
    public static half3x2 operator -(half3x2 a, half3x2 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1);

    [MethodImpl(256 | 512)]
    public static half3x2 operator *(half3x2 a, half3x2 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1);

    [MethodImpl(256 | 512)]
    public static half3x2 operator *(half3x2 a, half b) => 
        new(a.c0 * b, a.c1 * b);

    [MethodImpl(256 | 512)]
    public static half3x2 operator *(half a, half3x2 b) => 
        new(a * b.c0, a * b.c1);

    [MethodImpl(256 | 512)]
    public static half3x2 operator /(half3x2 a, half3x2 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1);

    [MethodImpl(256 | 512)]
    public static half3x2 operator /(half3x2 a, half b) => 
        new(a.c0 / b, a.c1 / b);

    [MethodImpl(256 | 512)]
    public static half3x2 operator %(half3x2 a, half3x2 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1);

    [MethodImpl(256 | 512)]
    public static half3x2 operator %(half3x2 a, half b) => 
        new(a.c0 % b, a.c1 % b);

    [MethodImpl(256 | 512)]
    public static half3x2 operator --(half3x2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static half3x2 operator ++(half3x2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half3x2 abs(this half3x2 a) => 
        new(a.c0.abs(), a.c1.abs());

    [MethodImpl(256 | 512)]
    public static half3x2 sign(this half3x2 a) => 
        new(a.c0.sign(), a.c1.sign());

    [MethodImpl(256 | 512)]
    public static half3x2 min(this half3x2 a, half3x2 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1));

    [MethodImpl(256 | 512)]
    public static half3x2 max(this half3x2 a, half3x2 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1));

    [MethodImpl(256 | 512)]
    public static half3x2 clamp(this half3x2 v, half3x2 min, half3x2 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1));

    [MethodImpl(256 | 512)]
    public static half3x2 square(this half3x2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static half3x2 fma(this half3x2 a, half3x2 b, half3x2 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static half3x2 fms(this half3x2 a, half3x2 b, half3x2 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1));

    [MethodImpl(256 | 512)]
    public static half2 csum(this half3x2 a) => 
        new(a.c0.csum(), a.c1.csum());

    [MethodImpl(256 | 512)]
    public static half2 cmin(this half3x2 a) => 
        new(a.c0.cmin(), a.c1.cmin());

    [MethodImpl(256 | 512)]
    public static half2 cmax(this half3x2 a) => 
        new(a.c0.cmax(), a.c1.cmax());
}

#endregion // half3x2

#region half3x3

public partial struct half3x3
{
    [MethodImpl(256 | 512)]
    public static half3x3 operator +(half3x3 a) => a;

    [MethodImpl(256 | 512)]
    public static half3x3 operator -(half3x3 a) => 
        new(-a.c0, -a.c1, -a.c2);

    [MethodImpl(256 | 512)]
    public static half3x3 operator +(half3x3 a, half3x3 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2);

    [MethodImpl(256 | 512)]
    public static half3x3 operator -(half3x3 a, half3x3 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2);

    [MethodImpl(256 | 512)]
    public static half3x3 operator *(half3x3 a, half3x3 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2);

    [MethodImpl(256 | 512)]
    public static half3x3 operator *(half3x3 a, half b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b);

    [MethodImpl(256 | 512)]
    public static half3x3 operator *(half a, half3x3 b) => 
        new(a * b.c0, a * b.c1, a * b.c2);

    [MethodImpl(256 | 512)]
    public static half3x3 operator /(half3x3 a, half3x3 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2);

    [MethodImpl(256 | 512)]
    public static half3x3 operator /(half3x3 a, half b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b);

    [MethodImpl(256 | 512)]
    public static half3x3 operator %(half3x3 a, half3x3 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2);

    [MethodImpl(256 | 512)]
    public static half3x3 operator %(half3x3 a, half b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b);

    [MethodImpl(256 | 512)]
    public static half3x3 operator --(half3x3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static half3x3 operator ++(half3x3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half3x3 abs(this half3x3 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs());

    [MethodImpl(256 | 512)]
    public static half3x3 sign(this half3x3 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign());

    [MethodImpl(256 | 512)]
    public static half3x3 min(this half3x3 a, half3x3 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2));

    [MethodImpl(256 | 512)]
    public static half3x3 max(this half3x3 a, half3x3 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2));

    [MethodImpl(256 | 512)]
    public static half3x3 clamp(this half3x3 v, half3x3 min, half3x3 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2));

    [MethodImpl(256 | 512)]
    public static half3x3 square(this half3x3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static half3x3 fma(this half3x3 a, half3x3 b, half3x3 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static half3x3 fms(this half3x3 a, half3x3 b, half3x3 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2));

    [MethodImpl(256 | 512)]
    public static half3 csum(this half3x3 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum());

    [MethodImpl(256 | 512)]
    public static half3 cmin(this half3x3 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin());

    [MethodImpl(256 | 512)]
    public static half3 cmax(this half3x3 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax());
}

#endregion // half3x3

#region half3x4

public partial struct half3x4
{
    [MethodImpl(256 | 512)]
    public static half3x4 operator +(half3x4 a) => a;

    [MethodImpl(256 | 512)]
    public static half3x4 operator -(half3x4 a) => 
        new(-a.c0, -a.c1, -a.c2, -a.c3);

    [MethodImpl(256 | 512)]
    public static half3x4 operator +(half3x4 a, half3x4 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2, a.c3 + b.c3);

    [MethodImpl(256 | 512)]
    public static half3x4 operator -(half3x4 a, half3x4 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2, a.c3 - b.c3);

    [MethodImpl(256 | 512)]
    public static half3x4 operator *(half3x4 a, half3x4 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2, a.c3 * b.c3);

    [MethodImpl(256 | 512)]
    public static half3x4 operator *(half3x4 a, half b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b, a.c3 * b);

    [MethodImpl(256 | 512)]
    public static half3x4 operator *(half a, half3x4 b) => 
        new(a * b.c0, a * b.c1, a * b.c2, a * b.c3);

    [MethodImpl(256 | 512)]
    public static half3x4 operator /(half3x4 a, half3x4 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2, a.c3 / b.c3);

    [MethodImpl(256 | 512)]
    public static half3x4 operator /(half3x4 a, half b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b, a.c3 / b);

    [MethodImpl(256 | 512)]
    public static half3x4 operator %(half3x4 a, half3x4 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2, a.c3 % b.c3);

    [MethodImpl(256 | 512)]
    public static half3x4 operator %(half3x4 a, half b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b, a.c3 % b);

    [MethodImpl(256 | 512)]
    public static half3x4 operator --(half3x4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static half3x4 operator ++(half3x4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half3x4 abs(this half3x4 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs(), a.c3.abs());

    [MethodImpl(256 | 512)]
    public static half3x4 sign(this half3x4 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign(), a.c3.sign());

    [MethodImpl(256 | 512)]
    public static half3x4 min(this half3x4 a, half3x4 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2), a.c3.min(b.c3));

    [MethodImpl(256 | 512)]
    public static half3x4 max(this half3x4 a, half3x4 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2), a.c3.max(b.c3));

    [MethodImpl(256 | 512)]
    public static half3x4 clamp(this half3x4 v, half3x4 min, half3x4 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2), v.c3.clamp(min.c3, max.c3));

    [MethodImpl(256 | 512)]
    public static half3x4 square(this half3x4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static half3x4 fma(this half3x4 a, half3x4 b, half3x4 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2), a.c3.fma(b.c3, c.c3));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static half3x4 fms(this half3x4 a, half3x4 b, half3x4 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2), a.c3.fms(b.c3, c.c3));

    [MethodImpl(256 | 512)]
    public static half4 csum(this half3x4 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum(), a.c3.csum());

    [MethodImpl(256 | 512)]
    public static half4 cmin(this half3x4 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin(), a.c3.cmin());

    [MethodImpl(256 | 512)]
    public static half4 cmax(this half3x4 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax(), a.c3.cmax());
}

#endregion // half3x4

#region half4x2

public partial struct half4x2
{
    [MethodImpl(256 | 512)]
    public static half4x2 operator +(half4x2 a) => a;

    [MethodImpl(256 | 512)]
    public static half4x2 operator -(half4x2 a) => 
        new(-a.c0, -a.c1);

    [MethodImpl(256 | 512)]
    public static half4x2 operator +(half4x2 a, half4x2 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1);

    [MethodImpl(256 | 512)]
    public static half4x2 operator -(half4x2 a, half4x2 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1);

    [MethodImpl(256 | 512)]
    public static half4x2 operator *(half4x2 a, half4x2 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1);

    [MethodImpl(256 | 512)]
    public static half4x2 operator *(half4x2 a, half b) => 
        new(a.c0 * b, a.c1 * b);

    [MethodImpl(256 | 512)]
    public static half4x2 operator *(half a, half4x2 b) => 
        new(a * b.c0, a * b.c1);

    [MethodImpl(256 | 512)]
    public static half4x2 operator /(half4x2 a, half4x2 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1);

    [MethodImpl(256 | 512)]
    public static half4x2 operator /(half4x2 a, half b) => 
        new(a.c0 / b, a.c1 / b);

    [MethodImpl(256 | 512)]
    public static half4x2 operator %(half4x2 a, half4x2 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1);

    [MethodImpl(256 | 512)]
    public static half4x2 operator %(half4x2 a, half b) => 
        new(a.c0 % b, a.c1 % b);

    [MethodImpl(256 | 512)]
    public static half4x2 operator --(half4x2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static half4x2 operator ++(half4x2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half4x2 abs(this half4x2 a) => 
        new(a.c0.abs(), a.c1.abs());

    [MethodImpl(256 | 512)]
    public static half4x2 sign(this half4x2 a) => 
        new(a.c0.sign(), a.c1.sign());

    [MethodImpl(256 | 512)]
    public static half4x2 min(this half4x2 a, half4x2 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1));

    [MethodImpl(256 | 512)]
    public static half4x2 max(this half4x2 a, half4x2 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1));

    [MethodImpl(256 | 512)]
    public static half4x2 clamp(this half4x2 v, half4x2 min, half4x2 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1));

    [MethodImpl(256 | 512)]
    public static half4x2 square(this half4x2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static half4x2 fma(this half4x2 a, half4x2 b, half4x2 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static half4x2 fms(this half4x2 a, half4x2 b, half4x2 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1));

    [MethodImpl(256 | 512)]
    public static half2 csum(this half4x2 a) => 
        new(a.c0.csum(), a.c1.csum());

    [MethodImpl(256 | 512)]
    public static half2 cmin(this half4x2 a) => 
        new(a.c0.cmin(), a.c1.cmin());

    [MethodImpl(256 | 512)]
    public static half2 cmax(this half4x2 a) => 
        new(a.c0.cmax(), a.c1.cmax());
}

#endregion // half4x2

#region half4x3

public partial struct half4x3
{
    [MethodImpl(256 | 512)]
    public static half4x3 operator +(half4x3 a) => a;

    [MethodImpl(256 | 512)]
    public static half4x3 operator -(half4x3 a) => 
        new(-a.c0, -a.c1, -a.c2);

    [MethodImpl(256 | 512)]
    public static half4x3 operator +(half4x3 a, half4x3 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2);

    [MethodImpl(256 | 512)]
    public static half4x3 operator -(half4x3 a, half4x3 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2);

    [MethodImpl(256 | 512)]
    public static half4x3 operator *(half4x3 a, half4x3 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2);

    [MethodImpl(256 | 512)]
    public static half4x3 operator *(half4x3 a, half b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b);

    [MethodImpl(256 | 512)]
    public static half4x3 operator *(half a, half4x3 b) => 
        new(a * b.c0, a * b.c1, a * b.c2);

    [MethodImpl(256 | 512)]
    public static half4x3 operator /(half4x3 a, half4x3 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2);

    [MethodImpl(256 | 512)]
    public static half4x3 operator /(half4x3 a, half b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b);

    [MethodImpl(256 | 512)]
    public static half4x3 operator %(half4x3 a, half4x3 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2);

    [MethodImpl(256 | 512)]
    public static half4x3 operator %(half4x3 a, half b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b);

    [MethodImpl(256 | 512)]
    public static half4x3 operator --(half4x3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static half4x3 operator ++(half4x3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half4x3 abs(this half4x3 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs());

    [MethodImpl(256 | 512)]
    public static half4x3 sign(this half4x3 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign());

    [MethodImpl(256 | 512)]
    public static half4x3 min(this half4x3 a, half4x3 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2));

    [MethodImpl(256 | 512)]
    public static half4x3 max(this half4x3 a, half4x3 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2));

    [MethodImpl(256 | 512)]
    public static half4x3 clamp(this half4x3 v, half4x3 min, half4x3 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2));

    [MethodImpl(256 | 512)]
    public static half4x3 square(this half4x3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static half4x3 fma(this half4x3 a, half4x3 b, half4x3 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static half4x3 fms(this half4x3 a, half4x3 b, half4x3 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2));

    [MethodImpl(256 | 512)]
    public static half3 csum(this half4x3 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum());

    [MethodImpl(256 | 512)]
    public static half3 cmin(this half4x3 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin());

    [MethodImpl(256 | 512)]
    public static half3 cmax(this half4x3 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax());
}

#endregion // half4x3

#region half4x4

public partial struct half4x4
{
    [MethodImpl(256 | 512)]
    public static half4x4 operator +(half4x4 a) => a;

    [MethodImpl(256 | 512)]
    public static half4x4 operator -(half4x4 a) => 
        new(-a.c0, -a.c1, -a.c2, -a.c3);

    [MethodImpl(256 | 512)]
    public static half4x4 operator +(half4x4 a, half4x4 b) => 
        new(a.c0 + b.c0, a.c1 + b.c1, a.c2 + b.c2, a.c3 + b.c3);

    [MethodImpl(256 | 512)]
    public static half4x4 operator -(half4x4 a, half4x4 b) => 
        new(a.c0 - b.c0, a.c1 - b.c1, a.c2 - b.c2, a.c3 - b.c3);

    [MethodImpl(256 | 512)]
    public static half4x4 operator *(half4x4 a, half4x4 b) => 
        new(a.c0 * b.c0, a.c1 * b.c1, a.c2 * b.c2, a.c3 * b.c3);

    [MethodImpl(256 | 512)]
    public static half4x4 operator *(half4x4 a, half b) => 
        new(a.c0 * b, a.c1 * b, a.c2 * b, a.c3 * b);

    [MethodImpl(256 | 512)]
    public static half4x4 operator *(half a, half4x4 b) => 
        new(a * b.c0, a * b.c1, a * b.c2, a * b.c3);

    [MethodImpl(256 | 512)]
    public static half4x4 operator /(half4x4 a, half4x4 b) => 
        new(a.c0 / b.c0, a.c1 / b.c1, a.c2 / b.c2, a.c3 / b.c3);

    [MethodImpl(256 | 512)]
    public static half4x4 operator /(half4x4 a, half b) => 
        new(a.c0 / b, a.c1 / b, a.c2 / b, a.c3 / b);

    [MethodImpl(256 | 512)]
    public static half4x4 operator %(half4x4 a, half4x4 b) => 
        new(a.c0 % b.c0, a.c1 % b.c1, a.c2 % b.c2, a.c3 % b.c3);

    [MethodImpl(256 | 512)]
    public static half4x4 operator %(half4x4 a, half b) => 
        new(a.c0 % b, a.c1 % b, a.c2 % b, a.c3 % b);

    [MethodImpl(256 | 512)]
    public static half4x4 operator --(half4x4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static half4x4 operator ++(half4x4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half4x4 abs(this half4x4 a) => 
        new(a.c0.abs(), a.c1.abs(), a.c2.abs(), a.c3.abs());

    [MethodImpl(256 | 512)]
    public static half4x4 sign(this half4x4 a) => 
        new(a.c0.sign(), a.c1.sign(), a.c2.sign(), a.c3.sign());

    [MethodImpl(256 | 512)]
    public static half4x4 min(this half4x4 a, half4x4 b) => 
        new(a.c0.min(b.c0), a.c1.min(b.c1), a.c2.min(b.c2), a.c3.min(b.c3));

    [MethodImpl(256 | 512)]
    public static half4x4 max(this half4x4 a, half4x4 b) => 
        new(a.c0.max(b.c0), a.c1.max(b.c1), a.c2.max(b.c2), a.c3.max(b.c3));

    [MethodImpl(256 | 512)]
    public static half4x4 clamp(this half4x4 v, half4x4 min, half4x4 max) => 
        new(v.c0.clamp(min.c0, max.c0), v.c1.clamp(min.c1, max.c1), v.c2.clamp(min.c2, max.c2), v.c3.clamp(min.c3, max.c3));

    [MethodImpl(256 | 512)]
    public static half4x4 square(this half4x4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static half4x4 fma(this half4x4 a, half4x4 b, half4x4 c) => 
        new(a.c0.fma(b.c0, c.c0), a.c1.fma(b.c1, c.c1), a.c2.fma(b.c2, c.c2), a.c3.fma(b.c3, c.c3));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static half4x4 fms(this half4x4 a, half4x4 b, half4x4 c) => 
        new(a.c0.fms(b.c0, c.c0), a.c1.fms(b.c1, c.c1), a.c2.fms(b.c2, c.c2), a.c3.fms(b.c3, c.c3));

    [MethodImpl(256 | 512)]
    public static half4 csum(this half4x4 a) => 
        new(a.c0.csum(), a.c1.csum(), a.c2.csum(), a.c3.csum());

    [MethodImpl(256 | 512)]
    public static half4 cmin(this half4x4 a) => 
        new(a.c0.cmin(), a.c1.cmin(), a.c2.cmin(), a.c3.cmin());

    [MethodImpl(256 | 512)]
    public static half4 cmax(this half4x4 a) => 
        new(a.c0.cmax(), a.c1.cmax(), a.c2.cmax(), a.c3.cmax());
}

#endregion // half4x4
