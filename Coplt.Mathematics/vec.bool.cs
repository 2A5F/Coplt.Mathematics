// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region b16v2

public partial struct b16v2
{
    [MethodImpl(256 | 512)]
    public static b16v2 operator !(b16v2 self)
    {
        return new(!self.x, !self.y);
    }
}

public static partial class math
{

    [MethodImpl(256 | 512)]
    public static bool all(this b16v2 v) => v.EqualsAll(new(b16v.True));

    [MethodImpl(256 | 512)]
    public static bool any(this b16v2 v) => v.EqualsAny(new(b16v.True));

}

#endregion // b16v2

#region b16v3

public partial struct b16v3
{
    [MethodImpl(256 | 512)]
    public static b16v3 operator !(b16v3 self)
    {
        return new(!self.x, !self.y, !self.z);
    }
}

public static partial class math
{

    [MethodImpl(256 | 512)]
    public static bool all(this b16v3 v) => v.EqualsAll(new(b16v.True));

    [MethodImpl(256 | 512)]
    public static bool any(this b16v3 v) => v.EqualsAny(new(b16v.True));

}

#endregion // b16v3

#region b16v4

public partial struct b16v4
{
    [MethodImpl(256 | 512)]
    public static b16v4 operator !(b16v4 self)
    {
        return new(!self.x, !self.y, !self.z, !self.w);
    }
}

public static partial class math
{

    [MethodImpl(256 | 512)]
    public static bool all(this b16v4 v) => v.EqualsAll(new(b16v.True));

    [MethodImpl(256 | 512)]
    public static bool any(this b16v4 v) => v.EqualsAny(new(b16v.True));

}

#endregion // b16v4

#region b32v2

public partial struct b32v2
{
    [MethodImpl(256 | 512)]
    public static b32v2 operator !(b32v2 self)
    {
        #if NET8_0_OR_GREATER
        return new((~self.vector));
        #else // NET8_0_OR_GREATER
        return new(!self.x, !self.y);
        #endif // NET8_0_OR_GREATER
    }
}

public static partial class math
{

    [MethodImpl(256 | 512)]
    public static bool all(this b32v2 v) => v.EqualsAll(new(b32v.True));

    [MethodImpl(256 | 512)]
    public static bool any(this b32v2 v) => v.EqualsAny(new(b32v.True));

}

#endregion // b32v2

#region b32v3

public partial struct b32v3
{
    [MethodImpl(256 | 512)]
    public static b32v3 operator !(b32v3 self)
    {
        #if NET8_0_OR_GREATER
        return new((~self.vector) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        #else // NET8_0_OR_GREATER
        return new(!self.x, !self.y, !self.z);
        #endif // NET8_0_OR_GREATER
    }
}

public static partial class math
{

    [MethodImpl(256 | 512)]
    public static bool all(this b32v3 v) => v.EqualsAll(new(b32v.True));

    [MethodImpl(256 | 512)]
    public static bool any(this b32v3 v) => v.EqualsAny(new(b32v.True));

}

#endregion // b32v3

#region b32v4

public partial struct b32v4
{
    [MethodImpl(256 | 512)]
    public static b32v4 operator !(b32v4 self)
    {
        #if NET8_0_OR_GREATER
        return new((~self.vector));
        #else // NET8_0_OR_GREATER
        return new(!self.x, !self.y, !self.z, !self.w);
        #endif // NET8_0_OR_GREATER
    }
}

public static partial class math
{

    [MethodImpl(256 | 512)]
    public static bool all(this b32v4 v) => v.EqualsAll(new(b32v.True));

    [MethodImpl(256 | 512)]
    public static bool any(this b32v4 v) => v.EqualsAny(new(b32v.True));

}

#endregion // b32v4

#region b64v2

public partial struct b64v2
{
    [MethodImpl(256 | 512)]
    public static b64v2 operator !(b64v2 self)
    {
        #if NET8_0_OR_GREATER
        return new((~self.vector));
        #else // NET8_0_OR_GREATER
        return new(!self.x, !self.y);
        #endif // NET8_0_OR_GREATER
    }
}

public static partial class math
{

    [MethodImpl(256 | 512)]
    public static bool all(this b64v2 v) => v.EqualsAll(new(b64v.True));

    [MethodImpl(256 | 512)]
    public static bool any(this b64v2 v) => v.EqualsAny(new(b64v.True));

}

#endregion // b64v2

#region b64v3

public partial struct b64v3
{
    [MethodImpl(256 | 512)]
    public static b64v3 operator !(b64v3 self)
    {
        #if NET8_0_OR_GREATER
        return new((~self.vector) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        #else // NET8_0_OR_GREATER
        return new(!self.x, !self.y, !self.z);
        #endif // NET8_0_OR_GREATER
    }
}

public static partial class math
{

    [MethodImpl(256 | 512)]
    public static bool all(this b64v3 v) => v.EqualsAll(new(b64v.True));

    [MethodImpl(256 | 512)]
    public static bool any(this b64v3 v) => v.EqualsAny(new(b64v.True));

}

#endregion // b64v3

#region b64v4

public partial struct b64v4
{
    [MethodImpl(256 | 512)]
    public static b64v4 operator !(b64v4 self)
    {
        #if NET8_0_OR_GREATER
        return new((~self.vector));
        #else // NET8_0_OR_GREATER
        return new(!self.x, !self.y, !self.z, !self.w);
        #endif // NET8_0_OR_GREATER
    }
}

public static partial class math
{

    [MethodImpl(256 | 512)]
    public static bool all(this b64v4 v) => v.EqualsAll(new(b64v.True));

    [MethodImpl(256 | 512)]
    public static bool any(this b64v4 v) => v.EqualsAny(new(b64v.True));

}

#endregion // b64v4
