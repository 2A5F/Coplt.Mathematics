// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region float2

public partial struct float2 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"float2({x}, {y})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"float2({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "float2(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "float2("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // float2

#region float3

public partial struct float3 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"float3({x}, {y}, {z})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"float3({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)}, {z.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "float3(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "float3("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // float3

#region float4

public partial struct float4 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"float4({x}, {y}, {z}, {w})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"float4({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)}, {z.ToString(format, formatProvider)}, {w.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "float4(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = w.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "float4("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = w.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // float4

#region double2

public partial struct double2 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"double2({x}, {y})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"double2({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "double2(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "double2("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // double2

#region double3

public partial struct double3 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"double3({x}, {y}, {z})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"double3({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)}, {z.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "double3(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "double3("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // double3

#region double4

public partial struct double4 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"double4({x}, {y}, {z}, {w})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"double4({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)}, {z.ToString(format, formatProvider)}, {w.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "double4(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = w.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "double4("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = w.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // double4

#region int2

public partial struct int2 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"int2({x}, {y})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"int2({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "int2(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "int2("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // int2

#region int3

public partial struct int3 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"int3({x}, {y}, {z})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"int3({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)}, {z.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "int3(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "int3("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // int3

#region int4

public partial struct int4 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"int4({x}, {y}, {z}, {w})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"int4({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)}, {z.ToString(format, formatProvider)}, {w.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "int4(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = w.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "int4("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = w.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // int4

#region uint2

public partial struct uint2 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"uint2({x}, {y})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"uint2({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "uint2(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "uint2("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // uint2

#region uint3

public partial struct uint3 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"uint3({x}, {y}, {z})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"uint3({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)}, {z.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "uint3(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "uint3("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // uint3

#region uint4

public partial struct uint4 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"uint4({x}, {y}, {z}, {w})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"uint4({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)}, {z.ToString(format, formatProvider)}, {w.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "uint4(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = w.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "uint4("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = w.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // uint4

#region long2

public partial struct long2 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"long2({x}, {y})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"long2({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "long2(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "long2("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // long2

#region long3

public partial struct long3 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"long3({x}, {y}, {z})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"long3({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)}, {z.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "long3(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "long3("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // long3

#region long4

public partial struct long4 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"long4({x}, {y}, {z}, {w})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"long4({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)}, {z.ToString(format, formatProvider)}, {w.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "long4(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = w.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "long4("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = w.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // long4

#region ulong2

public partial struct ulong2 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"ulong2({x}, {y})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"ulong2({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "ulong2(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "ulong2("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // ulong2

#region ulong3

public partial struct ulong3 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"ulong3({x}, {y}, {z})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"ulong3({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)}, {z.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "ulong3(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "ulong3("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // ulong3

#region ulong4

public partial struct ulong4 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"ulong4({x}, {y}, {z}, {w})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"ulong4({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)}, {z.ToString(format, formatProvider)}, {w.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "ulong4(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = w.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "ulong4("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = w.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // ulong4

#region decimal2

public partial struct decimal2 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"decimal2({x}, {y})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"decimal2({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "decimal2(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "decimal2("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // decimal2

#region decimal3

public partial struct decimal3 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"decimal3({x}, {y}, {z})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"decimal3({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)}, {z.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "decimal3(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "decimal3("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // decimal3

#region decimal4

public partial struct decimal4 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"decimal4({x}, {y}, {z}, {w})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"decimal4({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)}, {z.ToString(format, formatProvider)}, {w.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "decimal4(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = w.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "decimal4("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = w.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // decimal4

#region half2

public partial struct half2 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"half2({x}, {y})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"half2({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "half2(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "half2("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // half2

#region half3

public partial struct half3 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"half3({x}, {y}, {z})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"half3({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)}, {z.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "half3(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "half3("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // half3

#region half4

public partial struct half4 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"half4({x}, {y}, {z}, {w})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"half4({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)}, {z.ToString(format, formatProvider)}, {w.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "half4(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = w.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "half4("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = w.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // half4

#region b16v2

public partial struct b16v2 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"b16v2({x}, {y})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"b16v2({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "b16v2(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "b16v2("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // b16v2

#region b16v3

public partial struct b16v3 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"b16v3({x}, {y}, {z})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"b16v3({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)}, {z.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "b16v3(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "b16v3("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // b16v3

#region b16v4

public partial struct b16v4 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"b16v4({x}, {y}, {z}, {w})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"b16v4({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)}, {z.ToString(format, formatProvider)}, {w.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "b16v4(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = w.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "b16v4("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = w.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // b16v4

#region b32v2

public partial struct b32v2 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"b32v2({x}, {y})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"b32v2({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "b32v2(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "b32v2("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // b32v2

#region b32v3

public partial struct b32v3 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"b32v3({x}, {y}, {z})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"b32v3({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)}, {z.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "b32v3(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "b32v3("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // b32v3

#region b32v4

public partial struct b32v4 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"b32v4({x}, {y}, {z}, {w})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"b32v4({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)}, {z.ToString(format, formatProvider)}, {w.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "b32v4(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = w.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "b32v4("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = w.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // b32v4

#region b64v2

public partial struct b64v2 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"b64v2({x}, {y})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"b64v2({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "b64v2(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "b64v2("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // b64v2

#region b64v3

public partial struct b64v3 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"b64v3({x}, {y}, {z})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"b64v3({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)}, {z.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "b64v3(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "b64v3("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // b64v3

#region b64v4

public partial struct b64v4 : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    #endif
{
    public override string ToString() => $"b64v4({x}, {y}, {z}, {w})";

    public string ToString(string? format, IFormatProvider? formatProvider) => $"b64v4({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)}, {z.ToString(format, formatProvider)}, {w.ToString(format, formatProvider)})";

    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "b64v4(";
        var part1 = ")";
        if (dst.Length < part0.Length) return false;
        part0.AsSpan().CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = w.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.AsSpan().CopyTo(dst);
        nc += part1.Length;
        return true;
    }

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        var part0 = "b64v4("u8;
        var part1 = ")"u8;
        if (dst.Length < part0.Length) return false;
        part0.CopyTo(dst);
        nc += part0.Length;
        dst = dst[part0.Length..];
        int ic;
        bool r;
        r = x.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = y.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = z.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        r = w.TryFormat(dst, out ic, format, provider);
        nc += ic;
        if (!r) return false;
        dst = dst[ic..];
        if (dst.Length < part1.Length) return false;
        part1.CopyTo(dst);
        nc += part1.Length;
        return true;
    }
    #endif
}

#endregion // b64v4
