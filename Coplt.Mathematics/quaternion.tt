<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics;
<#
    foreach (var typ in Typ.Typs)
    {
        if (!typ.f || !typ.bin) continue;

        var typeBitSize = typ.size * 8;

        var byteSize = typ.size * 4;
        var bitSize = 8 * byteSize;

        var vecTypeName = $"{typ.name}{4}";
        var vecTypeName3 = $"{typ.name}{3}";
        var matTypeName3x3 = $"{typ.name}{3}x{3}";
        var matTypeName4x4 = $"{typ.name}{4}x{4}";
        var typeName = $"quaternion{typ.structSuffix}";
#>

#region <#= typeName #>

public partial struct <#= typeName #>
{
    public <#= vecTypeName #> value;

    public static <#= typeName #> Identity
    {
        [MethodImpl(256 | 512)]
        get => new(default, default, default, <#= typ.one #>);
    }
    
    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#= string.Join(", ", Enumerable.Range(0, 4).Select(i => $"{typ.compType} {Typ.xyzw[i]}")) #>) => 
        value = new(<#= string.Join(", ", Enumerable.Range(0, 4).Select(i => $"{Typ.xyzw[i]}")) #>); 

    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#= vecTypeName #> value) => this.value = value; 

    [MethodImpl(256 | 512)]
    public static implicit operator <#= typeName #>(<#= vecTypeName #> value) => new(value); 

    /// <summary>Constructs a unit quaternion from a <#= matTypeName3x3 #> rotation matrix. The matrix must be orthonormal</summary>
    /// <param name="m">The <#= matTypeName3x3 #> orthonormal rotation matrix</param>
    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#= matTypeName3x3 #> m)
    {
        var u = m.c0;
        var v = m.c1;
        var w = m.c2;

        var u_sign = (<#= typ.maskType #>)(u.x.asu() & <#= typ.maskNeg #>);
        var t = <#= typ.arithCast #>(v.y + ((<#= typ.maskType #>)(w.z.asu() ^ u_sign)).asf());
        var u_mask = new <#= typ.maskType #>4((<#= typ.maskType #>)(u_sign >> <#= typeBitSize - 1 #>)).asf();
        var t_mask = new <#= typ.sigMaskType #>4((<#= typ.sigMaskType #>)(t.asi() >> <#= typeBitSize - 1 #>)).asf();

        var tr = <#= typ.arithCast #>(<#= typ.one #> + u.x.abs());

        var sign_flips =
            new <#= typ.maskType #>4(default, <#= typ.maskNeg #>, <#= typ.maskNeg #>, <#= typ.maskNeg #>).asf()
            ^ (u_mask & new <#= typ.maskType #>4(default, <#= typ.maskNeg #>, default, <#= typ.maskNeg #>).asf())
            ^ (t_mask & new <#= typ.maskType #>4(<#= typ.maskNeg #>, <#= typ.maskNeg #>, <#= typ.maskNeg #>, default).asf());

        value = new <#= vecTypeName #>(tr, u.y, w.x, v.z) + (new <#= vecTypeName #>(t, v.x, u.z, w.y) ^ sign_flips); // +---, +++-, ++-+, +-++

        value = (value & ~u_mask) | (value.zwxy & u_mask);
        value = (value.wzyx & ~t_mask) | (value & t_mask);
        value = value.normalize();
    }

    /// <summary>Constructs a unit quaternion from an orthonormal <#= matTypeName4x4 #> matrix</summary>
    /// <param name="m">The <#= matTypeName4x4 #> orthonormal rotation matrix</param>
    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#= matTypeName4x4 #> m)
    {
        var u = m.c0;
        var v = m.c1;
        var w = m.c2;

        var u_sign = (<#= typ.maskType #>)(u.x.asu() & <#= typ.maskNeg #>);
        var t = <#= typ.arithCast #>(v.y + ((<#= typ.maskType #>)(w.z.asu() ^ u_sign)).asf());
        var u_mask = new <#= typ.maskType #>4((<#= typ.maskType #>)(u_sign >> <#= typeBitSize - 1 #>)).asf();
        var t_mask = new <#= typ.sigMaskType #>4((<#= typ.sigMaskType #>)(t.asi() >> <#= typeBitSize - 1 #>)).asf();

        var tr = <#= typ.arithCast #>(<#= typ.one #> + u.x.abs());

        var sign_flips =
            new <#= typ.maskType #>4(default, <#= typ.maskNeg #>, <#= typ.maskNeg #>, <#= typ.maskNeg #>).asf()
            ^ (u_mask & new <#= typ.maskType #>4(default, <#= typ.maskNeg #>, default, <#= typ.maskNeg #>).asf())
            ^ (t_mask & new <#= typ.maskType #>4(<#= typ.maskNeg #>, <#= typ.maskNeg #>, <#= typ.maskNeg #>, default).asf());

        value = new <#= vecTypeName #>(tr, u.y, w.x, v.z) + (new <#= vecTypeName #>(t, v.x, u.z, w.y) ^ sign_flips); // +---, +++-, ++-+, +-++

        value = (value & ~u_mask) | (value.zwxy & u_mask);
        value = (value.wzyx & ~t_mask) | (value & t_mask);
        value = value.normalize();
    }

    /// <summary>
    /// Returns a quaternion representing a rotation around a unit axis by an angle in radians
    /// The rotation direction is clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="axis">The axis of rotation</param>
    /// <param name="angle">The angle of rotation in radians</param>
    /// <returns>The quaternion representing a rotation around an axis</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> AxisAngle(<#= vecTypeName3 #> axis, <#= typ.compType #> angle)
    {
        math.sincos(<#= typ.arithCast #>(<#= typ.half #> * angle), out var sina, out var cosa);
        return new(new <#= vecTypeName #>(axis * sina, cosa));
    }
}

#endregion // <#= typeName #>
<#
    }
#>
