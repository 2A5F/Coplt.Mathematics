// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region float2

public partial struct float2
{
    [MethodImpl(256 | 512)]
    public static float2 operator +(float2 a) => a;
    [MethodImpl(256 | 512)]
    public static float2 operator -(float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new(-a.x, -a.y);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 operator +(float2 a, float2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x + b.x), (float)(a.y + b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 operator -(float2 a, float2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x - b.x), (float)(a.y - b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 operator *(float2 a, float2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x * b.x), (float)(a.y * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 operator *(float a, float2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a * b.x), (float)(a * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 operator *(float2 a, float b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x * b), (float)(a.y * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 operator /(float2 a, float2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x / b.x), (float)(a.y / b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 operator /(float2 a, float b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x / b), (float)(a.y / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 operator %(float2 a, float2 b)
    {
        return new((float)(a.x % b.x), (float)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static float2 operator %(float2 a, float b)
    {
        return new((float)(a.x % b), (float)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static float2 operator --(float2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static float2 operator ++(float2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float2 abs(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 sign(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignFloat(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign());
        #endif // NET8_0_OR_GREATER
    }
}

#endregion // float2

#region float3

public partial struct float3
{
    [MethodImpl(256 | 512)]
    public static float3 operator +(float3 a) => a;
    [MethodImpl(256 | 512)]
    public static float3 operator -(float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new(-a.x, -a.y, -a.z);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 operator +(float3 a, float3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x + b.x), (float)(a.y + b.y), (float)(a.z + b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 operator -(float3 a, float3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x - b.x), (float)(a.y - b.y), (float)(a.z - b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 operator *(float3 a, float3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x * b.x), (float)(a.y * b.y), (float)(a.z * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 operator *(float a, float3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a * b.x), (float)(a * b.y), (float)(a * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 operator *(float3 a, float b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x * b), (float)(a.y * b), (float)(a.z * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 operator /(float3 a, float3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x / b.x), (float)(a.y / b.y), (float)(a.z / b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 operator /(float3 a, float b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x / b), (float)(a.y / b), (float)(a.z / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 operator %(float3 a, float3 b)
    {
        return new((float)(a.x % b.x), (float)(a.y % b.y), (float)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static float3 operator %(float3 a, float b)
    {
        return new((float)(a.x % b), (float)(a.y % b), (float)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static float3 operator --(float3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static float3 operator ++(float3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float3 abs(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 sign(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignFloat(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign());
        #endif // NET8_0_OR_GREATER
    }
}

#endregion // float3

#region float4

public partial struct float4
{
    [MethodImpl(256 | 512)]
    public static float4 operator +(float4 a) => a;
    [MethodImpl(256 | 512)]
    public static float4 operator -(float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new(-a.x, -a.y, -a.z, -a.w);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 operator +(float4 a, float4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x + b.x), (float)(a.y + b.y), (float)(a.z + b.z), (float)(a.w + b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 operator -(float4 a, float4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x - b.x), (float)(a.y - b.y), (float)(a.z - b.z), (float)(a.w - b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 operator *(float4 a, float4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x * b.x), (float)(a.y * b.y), (float)(a.z * b.z), (float)(a.w * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 operator *(float a, float4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a * b.x), (float)(a * b.y), (float)(a * b.z), (float)(a * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 operator *(float4 a, float b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x * b), (float)(a.y * b), (float)(a.z * b), (float)(a.w * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 operator /(float4 a, float4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x / b.x), (float)(a.y / b.y), (float)(a.z / b.z), (float)(a.w / b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 operator /(float4 a, float b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x / b), (float)(a.y / b), (float)(a.z / b), (float)(a.w / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 operator %(float4 a, float4 b)
    {
        return new((float)(a.x % b.x), (float)(a.y % b.y), (float)(a.z % b.z), (float)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static float4 operator %(float4 a, float b)
    {
        return new((float)(a.x % b), (float)(a.y % b), (float)(a.z % b), (float)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static float4 operator --(float4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static float4 operator ++(float4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float4 abs(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 sign(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignFloat(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
        #endif // NET8_0_OR_GREATER
    }
}

#endregion // float4

#region double2

public partial struct double2
{
    [MethodImpl(256 | 512)]
    public static double2 operator +(double2 a) => a;
    [MethodImpl(256 | 512)]
    public static double2 operator -(double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new(-a.x, -a.y);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 operator +(double2 a, double2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x + b.x), (double)(a.y + b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 operator -(double2 a, double2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x - b.x), (double)(a.y - b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 operator *(double2 a, double2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x * b.x), (double)(a.y * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 operator *(double a, double2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a * b.x), (double)(a * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 operator *(double2 a, double b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x * b), (double)(a.y * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 operator /(double2 a, double2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x / b.x), (double)(a.y / b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 operator /(double2 a, double b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x / b), (double)(a.y / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 operator %(double2 a, double2 b)
    {
        return new((double)(a.x % b.x), (double)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static double2 operator %(double2 a, double b)
    {
        return new((double)(a.x % b), (double)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static double2 operator --(double2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static double2 operator ++(double2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double2 abs(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 sign(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignFloat(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign());
        #endif // NET8_0_OR_GREATER
    }
}

#endregion // double2

#region double3

public partial struct double3
{
    [MethodImpl(256 | 512)]
    public static double3 operator +(double3 a) => a;
    [MethodImpl(256 | 512)]
    public static double3 operator -(double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new(-a.x, -a.y, -a.z);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 operator +(double3 a, double3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x + b.x), (double)(a.y + b.y), (double)(a.z + b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 operator -(double3 a, double3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x - b.x), (double)(a.y - b.y), (double)(a.z - b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 operator *(double3 a, double3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x * b.x), (double)(a.y * b.y), (double)(a.z * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 operator *(double a, double3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a * b.x), (double)(a * b.y), (double)(a * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 operator *(double3 a, double b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x * b), (double)(a.y * b), (double)(a.z * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 operator /(double3 a, double3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x / b.x), (double)(a.y / b.y), (double)(a.z / b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 operator /(double3 a, double b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x / b), (double)(a.y / b), (double)(a.z / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 operator %(double3 a, double3 b)
    {
        return new((double)(a.x % b.x), (double)(a.y % b.y), (double)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static double3 operator %(double3 a, double b)
    {
        return new((double)(a.x % b), (double)(a.y % b), (double)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static double3 operator --(double3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static double3 operator ++(double3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double3 abs(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 sign(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignFloat(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign());
        #endif // NET8_0_OR_GREATER
    }
}

#endregion // double3

#region double4

public partial struct double4
{
    [MethodImpl(256 | 512)]
    public static double4 operator +(double4 a) => a;
    [MethodImpl(256 | 512)]
    public static double4 operator -(double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new(-a.x, -a.y, -a.z, -a.w);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 operator +(double4 a, double4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x + b.x), (double)(a.y + b.y), (double)(a.z + b.z), (double)(a.w + b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 operator -(double4 a, double4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x - b.x), (double)(a.y - b.y), (double)(a.z - b.z), (double)(a.w - b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 operator *(double4 a, double4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x * b.x), (double)(a.y * b.y), (double)(a.z * b.z), (double)(a.w * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 operator *(double a, double4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a * b.x), (double)(a * b.y), (double)(a * b.z), (double)(a * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 operator *(double4 a, double b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x * b), (double)(a.y * b), (double)(a.z * b), (double)(a.w * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 operator /(double4 a, double4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x / b.x), (double)(a.y / b.y), (double)(a.z / b.z), (double)(a.w / b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 operator /(double4 a, double b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x / b), (double)(a.y / b), (double)(a.z / b), (double)(a.w / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 operator %(double4 a, double4 b)
    {
        return new((double)(a.x % b.x), (double)(a.y % b.y), (double)(a.z % b.z), (double)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static double4 operator %(double4 a, double b)
    {
        return new((double)(a.x % b), (double)(a.y % b), (double)(a.z % b), (double)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static double4 operator --(double4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static double4 operator ++(double4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double4 abs(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 sign(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignFloat(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
        #endif // NET8_0_OR_GREATER
    }
}

#endregion // double4

#region int2

public partial struct int2
{
    [MethodImpl(256 | 512)]
    public static int2 operator +(int2 a) => a;
    [MethodImpl(256 | 512)]
    public static int2 operator -(int2 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new(-a.x, -a.y);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 operator +(int2 a, int2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x + b.x), (int)(a.y + b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 operator -(int2 a, int2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x - b.x), (int)(a.y - b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 operator *(int2 a, int2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x * b.x), (int)(a.y * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 operator *(int a, int2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a * b.x), (int)(a * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 operator *(int2 a, int b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x * b), (int)(a.y * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 operator /(int2 a, int2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x / b.x), (int)(a.y / b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 operator /(int2 a, int b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x / b), (int)(a.y / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 operator %(int2 a, int2 b)
    {
        return new((int)(a.x % b.x), (int)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static int2 operator %(int2 a, int b)
    {
        return new((int)(a.x % b), (int)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static int2 operator --(int2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static int2 operator ++(int2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int2 abs(this int2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 sign(this int2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignInt(a.vector)); 
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign());
        #endif // NET8_0_OR_GREATER
    }
}

#endregion // int2

#region int3

public partial struct int3
{
    [MethodImpl(256 | 512)]
    public static int3 operator +(int3 a) => a;
    [MethodImpl(256 | 512)]
    public static int3 operator -(int3 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new(-a.x, -a.y, -a.z);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 operator +(int3 a, int3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x + b.x), (int)(a.y + b.y), (int)(a.z + b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 operator -(int3 a, int3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x - b.x), (int)(a.y - b.y), (int)(a.z - b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 operator *(int3 a, int3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x * b.x), (int)(a.y * b.y), (int)(a.z * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 operator *(int a, int3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a * b.x), (int)(a * b.y), (int)(a * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 operator *(int3 a, int b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x * b), (int)(a.y * b), (int)(a.z * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 operator /(int3 a, int3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x / b.x), (int)(a.y / b.y), (int)(a.z / b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 operator /(int3 a, int b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x / b), (int)(a.y / b), (int)(a.z / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 operator %(int3 a, int3 b)
    {
        return new((int)(a.x % b.x), (int)(a.y % b.y), (int)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static int3 operator %(int3 a, int b)
    {
        return new((int)(a.x % b), (int)(a.y % b), (int)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static int3 operator --(int3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static int3 operator ++(int3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int3 abs(this int3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 sign(this int3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignInt(a.vector)); 
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign());
        #endif // NET8_0_OR_GREATER
    }
}

#endregion // int3

#region int4

public partial struct int4
{
    [MethodImpl(256 | 512)]
    public static int4 operator +(int4 a) => a;
    [MethodImpl(256 | 512)]
    public static int4 operator -(int4 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new(-a.x, -a.y, -a.z, -a.w);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 operator +(int4 a, int4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x + b.x), (int)(a.y + b.y), (int)(a.z + b.z), (int)(a.w + b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 operator -(int4 a, int4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x - b.x), (int)(a.y - b.y), (int)(a.z - b.z), (int)(a.w - b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 operator *(int4 a, int4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x * b.x), (int)(a.y * b.y), (int)(a.z * b.z), (int)(a.w * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 operator *(int a, int4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a * b.x), (int)(a * b.y), (int)(a * b.z), (int)(a * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 operator *(int4 a, int b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x * b), (int)(a.y * b), (int)(a.z * b), (int)(a.w * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 operator /(int4 a, int4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x / b.x), (int)(a.y / b.y), (int)(a.z / b.z), (int)(a.w / b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 operator /(int4 a, int b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x / b), (int)(a.y / b), (int)(a.z / b), (int)(a.w / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 operator %(int4 a, int4 b)
    {
        return new((int)(a.x % b.x), (int)(a.y % b.y), (int)(a.z % b.z), (int)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static int4 operator %(int4 a, int b)
    {
        return new((int)(a.x % b), (int)(a.y % b), (int)(a.z % b), (int)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static int4 operator --(int4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static int4 operator ++(int4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int4 abs(this int4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 sign(this int4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignInt(a.vector)); 
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
        #endif // NET8_0_OR_GREATER
    }
}

#endregion // int4

#region uint2

public partial struct uint2
{
    [MethodImpl(256 | 512)]
    public static uint2 operator +(uint2 a) => a;

    [MethodImpl(256 | 512)]
    public static uint2 operator +(uint2 a, uint2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x + b.x), (uint)(a.y + b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator -(uint2 a, uint2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x - b.x), (uint)(a.y - b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator *(uint2 a, uint2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x * b.x), (uint)(a.y * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator *(uint a, uint2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a * b.x), (uint)(a * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator *(uint2 a, uint b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x * b), (uint)(a.y * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator /(uint2 a, uint2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x / b.x), (uint)(a.y / b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator /(uint2 a, uint b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x / b), (uint)(a.y / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator %(uint2 a, uint2 b)
    {
        return new((uint)(a.x % b.x), (uint)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator %(uint2 a, uint b)
    {
        return new((uint)(a.x % b), (uint)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator --(uint2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static uint2 operator ++(uint2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint2 abs(this uint2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 sign(this uint2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignUInt(a.vector)); 
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign());
        #endif // NET8_0_OR_GREATER
    }
}

#endregion // uint2

#region uint3

public partial struct uint3
{
    [MethodImpl(256 | 512)]
    public static uint3 operator +(uint3 a) => a;

    [MethodImpl(256 | 512)]
    public static uint3 operator +(uint3 a, uint3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x + b.x), (uint)(a.y + b.y), (uint)(a.z + b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator -(uint3 a, uint3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x - b.x), (uint)(a.y - b.y), (uint)(a.z - b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator *(uint3 a, uint3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x * b.x), (uint)(a.y * b.y), (uint)(a.z * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator *(uint a, uint3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a * b.x), (uint)(a * b.y), (uint)(a * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator *(uint3 a, uint b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x * b), (uint)(a.y * b), (uint)(a.z * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator /(uint3 a, uint3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x / b.x), (uint)(a.y / b.y), (uint)(a.z / b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator /(uint3 a, uint b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x / b), (uint)(a.y / b), (uint)(a.z / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator %(uint3 a, uint3 b)
    {
        return new((uint)(a.x % b.x), (uint)(a.y % b.y), (uint)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator %(uint3 a, uint b)
    {
        return new((uint)(a.x % b), (uint)(a.y % b), (uint)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator --(uint3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static uint3 operator ++(uint3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint3 abs(this uint3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 sign(this uint3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignUInt(a.vector)); 
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign());
        #endif // NET8_0_OR_GREATER
    }
}

#endregion // uint3

#region uint4

public partial struct uint4
{
    [MethodImpl(256 | 512)]
    public static uint4 operator +(uint4 a) => a;

    [MethodImpl(256 | 512)]
    public static uint4 operator +(uint4 a, uint4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x + b.x), (uint)(a.y + b.y), (uint)(a.z + b.z), (uint)(a.w + b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator -(uint4 a, uint4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x - b.x), (uint)(a.y - b.y), (uint)(a.z - b.z), (uint)(a.w - b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator *(uint4 a, uint4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x * b.x), (uint)(a.y * b.y), (uint)(a.z * b.z), (uint)(a.w * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator *(uint a, uint4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a * b.x), (uint)(a * b.y), (uint)(a * b.z), (uint)(a * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator *(uint4 a, uint b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x * b), (uint)(a.y * b), (uint)(a.z * b), (uint)(a.w * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator /(uint4 a, uint4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x / b.x), (uint)(a.y / b.y), (uint)(a.z / b.z), (uint)(a.w / b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator /(uint4 a, uint b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x / b), (uint)(a.y / b), (uint)(a.z / b), (uint)(a.w / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator %(uint4 a, uint4 b)
    {
        return new((uint)(a.x % b.x), (uint)(a.y % b.y), (uint)(a.z % b.z), (uint)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator %(uint4 a, uint b)
    {
        return new((uint)(a.x % b), (uint)(a.y % b), (uint)(a.z % b), (uint)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator --(uint4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static uint4 operator ++(uint4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint4 abs(this uint4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 sign(this uint4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignUInt(a.vector)); 
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
        #endif // NET8_0_OR_GREATER
    }
}

#endregion // uint4

#region long2

public partial struct long2
{
    [MethodImpl(256 | 512)]
    public static long2 operator +(long2 a) => a;
    [MethodImpl(256 | 512)]
    public static long2 operator -(long2 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new(-a.x, -a.y);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 operator +(long2 a, long2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x + b.x), (long)(a.y + b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 operator -(long2 a, long2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x - b.x), (long)(a.y - b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 operator *(long2 a, long2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x * b.x), (long)(a.y * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 operator *(long a, long2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a * b.x), (long)(a * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 operator *(long2 a, long b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x * b), (long)(a.y * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 operator /(long2 a, long2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x / b.x), (long)(a.y / b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 operator /(long2 a, long b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x / b), (long)(a.y / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 operator %(long2 a, long2 b)
    {
        return new((long)(a.x % b.x), (long)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static long2 operator %(long2 a, long b)
    {
        return new((long)(a.x % b), (long)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static long2 operator --(long2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static long2 operator ++(long2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long2 abs(this long2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 sign(this long2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignInt(a.vector)); 
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign());
        #endif // NET8_0_OR_GREATER
    }
}

#endregion // long2

#region long3

public partial struct long3
{
    [MethodImpl(256 | 512)]
    public static long3 operator +(long3 a) => a;
    [MethodImpl(256 | 512)]
    public static long3 operator -(long3 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new(-a.x, -a.y, -a.z);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 operator +(long3 a, long3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x + b.x), (long)(a.y + b.y), (long)(a.z + b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 operator -(long3 a, long3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x - b.x), (long)(a.y - b.y), (long)(a.z - b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 operator *(long3 a, long3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x * b.x), (long)(a.y * b.y), (long)(a.z * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 operator *(long a, long3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a * b.x), (long)(a * b.y), (long)(a * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 operator *(long3 a, long b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x * b), (long)(a.y * b), (long)(a.z * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 operator /(long3 a, long3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x / b.x), (long)(a.y / b.y), (long)(a.z / b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 operator /(long3 a, long b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x / b), (long)(a.y / b), (long)(a.z / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 operator %(long3 a, long3 b)
    {
        return new((long)(a.x % b.x), (long)(a.y % b.y), (long)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static long3 operator %(long3 a, long b)
    {
        return new((long)(a.x % b), (long)(a.y % b), (long)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static long3 operator --(long3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static long3 operator ++(long3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long3 abs(this long3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 sign(this long3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignInt(a.vector)); 
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign());
        #endif // NET8_0_OR_GREATER
    }
}

#endregion // long3

#region long4

public partial struct long4
{
    [MethodImpl(256 | 512)]
    public static long4 operator +(long4 a) => a;
    [MethodImpl(256 | 512)]
    public static long4 operator -(long4 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new(-a.x, -a.y, -a.z, -a.w);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 operator +(long4 a, long4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x + b.x), (long)(a.y + b.y), (long)(a.z + b.z), (long)(a.w + b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 operator -(long4 a, long4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x - b.x), (long)(a.y - b.y), (long)(a.z - b.z), (long)(a.w - b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 operator *(long4 a, long4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x * b.x), (long)(a.y * b.y), (long)(a.z * b.z), (long)(a.w * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 operator *(long a, long4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a * b.x), (long)(a * b.y), (long)(a * b.z), (long)(a * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 operator *(long4 a, long b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x * b), (long)(a.y * b), (long)(a.z * b), (long)(a.w * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 operator /(long4 a, long4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x / b.x), (long)(a.y / b.y), (long)(a.z / b.z), (long)(a.w / b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 operator /(long4 a, long b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x / b), (long)(a.y / b), (long)(a.z / b), (long)(a.w / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 operator %(long4 a, long4 b)
    {
        return new((long)(a.x % b.x), (long)(a.y % b.y), (long)(a.z % b.z), (long)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static long4 operator %(long4 a, long b)
    {
        return new((long)(a.x % b), (long)(a.y % b), (long)(a.z % b), (long)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static long4 operator --(long4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static long4 operator ++(long4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long4 abs(this long4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 sign(this long4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignInt(a.vector)); 
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
        #endif // NET8_0_OR_GREATER
    }
}

#endregion // long4

#region ulong2

public partial struct ulong2
{
    [MethodImpl(256 | 512)]
    public static ulong2 operator +(ulong2 a) => a;

    [MethodImpl(256 | 512)]
    public static ulong2 operator +(ulong2 a, ulong2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x + b.x), (ulong)(a.y + b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator -(ulong2 a, ulong2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x - b.x), (ulong)(a.y - b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator *(ulong2 a, ulong2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x * b.x), (ulong)(a.y * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator *(ulong a, ulong2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a * b.x), (ulong)(a * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator *(ulong2 a, ulong b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x * b), (ulong)(a.y * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator /(ulong2 a, ulong2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x / b.x), (ulong)(a.y / b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator /(ulong2 a, ulong b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x / b), (ulong)(a.y / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator %(ulong2 a, ulong2 b)
    {
        return new((ulong)(a.x % b.x), (ulong)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator %(ulong2 a, ulong b)
    {
        return new((ulong)(a.x % b), (ulong)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator --(ulong2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ulong2 operator ++(ulong2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong2 abs(this ulong2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 sign(this ulong2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignUInt(a.vector)); 
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign());
        #endif // NET8_0_OR_GREATER
    }
}

#endregion // ulong2

#region ulong3

public partial struct ulong3
{
    [MethodImpl(256 | 512)]
    public static ulong3 operator +(ulong3 a) => a;

    [MethodImpl(256 | 512)]
    public static ulong3 operator +(ulong3 a, ulong3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x + b.x), (ulong)(a.y + b.y), (ulong)(a.z + b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator -(ulong3 a, ulong3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x - b.x), (ulong)(a.y - b.y), (ulong)(a.z - b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator *(ulong3 a, ulong3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x * b.x), (ulong)(a.y * b.y), (ulong)(a.z * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator *(ulong a, ulong3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a * b.x), (ulong)(a * b.y), (ulong)(a * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator *(ulong3 a, ulong b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x * b), (ulong)(a.y * b), (ulong)(a.z * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator /(ulong3 a, ulong3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x / b.x), (ulong)(a.y / b.y), (ulong)(a.z / b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator /(ulong3 a, ulong b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x / b), (ulong)(a.y / b), (ulong)(a.z / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator %(ulong3 a, ulong3 b)
    {
        return new((ulong)(a.x % b.x), (ulong)(a.y % b.y), (ulong)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator %(ulong3 a, ulong b)
    {
        return new((ulong)(a.x % b), (ulong)(a.y % b), (ulong)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator --(ulong3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ulong3 operator ++(ulong3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong3 abs(this ulong3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 sign(this ulong3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignUInt(a.vector)); 
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign());
        #endif // NET8_0_OR_GREATER
    }
}

#endregion // ulong3

#region ulong4

public partial struct ulong4
{
    [MethodImpl(256 | 512)]
    public static ulong4 operator +(ulong4 a) => a;

    [MethodImpl(256 | 512)]
    public static ulong4 operator +(ulong4 a, ulong4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x + b.x), (ulong)(a.y + b.y), (ulong)(a.z + b.z), (ulong)(a.w + b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator -(ulong4 a, ulong4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x - b.x), (ulong)(a.y - b.y), (ulong)(a.z - b.z), (ulong)(a.w - b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator *(ulong4 a, ulong4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x * b.x), (ulong)(a.y * b.y), (ulong)(a.z * b.z), (ulong)(a.w * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator *(ulong a, ulong4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a * b.x), (ulong)(a * b.y), (ulong)(a * b.z), (ulong)(a * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator *(ulong4 a, ulong b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x * b), (ulong)(a.y * b), (ulong)(a.z * b), (ulong)(a.w * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator /(ulong4 a, ulong4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x / b.x), (ulong)(a.y / b.y), (ulong)(a.z / b.z), (ulong)(a.w / b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator /(ulong4 a, ulong b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x / b), (ulong)(a.y / b), (ulong)(a.z / b), (ulong)(a.w / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator %(ulong4 a, ulong4 b)
    {
        return new((ulong)(a.x % b.x), (ulong)(a.y % b.y), (ulong)(a.z % b.z), (ulong)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator %(ulong4 a, ulong b)
    {
        return new((ulong)(a.x % b), (ulong)(a.y % b), (ulong)(a.z % b), (ulong)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator --(ulong4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ulong4 operator ++(ulong4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong4 abs(this ulong4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 sign(this ulong4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignUInt(a.vector)); 
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
        #endif // NET8_0_OR_GREATER
    }
}

#endregion // ulong4

#region decimal2

public partial struct decimal2
{
    [MethodImpl(256 | 512)]
    public static decimal2 operator +(decimal2 a) => a;
    [MethodImpl(256 | 512)]
    public static decimal2 operator -(decimal2 a)
    {
        return new(-a.x, -a.y);
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator +(decimal2 a, decimal2 b)
    {
        return new((decimal)(a.x + b.x), (decimal)(a.y + b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator -(decimal2 a, decimal2 b)
    {
        return new((decimal)(a.x - b.x), (decimal)(a.y - b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator *(decimal2 a, decimal2 b)
    {
        return new((decimal)(a.x * b.x), (decimal)(a.y * b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator *(decimal a, decimal2 b)
    {
        return new((decimal)(a * b.x), (decimal)(a * b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator *(decimal2 a, decimal b)
    {
        return new((decimal)(a.x * b), (decimal)(a.y * b));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator /(decimal2 a, decimal2 b)
    {
        return new((decimal)(a.x / b.x), (decimal)(a.y / b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator /(decimal2 a, decimal b)
    {
        return new((decimal)(a.x / b), (decimal)(a.y / b));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator %(decimal2 a, decimal2 b)
    {
        return new((decimal)(a.x % b.x), (decimal)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator %(decimal2 a, decimal b)
    {
        return new((decimal)(a.x % b), (decimal)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator --(decimal2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static decimal2 operator ++(decimal2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static decimal2 abs(this decimal2 a)
    {
        return new(a.x.abs(), a.y.abs());
    }

    [MethodImpl(256 | 512)]
    public static decimal2 sign(this decimal2 a)
    {
        return new(a.x.sign(), a.y.sign());
    }
}

#endregion // decimal2

#region decimal3

public partial struct decimal3
{
    [MethodImpl(256 | 512)]
    public static decimal3 operator +(decimal3 a) => a;
    [MethodImpl(256 | 512)]
    public static decimal3 operator -(decimal3 a)
    {
        return new(-a.x, -a.y, -a.z);
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator +(decimal3 a, decimal3 b)
    {
        return new((decimal)(a.x + b.x), (decimal)(a.y + b.y), (decimal)(a.z + b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator -(decimal3 a, decimal3 b)
    {
        return new((decimal)(a.x - b.x), (decimal)(a.y - b.y), (decimal)(a.z - b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator *(decimal3 a, decimal3 b)
    {
        return new((decimal)(a.x * b.x), (decimal)(a.y * b.y), (decimal)(a.z * b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator *(decimal a, decimal3 b)
    {
        return new((decimal)(a * b.x), (decimal)(a * b.y), (decimal)(a * b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator *(decimal3 a, decimal b)
    {
        return new((decimal)(a.x * b), (decimal)(a.y * b), (decimal)(a.z * b));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator /(decimal3 a, decimal3 b)
    {
        return new((decimal)(a.x / b.x), (decimal)(a.y / b.y), (decimal)(a.z / b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator /(decimal3 a, decimal b)
    {
        return new((decimal)(a.x / b), (decimal)(a.y / b), (decimal)(a.z / b));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator %(decimal3 a, decimal3 b)
    {
        return new((decimal)(a.x % b.x), (decimal)(a.y % b.y), (decimal)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator %(decimal3 a, decimal b)
    {
        return new((decimal)(a.x % b), (decimal)(a.y % b), (decimal)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator --(decimal3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static decimal3 operator ++(decimal3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static decimal3 abs(this decimal3 a)
    {
        return new(a.x.abs(), a.y.abs(), a.z.abs());
    }

    [MethodImpl(256 | 512)]
    public static decimal3 sign(this decimal3 a)
    {
        return new(a.x.sign(), a.y.sign(), a.z.sign());
    }
}

#endregion // decimal3

#region decimal4

public partial struct decimal4
{
    [MethodImpl(256 | 512)]
    public static decimal4 operator +(decimal4 a) => a;
    [MethodImpl(256 | 512)]
    public static decimal4 operator -(decimal4 a)
    {
        return new(-a.x, -a.y, -a.z, -a.w);
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator +(decimal4 a, decimal4 b)
    {
        return new((decimal)(a.x + b.x), (decimal)(a.y + b.y), (decimal)(a.z + b.z), (decimal)(a.w + b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator -(decimal4 a, decimal4 b)
    {
        return new((decimal)(a.x - b.x), (decimal)(a.y - b.y), (decimal)(a.z - b.z), (decimal)(a.w - b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator *(decimal4 a, decimal4 b)
    {
        return new((decimal)(a.x * b.x), (decimal)(a.y * b.y), (decimal)(a.z * b.z), (decimal)(a.w * b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator *(decimal a, decimal4 b)
    {
        return new((decimal)(a * b.x), (decimal)(a * b.y), (decimal)(a * b.z), (decimal)(a * b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator *(decimal4 a, decimal b)
    {
        return new((decimal)(a.x * b), (decimal)(a.y * b), (decimal)(a.z * b), (decimal)(a.w * b));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator /(decimal4 a, decimal4 b)
    {
        return new((decimal)(a.x / b.x), (decimal)(a.y / b.y), (decimal)(a.z / b.z), (decimal)(a.w / b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator /(decimal4 a, decimal b)
    {
        return new((decimal)(a.x / b), (decimal)(a.y / b), (decimal)(a.z / b), (decimal)(a.w / b));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator %(decimal4 a, decimal4 b)
    {
        return new((decimal)(a.x % b.x), (decimal)(a.y % b.y), (decimal)(a.z % b.z), (decimal)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator %(decimal4 a, decimal b)
    {
        return new((decimal)(a.x % b), (decimal)(a.y % b), (decimal)(a.z % b), (decimal)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator --(decimal4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static decimal4 operator ++(decimal4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static decimal4 abs(this decimal4 a)
    {
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
    }

    [MethodImpl(256 | 512)]
    public static decimal4 sign(this decimal4 a)
    {
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
    }
}

#endregion // decimal4

#region half2

public partial struct half2
{
    [MethodImpl(256 | 512)]
    public static half2 operator +(half2 a) => a;
    [MethodImpl(256 | 512)]
    public static half2 operator -(half2 a)
    {
        return new(-a.x, -a.y);
    }

    [MethodImpl(256 | 512)]
    public static half2 operator +(half2 a, half2 b)
    {
        return new((half)(a.x + b.x), (half)(a.y + b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator -(half2 a, half2 b)
    {
        return new((half)(a.x - b.x), (half)(a.y - b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator *(half2 a, half2 b)
    {
        return new((half)(a.x * b.x), (half)(a.y * b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator *(half a, half2 b)
    {
        return new((half)(a * b.x), (half)(a * b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator *(half2 a, half b)
    {
        return new((half)(a.x * b), (half)(a.y * b));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator /(half2 a, half2 b)
    {
        return new((half)(a.x / b.x), (half)(a.y / b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator /(half2 a, half b)
    {
        return new((half)(a.x / b), (half)(a.y / b));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator %(half2 a, half2 b)
    {
        return new((half)(a.x % b.x), (half)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator %(half2 a, half b)
    {
        return new((half)(a.x % b), (half)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator --(half2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static half2 operator ++(half2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half2 abs(this half2 a)
    {
        return new(a.x.abs(), a.y.abs());
    }

    [MethodImpl(256 | 512)]
    public static half2 sign(this half2 a)
    {
        return new(a.x.sign(), a.y.sign());
    }
}

#endregion // half2

#region half3

public partial struct half3
{
    [MethodImpl(256 | 512)]
    public static half3 operator +(half3 a) => a;
    [MethodImpl(256 | 512)]
    public static half3 operator -(half3 a)
    {
        return new(-a.x, -a.y, -a.z);
    }

    [MethodImpl(256 | 512)]
    public static half3 operator +(half3 a, half3 b)
    {
        return new((half)(a.x + b.x), (half)(a.y + b.y), (half)(a.z + b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator -(half3 a, half3 b)
    {
        return new((half)(a.x - b.x), (half)(a.y - b.y), (half)(a.z - b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator *(half3 a, half3 b)
    {
        return new((half)(a.x * b.x), (half)(a.y * b.y), (half)(a.z * b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator *(half a, half3 b)
    {
        return new((half)(a * b.x), (half)(a * b.y), (half)(a * b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator *(half3 a, half b)
    {
        return new((half)(a.x * b), (half)(a.y * b), (half)(a.z * b));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator /(half3 a, half3 b)
    {
        return new((half)(a.x / b.x), (half)(a.y / b.y), (half)(a.z / b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator /(half3 a, half b)
    {
        return new((half)(a.x / b), (half)(a.y / b), (half)(a.z / b));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator %(half3 a, half3 b)
    {
        return new((half)(a.x % b.x), (half)(a.y % b.y), (half)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator %(half3 a, half b)
    {
        return new((half)(a.x % b), (half)(a.y % b), (half)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator --(half3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static half3 operator ++(half3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half3 abs(this half3 a)
    {
        return new(a.x.abs(), a.y.abs(), a.z.abs());
    }

    [MethodImpl(256 | 512)]
    public static half3 sign(this half3 a)
    {
        return new(a.x.sign(), a.y.sign(), a.z.sign());
    }
}

#endregion // half3

#region half4

public partial struct half4
{
    [MethodImpl(256 | 512)]
    public static half4 operator +(half4 a) => a;
    [MethodImpl(256 | 512)]
    public static half4 operator -(half4 a)
    {
        return new(-a.x, -a.y, -a.z, -a.w);
    }

    [MethodImpl(256 | 512)]
    public static half4 operator +(half4 a, half4 b)
    {
        return new((half)(a.x + b.x), (half)(a.y + b.y), (half)(a.z + b.z), (half)(a.w + b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator -(half4 a, half4 b)
    {
        return new((half)(a.x - b.x), (half)(a.y - b.y), (half)(a.z - b.z), (half)(a.w - b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator *(half4 a, half4 b)
    {
        return new((half)(a.x * b.x), (half)(a.y * b.y), (half)(a.z * b.z), (half)(a.w * b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator *(half a, half4 b)
    {
        return new((half)(a * b.x), (half)(a * b.y), (half)(a * b.z), (half)(a * b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator *(half4 a, half b)
    {
        return new((half)(a.x * b), (half)(a.y * b), (half)(a.z * b), (half)(a.w * b));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator /(half4 a, half4 b)
    {
        return new((half)(a.x / b.x), (half)(a.y / b.y), (half)(a.z / b.z), (half)(a.w / b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator /(half4 a, half b)
    {
        return new((half)(a.x / b), (half)(a.y / b), (half)(a.z / b), (half)(a.w / b));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator %(half4 a, half4 b)
    {
        return new((half)(a.x % b.x), (half)(a.y % b.y), (half)(a.z % b.z), (half)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator %(half4 a, half b)
    {
        return new((half)(a.x % b), (half)(a.y % b), (half)(a.z % b), (half)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator --(half4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static half4 operator ++(half4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half4 abs(this half4 a)
    {
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
    }

    [MethodImpl(256 | 512)]
    public static half4 sign(this half4 a)
    {
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
    }
}

#endregion // half4
