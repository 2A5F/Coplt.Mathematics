// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region float2

public partial struct float2
{
    [MethodImpl(256 | 512)]
    public static float2 operator +(float2 a) => a;
    [MethodImpl(256 | 512)]
    public static float2 operator -(float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new(-a.x, -a.y);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 operator +(float2 a, float2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x + b.x), (float)(a.y + b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 operator -(float2 a, float2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x - b.x), (float)(a.y - b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 operator *(float2 a, float2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x * b.x), (float)(a.y * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 operator *(float a, float2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a * b.x), (float)(a * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 operator *(float2 a, float b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x * b), (float)(a.y * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 operator /(float2 a, float2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x / b.x), (float)(a.y / b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 operator /(float2 a, float b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x / b), (float)(a.y / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 operator %(float2 a, float2 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Mod(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new((float)(a.x % b.x), (float)(a.y % b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 operator %(float2 a, float b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Mod(a.vector, b));
        #else // NET8_0_OR_GREATER
        return new((float)(a.x % b), (float)(a.y % b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 operator --(float2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static float2 operator ++(float2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float2 abs(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 sign(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignFloat(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 min(this float2 a, float2 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 max(this float2 a, float2 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 clamp(this float2 v, float2 min, float2 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Max(min.vector, Vector64.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float dot(this float2 a, float2 b)
    {
        #if NET8_0_OR_GREATER
        return Vector64.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (float)(a.x * b.x + a.y * b.y);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float lengthsq(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return Vector64.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float distancesq(this float2 a, float2 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static float2 square(this float2 a) => a * a;
}

#endregion // float2

#region float3

public partial struct float3
{
    [MethodImpl(256 | 512)]
    public static float3 operator +(float3 a) => a;
    [MethodImpl(256 | 512)]
    public static float3 operator -(float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new(-a.x, -a.y, -a.z);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 operator +(float3 a, float3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x + b.x), (float)(a.y + b.y), (float)(a.z + b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 operator -(float3 a, float3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x - b.x), (float)(a.y - b.y), (float)(a.z - b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 operator *(float3 a, float3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x * b.x), (float)(a.y * b.y), (float)(a.z * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 operator *(float a, float3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a * b.x), (float)(a * b.y), (float)(a * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 operator *(float3 a, float b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x * b), (float)(a.y * b), (float)(a.z * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 operator /(float3 a, float3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x / b.x), (float)(a.y / b.y), (float)(a.z / b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 operator /(float3 a, float b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x / b), (float)(a.y / b), (float)(a.z / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 operator %(float3 a, float3 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Mod(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new((float)(a.x % b.x), (float)(a.y % b.y), (float)(a.z % b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 operator %(float3 a, float b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Mod(a.vector, b));
        #else // NET8_0_OR_GREATER
        return new((float)(a.x % b), (float)(a.y % b), (float)(a.z % b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 operator --(float3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static float3 operator ++(float3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float3 abs(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 sign(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignFloat(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 min(this float3 a, float3 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 max(this float3 a, float3 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 clamp(this float3 v, float3 min, float3 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(min.vector, Vector128.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float dot(this float3 a, float3 b)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (float)(a.x * b.x + a.y * b.y + a.z * b.z);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 cross(this float3 a, float3 b) => (a * b.yzx - a.yzx * b).yzx;

    [MethodImpl(256 | 512)]
    public static float lengthsq(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float distancesq(this float3 a, float3 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static float3 square(this float3 a) => a * a;
}

#endregion // float3

#region float4

public partial struct float4
{
    [MethodImpl(256 | 512)]
    public static float4 operator +(float4 a) => a;
    [MethodImpl(256 | 512)]
    public static float4 operator -(float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new(-a.x, -a.y, -a.z, -a.w);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 operator +(float4 a, float4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x + b.x), (float)(a.y + b.y), (float)(a.z + b.z), (float)(a.w + b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 operator -(float4 a, float4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x - b.x), (float)(a.y - b.y), (float)(a.z - b.z), (float)(a.w - b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 operator *(float4 a, float4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x * b.x), (float)(a.y * b.y), (float)(a.z * b.z), (float)(a.w * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 operator *(float a, float4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a * b.x), (float)(a * b.y), (float)(a * b.z), (float)(a * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 operator *(float4 a, float b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x * b), (float)(a.y * b), (float)(a.z * b), (float)(a.w * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 operator /(float4 a, float4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x / b.x), (float)(a.y / b.y), (float)(a.z / b.z), (float)(a.w / b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 operator /(float4 a, float b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x / b), (float)(a.y / b), (float)(a.z / b), (float)(a.w / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 operator %(float4 a, float4 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Mod(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new((float)(a.x % b.x), (float)(a.y % b.y), (float)(a.z % b.z), (float)(a.w % b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 operator %(float4 a, float b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Mod(a.vector, b));
        #else // NET8_0_OR_GREATER
        return new((float)(a.x % b), (float)(a.y % b), (float)(a.z % b), (float)(a.w % b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 operator --(float4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static float4 operator ++(float4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float4 abs(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 sign(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignFloat(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 min(this float4 a, float4 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z), a.w.min(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 max(this float4 a, float4 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z), a.w.max(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 clamp(this float4 v, float4 min, float4 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(min.vector, Vector128.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z), v.w.clamp(min.w, max.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float dot(this float4 a, float4 b)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (float)(a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float lengthsq(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float distancesq(this float4 a, float4 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static float4 square(this float4 a) => a * a;
}

#endregion // float4

#region double2

public partial struct double2
{
    [MethodImpl(256 | 512)]
    public static double2 operator +(double2 a) => a;
    [MethodImpl(256 | 512)]
    public static double2 operator -(double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new(-a.x, -a.y);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 operator +(double2 a, double2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x + b.x), (double)(a.y + b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 operator -(double2 a, double2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x - b.x), (double)(a.y - b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 operator *(double2 a, double2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x * b.x), (double)(a.y * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 operator *(double a, double2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a * b.x), (double)(a * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 operator *(double2 a, double b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x * b), (double)(a.y * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 operator /(double2 a, double2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x / b.x), (double)(a.y / b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 operator /(double2 a, double b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x / b), (double)(a.y / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 operator %(double2 a, double2 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Mod(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new((double)(a.x % b.x), (double)(a.y % b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 operator %(double2 a, double b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Mod(a.vector, b));
        #else // NET8_0_OR_GREATER
        return new((double)(a.x % b), (double)(a.y % b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 operator --(double2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static double2 operator ++(double2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double2 abs(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 sign(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignFloat(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 min(this double2 a, double2 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 max(this double2 a, double2 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 clamp(this double2 v, double2 min, double2 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(min.vector, Vector128.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double dot(this double2 a, double2 b)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (double)(a.x * b.x + a.y * b.y);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double lengthsq(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double distancesq(this double2 a, double2 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static double2 square(this double2 a) => a * a;
}

#endregion // double2

#region double3

public partial struct double3
{
    [MethodImpl(256 | 512)]
    public static double3 operator +(double3 a) => a;
    [MethodImpl(256 | 512)]
    public static double3 operator -(double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new(-a.x, -a.y, -a.z);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 operator +(double3 a, double3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x + b.x), (double)(a.y + b.y), (double)(a.z + b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 operator -(double3 a, double3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x - b.x), (double)(a.y - b.y), (double)(a.z - b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 operator *(double3 a, double3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x * b.x), (double)(a.y * b.y), (double)(a.z * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 operator *(double a, double3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a * b.x), (double)(a * b.y), (double)(a * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 operator *(double3 a, double b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x * b), (double)(a.y * b), (double)(a.z * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 operator /(double3 a, double3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x / b.x), (double)(a.y / b.y), (double)(a.z / b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 operator /(double3 a, double b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x / b), (double)(a.y / b), (double)(a.z / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 operator %(double3 a, double3 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Mod(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new((double)(a.x % b.x), (double)(a.y % b.y), (double)(a.z % b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 operator %(double3 a, double b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Mod(a.vector, b));
        #else // NET8_0_OR_GREATER
        return new((double)(a.x % b), (double)(a.y % b), (double)(a.z % b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 operator --(double3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static double3 operator ++(double3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double3 abs(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 sign(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignFloat(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 min(this double3 a, double3 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 max(this double3 a, double3 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 clamp(this double3 v, double3 min, double3 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Max(min.vector, Vector256.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double dot(this double3 a, double3 b)
    {
        #if NET8_0_OR_GREATER
        return Vector256.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (double)(a.x * b.x + a.y * b.y + a.z * b.z);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 cross(this double3 a, double3 b) => (a * b.yzx - a.yzx * b).yzx;

    [MethodImpl(256 | 512)]
    public static double lengthsq(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return Vector256.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double distancesq(this double3 a, double3 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static double3 square(this double3 a) => a * a;
}

#endregion // double3

#region double4

public partial struct double4
{
    [MethodImpl(256 | 512)]
    public static double4 operator +(double4 a) => a;
    [MethodImpl(256 | 512)]
    public static double4 operator -(double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new(-a.x, -a.y, -a.z, -a.w);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 operator +(double4 a, double4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x + b.x), (double)(a.y + b.y), (double)(a.z + b.z), (double)(a.w + b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 operator -(double4 a, double4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x - b.x), (double)(a.y - b.y), (double)(a.z - b.z), (double)(a.w - b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 operator *(double4 a, double4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x * b.x), (double)(a.y * b.y), (double)(a.z * b.z), (double)(a.w * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 operator *(double a, double4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a * b.x), (double)(a * b.y), (double)(a * b.z), (double)(a * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 operator *(double4 a, double b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x * b), (double)(a.y * b), (double)(a.z * b), (double)(a.w * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 operator /(double4 a, double4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x / b.x), (double)(a.y / b.y), (double)(a.z / b.z), (double)(a.w / b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 operator /(double4 a, double b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x / b), (double)(a.y / b), (double)(a.z / b), (double)(a.w / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 operator %(double4 a, double4 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Mod(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new((double)(a.x % b.x), (double)(a.y % b.y), (double)(a.z % b.z), (double)(a.w % b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 operator %(double4 a, double b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Mod(a.vector, b));
        #else // NET8_0_OR_GREATER
        return new((double)(a.x % b), (double)(a.y % b), (double)(a.z % b), (double)(a.w % b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 operator --(double4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static double4 operator ++(double4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double4 abs(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 sign(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignFloat(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 min(this double4 a, double4 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z), a.w.min(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 max(this double4 a, double4 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z), a.w.max(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 clamp(this double4 v, double4 min, double4 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Max(min.vector, Vector256.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z), v.w.clamp(min.w, max.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double dot(this double4 a, double4 b)
    {
        #if NET8_0_OR_GREATER
        return Vector256.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (double)(a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double lengthsq(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return Vector256.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double distancesq(this double4 a, double4 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static double4 square(this double4 a) => a * a;
}

#endregion // double4

#region int2

public partial struct int2
{
    [MethodImpl(256 | 512)]
    public static int2 operator +(int2 a) => a;
    [MethodImpl(256 | 512)]
    public static int2 operator -(int2 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new(-a.x, -a.y);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 operator +(int2 a, int2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x + b.x), (int)(a.y + b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 operator -(int2 a, int2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x - b.x), (int)(a.y - b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 operator *(int2 a, int2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x * b.x), (int)(a.y * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 operator *(int a, int2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a * b.x), (int)(a * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 operator *(int2 a, int b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x * b), (int)(a.y * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 operator /(int2 a, int2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x / b.x), (int)(a.y / b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 operator /(int2 a, int b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x / b), (int)(a.y / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 operator %(int2 a, int2 b)
    {
        return new((int)(a.x % b.x), (int)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static int2 operator %(int2 a, int b)
    {
        return new((int)(a.x % b), (int)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static int2 operator --(int2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static int2 operator ++(int2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int2 abs(this int2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 sign(this int2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignInt(a.vector)); 
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 min(this int2 a, int2 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 max(this int2 a, int2 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 clamp(this int2 v, int2 min, int2 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Max(min.vector, Vector64.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int dot(this int2 a, int2 b)
    {
        #if NET8_0_OR_GREATER
        return Vector64.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (int)(a.x * b.x + a.y * b.y);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int lengthsq(this int2 a)
    {
        #if NET8_0_OR_GREATER
        return Vector64.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int distancesq(this int2 a, int2 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static int2 square(this int2 a) => a * a;
}

#endregion // int2

#region int3

public partial struct int3
{
    [MethodImpl(256 | 512)]
    public static int3 operator +(int3 a) => a;
    [MethodImpl(256 | 512)]
    public static int3 operator -(int3 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new(-a.x, -a.y, -a.z);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 operator +(int3 a, int3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x + b.x), (int)(a.y + b.y), (int)(a.z + b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 operator -(int3 a, int3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x - b.x), (int)(a.y - b.y), (int)(a.z - b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 operator *(int3 a, int3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x * b.x), (int)(a.y * b.y), (int)(a.z * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 operator *(int a, int3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a * b.x), (int)(a * b.y), (int)(a * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 operator *(int3 a, int b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x * b), (int)(a.y * b), (int)(a.z * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 operator /(int3 a, int3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x / b.x), (int)(a.y / b.y), (int)(a.z / b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 operator /(int3 a, int b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x / b), (int)(a.y / b), (int)(a.z / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 operator %(int3 a, int3 b)
    {
        return new((int)(a.x % b.x), (int)(a.y % b.y), (int)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static int3 operator %(int3 a, int b)
    {
        return new((int)(a.x % b), (int)(a.y % b), (int)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static int3 operator --(int3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static int3 operator ++(int3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int3 abs(this int3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 sign(this int3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignInt(a.vector)); 
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 min(this int3 a, int3 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 max(this int3 a, int3 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 clamp(this int3 v, int3 min, int3 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(min.vector, Vector128.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int dot(this int3 a, int3 b)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (int)(a.x * b.x + a.y * b.y + a.z * b.z);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 cross(this int3 a, int3 b) => (a * b.yzx - a.yzx * b).yzx;

    [MethodImpl(256 | 512)]
    public static int lengthsq(this int3 a)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int distancesq(this int3 a, int3 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static int3 square(this int3 a) => a * a;
}

#endregion // int3

#region int4

public partial struct int4
{
    [MethodImpl(256 | 512)]
    public static int4 operator +(int4 a) => a;
    [MethodImpl(256 | 512)]
    public static int4 operator -(int4 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new(-a.x, -a.y, -a.z, -a.w);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 operator +(int4 a, int4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x + b.x), (int)(a.y + b.y), (int)(a.z + b.z), (int)(a.w + b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 operator -(int4 a, int4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x - b.x), (int)(a.y - b.y), (int)(a.z - b.z), (int)(a.w - b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 operator *(int4 a, int4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x * b.x), (int)(a.y * b.y), (int)(a.z * b.z), (int)(a.w * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 operator *(int a, int4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a * b.x), (int)(a * b.y), (int)(a * b.z), (int)(a * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 operator *(int4 a, int b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x * b), (int)(a.y * b), (int)(a.z * b), (int)(a.w * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 operator /(int4 a, int4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x / b.x), (int)(a.y / b.y), (int)(a.z / b.z), (int)(a.w / b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 operator /(int4 a, int b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x / b), (int)(a.y / b), (int)(a.z / b), (int)(a.w / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 operator %(int4 a, int4 b)
    {
        return new((int)(a.x % b.x), (int)(a.y % b.y), (int)(a.z % b.z), (int)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static int4 operator %(int4 a, int b)
    {
        return new((int)(a.x % b), (int)(a.y % b), (int)(a.z % b), (int)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static int4 operator --(int4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static int4 operator ++(int4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int4 abs(this int4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 sign(this int4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignInt(a.vector)); 
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 min(this int4 a, int4 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z), a.w.min(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 max(this int4 a, int4 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z), a.w.max(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 clamp(this int4 v, int4 min, int4 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(min.vector, Vector128.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z), v.w.clamp(min.w, max.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int dot(this int4 a, int4 b)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (int)(a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int lengthsq(this int4 a)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int distancesq(this int4 a, int4 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static int4 square(this int4 a) => a * a;
}

#endregion // int4

#region uint2

public partial struct uint2
{
    [MethodImpl(256 | 512)]
    public static uint2 operator +(uint2 a) => a;

    [MethodImpl(256 | 512)]
    public static uint2 operator +(uint2 a, uint2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x + b.x), (uint)(a.y + b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator -(uint2 a, uint2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x - b.x), (uint)(a.y - b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator *(uint2 a, uint2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x * b.x), (uint)(a.y * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator *(uint a, uint2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a * b.x), (uint)(a * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator *(uint2 a, uint b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x * b), (uint)(a.y * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator /(uint2 a, uint2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x / b.x), (uint)(a.y / b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator /(uint2 a, uint b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x / b), (uint)(a.y / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator %(uint2 a, uint2 b)
    {
        return new((uint)(a.x % b.x), (uint)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator %(uint2 a, uint b)
    {
        return new((uint)(a.x % b), (uint)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator --(uint2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static uint2 operator ++(uint2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint2 abs(this uint2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 sign(this uint2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignUInt(a.vector)); 
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 min(this uint2 a, uint2 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 max(this uint2 a, uint2 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 clamp(this uint2 v, uint2 min, uint2 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Max(min.vector, Vector64.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint dot(this uint2 a, uint2 b)
    {
        #if NET8_0_OR_GREATER
        return Vector64.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (uint)(a.x * b.x + a.y * b.y);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint lengthsq(this uint2 a)
    {
        #if NET8_0_OR_GREATER
        return Vector64.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint distancesq(this uint2 a, uint2 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static uint2 square(this uint2 a) => a * a;
}

#endregion // uint2

#region uint3

public partial struct uint3
{
    [MethodImpl(256 | 512)]
    public static uint3 operator +(uint3 a) => a;

    [MethodImpl(256 | 512)]
    public static uint3 operator +(uint3 a, uint3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x + b.x), (uint)(a.y + b.y), (uint)(a.z + b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator -(uint3 a, uint3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x - b.x), (uint)(a.y - b.y), (uint)(a.z - b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator *(uint3 a, uint3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x * b.x), (uint)(a.y * b.y), (uint)(a.z * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator *(uint a, uint3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a * b.x), (uint)(a * b.y), (uint)(a * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator *(uint3 a, uint b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x * b), (uint)(a.y * b), (uint)(a.z * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator /(uint3 a, uint3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x / b.x), (uint)(a.y / b.y), (uint)(a.z / b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator /(uint3 a, uint b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x / b), (uint)(a.y / b), (uint)(a.z / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator %(uint3 a, uint3 b)
    {
        return new((uint)(a.x % b.x), (uint)(a.y % b.y), (uint)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator %(uint3 a, uint b)
    {
        return new((uint)(a.x % b), (uint)(a.y % b), (uint)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator --(uint3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static uint3 operator ++(uint3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint3 abs(this uint3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 sign(this uint3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignUInt(a.vector)); 
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 min(this uint3 a, uint3 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 max(this uint3 a, uint3 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 clamp(this uint3 v, uint3 min, uint3 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(min.vector, Vector128.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint dot(this uint3 a, uint3 b)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (uint)(a.x * b.x + a.y * b.y + a.z * b.z);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 cross(this uint3 a, uint3 b) => (a * b.yzx - a.yzx * b).yzx;

    [MethodImpl(256 | 512)]
    public static uint lengthsq(this uint3 a)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint distancesq(this uint3 a, uint3 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static uint3 square(this uint3 a) => a * a;
}

#endregion // uint3

#region uint4

public partial struct uint4
{
    [MethodImpl(256 | 512)]
    public static uint4 operator +(uint4 a) => a;

    [MethodImpl(256 | 512)]
    public static uint4 operator +(uint4 a, uint4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x + b.x), (uint)(a.y + b.y), (uint)(a.z + b.z), (uint)(a.w + b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator -(uint4 a, uint4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x - b.x), (uint)(a.y - b.y), (uint)(a.z - b.z), (uint)(a.w - b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator *(uint4 a, uint4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x * b.x), (uint)(a.y * b.y), (uint)(a.z * b.z), (uint)(a.w * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator *(uint a, uint4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a * b.x), (uint)(a * b.y), (uint)(a * b.z), (uint)(a * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator *(uint4 a, uint b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x * b), (uint)(a.y * b), (uint)(a.z * b), (uint)(a.w * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator /(uint4 a, uint4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x / b.x), (uint)(a.y / b.y), (uint)(a.z / b.z), (uint)(a.w / b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator /(uint4 a, uint b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x / b), (uint)(a.y / b), (uint)(a.z / b), (uint)(a.w / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator %(uint4 a, uint4 b)
    {
        return new((uint)(a.x % b.x), (uint)(a.y % b.y), (uint)(a.z % b.z), (uint)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator %(uint4 a, uint b)
    {
        return new((uint)(a.x % b), (uint)(a.y % b), (uint)(a.z % b), (uint)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator --(uint4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static uint4 operator ++(uint4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint4 abs(this uint4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 sign(this uint4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignUInt(a.vector)); 
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 min(this uint4 a, uint4 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z), a.w.min(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 max(this uint4 a, uint4 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z), a.w.max(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 clamp(this uint4 v, uint4 min, uint4 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(min.vector, Vector128.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z), v.w.clamp(min.w, max.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint dot(this uint4 a, uint4 b)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (uint)(a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint lengthsq(this uint4 a)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint distancesq(this uint4 a, uint4 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static uint4 square(this uint4 a) => a * a;
}

#endregion // uint4

#region long2

public partial struct long2
{
    [MethodImpl(256 | 512)]
    public static long2 operator +(long2 a) => a;
    [MethodImpl(256 | 512)]
    public static long2 operator -(long2 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new(-a.x, -a.y);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 operator +(long2 a, long2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x + b.x), (long)(a.y + b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 operator -(long2 a, long2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x - b.x), (long)(a.y - b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 operator *(long2 a, long2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x * b.x), (long)(a.y * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 operator *(long a, long2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a * b.x), (long)(a * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 operator *(long2 a, long b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x * b), (long)(a.y * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 operator /(long2 a, long2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x / b.x), (long)(a.y / b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 operator /(long2 a, long b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x / b), (long)(a.y / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 operator %(long2 a, long2 b)
    {
        return new((long)(a.x % b.x), (long)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static long2 operator %(long2 a, long b)
    {
        return new((long)(a.x % b), (long)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static long2 operator --(long2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static long2 operator ++(long2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long2 abs(this long2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 sign(this long2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignInt(a.vector)); 
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 min(this long2 a, long2 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 max(this long2 a, long2 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 clamp(this long2 v, long2 min, long2 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(min.vector, Vector128.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long dot(this long2 a, long2 b)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (long)(a.x * b.x + a.y * b.y);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long lengthsq(this long2 a)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long distancesq(this long2 a, long2 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static long2 square(this long2 a) => a * a;
}

#endregion // long2

#region long3

public partial struct long3
{
    [MethodImpl(256 | 512)]
    public static long3 operator +(long3 a) => a;
    [MethodImpl(256 | 512)]
    public static long3 operator -(long3 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new(-a.x, -a.y, -a.z);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 operator +(long3 a, long3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x + b.x), (long)(a.y + b.y), (long)(a.z + b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 operator -(long3 a, long3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x - b.x), (long)(a.y - b.y), (long)(a.z - b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 operator *(long3 a, long3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x * b.x), (long)(a.y * b.y), (long)(a.z * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 operator *(long a, long3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a * b.x), (long)(a * b.y), (long)(a * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 operator *(long3 a, long b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x * b), (long)(a.y * b), (long)(a.z * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 operator /(long3 a, long3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x / b.x), (long)(a.y / b.y), (long)(a.z / b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 operator /(long3 a, long b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x / b), (long)(a.y / b), (long)(a.z / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 operator %(long3 a, long3 b)
    {
        return new((long)(a.x % b.x), (long)(a.y % b.y), (long)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static long3 operator %(long3 a, long b)
    {
        return new((long)(a.x % b), (long)(a.y % b), (long)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static long3 operator --(long3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static long3 operator ++(long3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long3 abs(this long3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 sign(this long3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignInt(a.vector)); 
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 min(this long3 a, long3 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 max(this long3 a, long3 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 clamp(this long3 v, long3 min, long3 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Max(min.vector, Vector256.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long dot(this long3 a, long3 b)
    {
        #if NET8_0_OR_GREATER
        return Vector256.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (long)(a.x * b.x + a.y * b.y + a.z * b.z);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 cross(this long3 a, long3 b) => (a * b.yzx - a.yzx * b).yzx;

    [MethodImpl(256 | 512)]
    public static long lengthsq(this long3 a)
    {
        #if NET8_0_OR_GREATER
        return Vector256.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long distancesq(this long3 a, long3 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static long3 square(this long3 a) => a * a;
}

#endregion // long3

#region long4

public partial struct long4
{
    [MethodImpl(256 | 512)]
    public static long4 operator +(long4 a) => a;
    [MethodImpl(256 | 512)]
    public static long4 operator -(long4 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new(-a.x, -a.y, -a.z, -a.w);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 operator +(long4 a, long4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x + b.x), (long)(a.y + b.y), (long)(a.z + b.z), (long)(a.w + b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 operator -(long4 a, long4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x - b.x), (long)(a.y - b.y), (long)(a.z - b.z), (long)(a.w - b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 operator *(long4 a, long4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x * b.x), (long)(a.y * b.y), (long)(a.z * b.z), (long)(a.w * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 operator *(long a, long4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a * b.x), (long)(a * b.y), (long)(a * b.z), (long)(a * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 operator *(long4 a, long b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x * b), (long)(a.y * b), (long)(a.z * b), (long)(a.w * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 operator /(long4 a, long4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x / b.x), (long)(a.y / b.y), (long)(a.z / b.z), (long)(a.w / b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 operator /(long4 a, long b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x / b), (long)(a.y / b), (long)(a.z / b), (long)(a.w / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 operator %(long4 a, long4 b)
    {
        return new((long)(a.x % b.x), (long)(a.y % b.y), (long)(a.z % b.z), (long)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static long4 operator %(long4 a, long b)
    {
        return new((long)(a.x % b), (long)(a.y % b), (long)(a.z % b), (long)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static long4 operator --(long4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static long4 operator ++(long4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long4 abs(this long4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 sign(this long4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignInt(a.vector)); 
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 min(this long4 a, long4 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z), a.w.min(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 max(this long4 a, long4 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z), a.w.max(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 clamp(this long4 v, long4 min, long4 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Max(min.vector, Vector256.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z), v.w.clamp(min.w, max.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long dot(this long4 a, long4 b)
    {
        #if NET8_0_OR_GREATER
        return Vector256.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (long)(a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long lengthsq(this long4 a)
    {
        #if NET8_0_OR_GREATER
        return Vector256.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long distancesq(this long4 a, long4 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static long4 square(this long4 a) => a * a;
}

#endregion // long4

#region ulong2

public partial struct ulong2
{
    [MethodImpl(256 | 512)]
    public static ulong2 operator +(ulong2 a) => a;

    [MethodImpl(256 | 512)]
    public static ulong2 operator +(ulong2 a, ulong2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x + b.x), (ulong)(a.y + b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator -(ulong2 a, ulong2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x - b.x), (ulong)(a.y - b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator *(ulong2 a, ulong2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x * b.x), (ulong)(a.y * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator *(ulong a, ulong2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a * b.x), (ulong)(a * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator *(ulong2 a, ulong b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x * b), (ulong)(a.y * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator /(ulong2 a, ulong2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x / b.x), (ulong)(a.y / b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator /(ulong2 a, ulong b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x / b), (ulong)(a.y / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator %(ulong2 a, ulong2 b)
    {
        return new((ulong)(a.x % b.x), (ulong)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator %(ulong2 a, ulong b)
    {
        return new((ulong)(a.x % b), (ulong)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator --(ulong2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ulong2 operator ++(ulong2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong2 abs(this ulong2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 sign(this ulong2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignUInt(a.vector)); 
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 min(this ulong2 a, ulong2 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 max(this ulong2 a, ulong2 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 clamp(this ulong2 v, ulong2 min, ulong2 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(min.vector, Vector128.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong dot(this ulong2 a, ulong2 b)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (ulong)(a.x * b.x + a.y * b.y);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong lengthsq(this ulong2 a)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong distancesq(this ulong2 a, ulong2 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static ulong2 square(this ulong2 a) => a * a;
}

#endregion // ulong2

#region ulong3

public partial struct ulong3
{
    [MethodImpl(256 | 512)]
    public static ulong3 operator +(ulong3 a) => a;

    [MethodImpl(256 | 512)]
    public static ulong3 operator +(ulong3 a, ulong3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x + b.x), (ulong)(a.y + b.y), (ulong)(a.z + b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator -(ulong3 a, ulong3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x - b.x), (ulong)(a.y - b.y), (ulong)(a.z - b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator *(ulong3 a, ulong3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x * b.x), (ulong)(a.y * b.y), (ulong)(a.z * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator *(ulong a, ulong3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a * b.x), (ulong)(a * b.y), (ulong)(a * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator *(ulong3 a, ulong b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x * b), (ulong)(a.y * b), (ulong)(a.z * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator /(ulong3 a, ulong3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x / b.x), (ulong)(a.y / b.y), (ulong)(a.z / b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator /(ulong3 a, ulong b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x / b), (ulong)(a.y / b), (ulong)(a.z / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator %(ulong3 a, ulong3 b)
    {
        return new((ulong)(a.x % b.x), (ulong)(a.y % b.y), (ulong)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator %(ulong3 a, ulong b)
    {
        return new((ulong)(a.x % b), (ulong)(a.y % b), (ulong)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator --(ulong3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ulong3 operator ++(ulong3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong3 abs(this ulong3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 sign(this ulong3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignUInt(a.vector)); 
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 min(this ulong3 a, ulong3 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 max(this ulong3 a, ulong3 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 clamp(this ulong3 v, ulong3 min, ulong3 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Max(min.vector, Vector256.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong dot(this ulong3 a, ulong3 b)
    {
        #if NET8_0_OR_GREATER
        return Vector256.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (ulong)(a.x * b.x + a.y * b.y + a.z * b.z);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 cross(this ulong3 a, ulong3 b) => (a * b.yzx - a.yzx * b).yzx;

    [MethodImpl(256 | 512)]
    public static ulong lengthsq(this ulong3 a)
    {
        #if NET8_0_OR_GREATER
        return Vector256.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong distancesq(this ulong3 a, ulong3 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static ulong3 square(this ulong3 a) => a * a;
}

#endregion // ulong3

#region ulong4

public partial struct ulong4
{
    [MethodImpl(256 | 512)]
    public static ulong4 operator +(ulong4 a) => a;

    [MethodImpl(256 | 512)]
    public static ulong4 operator +(ulong4 a, ulong4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x + b.x), (ulong)(a.y + b.y), (ulong)(a.z + b.z), (ulong)(a.w + b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator -(ulong4 a, ulong4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x - b.x), (ulong)(a.y - b.y), (ulong)(a.z - b.z), (ulong)(a.w - b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator *(ulong4 a, ulong4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x * b.x), (ulong)(a.y * b.y), (ulong)(a.z * b.z), (ulong)(a.w * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator *(ulong a, ulong4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a * b.x), (ulong)(a * b.y), (ulong)(a * b.z), (ulong)(a * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator *(ulong4 a, ulong b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x * b), (ulong)(a.y * b), (ulong)(a.z * b), (ulong)(a.w * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator /(ulong4 a, ulong4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x / b.x), (ulong)(a.y / b.y), (ulong)(a.z / b.z), (ulong)(a.w / b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator /(ulong4 a, ulong b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector / b);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x / b), (ulong)(a.y / b), (ulong)(a.z / b), (ulong)(a.w / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator %(ulong4 a, ulong4 b)
    {
        return new((ulong)(a.x % b.x), (ulong)(a.y % b.y), (ulong)(a.z % b.z), (ulong)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator %(ulong4 a, ulong b)
    {
        return new((ulong)(a.x % b), (ulong)(a.y % b), (ulong)(a.z % b), (ulong)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator --(ulong4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ulong4 operator ++(ulong4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong4 abs(this ulong4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 sign(this ulong4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignUInt(a.vector)); 
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 min(this ulong4 a, ulong4 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z), a.w.min(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 max(this ulong4 a, ulong4 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z), a.w.max(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 clamp(this ulong4 v, ulong4 min, ulong4 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Max(min.vector, Vector256.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z), v.w.clamp(min.w, max.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong dot(this ulong4 a, ulong4 b)
    {
        #if NET8_0_OR_GREATER
        return Vector256.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (ulong)(a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong lengthsq(this ulong4 a)
    {
        #if NET8_0_OR_GREATER
        return Vector256.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong distancesq(this ulong4 a, ulong4 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static ulong4 square(this ulong4 a) => a * a;
}

#endregion // ulong4

#region decimal2

public partial struct decimal2
{
    [MethodImpl(256 | 512)]
    public static decimal2 operator +(decimal2 a) => a;
    [MethodImpl(256 | 512)]
    public static decimal2 operator -(decimal2 a)
    {
        return new(-a.x, -a.y);
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator +(decimal2 a, decimal2 b)
    {
        return new((decimal)(a.x + b.x), (decimal)(a.y + b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator -(decimal2 a, decimal2 b)
    {
        return new((decimal)(a.x - b.x), (decimal)(a.y - b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator *(decimal2 a, decimal2 b)
    {
        return new((decimal)(a.x * b.x), (decimal)(a.y * b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator *(decimal a, decimal2 b)
    {
        return new((decimal)(a * b.x), (decimal)(a * b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator *(decimal2 a, decimal b)
    {
        return new((decimal)(a.x * b), (decimal)(a.y * b));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator /(decimal2 a, decimal2 b)
    {
        return new((decimal)(a.x / b.x), (decimal)(a.y / b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator /(decimal2 a, decimal b)
    {
        return new((decimal)(a.x / b), (decimal)(a.y / b));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator %(decimal2 a, decimal2 b)
    {
        return new((decimal)(a.x % b.x), (decimal)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator %(decimal2 a, decimal b)
    {
        return new((decimal)(a.x % b), (decimal)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator --(decimal2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static decimal2 operator ++(decimal2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static decimal2 abs(this decimal2 a)
    {
        return new(a.x.abs(), a.y.abs());
    }

    [MethodImpl(256 | 512)]
    public static decimal2 sign(this decimal2 a)
    {
        return new(a.x.sign(), a.y.sign());
    }

    [MethodImpl(256 | 512)]
    public static decimal2 min(this decimal2 a, decimal2 b)
    {
        return new(a.x.min(b.x), a.y.min(b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 max(this decimal2 a, decimal2 b)
    {
        return new(a.x.max(b.x), a.y.max(b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 clamp(this decimal2 v, decimal2 min, decimal2 max)
    {
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal dot(this decimal2 a, decimal2 b)
    {
        return (decimal)(a.x * b.x + a.y * b.y);
    }

    [MethodImpl(256 | 512)]
    public static decimal lengthsq(this decimal2 a)
    {
        return a.dot(a);
    }

    [MethodImpl(256 | 512)]
    public static decimal distancesq(this decimal2 a, decimal2 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static decimal2 square(this decimal2 a) => a * a;
}

#endregion // decimal2

#region decimal3

public partial struct decimal3
{
    [MethodImpl(256 | 512)]
    public static decimal3 operator +(decimal3 a) => a;
    [MethodImpl(256 | 512)]
    public static decimal3 operator -(decimal3 a)
    {
        return new(-a.x, -a.y, -a.z);
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator +(decimal3 a, decimal3 b)
    {
        return new((decimal)(a.x + b.x), (decimal)(a.y + b.y), (decimal)(a.z + b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator -(decimal3 a, decimal3 b)
    {
        return new((decimal)(a.x - b.x), (decimal)(a.y - b.y), (decimal)(a.z - b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator *(decimal3 a, decimal3 b)
    {
        return new((decimal)(a.x * b.x), (decimal)(a.y * b.y), (decimal)(a.z * b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator *(decimal a, decimal3 b)
    {
        return new((decimal)(a * b.x), (decimal)(a * b.y), (decimal)(a * b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator *(decimal3 a, decimal b)
    {
        return new((decimal)(a.x * b), (decimal)(a.y * b), (decimal)(a.z * b));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator /(decimal3 a, decimal3 b)
    {
        return new((decimal)(a.x / b.x), (decimal)(a.y / b.y), (decimal)(a.z / b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator /(decimal3 a, decimal b)
    {
        return new((decimal)(a.x / b), (decimal)(a.y / b), (decimal)(a.z / b));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator %(decimal3 a, decimal3 b)
    {
        return new((decimal)(a.x % b.x), (decimal)(a.y % b.y), (decimal)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator %(decimal3 a, decimal b)
    {
        return new((decimal)(a.x % b), (decimal)(a.y % b), (decimal)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator --(decimal3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static decimal3 operator ++(decimal3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static decimal3 abs(this decimal3 a)
    {
        return new(a.x.abs(), a.y.abs(), a.z.abs());
    }

    [MethodImpl(256 | 512)]
    public static decimal3 sign(this decimal3 a)
    {
        return new(a.x.sign(), a.y.sign(), a.z.sign());
    }

    [MethodImpl(256 | 512)]
    public static decimal3 min(this decimal3 a, decimal3 b)
    {
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 max(this decimal3 a, decimal3 b)
    {
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 clamp(this decimal3 v, decimal3 min, decimal3 max)
    {
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal dot(this decimal3 a, decimal3 b)
    {
        return (decimal)(a.x * b.x + a.y * b.y + a.z * b.z);
    }

    [MethodImpl(256 | 512)]
    public static decimal3 cross(this decimal3 a, decimal3 b) => (a * b.yzx - a.yzx * b).yzx;

    [MethodImpl(256 | 512)]
    public static decimal lengthsq(this decimal3 a)
    {
        return a.dot(a);
    }

    [MethodImpl(256 | 512)]
    public static decimal distancesq(this decimal3 a, decimal3 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static decimal3 square(this decimal3 a) => a * a;
}

#endregion // decimal3

#region decimal4

public partial struct decimal4
{
    [MethodImpl(256 | 512)]
    public static decimal4 operator +(decimal4 a) => a;
    [MethodImpl(256 | 512)]
    public static decimal4 operator -(decimal4 a)
    {
        return new(-a.x, -a.y, -a.z, -a.w);
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator +(decimal4 a, decimal4 b)
    {
        return new((decimal)(a.x + b.x), (decimal)(a.y + b.y), (decimal)(a.z + b.z), (decimal)(a.w + b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator -(decimal4 a, decimal4 b)
    {
        return new((decimal)(a.x - b.x), (decimal)(a.y - b.y), (decimal)(a.z - b.z), (decimal)(a.w - b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator *(decimal4 a, decimal4 b)
    {
        return new((decimal)(a.x * b.x), (decimal)(a.y * b.y), (decimal)(a.z * b.z), (decimal)(a.w * b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator *(decimal a, decimal4 b)
    {
        return new((decimal)(a * b.x), (decimal)(a * b.y), (decimal)(a * b.z), (decimal)(a * b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator *(decimal4 a, decimal b)
    {
        return new((decimal)(a.x * b), (decimal)(a.y * b), (decimal)(a.z * b), (decimal)(a.w * b));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator /(decimal4 a, decimal4 b)
    {
        return new((decimal)(a.x / b.x), (decimal)(a.y / b.y), (decimal)(a.z / b.z), (decimal)(a.w / b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator /(decimal4 a, decimal b)
    {
        return new((decimal)(a.x / b), (decimal)(a.y / b), (decimal)(a.z / b), (decimal)(a.w / b));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator %(decimal4 a, decimal4 b)
    {
        return new((decimal)(a.x % b.x), (decimal)(a.y % b.y), (decimal)(a.z % b.z), (decimal)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator %(decimal4 a, decimal b)
    {
        return new((decimal)(a.x % b), (decimal)(a.y % b), (decimal)(a.z % b), (decimal)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator --(decimal4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static decimal4 operator ++(decimal4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static decimal4 abs(this decimal4 a)
    {
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
    }

    [MethodImpl(256 | 512)]
    public static decimal4 sign(this decimal4 a)
    {
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
    }

    [MethodImpl(256 | 512)]
    public static decimal4 min(this decimal4 a, decimal4 b)
    {
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z), a.w.min(b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 max(this decimal4 a, decimal4 b)
    {
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z), a.w.max(b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 clamp(this decimal4 v, decimal4 min, decimal4 max)
    {
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z), v.w.clamp(min.w, max.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal dot(this decimal4 a, decimal4 b)
    {
        return (decimal)(a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w);
    }

    [MethodImpl(256 | 512)]
    public static decimal lengthsq(this decimal4 a)
    {
        return a.dot(a);
    }

    [MethodImpl(256 | 512)]
    public static decimal distancesq(this decimal4 a, decimal4 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static decimal4 square(this decimal4 a) => a * a;
}

#endregion // decimal4

#region half2

public partial struct half2
{
    [MethodImpl(256 | 512)]
    public static half2 operator +(half2 a) => a;
    [MethodImpl(256 | 512)]
    public static half2 operator -(half2 a)
    {
        return new(-a.x, -a.y);
    }

    [MethodImpl(256 | 512)]
    public static half2 operator +(half2 a, half2 b)
    {
        return new((half)(a.x + b.x), (half)(a.y + b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator -(half2 a, half2 b)
    {
        return new((half)(a.x - b.x), (half)(a.y - b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator *(half2 a, half2 b)
    {
        return new((half)(a.x * b.x), (half)(a.y * b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator *(half a, half2 b)
    {
        return new((half)(a * b.x), (half)(a * b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator *(half2 a, half b)
    {
        return new((half)(a.x * b), (half)(a.y * b));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator /(half2 a, half2 b)
    {
        return new((half)(a.x / b.x), (half)(a.y / b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator /(half2 a, half b)
    {
        return new((half)(a.x / b), (half)(a.y / b));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator %(half2 a, half2 b)
    {
        return new((half)(a.x % b.x), (half)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator %(half2 a, half b)
    {
        return new((half)(a.x % b), (half)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator --(half2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static half2 operator ++(half2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half2 abs(this half2 a)
    {
        return new(a.x.abs(), a.y.abs());
    }

    [MethodImpl(256 | 512)]
    public static half2 sign(this half2 a)
    {
        return new(a.x.sign(), a.y.sign());
    }

    [MethodImpl(256 | 512)]
    public static half2 min(this half2 a, half2 b)
    {
        return new(a.x.min(b.x), a.y.min(b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 max(this half2 a, half2 b)
    {
        return new(a.x.max(b.x), a.y.max(b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 clamp(this half2 v, half2 min, half2 max)
    {
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y));
    }

    [MethodImpl(256 | 512)]
    public static half dot(this half2 a, half2 b)
    {
        return (half)(a.x * b.x + a.y * b.y);
    }

    [MethodImpl(256 | 512)]
    public static half lengthsq(this half2 a)
    {
        return a.dot(a);
    }

    [MethodImpl(256 | 512)]
    public static half distancesq(this half2 a, half2 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static half2 square(this half2 a) => a * a;
}

#endregion // half2

#region half3

public partial struct half3
{
    [MethodImpl(256 | 512)]
    public static half3 operator +(half3 a) => a;
    [MethodImpl(256 | 512)]
    public static half3 operator -(half3 a)
    {
        return new(-a.x, -a.y, -a.z);
    }

    [MethodImpl(256 | 512)]
    public static half3 operator +(half3 a, half3 b)
    {
        return new((half)(a.x + b.x), (half)(a.y + b.y), (half)(a.z + b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator -(half3 a, half3 b)
    {
        return new((half)(a.x - b.x), (half)(a.y - b.y), (half)(a.z - b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator *(half3 a, half3 b)
    {
        return new((half)(a.x * b.x), (half)(a.y * b.y), (half)(a.z * b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator *(half a, half3 b)
    {
        return new((half)(a * b.x), (half)(a * b.y), (half)(a * b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator *(half3 a, half b)
    {
        return new((half)(a.x * b), (half)(a.y * b), (half)(a.z * b));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator /(half3 a, half3 b)
    {
        return new((half)(a.x / b.x), (half)(a.y / b.y), (half)(a.z / b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator /(half3 a, half b)
    {
        return new((half)(a.x / b), (half)(a.y / b), (half)(a.z / b));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator %(half3 a, half3 b)
    {
        return new((half)(a.x % b.x), (half)(a.y % b.y), (half)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator %(half3 a, half b)
    {
        return new((half)(a.x % b), (half)(a.y % b), (half)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator --(half3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static half3 operator ++(half3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half3 abs(this half3 a)
    {
        return new(a.x.abs(), a.y.abs(), a.z.abs());
    }

    [MethodImpl(256 | 512)]
    public static half3 sign(this half3 a)
    {
        return new(a.x.sign(), a.y.sign(), a.z.sign());
    }

    [MethodImpl(256 | 512)]
    public static half3 min(this half3 a, half3 b)
    {
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 max(this half3 a, half3 b)
    {
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 clamp(this half3 v, half3 min, half3 max)
    {
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z));
    }

    [MethodImpl(256 | 512)]
    public static half dot(this half3 a, half3 b)
    {
        return (half)(a.x * b.x + a.y * b.y + a.z * b.z);
    }

    [MethodImpl(256 | 512)]
    public static half3 cross(this half3 a, half3 b) => (a * b.yzx - a.yzx * b).yzx;

    [MethodImpl(256 | 512)]
    public static half lengthsq(this half3 a)
    {
        return a.dot(a);
    }

    [MethodImpl(256 | 512)]
    public static half distancesq(this half3 a, half3 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static half3 square(this half3 a) => a * a;
}

#endregion // half3

#region half4

public partial struct half4
{
    [MethodImpl(256 | 512)]
    public static half4 operator +(half4 a) => a;
    [MethodImpl(256 | 512)]
    public static half4 operator -(half4 a)
    {
        return new(-a.x, -a.y, -a.z, -a.w);
    }

    [MethodImpl(256 | 512)]
    public static half4 operator +(half4 a, half4 b)
    {
        return new((half)(a.x + b.x), (half)(a.y + b.y), (half)(a.z + b.z), (half)(a.w + b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator -(half4 a, half4 b)
    {
        return new((half)(a.x - b.x), (half)(a.y - b.y), (half)(a.z - b.z), (half)(a.w - b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator *(half4 a, half4 b)
    {
        return new((half)(a.x * b.x), (half)(a.y * b.y), (half)(a.z * b.z), (half)(a.w * b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator *(half a, half4 b)
    {
        return new((half)(a * b.x), (half)(a * b.y), (half)(a * b.z), (half)(a * b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator *(half4 a, half b)
    {
        return new((half)(a.x * b), (half)(a.y * b), (half)(a.z * b), (half)(a.w * b));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator /(half4 a, half4 b)
    {
        return new((half)(a.x / b.x), (half)(a.y / b.y), (half)(a.z / b.z), (half)(a.w / b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator /(half4 a, half b)
    {
        return new((half)(a.x / b), (half)(a.y / b), (half)(a.z / b), (half)(a.w / b));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator %(half4 a, half4 b)
    {
        return new((half)(a.x % b.x), (half)(a.y % b.y), (half)(a.z % b.z), (half)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator %(half4 a, half b)
    {
        return new((half)(a.x % b), (half)(a.y % b), (half)(a.z % b), (half)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator --(half4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static half4 operator ++(half4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half4 abs(this half4 a)
    {
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
    }

    [MethodImpl(256 | 512)]
    public static half4 sign(this half4 a)
    {
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
    }

    [MethodImpl(256 | 512)]
    public static half4 min(this half4 a, half4 b)
    {
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z), a.w.min(b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 max(this half4 a, half4 b)
    {
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z), a.w.max(b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 clamp(this half4 v, half4 min, half4 max)
    {
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z), v.w.clamp(min.w, max.w));
    }

    [MethodImpl(256 | 512)]
    public static half dot(this half4 a, half4 b)
    {
        return (half)(a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w);
    }

    [MethodImpl(256 | 512)]
    public static half lengthsq(this half4 a)
    {
        return a.dot(a);
    }

    [MethodImpl(256 | 512)]
    public static half distancesq(this half4 a, half4 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static half4 square(this half4 a) => a * a;
}

#endregion // half4
