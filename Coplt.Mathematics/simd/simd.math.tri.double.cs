// generated by template, do not modify manually
#if NET8_0_OR_GREATER

namespace Coplt.Mathematics.Simd;

public static partial class simd_math
{
    #region Sin Cos

    #region SinCos

    [MethodImpl(256 | 512)]
    public static Vector128<f64> SinCos(Vector128<f64> x) => Sin(x + Vector128.Create(0.0, math.D_Half_PI));

    [MethodImpl(256 | 512)]
    public static Vector256<f64>SinCos(Vector256<f64> x) => Sin(x + Vector256.Create(0.0, 0.0, math.D_Half_PI, math.D_Half_PI));

    [MethodImpl(256 | 512)]
    public static Vector512<f64> SinCos(Vector512<f64> x) =>
        Sin(x + Vector512.Create(0.0, 0.0, 0.0, 0.0, math.D_Half_PI, math.D_Half_PI, math.D_Half_PI, math.D_Half_PI));

    #endregion

    #region Vector128<f64>

    [MethodImpl(256 | 512)]
    public static Vector128<f64> Cos(Vector128<f64> x) => Sin(x + Vector128.Create(math.D_Half_PI));

    [MethodImpl(256 | 512)]
    public static Vector128<f64> Sin(Vector128<f64> x)
    {
        // Since sin() is periodic around 2pi, this converts x into the range of [0, 2pi]
        var xt = Wrap0To2Pi(x);

        // Since sin() in [0, 2pi] is an odd function around pi, this converts the range to [0, pi], then stores whether or not the result needs to be negated in is_neg.
        var is_neg = Vector128.GreaterThan(xt, Vector128.Create(math.D_PI));
        xt -= is_neg & Vector128.Create(math.D_PI);

        is_neg &= Vector128.Create(-2.0);
        is_neg += Vector128<f64>.One;

        var is_nan = simd.Ne(x, x);
        is_nan += Vector128.GreaterThan(x, Vector128.Create(f64.MaxValue));
        is_nan += Vector128.LessThan(x, Vector128.Create(f64.MinValue));

        // Since sin() on [0, pi] is an even function around pi/2, this "folds" the range into [0, pi/2]. I.e. 3pi/5 becomes 2pi/5.
        xt = Vector128.Create(math.D_Half_PI) - Vector128.Abs(xt - Vector128.Create(math.D_Half_PI));

        var sq = xt * xt;
        var r = simd.Fma(sq, Vector128.Create(-0.0000000000007384998082865), Vector128.Create(0.000000000160490521296459));
        r = simd.Fma(r, sq, Vector128.Create(-0.00000002505191090496049));
        r = simd.Fma(r, sq, Vector128.Create(0.00000275573170815073144));
        r = simd.Fma(r, sq, Vector128.Create(-0.00019841269828860068271));
        r = simd.Fma(r, sq, Vector128.Create(0.008333333333299304989001));
        r = simd.Fma(r, sq, Vector128.Create(-0.166666666666663509013977));
        r = simd.Fma(r, sq, Vector128<f64>.One);

        r *= xt;

        r = simd.Fma(r, is_neg, is_nan);

        return r;
    }

    #endregion

    #region Vector256<f64>

    [MethodImpl(256 | 512)]
    public static Vector256<f64> Cos(Vector256<f64> x) => Sin(x + Vector256.Create(math.D_Half_PI));

    [MethodImpl(256 | 512)]
    public static Vector256<f64> Sin(Vector256<f64> x)
    {
        // Since sin() is periodic around 2pi, this converts x into the range of [0, 2pi]
        var xt = Wrap0To2Pi(x);

        // Since sin() in [0, 2pi] is an odd function around pi, this converts the range to [0, pi], then stores whether or not the result needs to be negated in is_neg.
        var is_neg = Vector256.GreaterThan(xt, Vector256.Create(math.D_PI));
        xt -= is_neg & Vector256.Create(math.D_PI);

        is_neg &= Vector256.Create(-2.0);
        is_neg += Vector256<f64>.One;

        var is_nan = simd.Ne(x, x);
        is_nan += Vector256.GreaterThan(x, Vector256.Create(f64.MaxValue));
        is_nan += Vector256.LessThan(x, Vector256.Create(f64.MinValue));

        // Since sin() on [0, pi] is an even function around pi/2, this "folds" the range into [0, pi/2]. I.e. 3pi/5 becomes 2pi/5.
        xt = Vector256.Create(math.D_Half_PI) - Vector256.Abs(xt - Vector256.Create(math.D_Half_PI));

        var sq = xt * xt;
        var r = simd.Fma(sq, Vector256.Create(-0.0000000000007384998082865), Vector256.Create(0.000000000160490521296459));
        r = simd.Fma(r, sq, Vector256.Create(-0.00000002505191090496049));
        r = simd.Fma(r, sq, Vector256.Create(0.00000275573170815073144));
        r = simd.Fma(r, sq, Vector256.Create(-0.00019841269828860068271));
        r = simd.Fma(r, sq, Vector256.Create(0.008333333333299304989001));
        r = simd.Fma(r, sq, Vector256.Create(-0.166666666666663509013977));
        r = simd.Fma(r, sq, Vector256<f64>.One);

        r *= xt;

        r = simd.Fma(r, is_neg, is_nan);

        return r;
    }

    #endregion

    #region Vector512<f64>

    [MethodImpl(256 | 512)]
    public static Vector512<f64> Cos(Vector512<f64> x) => Sin(x + Vector512.Create(math.D_Half_PI));

    [MethodImpl(256 | 512)]
    public static Vector512<f64> Sin(Vector512<f64> x)
    {
        // Since sin() is periodic around 2pi, this converts x into the range of [0, 2pi]
        var xt = Wrap0To2Pi(x);

        // Since sin() in [0, 2pi] is an odd function around pi, this converts the range to [0, pi], then stores whether or not the result needs to be negated in is_neg.
        var is_neg = Vector512.GreaterThan(xt, Vector512.Create(math.D_PI));
        xt -= is_neg & Vector512.Create(math.D_PI);

        is_neg &= Vector512.Create(-2.0);
        is_neg += Vector512<f64>.One;

        var is_nan = simd.Ne(x, x);
        is_nan += Vector512.GreaterThan(x, Vector512.Create(f64.MaxValue));
        is_nan += Vector512.LessThan(x, Vector512.Create(f64.MinValue));

        // Since sin() on [0, pi] is an even function around pi/2, this "folds" the range into [0, pi/2]. I.e. 3pi/5 becomes 2pi/5.
        xt = Vector512.Create(math.D_Half_PI) - Vector512.Abs(xt - Vector512.Create(math.D_Half_PI));

        var sq = xt * xt;
        var r = simd.Fma(sq, Vector512.Create(-0.0000000000007384998082865), Vector512.Create(0.000000000160490521296459));
        r = simd.Fma(r, sq, Vector512.Create(-0.00000002505191090496049));
        r = simd.Fma(r, sq, Vector512.Create(0.00000275573170815073144));
        r = simd.Fma(r, sq, Vector512.Create(-0.00019841269828860068271));
        r = simd.Fma(r, sq, Vector512.Create(0.008333333333299304989001));
        r = simd.Fma(r, sq, Vector512.Create(-0.166666666666663509013977));
        r = simd.Fma(r, sq, Vector512<f64>.One);

        r *= xt;

        r = simd.Fma(r, is_neg, is_nan);

        return r;
    }

    #endregion

    #endregion

    #region Tan

    #region Vector128<f64>

    /// <summary>
    /// Computes sines in [0,pi/4]
    /// </summary>
    [MethodImpl(512)]
    public static Vector128<f64> SinIn0P4(Vector128<f64> x) => SinIn0P4_impl(x);

    /// <summary>
    /// Computes sines in [0,pi/4]
    /// </summary>
    [MethodImpl(256 | 512)]
    public static Vector128<f64> SinIn0P4_impl(Vector128<f64> x)
    {
        var sq = x * x;

        // This is an odd-only Taylor series approximation of sin() on [0, pi/4]. 
        var r = simd.Fma(sq, Vector128.Create(0.0000000001590238118466), Vector128.Create(-0.0000000250508528135474));
        r = simd.Fma(r, sq, Vector128.Create(0.0000027557314284120030));
        r = simd.Fma(r, sq, Vector128.Create(-0.00019841269831470328245));
        r = simd.Fma(r, sq, Vector128.Create(0.008333333333324419158220));
        r = simd.Fma(r, sq, Vector128.Create(-0.1666666666666663969165095));
        r = simd.Fma(r, sq, Vector128<f64>.One);
        r *= x;

        return r;
    }

    [MethodImpl(512)]
    public static Vector128<f64> Tan(Vector128<f64> x)
    {
        // Since tan() is periodic around pi, this converts x into the range of [0, pi]
        var xt = Wrap0ToPi(x);

        // Since tan() in [0, pi] is an odd function around pi/2, this converts the range to [0, pi/2], then stores whether or not the result needs to be negated in is_neg.
        var is_neg = Vector128.GreaterThan(xt, Vector128.Create(math.D_Half_PI));
        xt += is_neg & ((xt - Vector128.Create(math.D_Half_PI)) * -2);

        is_neg &= Vector128.Create(-2.0);
        is_neg += Vector128<f64>.One;

        var is_nan = simd.Ne(x, x);
        is_nan += Vector128.GreaterThan(x, Vector128.Create(f64.MaxValue));
        is_nan += Vector128.LessThan(x, Vector128.Create(f64.MinValue));

        // Since tan() on [0, pi/2] is an inversed function around pi/4, this "folds" the range into [0, pi/4]. I.e. 3pi/10 becomes 2pi/10.
        var do_inv_mask = Vector128.GreaterThan(xt, Vector128.Create(math.D_Quarter_PI));
        var no_inv_mask = Vector128.LessThanOrEqual(xt, Vector128.Create(math.D_Quarter_PI));
        xt = Vector128.Create(math.D_Quarter_PI) - Vector128.Abs(xt - Vector128.Create(math.D_Quarter_PI));

        var xx = SinIn0P4_impl(xt);

        xt = Vector128.Sqrt(Vector128<f64>.One - xx * xx);

        xx = (do_inv_mask & (xt / xx)) + (no_inv_mask & (xx / xt));

        xx = simd.Fma(xx, is_neg, is_nan);
        return xx;
    }

    #endregion

    #region Vector256<f64>

    /// <summary>
    /// Computes sines in [0,pi/4]
    /// </summary>
    [MethodImpl(512)]
    public static Vector256<f64> SinIn0P4(Vector256<f64> x) => SinIn0P4_impl(x);

    /// <summary>
    /// Computes sines in [0,pi/4]
    /// </summary>
    [MethodImpl(256 | 512)]
    public static Vector256<f64> SinIn0P4_impl(Vector256<f64> x)
    {
        var sq = x * x;

        // This is an odd-only Taylor series approximation of sin() on [0, pi/4]. 
        var r = simd.Fma(sq, Vector256.Create(0.0000000001590238118466), Vector256.Create(-0.0000000250508528135474));
        r = simd.Fma(r, sq, Vector256.Create(0.0000027557314284120030));
        r = simd.Fma(r, sq, Vector256.Create(-0.00019841269831470328245));
        r = simd.Fma(r, sq, Vector256.Create(0.008333333333324419158220));
        r = simd.Fma(r, sq, Vector256.Create(-0.1666666666666663969165095));
        r = simd.Fma(r, sq, Vector256<f64>.One);
        r *= x;

        return r;
    }

    [MethodImpl(512)]
    public static Vector256<f64> Tan(Vector256<f64> x)
    {
        // Since tan() is periodic around pi, this converts x into the range of [0, pi]
        var xt = Wrap0ToPi(x);

        // Since tan() in [0, pi] is an odd function around pi/2, this converts the range to [0, pi/2], then stores whether or not the result needs to be negated in is_neg.
        var is_neg = Vector256.GreaterThan(xt, Vector256.Create(math.D_Half_PI));
        xt += is_neg & ((xt - Vector256.Create(math.D_Half_PI)) * -2);

        is_neg &= Vector256.Create(-2.0);
        is_neg += Vector256<f64>.One;

        var is_nan = simd.Ne(x, x);
        is_nan += Vector256.GreaterThan(x, Vector256.Create(f64.MaxValue));
        is_nan += Vector256.LessThan(x, Vector256.Create(f64.MinValue));

        // Since tan() on [0, pi/2] is an inversed function around pi/4, this "folds" the range into [0, pi/4]. I.e. 3pi/10 becomes 2pi/10.
        var do_inv_mask = Vector256.GreaterThan(xt, Vector256.Create(math.D_Quarter_PI));
        var no_inv_mask = Vector256.LessThanOrEqual(xt, Vector256.Create(math.D_Quarter_PI));
        xt = Vector256.Create(math.D_Quarter_PI) - Vector256.Abs(xt - Vector256.Create(math.D_Quarter_PI));

        var xx = SinIn0P4_impl(xt);

        xt = Vector256.Sqrt(Vector256<f64>.One - xx * xx);

        xx = (do_inv_mask & (xt / xx)) + (no_inv_mask & (xx / xt));

        xx = simd.Fma(xx, is_neg, is_nan);
        return xx;
    }

    #endregion

    #region Vector512<f64>

    /// <summary>
    /// Computes sines in [0,pi/4]
    /// </summary>
    [MethodImpl(512)]
    public static Vector512<f64> SinIn0P4(Vector512<f64> x) => SinIn0P4_impl(x);

    /// <summary>
    /// Computes sines in [0,pi/4]
    /// </summary>
    [MethodImpl(256 | 512)]
    public static Vector512<f64> SinIn0P4_impl(Vector512<f64> x)
    {
        var sq = x * x;

        // This is an odd-only Taylor series approximation of sin() on [0, pi/4]. 
        var r = simd.Fma(sq, Vector512.Create(0.0000000001590238118466), Vector512.Create(-0.0000000250508528135474));
        r = simd.Fma(r, sq, Vector512.Create(0.0000027557314284120030));
        r = simd.Fma(r, sq, Vector512.Create(-0.00019841269831470328245));
        r = simd.Fma(r, sq, Vector512.Create(0.008333333333324419158220));
        r = simd.Fma(r, sq, Vector512.Create(-0.1666666666666663969165095));
        r = simd.Fma(r, sq, Vector512<f64>.One);
        r *= x;

        return r;
    }

    [MethodImpl(512)]
    public static Vector512<f64> Tan(Vector512<f64> x)
    {
        // Since tan() is periodic around pi, this converts x into the range of [0, pi]
        var xt = Wrap0ToPi(x);

        // Since tan() in [0, pi] is an odd function around pi/2, this converts the range to [0, pi/2], then stores whether or not the result needs to be negated in is_neg.
        var is_neg = Vector512.GreaterThan(xt, Vector512.Create(math.D_Half_PI));
        xt += is_neg & ((xt - Vector512.Create(math.D_Half_PI)) * -2);

        is_neg &= Vector512.Create(-2.0);
        is_neg += Vector512<f64>.One;

        var is_nan = simd.Ne(x, x);
        is_nan += Vector512.GreaterThan(x, Vector512.Create(f64.MaxValue));
        is_nan += Vector512.LessThan(x, Vector512.Create(f64.MinValue));

        // Since tan() on [0, pi/2] is an inversed function around pi/4, this "folds" the range into [0, pi/4]. I.e. 3pi/10 becomes 2pi/10.
        var do_inv_mask = Vector512.GreaterThan(xt, Vector512.Create(math.D_Quarter_PI));
        var no_inv_mask = Vector512.LessThanOrEqual(xt, Vector512.Create(math.D_Quarter_PI));
        xt = Vector512.Create(math.D_Quarter_PI) - Vector512.Abs(xt - Vector512.Create(math.D_Quarter_PI));

        var xx = SinIn0P4_impl(xt);

        xt = Vector512.Sqrt(Vector512<f64>.One - xx * xx);

        xx = (do_inv_mask & (xt / xx)) + (no_inv_mask & (xx / xt));

        xx = simd.Fma(xx, is_neg, is_nan);
        return xx;
    }

    #endregion

    #endregion

#region Sinh Cosh Tanh

    #region Vector128<f64>

    [MethodImpl(512)]
    public static Vector128<f64> Sinh(Vector128<f64> x)
    {
        var r = Exp(x);
        var rr = Vector128<f64>.One / r;
        return (r - rr) * 0.5;
    }

    [MethodImpl(512)]
    public static Vector128<f64> Cosh(Vector128<f64> x)
    {
        var r = Exp(x);
        var rr = Vector128<f64>.One / r;
        return (r + rr) * 0.5;
    }

    [MethodImpl(512)]
    public static Vector128<f64> Tanh(Vector128<f64> x)
    {
        var r = Exp(x);
        var rr = Vector128<f64>.One / r;
        return (r - rr) / (r + rr);
    }

    #endregion

    #region Vector256<f64>

    [MethodImpl(512)]
    public static Vector256<f64> Sinh(Vector256<f64> x)
    {
        var r = Exp(x);
        var rr = Vector256<f64>.One / r;
        return (r - rr) * 0.5;
    }

    [MethodImpl(512)]
    public static Vector256<f64> Cosh(Vector256<f64> x)
    {
        var r = Exp(x);
        var rr = Vector256<f64>.One / r;
        return (r + rr) * 0.5;
    }

    [MethodImpl(512)]
    public static Vector256<f64> Tanh(Vector256<f64> x)
    {
        var r = Exp(x);
        var rr = Vector256<f64>.One / r;
        return (r - rr) / (r + rr);
    }

    #endregion

    #region Vector512<f64>

    [MethodImpl(512)]
    public static Vector512<f64> Sinh(Vector512<f64> x)
    {
        var r = Exp(x);
        var rr = Vector512<f64>.One / r;
        return (r - rr) * 0.5;
    }

    [MethodImpl(512)]
    public static Vector512<f64> Cosh(Vector512<f64> x)
    {
        var r = Exp(x);
        var rr = Vector512<f64>.One / r;
        return (r + rr) * 0.5;
    }

    [MethodImpl(512)]
    public static Vector512<f64> Tanh(Vector512<f64> x)
    {
        var r = Exp(x);
        var rr = Vector512<f64>.One / r;
        return (r - rr) / (r + rr);
    }

    #endregion

    #region SinhCosh

    [MethodImpl(512)]
    public static Vector256<f64> SinhCosh(Vector256<f64> x)
    {
        var r = Exp(x);
        var rr = Vector256<f64>.One / r;
        var rrr = simd.Fma(rr, Vector256.Create(1.0, 1.0, -1.0, -1.0), r);
        return rrr * 0.5;
    }

    [MethodImpl(512)]
    public static Vector256<f64> SinhCoshD128To256(Vector128<f64> x)
    {
        var r = Exp(x);
        var r256 = Vector256.Create(r, r);
        var rr = Vector256<f64>.One / r256;
        var rrr = simd.Fma(rr, Vector256.Create(1.0, 1.0, -1.0, -1.0), r256);
        return rrr * 0.5;
    }

    [MethodImpl(512)]
    public static Vector512<f64> SinhCosh(Vector512<f64> x)
    {
        var r = Exp(x);
        var rr = Vector512<f64>.One / r;
        var rrr = simd.Fma(rr, Vector512.Create(1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0), r);
        return rrr * 0.5;
    }

    [MethodImpl(512)]
    public static Vector512<f64> SinhCoshD256To512(Vector256<f64> x)
    {
        var r = Exp(x);
        var r512 = Vector512.Create(r, r);
        var rr = Vector512<f64>.One / r512;
        var rrr = simd.Fma(rr, Vector512.Create(1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0), r512);
        return rrr * 0.5;
    }

    #endregion

    #endregion

    #region Asinh Acosh

    #region Vector128<f64>

    [MethodImpl(256 | 512)]
    public static Vector128<f64> Asinh(Vector128<f64> x)
    {
        var r = simd.Fma(x, x, Vector128<f64>.One);
        r = Vector128.Sqrt(r);
        r += x;
        r = Log(r);
        return r;
    }

    [MethodImpl(256 | 512)]
    public static Vector128<f64> Acosh(Vector128<f64> x)
    {
        var r = simd.Fma(x, x, -Vector128<f64>.One);
        r = Vector128.Sqrt(r);
        r += x;
        r = Log(r);
        return r;
    }

    #endregion

    #region Vector256<f64>

    [MethodImpl(256 | 512)]
    public static Vector256<f64> Asinh(Vector256<f64> x)
    {
        var r = simd.Fma(x, x, Vector256<f64>.One);
        r = Vector256.Sqrt(r);
        r += x;
        r = Log(r);
        return r;
    }

    [MethodImpl(256 | 512)]
    public static Vector256<f64> Acosh(Vector256<f64> x)
    {
        var r = simd.Fma(x, x, -Vector256<f64>.One);
        r = Vector256.Sqrt(r);
        r += x;
        r = Log(r);
        return r;
    }

    #endregion

    #region Vector512<f64>

    [MethodImpl(256 | 512)]
    public static Vector512<f64> Asinh(Vector512<f64> x)
    {
        var r = simd.Fma(x, x, Vector512<f64>.One);
        r = Vector512.Sqrt(r);
        r += x;
        r = Log(r);
        return r;
    }

    [MethodImpl(256 | 512)]
    public static Vector512<f64> Acosh(Vector512<f64> x)
    {
        var r = simd.Fma(x, x, -Vector512<f64>.One);
        r = Vector512.Sqrt(r);
        r += x;
        r = Log(r);
        return r;
    }

    #endregion

    #region AsinhAcosh

    [MethodImpl(256 | 512)]
    public static Vector256<f64> AsinhAcosh(Vector256<f64> x)
    {
        var r = simd.Fma(x, x, Vector256.Create(1.0, 1.0, -1.0, -1.0));
        r = Vector256.Sqrt(r);
        r += x;
        r = Log(r);
        return r;
    }

    [MethodImpl(256 | 512)]
    public static Vector512<f64> AsinhAcosh(Vector512<f64> x)
    {
        var r = simd.Fma(x, x, Vector512.Create(1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0));
        r = Vector512.Sqrt(r);
        r += x;
        r = Log(r);
        return r;
    }

    #endregion

    #endregion
}

#endif
