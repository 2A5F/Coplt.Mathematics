<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="../types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually
#if NET8_0_OR_GREATER

namespace Coplt.Mathematics.Simd;
<#
    var type = "f64";
    var sizes = new[] { 128, 256, 512 };

    var v128 = $"Vector{128}";
    var v256 = $"Vector{256}";
    var v512 = $"Vector{512}";

    var vt128 = $"{v128}<f64>";
    var vt256 = $"{v256}<f64>";
    var vt512 = $"{v512}<f64>";
#>

public static partial class simd_math
{
    #region Sin Cos

    #region SinCos

    [MethodImpl(256 | 512)]
    public static <#= vt128 #> SinCos(<#= vt128 #> x) => Sin(x + <#= v128 #>.Create(0.0, math.D_Half_PI));

    [MethodImpl(256 | 512)]
    public static <#= vt256 #>SinCos(<#= vt256 #> x) => Sin(x + <#= v256 #>.Create(0.0, 0.0, math.D_Half_PI, math.D_Half_PI));

    [MethodImpl(256 | 512)]
    public static <#= vt512 #> SinCos(<#= vt512 #> x) =>
        Sin(x + <#= v512 #>.Create(0.0, 0.0, 0.0, 0.0, math.D_Half_PI, math.D_Half_PI, math.D_Half_PI, math.D_Half_PI));

    #endregion

<#
    foreach (var size in sizes)
    {
        var vector = $"Vector{size}";
        var vt = $"{vector}<{type}>";
#>
    #region <#= vt #>

    [MethodImpl(256 | 512)]
    public static <#= vt #> Cos(<#= vt #> x) => Sin(x + <#= vector #>.Create(math.D_Half_PI));

    [MethodImpl(256 | 512)]
    public static <#= vt #> Sin(<#= vt #> x)
    {
        // Since sin() is periodic around 2pi, this converts x into the range of [0, 2pi]
        var xt = Wrap0To2Pi(x);

        // Since sin() in [0, 2pi] is an odd function around pi, this converts the range to [0, pi], then stores whether or not the result needs to be negated in is_neg.
        var is_neg = <#= vector #>.GreaterThan(xt, <#= vector #>.Create(math.D_PI));
        xt -= is_neg & <#= vector #>.Create(math.D_PI);

        is_neg &= <#= vector #>.Create(-2.0);
        is_neg += <#= vt #>.One;

        var is_nan = simd.Ne(x, x);
        is_nan += <#= vector #>.GreaterThan(x, <#= vector #>.Create(f64.MaxValue));
        is_nan += <#= vector #>.LessThan(x, <#= vector #>.Create(f64.MinValue));

        // Since sin() on [0, pi] is an even function around pi/2, this "folds" the range into [0, pi/2]. I.e. 3pi/5 becomes 2pi/5.
        xt = <#= vector #>.Create(math.D_Half_PI) - <#= vector #>.Abs(xt - <#= vector #>.Create(math.D_Half_PI));

        var sq = xt * xt;
        var r = simd.Fma(sq, <#= vector #>.Create(-0.0000000000007384998082865), <#= vector #>.Create(0.000000000160490521296459));
        r = simd.Fma(r, sq, <#= vector #>.Create(-0.00000002505191090496049));
        r = simd.Fma(r, sq, <#= vector #>.Create(0.00000275573170815073144));
        r = simd.Fma(r, sq, <#= vector #>.Create(-0.00019841269828860068271));
        r = simd.Fma(r, sq, <#= vector #>.Create(0.008333333333299304989001));
        r = simd.Fma(r, sq, <#= vector #>.Create(-0.166666666666663509013977));
        r = simd.Fma(r, sq, <#= vt #>.One);

        r *= xt;

        r = simd.Fma(r, is_neg, is_nan);

        return r;
    }

    #endregion

<#
    }
#>
    #endregion

    #region Tan

<#
    foreach (var size in sizes)
    {
        var vector = $"Vector{size}";
        var vt = $"{vector}<{type}>";
#>
    #region <#= vt #>

    /// <summary>
    /// Computes sines in [0,pi/4]
    /// </summary>
    [MethodImpl(512)]
    public static <#= vt #> SinIn0P4(<#= vt #> x) => SinIn0P4_impl(x);

    /// <summary>
    /// Computes sines in [0,pi/4]
    /// </summary>
    [MethodImpl(256 | 512)]
    public static <#= vt #> SinIn0P4_impl(<#= vt #> x)
    {
        var sq = x * x;

        // This is an odd-only Taylor series approximation of sin() on [0, pi/4]. 
        var r = simd.Fma(sq, <#= vector #>.Create(0.0000000001590238118466), <#= vector #>.Create(-0.0000000250508528135474));
        r = simd.Fma(r, sq, <#= vector #>.Create(0.0000027557314284120030));
        r = simd.Fma(r, sq, <#= vector #>.Create(-0.00019841269831470328245));
        r = simd.Fma(r, sq, <#= vector #>.Create(0.008333333333324419158220));
        r = simd.Fma(r, sq, <#= vector #>.Create(-0.1666666666666663969165095));
        r = simd.Fma(r, sq, <#= vt #>.One);
        r *= x;

        return r;
    }

    [MethodImpl(512)]
    public static <#= vt #> Tan(<#= vt #> x)
    {
        // Since tan() is periodic around pi, this converts x into the range of [0, pi]
        var xt = Wrap0ToPi(x);

        // Since tan() in [0, pi] is an odd function around pi/2, this converts the range to [0, pi/2], then stores whether or not the result needs to be negated in is_neg.
        var is_neg = <#= vector #>.GreaterThan(xt, <#= vector #>.Create(math.D_Half_PI));
        xt += is_neg & ((xt - <#= vector #>.Create(math.D_Half_PI)) * -2);

        is_neg &= <#= vector #>.Create(-2.0);
        is_neg += <#= vt #>.One;

        var is_nan = simd.Ne(x, x);
        is_nan += <#= vector #>.GreaterThan(x, <#= vector #>.Create(f64.MaxValue));
        is_nan += <#= vector #>.LessThan(x, <#= vector #>.Create(f64.MinValue));

        // Since tan() on [0, pi/2] is an inversed function around pi/4, this "folds" the range into [0, pi/4]. I.e. 3pi/10 becomes 2pi/10.
        var do_inv_mask = <#= vector #>.GreaterThan(xt, <#= vector #>.Create(math.D_Quarter_PI));
        var no_inv_mask = <#= vector #>.LessThanOrEqual(xt, <#= vector #>.Create(math.D_Quarter_PI));
        xt = <#= vector #>.Create(math.D_Quarter_PI) - <#= vector #>.Abs(xt - <#= vector #>.Create(math.D_Quarter_PI));

        var xx = SinIn0P4_impl(xt);

        xt = <#= vector #>.Sqrt(<#= vt #>.One - xx * xx);

        xx = (do_inv_mask & (xt / xx)) + (no_inv_mask & (xx / xt));

        xx = simd.Fma(xx, is_neg, is_nan);
        return xx;
    }

    #endregion

<#
    }
#>
    #endregion

    #region Sinh Cosh Tanh

<#
    foreach (var size in sizes)
    {
        var vector = $"Vector{size}";
        var vt = $"{vector}<{type}>";
#>
    #region <#= vt #>

    [MethodImpl(512)]
    public static <#= vt #> Sinh(<#= vt #> x)
    {
        var r = Exp(x);
        var rr = <#= vt #>.One / r;
        return (r - rr) * 0.5;
    }

    [MethodImpl(512)]
    public static <#= vt #> Cosh(<#= vt #> x)
    {
        var r = Exp(x);
        var rr = <#= vt #>.One / r;
        return (r + rr) * 0.5;
    }

    [MethodImpl(512)]
    public static <#= vt #> Tanh(<#= vt #> x)
    {
        var r = Exp(x);
        var rr = <#= vt #>.One / r;
        return (r - rr) / (r + rr);
    }

    #endregion

<#
    }
#>
    #region SinhCosh

    [MethodImpl(512)]
    public static <#= vt256 #> SinhCosh(<#= vt256 #> x)
    {
        var r = Exp(x);
        var rr = <#= vt256 #>.One / r;
        var rrr = simd.Fma(rr, <#= v256 #>.Create(1.0, 1.0, -1.0, -1.0), r);
        return rrr * 0.5;
    }

    [MethodImpl(512)]
    public static <#= vt256 #> SinhCoshD128To256(<#= vt128 #> x)
    {
        var r = Exp(x);
        var r256 = <#= v256 #>.Create(r, r);
        var rr = <#= vt256 #>.One / r256;
        var rrr = simd.Fma(rr, <#= v256 #>.Create(1.0, 1.0, -1.0, -1.0), r256);
        return rrr * 0.5;
    }

    [MethodImpl(512)]
    public static <#= vt512 #> SinhCosh(<#= vt512 #> x)
    {
        var r = Exp(x);
        var rr = <#= vt512 #>.One / r;
        var rrr = simd.Fma(rr, <#= v512 #>.Create(1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0), r);
        return rrr * 0.5;
    }

    [MethodImpl(512)]
    public static <#= vt512 #> SinhCoshD256To512(<#= vt256 #> x)
    {
        var r = Exp(x);
        var r512 = <#= v512 #>.Create(r, r);
        var rr = <#= vt512 #>.One / r512;
        var rrr = simd.Fma(rr, <#= v512 #>.Create(1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0), r512);
        return rrr * 0.5;
    }

    #endregion

    #endregion

    #region Asinh Acosh

<#
    foreach (var size in sizes)
    {
        var vector = $"Vector{size}";
        var vt = $"{vector}<{type}>";
#>
    #region <#= vt #>

    [MethodImpl(512)]
    public static <#= vt #> Asinh(<#= vt #> x)
    {
        var r = simd.Fma(x, x, <#= vt #>.One);
        r = <#= vector #>.Sqrt(r);
        r += x;
        r = Log(r);
        return r;
    }

    [MethodImpl(512)]
    public static <#= vt #> Acosh(<#= vt #> x)
    {
        var r = simd.Fma(x, x, -<#= vt #>.One);
        r = <#= vector #>.Sqrt(r);
        r += x;
        r = Log(r);
        return r;
    }

    #endregion

<#
    }
#>
    #region AsinhAcosh

    [MethodImpl(512)]
    public static <#= vt256 #> AsinhAcosh(<#= vt256 #> x)
    {
        var r = simd.Fma(x, x, <#= v256 #>.Create(1.0, 1.0, -1.0, -1.0));
        r = <#= v256 #>.Sqrt(r);
        r += x;
        r = Log(r);
        return r;
    }

    [MethodImpl(512)]
    public static <#= vt512 #> AsinhAcosh(<#= vt512 #> x)
    {
        var r = simd.Fma(x, x, <#= v512 #>.Create(1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0));
        r = <#= v512 #>.Sqrt(r);
        r += x;
        r = Log(r);
        return r;
    }

    #endregion

    #endregion

    #region Asin

<#
    foreach (var size in sizes)
    {
        var vector = $"Vector{size}";
        var vt = $"{vector}<{type}>";
#>
    #region <#= vt #>

    [MethodImpl(512)]
    public static <#= vt #> Asin(<#= vt #> d)
    {
        var abs = <#= vector #>.Abs(d);
        var o = <#= vector #>.LessThan(abs, <#= vector #>.Create(0.5));
        var x2 = <#= vector #>.ConditionalSelect(o, d * d, (<#= vt #>.One - abs) * <#= vector #>.Create(0.5));
        var x = <#= vector #>.ConditionalSelect(o, abs, <#= vector #>.Sqrt(x2));

        var x4 = x2 * x2;
        var x8 = x4 * x4;
        var x16 = x8 * x8;

        var u = simd.Fma(x16,
            simd.Fma(x4,
                simd.Fma(x2, <#= vector #>.Create(+0.3161587650653934628e-1), <#= vector #>.Create(-0.1581918243329996643e-1)),
                simd.Fma(x2, <#= vector #>.Create(+0.1929045477267910674e-1), <#= vector #>.Create(+0.6606077476277170610e-2))
            ),
            simd.Fma(x8,
                simd.Fma(x4,
                    simd.Fma(x2, <#= vector #>.Create(+0.1215360525577377331e-1), <#= vector #>.Create(+0.1388715184501609218e-1)),
                    simd.Fma(x2, <#= vector #>.Create(+0.1735956991223614604e-1), <#= vector #>.Create(+0.2237176181932048341e-1))
                ),
                simd.Fma(x4,
                    simd.Fma(x2, <#= vector #>.Create(+0.3038195928038132237e-1), <#= vector #>.Create(+0.4464285681377102438e-1)),
                    simd.Fma(x2, <#= vector #>.Create(+0.7500000000378581611e-1), <#= vector #>.Create(+0.1666666666666497543e+0))
                )
            )
        );

        u = simd.Fma(u, x * x2, x);

        var r = simd.Fnma(u, <#= vector #>.Create(2.0), <#= vector #>.Create(math.D_Half_PI));
        r = <#= vector #>.ConditionalSelect(o, u, r);

        r ^= d & -<#= vt #>.Zero;
        return r;
    }

    #endregion

<#
    }
#>
    #endregion

    #region Acos

<#
    foreach (var size in sizes)
    {
        var vector = $"Vector{size}";
        var vt = $"{vector}<{type}>";
#>
    #region <#= vt #>

    [MethodImpl(512)]
    public static <#= vt #> Acos(<#= vt #> d)
    {
        var abs = <#= vector #>.Abs(d);
        var o = <#= vector #>.LessThan(abs, <#= vector #>.Create(0.5));
        var x2 = <#= vector #>.ConditionalSelect(o, d * d, (<#= vt #>.One - abs) * <#= vector #>.Create(0.5));
        var x = <#= vector #>.ConditionalSelect(o, abs, <#= vector #>.Sqrt(x2));
        x &= simd.Ne(<#= vt #>.One, abs);

        var x4 = x2 * x2;
        var x8 = x4 * x4;
        var x16 = x8 * x8;

        var u = simd.Fma(x16,
            simd.Fma(x4,
                simd.Fma(x2, <#= vector #>.Create(+0.3161587650653934628e-1), <#= vector #>.Create(-0.1581918243329996643e-1)),
                simd.Fma(x2, <#= vector #>.Create(+0.1929045477267910674e-1), <#= vector #>.Create(+0.6606077476277170610e-2))
            ),
            simd.Fma(x8,
                simd.Fma(x4,
                    simd.Fma(x2, <#= vector #>.Create(+0.1215360525577377331e-1), <#= vector #>.Create(+0.1388715184501609218e-1)),
                    simd.Fma(x2, <#= vector #>.Create(+0.1735956991223614604e-1), <#= vector #>.Create(+0.2237176181932048341e-1))
                ),
                simd.Fma(x4,
                    simd.Fma(x2, <#= vector #>.Create(+0.3038195928038132237e-1), <#= vector #>.Create(+0.4464285681377102438e-1)),
                    simd.Fma(x2, <#= vector #>.Create(+0.7500000000378581611e-1), <#= vector #>.Create(+0.1666666666666497543e+0))
                )
            )
        );
        u *= x * x2;
        
        var sign = d & -<#= vt #>.Zero;
        
        var y = <#= vector #>.Create(math.D_Half_PI) - ((x ^ sign) + (u ^ sign));
        x += u;
        var r = <#= vector #>.ConditionalSelect(o, y, x * 2);
        var c = <#= vector #>.LessThan(d, <#= vt #>.Zero) & ~o;
        r = <#= vector #>.ConditionalSelect(c, <#= vector #>.Create(math.D_PI) - r, r);
        return r;
    }

    #endregion

<#
    }
#>
    #endregion

    #region Atan

<#
    foreach (var size in sizes)
    {
        var vector = $"Vector{size}";
        var vt = $"{vector}<{type}>";
#>
    #region <#= vt #>

    [MethodImpl(512)]
    public static <#= vt #> Atan(<#= vt #> s)
    {
        var sign = s & -<#= vt #>.Zero;
        s = <#= vector #>.Abs(s);
        var is_gt_1 = <#= vector #>.GreaterThan(s, <#= vt #>.One);
        s = <#= vector #>.ConditionalSelect(is_gt_1, <#= vt #>.One / s, s);

        var t = s * s;
        var t2 = t * t;
        var t4 = t2 * t2;
        var t8 = t4 * t4;
        var t16 = t8 * t8;

        var u = simd.Fma(t16,
            simd.Fma(t2, <#= vector #>.Create(-1.88796008463073496563746e-05),
                simd.Fma(t, <#= vector #>.Create(0.000209850076645816976906797), <#= vector #>.Create(-0.00110611831486672482563471))
            ),
            simd.Fma(t8,
                simd.Fma(t4,
                    simd.Fma(t2,
                        simd.Fma(t, <#= vector #>.Create(0.00370026744188713119232403), <#= vector #>.Create(-0.00889896195887655491740809)),
                        simd.Fma(t, <#= vector #>.Create(0.016599329773529201970117), <#= vector #>.Create(-0.0254517624932312641616861))
                    ),
                    simd.Fma(t2,
                        simd.Fma(t, <#= vector #>.Create(0.0337852580001353069993897), <#= vector #>.Create(-0.0407629191276836500001934)),
                        simd.Fma(t, <#= vector #>.Create(0.0466667150077840625632675), <#= vector #>.Create(-0.0523674852303482457616113))
                    )
                ),
                simd.Fma(t4,
                    simd.Fma(t2,
                        simd.Fma(t, <#= vector #>.Create(0.0587666392926673580854313), <#= vector #>.Create(-0.0666573579361080525984562)),
                        simd.Fma(t, <#= vector #>.Create(0.0769219538311769618355029), <#= vector #>.Create(-0.090908995008245008229153))
                    ),
                    simd.Fma(t2,
                        simd.Fma(t, <#= vector #>.Create(0.111111105648261418443745), <#= vector #>.Create(-0.14285714266771329383765)),
                        simd.Fma(t, <#= vector #>.Create(0.199999999996591265594148), <#= vector #>.Create(-0.333333333333311110369124))
                    )
                )
            )
        );
        t = simd.Fma(s, t * u, s);

        t = <#= vector #>.ConditionalSelect(
            is_gt_1,
            <#= vector #>.Create(math.D_Half_PI) - t,
            t
        );
        t ^= sign;

        return t;
    }

    #endregion

<#
    }
#>
    #endregion
}

#endif
