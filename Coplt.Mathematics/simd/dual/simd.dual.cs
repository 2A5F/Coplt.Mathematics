// generated by template, do not modify manually
#if NET8_0_OR_GREATER

namespace Coplt.Mathematics.Simd.Numerics;

#region 64

[method: MethodImpl(256 | 512)]
internal struct vdual64f(Vector64<f32> x, Vector64<f32> y)
{
    public Vector64<f32> x = x;
    public Vector64<f32> y = y;

    [MethodImpl(256 | 512)]
    public static vdual64f Add(Vector64<f32> x, Vector64<f32> y)
    {
        var s = x + y;
        return new(s, x - s + y);
    }

    [MethodImpl(256 | 512)]
    public static vdual64f Mul(Vector64<f32> x, Vector64<f32> y)
    {
        var s = x * y;
        return new(s, simd.Fms(x, y, s));
    }

    [MethodImpl(256 | 512)]
    public static vdual64f OneDiv(Vector64<f32> d)
    {
        var s = Vector64<f32>.One / d;
        return new(s, simd.Fnma(d, s, Vector64<f32>.One));
    }

    [MethodImpl(256 | 512)]
    public static vdual64f Sqrt(Vector64<f32> d)
    {
        var t = Vector64.Sqrt(d);
        return (Mul(t, t).LeftAdd2(d) * OneDiv(t)).Scale(Vector64.Create(0.5f));
    }

    [MethodImpl(256 | 512)]
    public static vdual64f operator +(vdual64f x) => x;

    [MethodImpl(256 | 512)]
    public static vdual64f operator -(vdual64f x) => new(-x.x, -x.y);

    [MethodImpl(256 | 512)]
    public static vdual64f operator +(vdual64f x, vdual64f y)
    {
        var s = x.x + y.x;
        return new(s, x.x - s + y.x + x.y + y.y);
    }

    [MethodImpl(256 | 512)]
    public static vdual64f operator -(vdual64f x, vdual64f y)
    {
        var s = x.x - y.x;
        return new(s, x.x - s - y.x + x.y - y.y);
    }

    [MethodImpl(256 | 512)]
    public static vdual64f operator *(vdual64f x, vdual64f y)
    {
        var s = x.x * y.x;
        return new(s, simd.Fma(x.x, y.y, simd.Fma(x.y, y.x, simd.Fms(x.x, y.x, s))));
    }

    [MethodImpl(256 | 512)]
    public static vdual64f operator /(vdual64f n, vdual64f d)
    {
        var t = Vector64<f32>.One / d.x;
        var s = n.x * t;
        var u = simd.Fms(t, n.x, s);
        var v = simd.Fnma(d.y, t, simd.Fnma(d.x, t, Vector64<f32>.One));
        return new(s, simd.Fma(s, v, simd.Fma(n.y, t, u)));
    }

    [MethodImpl(256 | 512)]
    public vdual64f Scale(Vector64<f32> s) => new(x * s, y * s);

    [MethodImpl(256 | 512)]
    public vdual64f Normalize()
    {
        var s = x + y;
        return new(s, x - s + y);
    }

    [MethodImpl(256 | 512)]
    public vdual64f Abs() => new(Vector64.Abs(x), y ^ (x & -Vector64<f32>.Zero));

    [MethodImpl(256 | 512)]
    public vdual64f LeftAdd2(Vector64<f32> a)
    {
        var s = a + x;
        var v = s - a;
        return new(s, a - (s - v) + (x - v) + y);
    }

    [MethodImpl(256 | 512)]
    public vdual64f Add2(vdual64f a)
    {
        var s = x + a.x;
        var v = s - x;
        var t = x - (s - v) + (a.x - v);
        return new(s, t + y + a.y);
    }

    [MethodImpl(256 | 512)]
    public vdual64f Sqrt()
    {
        var t = Vector64.Sqrt(x + y);
        return (Add2(Mul(t, t)) * OneDiv(t)).Scale(Vector64.Create(0.5f));
    }
}

#endregion

#region 128

[method: MethodImpl(256 | 512)]
internal struct vdual128f(Vector128<f32> x, Vector128<f32> y)
{
    public Vector128<f32> x = x;
    public Vector128<f32> y = y;

    [MethodImpl(256 | 512)]
    public static vdual128f Add(Vector128<f32> x, Vector128<f32> y)
    {
        var s = x + y;
        return new(s, x - s + y);
    }

    [MethodImpl(256 | 512)]
    public static vdual128f Mul(Vector128<f32> x, Vector128<f32> y)
    {
        var s = x * y;
        return new(s, simd.Fms(x, y, s));
    }

    [MethodImpl(256 | 512)]
    public static vdual128f OneDiv(Vector128<f32> d)
    {
        var s = Vector128<f32>.One / d;
        return new(s, simd.Fnma(d, s, Vector128<f32>.One));
    }

    [MethodImpl(256 | 512)]
    public static vdual128f Sqrt(Vector128<f32> d)
    {
        var t = Vector128.Sqrt(d);
        return (Mul(t, t).LeftAdd2(d) * OneDiv(t)).Scale(Vector128.Create(0.5f));
    }

    [MethodImpl(256 | 512)]
    public static vdual128f operator +(vdual128f x) => x;

    [MethodImpl(256 | 512)]
    public static vdual128f operator -(vdual128f x) => new(-x.x, -x.y);

    [MethodImpl(256 | 512)]
    public static vdual128f operator +(vdual128f x, vdual128f y)
    {
        var s = x.x + y.x;
        return new(s, x.x - s + y.x + x.y + y.y);
    }

    [MethodImpl(256 | 512)]
    public static vdual128f operator -(vdual128f x, vdual128f y)
    {
        var s = x.x - y.x;
        return new(s, x.x - s - y.x + x.y - y.y);
    }

    [MethodImpl(256 | 512)]
    public static vdual128f operator *(vdual128f x, vdual128f y)
    {
        var s = x.x * y.x;
        return new(s, simd.Fma(x.x, y.y, simd.Fma(x.y, y.x, simd.Fms(x.x, y.x, s))));
    }

    [MethodImpl(256 | 512)]
    public static vdual128f operator /(vdual128f n, vdual128f d)
    {
        var t = Vector128<f32>.One / d.x;
        var s = n.x * t;
        var u = simd.Fms(t, n.x, s);
        var v = simd.Fnma(d.y, t, simd.Fnma(d.x, t, Vector128<f32>.One));
        return new(s, simd.Fma(s, v, simd.Fma(n.y, t, u)));
    }

    [MethodImpl(256 | 512)]
    public vdual128f Scale(Vector128<f32> s) => new(x * s, y * s);

    [MethodImpl(256 | 512)]
    public vdual128f Normalize()
    {
        var s = x + y;
        return new(s, x - s + y);
    }

    [MethodImpl(256 | 512)]
    public vdual128f Abs() => new(Vector128.Abs(x), y ^ (x & -Vector128<f32>.Zero));

    [MethodImpl(256 | 512)]
    public vdual128f LeftAdd2(Vector128<f32> a)
    {
        var s = a + x;
        var v = s - a;
        return new(s, a - (s - v) + (x - v) + y);
    }

    [MethodImpl(256 | 512)]
    public vdual128f Add2(vdual128f a)
    {
        var s = x + a.x;
        var v = s - x;
        var t = x - (s - v) + (a.x - v);
        return new(s, t + y + a.y);
    }

    [MethodImpl(256 | 512)]
    public vdual128f Sqrt()
    {
        var t = Vector128.Sqrt(x + y);
        return (Add2(Mul(t, t)) * OneDiv(t)).Scale(Vector128.Create(0.5f));
    }
}

#endregion

#region 256

[method: MethodImpl(256 | 512)]
internal struct vdual256f(Vector256<f32> x, Vector256<f32> y)
{
    public Vector256<f32> x = x;
    public Vector256<f32> y = y;

    [MethodImpl(256 | 512)]
    public static vdual256f Add(Vector256<f32> x, Vector256<f32> y)
    {
        var s = x + y;
        return new(s, x - s + y);
    }

    [MethodImpl(256 | 512)]
    public static vdual256f Mul(Vector256<f32> x, Vector256<f32> y)
    {
        var s = x * y;
        return new(s, simd.Fms(x, y, s));
    }

    [MethodImpl(256 | 512)]
    public static vdual256f OneDiv(Vector256<f32> d)
    {
        var s = Vector256<f32>.One / d;
        return new(s, simd.Fnma(d, s, Vector256<f32>.One));
    }

    [MethodImpl(256 | 512)]
    public static vdual256f Sqrt(Vector256<f32> d)
    {
        var t = Vector256.Sqrt(d);
        return (Mul(t, t).LeftAdd2(d) * OneDiv(t)).Scale(Vector256.Create(0.5f));
    }

    [MethodImpl(256 | 512)]
    public static vdual256f operator +(vdual256f x) => x;

    [MethodImpl(256 | 512)]
    public static vdual256f operator -(vdual256f x) => new(-x.x, -x.y);

    [MethodImpl(256 | 512)]
    public static vdual256f operator +(vdual256f x, vdual256f y)
    {
        var s = x.x + y.x;
        return new(s, x.x - s + y.x + x.y + y.y);
    }

    [MethodImpl(256 | 512)]
    public static vdual256f operator -(vdual256f x, vdual256f y)
    {
        var s = x.x - y.x;
        return new(s, x.x - s - y.x + x.y - y.y);
    }

    [MethodImpl(256 | 512)]
    public static vdual256f operator *(vdual256f x, vdual256f y)
    {
        var s = x.x * y.x;
        return new(s, simd.Fma(x.x, y.y, simd.Fma(x.y, y.x, simd.Fms(x.x, y.x, s))));
    }

    [MethodImpl(256 | 512)]
    public static vdual256f operator /(vdual256f n, vdual256f d)
    {
        var t = Vector256<f32>.One / d.x;
        var s = n.x * t;
        var u = simd.Fms(t, n.x, s);
        var v = simd.Fnma(d.y, t, simd.Fnma(d.x, t, Vector256<f32>.One));
        return new(s, simd.Fma(s, v, simd.Fma(n.y, t, u)));
    }

    [MethodImpl(256 | 512)]
    public vdual256f Scale(Vector256<f32> s) => new(x * s, y * s);

    [MethodImpl(256 | 512)]
    public vdual256f Normalize()
    {
        var s = x + y;
        return new(s, x - s + y);
    }

    [MethodImpl(256 | 512)]
    public vdual256f Abs() => new(Vector256.Abs(x), y ^ (x & -Vector256<f32>.Zero));

    [MethodImpl(256 | 512)]
    public vdual256f LeftAdd2(Vector256<f32> a)
    {
        var s = a + x;
        var v = s - a;
        return new(s, a - (s - v) + (x - v) + y);
    }

    [MethodImpl(256 | 512)]
    public vdual256f Add2(vdual256f a)
    {
        var s = x + a.x;
        var v = s - x;
        var t = x - (s - v) + (a.x - v);
        return new(s, t + y + a.y);
    }

    [MethodImpl(256 | 512)]
    public vdual256f Sqrt()
    {
        var t = Vector256.Sqrt(x + y);
        return (Add2(Mul(t, t)) * OneDiv(t)).Scale(Vector256.Create(0.5f));
    }
}

#endregion

#region 128

[method: MethodImpl(256 | 512)]
internal struct vdual128(Vector128<f64> x, Vector128<f64> y)
{
    public Vector128<f64> x = x;
    public Vector128<f64> y = y;

    [MethodImpl(256 | 512)]
    public static vdual128 Add(Vector128<f64> x, Vector128<f64> y)
    {
        var s = x + y;
        return new(s, x - s + y);
    }

    [MethodImpl(256 | 512)]
    public static vdual128 Mul(Vector128<f64> x, Vector128<f64> y)
    {
        var s = x * y;
        return new(s, simd.Fms(x, y, s));
    }

    [MethodImpl(256 | 512)]
    public static vdual128 OneDiv(Vector128<f64> d)
    {
        var s = Vector128<f64>.One / d;
        return new(s, simd.Fnma(d, s, Vector128<f64>.One));
    }

    [MethodImpl(256 | 512)]
    public static vdual128 Sqrt(Vector128<f64> d)
    {
        var t = Vector128.Sqrt(d);
        return (Mul(t, t).LeftAdd2(d) * OneDiv(t)).Scale(Vector128.Create(0.5));
    }

    [MethodImpl(256 | 512)]
    public static vdual128 operator +(vdual128 x) => x;

    [MethodImpl(256 | 512)]
    public static vdual128 operator -(vdual128 x) => new(-x.x, -x.y);

    [MethodImpl(256 | 512)]
    public static vdual128 operator +(vdual128 x, vdual128 y)
    {
        var s = x.x + y.x;
        return new(s, x.x - s + y.x + x.y + y.y);
    }

    [MethodImpl(256 | 512)]
    public static vdual128 operator -(vdual128 x, vdual128 y)
    {
        var s = x.x - y.x;
        return new(s, x.x - s - y.x + x.y - y.y);
    }

    [MethodImpl(256 | 512)]
    public static vdual128 operator *(vdual128 x, vdual128 y)
    {
        var s = x.x * y.x;
        return new(s, simd.Fma(x.x, y.y, simd.Fma(x.y, y.x, simd.Fms(x.x, y.x, s))));
    }

    [MethodImpl(256 | 512)]
    public static vdual128 operator /(vdual128 n, vdual128 d)
    {
        var t = Vector128<f64>.One / d.x;
        var s = n.x * t;
        var u = simd.Fms(t, n.x, s);
        var v = simd.Fnma(d.y, t, simd.Fnma(d.x, t, Vector128<f64>.One));
        return new(s, simd.Fma(s, v, simd.Fma(n.y, t, u)));
    }

    [MethodImpl(256 | 512)]
    public vdual128 Scale(Vector128<f64> s) => new(x * s, y * s);

    [MethodImpl(256 | 512)]
    public vdual128 Normalize()
    {
        var s = x + y;
        return new(s, x - s + y);
    }

    [MethodImpl(256 | 512)]
    public vdual128 Abs() => new(Vector128.Abs(x), y ^ (x & -Vector128<f64>.Zero));

    [MethodImpl(256 | 512)]
    public vdual128 LeftAdd2(Vector128<f64> a)
    {
        var s = a + x;
        var v = s - a;
        return new(s, a - (s - v) + (x - v) + y);
    }

    [MethodImpl(256 | 512)]
    public vdual128 Add2(vdual128 a)
    {
        var s = x + a.x;
        var v = s - x;
        var t = x - (s - v) + (a.x - v);
        return new(s, t + y + a.y);
    }

    [MethodImpl(256 | 512)]
    public vdual128 Sqrt()
    {
        var t = Vector128.Sqrt(x + y);
        return (Add2(Mul(t, t)) * OneDiv(t)).Scale(Vector128.Create(0.5));
    }
}

#endregion

#region 256

[method: MethodImpl(256 | 512)]
internal struct vdual256(Vector256<f64> x, Vector256<f64> y)
{
    public Vector256<f64> x = x;
    public Vector256<f64> y = y;

    [MethodImpl(256 | 512)]
    public static vdual256 Add(Vector256<f64> x, Vector256<f64> y)
    {
        var s = x + y;
        return new(s, x - s + y);
    }

    [MethodImpl(256 | 512)]
    public static vdual256 Mul(Vector256<f64> x, Vector256<f64> y)
    {
        var s = x * y;
        return new(s, simd.Fms(x, y, s));
    }

    [MethodImpl(256 | 512)]
    public static vdual256 OneDiv(Vector256<f64> d)
    {
        var s = Vector256<f64>.One / d;
        return new(s, simd.Fnma(d, s, Vector256<f64>.One));
    }

    [MethodImpl(256 | 512)]
    public static vdual256 Sqrt(Vector256<f64> d)
    {
        var t = Vector256.Sqrt(d);
        return (Mul(t, t).LeftAdd2(d) * OneDiv(t)).Scale(Vector256.Create(0.5));
    }

    [MethodImpl(256 | 512)]
    public static vdual256 operator +(vdual256 x) => x;

    [MethodImpl(256 | 512)]
    public static vdual256 operator -(vdual256 x) => new(-x.x, -x.y);

    [MethodImpl(256 | 512)]
    public static vdual256 operator +(vdual256 x, vdual256 y)
    {
        var s = x.x + y.x;
        return new(s, x.x - s + y.x + x.y + y.y);
    }

    [MethodImpl(256 | 512)]
    public static vdual256 operator -(vdual256 x, vdual256 y)
    {
        var s = x.x - y.x;
        return new(s, x.x - s - y.x + x.y - y.y);
    }

    [MethodImpl(256 | 512)]
    public static vdual256 operator *(vdual256 x, vdual256 y)
    {
        var s = x.x * y.x;
        return new(s, simd.Fma(x.x, y.y, simd.Fma(x.y, y.x, simd.Fms(x.x, y.x, s))));
    }

    [MethodImpl(256 | 512)]
    public static vdual256 operator /(vdual256 n, vdual256 d)
    {
        var t = Vector256<f64>.One / d.x;
        var s = n.x * t;
        var u = simd.Fms(t, n.x, s);
        var v = simd.Fnma(d.y, t, simd.Fnma(d.x, t, Vector256<f64>.One));
        return new(s, simd.Fma(s, v, simd.Fma(n.y, t, u)));
    }

    [MethodImpl(256 | 512)]
    public vdual256 Scale(Vector256<f64> s) => new(x * s, y * s);

    [MethodImpl(256 | 512)]
    public vdual256 Normalize()
    {
        var s = x + y;
        return new(s, x - s + y);
    }

    [MethodImpl(256 | 512)]
    public vdual256 Abs() => new(Vector256.Abs(x), y ^ (x & -Vector256<f64>.Zero));

    [MethodImpl(256 | 512)]
    public vdual256 LeftAdd2(Vector256<f64> a)
    {
        var s = a + x;
        var v = s - a;
        return new(s, a - (s - v) + (x - v) + y);
    }

    [MethodImpl(256 | 512)]
    public vdual256 Add2(vdual256 a)
    {
        var s = x + a.x;
        var v = s - x;
        var t = x - (s - v) + (a.x - v);
        return new(s, t + y + a.y);
    }

    [MethodImpl(256 | 512)]
    public vdual256 Sqrt()
    {
        var t = Vector256.Sqrt(x + y);
        return (Add2(Mul(t, t)) * OneDiv(t)).Scale(Vector256.Create(0.5));
    }
}

#endregion

#region 512

[method: MethodImpl(256 | 512)]
internal struct vdual512(Vector512<f64> x, Vector512<f64> y)
{
    public Vector512<f64> x = x;
    public Vector512<f64> y = y;

    [MethodImpl(256 | 512)]
    public static vdual512 Add(Vector512<f64> x, Vector512<f64> y)
    {
        var s = x + y;
        return new(s, x - s + y);
    }

    [MethodImpl(256 | 512)]
    public static vdual512 Mul(Vector512<f64> x, Vector512<f64> y)
    {
        var s = x * y;
        return new(s, simd.Fms(x, y, s));
    }

    [MethodImpl(256 | 512)]
    public static vdual512 OneDiv(Vector512<f64> d)
    {
        var s = Vector512<f64>.One / d;
        return new(s, simd.Fnma(d, s, Vector512<f64>.One));
    }

    [MethodImpl(256 | 512)]
    public static vdual512 Sqrt(Vector512<f64> d)
    {
        var t = Vector512.Sqrt(d);
        return (Mul(t, t).LeftAdd2(d) * OneDiv(t)).Scale(Vector512.Create(0.5));
    }

    [MethodImpl(256 | 512)]
    public static vdual512 operator +(vdual512 x) => x;

    [MethodImpl(256 | 512)]
    public static vdual512 operator -(vdual512 x) => new(-x.x, -x.y);

    [MethodImpl(256 | 512)]
    public static vdual512 operator +(vdual512 x, vdual512 y)
    {
        var s = x.x + y.x;
        return new(s, x.x - s + y.x + x.y + y.y);
    }

    [MethodImpl(256 | 512)]
    public static vdual512 operator -(vdual512 x, vdual512 y)
    {
        var s = x.x - y.x;
        return new(s, x.x - s - y.x + x.y - y.y);
    }

    [MethodImpl(256 | 512)]
    public static vdual512 operator *(vdual512 x, vdual512 y)
    {
        var s = x.x * y.x;
        return new(s, simd.Fma(x.x, y.y, simd.Fma(x.y, y.x, simd.Fms(x.x, y.x, s))));
    }

    [MethodImpl(256 | 512)]
    public static vdual512 operator /(vdual512 n, vdual512 d)
    {
        var t = Vector512<f64>.One / d.x;
        var s = n.x * t;
        var u = simd.Fms(t, n.x, s);
        var v = simd.Fnma(d.y, t, simd.Fnma(d.x, t, Vector512<f64>.One));
        return new(s, simd.Fma(s, v, simd.Fma(n.y, t, u)));
    }

    [MethodImpl(256 | 512)]
    public vdual512 Scale(Vector512<f64> s) => new(x * s, y * s);

    [MethodImpl(256 | 512)]
    public vdual512 Normalize()
    {
        var s = x + y;
        return new(s, x - s + y);
    }

    [MethodImpl(256 | 512)]
    public vdual512 Abs() => new(Vector512.Abs(x), y ^ (x & -Vector512<f64>.Zero));

    [MethodImpl(256 | 512)]
    public vdual512 LeftAdd2(Vector512<f64> a)
    {
        var s = a + x;
        var v = s - a;
        return new(s, a - (s - v) + (x - v) + y);
    }

    [MethodImpl(256 | 512)]
    public vdual512 Add2(vdual512 a)
    {
        var s = x + a.x;
        var v = s - x;
        var t = x - (s - v) + (a.x - v);
        return new(s, t + y + a.y);
    }

    [MethodImpl(256 | 512)]
    public vdual512 Sqrt()
    {
        var t = Vector512.Sqrt(x + y);
        return (Add2(Mul(t, t)) * OneDiv(t)).Scale(Vector512.Create(0.5));
    }
}

#endregion

#endif
