<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="../../types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics.Simd.Numerics;

<#
    var types = new[] { "f32", "f64" };
    var sizes = new[] { 64, 128, 256, 512 };
    var pairs = (from t in types
        from s in sizes
        where (t, s) is not (("f64", 64) or ("f32", 512))
        select (t, s)).ToList();

    foreach (var (type, size) in pairs)
    {
        var suffix = type == "f32" ? "f" : "";
        var v = $"Vector{size}";
        var vt = $"{v}<{type}>";
        var self = $"vdual{size}{suffix}";
#>
#region <#= size #>

[method: MethodImpl(256 | 512)]
internal struct <#= self #>(<#= vt #> x, <#= vt #> y)
{
    public <#= vt #> x = x;
    public <#= vt #> y = y;

    [MethodImpl(256 | 512)]
    public static <#= self #> Add(<#= vt #> x, <#= vt #> y)
    {
        var s = x + y;
        return new(s, x - s + y);
    }

    [MethodImpl(256 | 512)]
    public static <#= self #> Mul(<#= vt #> x, <#= vt #> y)
    {
        var s = x * y;
        return new(s, simd.Fms(x, y, s));
    }

    [MethodImpl(256 | 512)]
    public static <#= self #> OneDiv(<#= vt #> d)
    {
        var s = <#= vt #>.One / d;
        return new(s, simd.Fnma(d, s, <#= vt #>.One));
    }

    [MethodImpl(256 | 512)]
    public static <#= self #> Sqrt(<#= vt #> d)
    {
        var t = <#= v #>.Sqrt(d);
        return (Mul(t, t).LeftAdd2(d) * OneDiv(t)).Scale(<#= v #>.Create(0.5<#= suffix #>));
    }

    [MethodImpl(256 | 512)]
    public static <#= self #> operator +(<#= self #> x) => x;

    [MethodImpl(256 | 512)]
    public static <#= self #> operator -(<#= self #> x) => new(-x.x, -x.y);

    [MethodImpl(256 | 512)]
    public static <#= self #> operator +(<#= self #> x, <#= self #> y)
    {
        var s = x.x + y.x;
        return new(s, x.x - s + y.x + x.y + y.y);
    }

    [MethodImpl(256 | 512)]
    public static <#= self #> operator -(<#= self #> x, <#= self #> y)
    {
        var s = x.x - y.x;
        return new(s, x.x - s - y.x + x.y - y.y);
    }

    [MethodImpl(256 | 512)]
    public static <#= self #> operator *(<#= self #> x, <#= self #> y)
    {
        var s = x.x * y.x;
        return new(s, simd.Fma(x.x, y.y, simd.Fma(x.y, y.x, simd.Fms(x.x, y.x, s))));
    }

    [MethodImpl(256 | 512)]
    public static <#= self #> operator /(<#= self #> n, <#= self #> d)
    {
        var t = <#= vt #>.One / d.x;
        var s = n.x * t;
        var u = simd.Fms(t, n.x, s);
        var v = simd.Fnma(d.y, t, simd.Fnma(d.x, t, <#= vt #>.One));
        return new(s, simd.Fma(s, v, simd.Fma(n.y, t, u)));
    }

    [MethodImpl(256 | 512)]
    public <#= self #> Scale(<#= vt #> s) => new(x * s, y * s);

    [MethodImpl(256 | 512)]
    public <#= self #> Normalize()
    {
        var s = x + y;
        return new(s, x - s + y);
    }

    [MethodImpl(256 | 512)]
    public <#= self #> Abs() => new(<#= v #>.Abs(x), y ^ (x & -<#= vt #>.Zero));

    [MethodImpl(256 | 512)]
    public <#= self #> LeftAdd2(<#= vt #> a)
    {
        var s = a + x;
        var v = s - a;
        return new(s, a - (s - v) + (x - v) + y);
    }

    [MethodImpl(256 | 512)]
    public <#= self #> Add2(<#= self #> a)
    {
        var s = x + a.x;
        var v = s - x;
        var t = x - (s - v) + (a.x - v);
        return new(s, t + y + a.y);
    }

    [MethodImpl(256 | 512)]
    public <#= self #> Sqrt()
    {
        var t = <#= v #>.Sqrt(x + y);
        return (Add2(Mul(t, t)) * OneDiv(t)).Scale(<#= v #>.Create(0.5<#= suffix #>));
    }
}

#endregion

<#
    }
#>
