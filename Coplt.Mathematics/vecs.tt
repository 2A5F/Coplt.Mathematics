<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="types.ttinclude" #>// generated by template, do not modify manually

using System;
#if NET8_0_OR_GREATER
using System.Numerics;
using System.Runtime.Intrinsics;
#endif
using System.Runtime.CompilerServices;
using System.Diagnostics.CodeAnalysis;
using half = System.Half;

namespace Coplt.Mathematics;
<#
    void NoSimdComps(Typ typ, int size)
    {
        for (var c = 0; c < size; c++)
        {
            var comp = Typ.xyzw[c];
            WriteLine($"    private {typ.name} _{comp};");
            WriteLine($"    public {typ.name} {comp}");
            WriteLine($"    {{");
            WriteLine($"        [MethodImpl(256 | 512)]");
            WriteLine($"        get => _{comp};");
            WriteLine($"        [MethodImpl(256 | 512)]");
            WriteLine($"        set => _{comp} = value;");
            WriteLine($"    }}");
        }
        if (size == 3)
        {
            WriteLine($"    private {typ.name} _align;");
        }
    }

    void SimdComps(Typ typ, int size)
    {
        for (var c = 0; c < size; c++)
        {
            var comp = Typ.xyzw[c];
            WriteLine($"    public {typ.name} {comp}");
            WriteLine($"    {{");
            WriteLine($"        [MethodImpl(256 | 512)]");
            WriteLine($"        get => vector.GetElement({c});");
            WriteLine($"        [MethodImpl(256 | 512)]");
            WriteLine($"        set => vector = vector.WithElement(0, value);");
            WriteLine($"    }}");
        }
    }

    void ColorComps(Typ typ, int size)
    {
        for (var c = 0; c < size; c++)
        {
            var xyzw = Typ.xyzw[c];
            var rgba = Typ.rgba[c];
            WriteLine($"    public {typ.name} {rgba}");
            WriteLine($"    {{");
            WriteLine($"        [MethodImpl(256 | 512)]");
            WriteLine($"        get => {xyzw};");
            WriteLine($"        [MethodImpl(256 | 512)]");
            WriteLine($"        set => {xyzw} = value;");
            WriteLine($"    }}");
        }
    }

    void NoSimdCtor(int size)
    {
        for (var c = 0; c < size; c++)
        {
            var comp = Typ.xyzw[c];
            WriteLine($"        this.{comp} = {comp};");
        }
    }

    void SimdCtor(int size, int bitSize)
    {
        Write($"        vector = Vector{bitSize}.Create(");
        var first = true;
        for (var c = 0; c < size; c++)
        {
            if (first) first = false;
            else Write($", ");
            var comp = Typ.xyzw[c];
            Write($"{comp}");
        }
        if (size == 3) Write($", default");
        WriteLine($");");
    }

    void NoSimdCtorSame(int size)
    {
        for (var c = 0; c < size; c++)
        {
            var comp = Typ.xyzw[c];
            WriteLine($"        {comp} = value;");
        }
    }

    void SimdCtorSame(int size, int bitSize)
    {
        if (size == 3) WriteLine($"        vector = Vector{bitSize}.Create(value, value, value, default);");
        else WriteLine($"        vector = Vector{bitSize}.Create(value);");
    }
    
    void NoSimdCtorScalar(int size)
    {
        WriteLine($"        x = value;");
    }

    void SimdCtorScalar(int size, int bitSize)
    {
        WriteLine($"        vector = Vector{bitSize}.CreateScalar(value);");
    }

    foreach (var typ in Typ.Typs)
    {
        for (var i = 2; i <= 4; i++)
        {
            var byteSize = typ.size * (i is 3 ? 4 : i);
            var bitSize = 8 * byteSize;

            var typeName = $"{typ.name}{i}";
#>
#region <#= typeName #>

public partial struct <#= typeName #> : 
    IVector<#= i #><<#= typ.name #>>, IVectorSelf<<#= typeName #>>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => <#= typ.simd ? "true" : "false" #>; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => <#= i #>; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => <#= byteSize #>; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => <#= bitSize #>; 
    }

    public static <#= typeName #> Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static <#= typeName #> One
    { 
        [MethodImpl(256 | 512)]
        get => new(<#= typ.one #>); 
    }

    #endregion

    #region fields

<#
            if (typ.simd)
            {
                WriteLine($"    #if NET8_0_OR_GREATER");
#>
    internal Vector<#= bitSize #><<#= typ.name #>> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector<#= bitSize #><<#= typ.name #>>(<#= typeName #> self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector<#= bitSize #><<#= typ.name #>> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector<#= bitSize #><<#= typ.name #>> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector<#= bitSize #><<#= typ.name #>> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

<#
                SimdComps(typ, i);
                WriteLine($"    #else // NET8_0_OR_GREATER");
            }
            NoSimdComps(typ, i);
            if (typ.simd) WriteLine($"    #endif // NET8_0_OR_GREATER");
            ColorComps(typ, i);
#>

    #endregion

    #region ctors

<#
            if (typ.simd)
            {
                WriteLine($"    #if NET8_0_OR_GREATER");
#>
    [MethodImpl(256 | 512)]
    internal <#= typeName #>(Vector<#= bitSize #><<#= typ.name #>> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static <#= typeName #> UnsafeFromInner(Vector<#= bitSize #><<#= typ.name #>> vector) => new(vector);
<#
                WriteLine($"    #endif // NET8_0_OR_GREATER");
            }
#>

    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#
            {
                var first = true;
                for (var n = 0; n < i; n++)
                {
                    if (first) first = false;
                    else Write(", ");
                    Write($"{typ.name} {Typ.xyzw[n]}");
                }
            }
#>)
    {
<#
            if (typ.simd)
            {
                WriteLine($"        #if NET8_0_OR_GREATER");
                SimdCtor(i, bitSize);
                WriteLine($"        #else // NET8_0_OR_GREATER");
            }
            NoSimdCtor(i);
            if (typ.simd) WriteLine($"        #endif // NET8_0_OR_GREATER");
#>
    }

    [MethodImpl(256 | 512)]
    public static implicit operator <#= typeName #>(<#= typ.name #> value) => new(value);

    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#= typ.name #> value)
    {
<#
            if (typ.simd)
            {
                WriteLine($"        #if NET8_0_OR_GREATER");
                SimdCtorSame(i, bitSize);
                WriteLine($"        #else // NET8_0_OR_GREATER");
            }
            NoSimdCtorSame(i);
            if (typ.simd) WriteLine($"        #endif // NET8_0_OR_GREATER");
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> Scalar(<#= typ.name #> value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal <#= typeName #>(<#= typ.name #> value, is_scalar _)
    {
<#
            if (typ.simd)
            {
                WriteLine($"        #if NET8_0_OR_GREATER");
                SimdCtorScalar(i, bitSize);
                WriteLine($"        #else // NET8_0_OR_GREATER");
            }
            NoSimdCtorScalar(i);
            if (typ.simd) WriteLine($"        #endif // NET8_0_OR_GREATER");
#>
    }

    #endregion // ctors

}

#endregion // <#= typeName #>
<#
        }
    }
#>
