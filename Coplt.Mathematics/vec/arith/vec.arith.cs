// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region float2

public partial struct float2
{
    [MethodImpl(256 | 512)]
    public static float2 operator +(float2 a) => a;
    [MethodImpl(256 | 512)]
    public static float2 operator -(float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new((-a.x), (-a.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 operator +(float2 a, float2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x + b.x), (float)(a.y + b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 operator +(float2 a, float b) => a + new float2(b);

    [MethodImpl(256 | 512)]
    public static float2 operator +(float a, float2 b) => new float2(a) + b;

    [MethodImpl(256 | 512)]
    public static float2 operator -(float2 a, float2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x - b.x), (float)(a.y - b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 operator -(float2 a, float b) => a - new float2(b);

    [MethodImpl(256 | 512)]
    public static float2 operator -(float a, float2 b) => new float2(a) - b;

    [MethodImpl(256 | 512)]
    public static float2 operator *(float2 a, float2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x * b.x), (float)(a.y * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 operator *(float a, float2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a * b.x), (float)(a * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 operator *(float2 a, float b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x * b), (float)(a.y * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 operator /(float2 a, float2 b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b.vector));
        #else // NET8_0_OR_GREATER
        return new((float)(a.x / b.x), (float)(a.y / b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 operator /(float2 a, float b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b));
        #else // NET8_0_OR_GREATER
        return new((float)(a.x / b), (float)(a.y / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 operator /(float a, float2 b) => new float2(a) / b;

    [MethodImpl(256 | 512)]
    public static float2 operator %(float2 a, float2 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Rem(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new((float)(a.x % b.x), (float)(a.y % b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 operator %(float2 a, float b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Rem(a.vector, b));
        #else // NET8_0_OR_GREATER
        return new((float)(a.x % b), (float)(a.y % b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 operator %(float a, float2 b) => new float2(a) % b;

    [MethodImpl(256 | 512)]
    public static float2 operator --(float2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static float2 operator ++(float2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float2 abs(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 sign(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignFloat(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 min(this float2 a, float2 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 max(this float2 a, float2 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 clamp(this float2 v, float2 min, float2 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Max(min.vector, Vector64.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 clamp(this float2 v, float min, float max) => v.clamp(new float2(min), new float2(max));

    [MethodImpl(256 | 512)]
    public static float2 lerp(this float2 t, float2 start, float2 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 lerp(this float t, float2 start, float2 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(new(t), end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 lerp(this float2 t, float start, float end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, (end - start), new(start));
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 unlerp(this float2 a, float2 start, float2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float2 unlerp(this float a, float2 start, float2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float2 unlerp(this float2 a, float start, float end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float2 remap(this float2 a, float2 srcStart, float2 srcEnd, float2 dstStart, float2 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float2 remap(this float2 a, float srcStart, float srcEnd, float dstStart, float dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float dot(this float2 a, float2 b)
    {
        #if NET8_0_OR_GREATER
        return Vector64.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (float)(a.x * b.x + a.y * b.y);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float lengthsq(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return Vector64.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float distancesq(this float2 a, float2 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static float2 square(this float2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float2 fma(this float2 a, float2 b, float2 c)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Fma(a.vector, b.vector, c.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y));
        #endif // NET8_0_OR_GREATER
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static float2 fms(this float2 a, float2 b, float2 c)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Fms(a.vector, b.vector, c.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y));
        #endif // NET8_0_OR_GREATER
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static float2 fnma(this float2 a, float2 b, float2 c)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Fnma(a.vector, b.vector, c.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y));
        #endif // NET8_0_OR_GREATER
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static float2 fsm(this float2 c, float2 a, float2 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float2 fam(this float2 c, float2 a, float2 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float2 mad(this float2 a, float2 b, float2 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static float csum(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return Vector64.Sum(a.vector);
        #else // NET8_0_OR_GREATER
        return (a.x + a.y);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float cmin(this float2 a)
    {
        return a.x.min(a.y);
    }

    [MethodImpl(256 | 512)]
    public static float cmax(this float2 a)
    {
        return a.x.max(a.y);
    }
}

#endregion // float2

#region float3

public partial struct float3
{
    [MethodImpl(256 | 512)]
    public static float3 operator +(float3 a) => a;
    [MethodImpl(256 | 512)]
    public static float3 operator -(float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector & Vector128.Create(-1, -1, -1, 0).AsSingle());
        #else // NET8_0_OR_GREATER
        return new((-a.x), (-a.y), (-a.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 operator +(float3 a, float3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x + b.x), (float)(a.y + b.y), (float)(a.z + b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 operator +(float3 a, float b) => a + new float3(b);

    [MethodImpl(256 | 512)]
    public static float3 operator +(float a, float3 b) => new float3(a) + b;

    [MethodImpl(256 | 512)]
    public static float3 operator -(float3 a, float3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x - b.x), (float)(a.y - b.y), (float)(a.z - b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 operator -(float3 a, float b) => a - new float3(b);

    [MethodImpl(256 | 512)]
    public static float3 operator -(float a, float3 b) => new float3(a) - b;

    [MethodImpl(256 | 512)]
    public static float3 operator *(float3 a, float3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x * b.x), (float)(a.y * b.y), (float)(a.z * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 operator *(float a, float3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a * b.x), (float)(a * b.y), (float)(a * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 operator *(float3 a, float b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x * b), (float)(a.y * b), (float)(a.z * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 operator /(float3 a, float3 b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b.vector) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        #else // NET8_0_OR_GREATER
        return new((float)(a.x / b.x), (float)(a.y / b.y), (float)(a.z / b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 operator /(float3 a, float b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        #else // NET8_0_OR_GREATER
        return new((float)(a.x / b), (float)(a.y / b), (float)(a.z / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 operator /(float a, float3 b) => new float3(a) / b;

    [MethodImpl(256 | 512)]
    public static float3 operator %(float3 a, float3 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Rem(a.vector, b.vector) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        #else // NET8_0_OR_GREATER
        return new((float)(a.x % b.x), (float)(a.y % b.y), (float)(a.z % b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 operator %(float3 a, float b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Rem(a.vector, b) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        #else // NET8_0_OR_GREATER
        return new((float)(a.x % b), (float)(a.y % b), (float)(a.z % b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 operator %(float a, float3 b) => new float3(a) % b;

    [MethodImpl(256 | 512)]
    public static float3 operator --(float3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static float3 operator ++(float3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float3 abs(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 sign(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignFloat(a.vector) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 min(this float3 a, float3 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 max(this float3 a, float3 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 clamp(this float3 v, float3 min, float3 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(min.vector, Vector128.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 clamp(this float3 v, float min, float max) => v.clamp(new float3(min), new float3(max));

    [MethodImpl(256 | 512)]
    public static float3 lerp(this float3 t, float3 start, float3 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 lerp(this float t, float3 start, float3 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(new(t), end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 lerp(this float3 t, float start, float end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, (end - start), new(start));
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 unlerp(this float3 a, float3 start, float3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float3 unlerp(this float a, float3 start, float3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float3 unlerp(this float3 a, float start, float end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float3 remap(this float3 a, float3 srcStart, float3 srcEnd, float3 dstStart, float3 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float3 remap(this float3 a, float srcStart, float srcEnd, float dstStart, float dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float dot(this float3 a, float3 b)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (float)(a.x * b.x + a.y * b.y + a.z * b.z);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 cross(this float3 a, float3 b) => (a * b.yzx - a.yzx * b).yzx;

    [MethodImpl(256 | 512)]
    public static float lengthsq(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float distancesq(this float3 a, float3 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static float3 square(this float3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float3 fma(this float3 a, float3 b, float3 c)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Fma(a.vector, b.vector, c.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z));
        #endif // NET8_0_OR_GREATER
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static float3 fms(this float3 a, float3 b, float3 c)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Fms(a.vector, b.vector, c.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z));
        #endif // NET8_0_OR_GREATER
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static float3 fnma(this float3 a, float3 b, float3 c)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Fnma(a.vector, b.vector, c.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z));
        #endif // NET8_0_OR_GREATER
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static float3 fsm(this float3 c, float3 a, float3 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float3 fam(this float3 c, float3 a, float3 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float3 mad(this float3 a, float3 b, float3 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static float csum(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Sum(a.vector);
        #else // NET8_0_OR_GREATER
        return (a.x + a.y + a.z);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float cmin(this float3 a)
    {
        return a.x.min(a.y).min(a.z);
    }

    [MethodImpl(256 | 512)]
    public static float cmax(this float3 a)
    {
        return a.x.max(a.y).max(a.z);
    }
}

#endregion // float3

#region float4

public partial struct float4
{
    [MethodImpl(256 | 512)]
    public static float4 operator +(float4 a) => a;
    [MethodImpl(256 | 512)]
    public static float4 operator -(float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new((-a.x), (-a.y), (-a.z), (-a.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 operator +(float4 a, float4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x + b.x), (float)(a.y + b.y), (float)(a.z + b.z), (float)(a.w + b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 operator +(float4 a, float b) => a + new float4(b);

    [MethodImpl(256 | 512)]
    public static float4 operator +(float a, float4 b) => new float4(a) + b;

    [MethodImpl(256 | 512)]
    public static float4 operator -(float4 a, float4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x - b.x), (float)(a.y - b.y), (float)(a.z - b.z), (float)(a.w - b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 operator -(float4 a, float b) => a - new float4(b);

    [MethodImpl(256 | 512)]
    public static float4 operator -(float a, float4 b) => new float4(a) - b;

    [MethodImpl(256 | 512)]
    public static float4 operator *(float4 a, float4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x * b.x), (float)(a.y * b.y), (float)(a.z * b.z), (float)(a.w * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 operator *(float a, float4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((float)(a * b.x), (float)(a * b.y), (float)(a * b.z), (float)(a * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 operator *(float4 a, float b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((float)(a.x * b), (float)(a.y * b), (float)(a.z * b), (float)(a.w * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 operator /(float4 a, float4 b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b.vector));
        #else // NET8_0_OR_GREATER
        return new((float)(a.x / b.x), (float)(a.y / b.y), (float)(a.z / b.z), (float)(a.w / b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 operator /(float4 a, float b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b));
        #else // NET8_0_OR_GREATER
        return new((float)(a.x / b), (float)(a.y / b), (float)(a.z / b), (float)(a.w / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 operator /(float a, float4 b) => new float4(a) / b;

    [MethodImpl(256 | 512)]
    public static float4 operator %(float4 a, float4 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Rem(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new((float)(a.x % b.x), (float)(a.y % b.y), (float)(a.z % b.z), (float)(a.w % b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 operator %(float4 a, float b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Rem(a.vector, b));
        #else // NET8_0_OR_GREATER
        return new((float)(a.x % b), (float)(a.y % b), (float)(a.z % b), (float)(a.w % b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 operator %(float a, float4 b) => new float4(a) % b;

    [MethodImpl(256 | 512)]
    public static float4 operator --(float4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static float4 operator ++(float4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float4 abs(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 sign(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignFloat(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 min(this float4 a, float4 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z), a.w.min(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 max(this float4 a, float4 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z), a.w.max(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 clamp(this float4 v, float4 min, float4 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(min.vector, Vector128.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z), v.w.clamp(min.w, max.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 clamp(this float4 v, float min, float max) => v.clamp(new float4(min), new float4(max));

    [MethodImpl(256 | 512)]
    public static float4 lerp(this float4 t, float4 start, float4 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 lerp(this float t, float4 start, float4 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(new(t), end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 lerp(this float4 t, float start, float end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, (end - start), new(start));
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 unlerp(this float4 a, float4 start, float4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float4 unlerp(this float a, float4 start, float4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float4 unlerp(this float4 a, float start, float end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float4 remap(this float4 a, float4 srcStart, float4 srcEnd, float4 dstStart, float4 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float4 remap(this float4 a, float srcStart, float srcEnd, float dstStart, float dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float dot(this float4 a, float4 b)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (float)(a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float lengthsq(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float distancesq(this float4 a, float4 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static float4 square(this float4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float4 fma(this float4 a, float4 b, float4 c)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Fma(a.vector, b.vector, c.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z), a.w.fma(b.w, c.w));
        #endif // NET8_0_OR_GREATER
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static float4 fms(this float4 a, float4 b, float4 c)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Fms(a.vector, b.vector, c.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z), a.w.fms(b.w, c.w));
        #endif // NET8_0_OR_GREATER
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static float4 fnma(this float4 a, float4 b, float4 c)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Fnma(a.vector, b.vector, c.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z), a.w.fnma(b.w, c.w));
        #endif // NET8_0_OR_GREATER
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static float4 fsm(this float4 c, float4 a, float4 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float4 fam(this float4 c, float4 a, float4 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float4 mad(this float4 a, float4 b, float4 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static float csum(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Sum(a.vector);
        #else // NET8_0_OR_GREATER
        return (a.x + a.y + a.z + a.w);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float cmin(this float4 a)
    {
        return a.x.min(a.y).min(a.z).min(a.w);
    }

    [MethodImpl(256 | 512)]
    public static float cmax(this float4 a)
    {
        return a.x.max(a.y).max(a.z).max(a.w);
    }
}

#endregion // float4

#region double2

public partial struct double2
{
    [MethodImpl(256 | 512)]
    public static double2 operator +(double2 a) => a;
    [MethodImpl(256 | 512)]
    public static double2 operator -(double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new((-a.x), (-a.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 operator +(double2 a, double2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x + b.x), (double)(a.y + b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 operator +(double2 a, double b) => a + new double2(b);

    [MethodImpl(256 | 512)]
    public static double2 operator +(double a, double2 b) => new double2(a) + b;

    [MethodImpl(256 | 512)]
    public static double2 operator -(double2 a, double2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x - b.x), (double)(a.y - b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 operator -(double2 a, double b) => a - new double2(b);

    [MethodImpl(256 | 512)]
    public static double2 operator -(double a, double2 b) => new double2(a) - b;

    [MethodImpl(256 | 512)]
    public static double2 operator *(double2 a, double2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x * b.x), (double)(a.y * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 operator *(double a, double2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a * b.x), (double)(a * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 operator *(double2 a, double b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x * b), (double)(a.y * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 operator /(double2 a, double2 b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b.vector));
        #else // NET8_0_OR_GREATER
        return new((double)(a.x / b.x), (double)(a.y / b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 operator /(double2 a, double b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b));
        #else // NET8_0_OR_GREATER
        return new((double)(a.x / b), (double)(a.y / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 operator /(double a, double2 b) => new double2(a) / b;

    [MethodImpl(256 | 512)]
    public static double2 operator %(double2 a, double2 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Rem(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new((double)(a.x % b.x), (double)(a.y % b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 operator %(double2 a, double b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Rem(a.vector, b));
        #else // NET8_0_OR_GREATER
        return new((double)(a.x % b), (double)(a.y % b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 operator %(double a, double2 b) => new double2(a) % b;

    [MethodImpl(256 | 512)]
    public static double2 operator --(double2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static double2 operator ++(double2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double2 abs(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 sign(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignFloat(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 min(this double2 a, double2 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 max(this double2 a, double2 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 clamp(this double2 v, double2 min, double2 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(min.vector, Vector128.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 clamp(this double2 v, double min, double max) => v.clamp(new double2(min), new double2(max));

    [MethodImpl(256 | 512)]
    public static double2 lerp(this double2 t, double2 start, double2 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 lerp(this double t, double2 start, double2 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(new(t), end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 lerp(this double2 t, double start, double end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, (end - start), new(start));
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 unlerp(this double2 a, double2 start, double2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double2 unlerp(this double a, double2 start, double2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double2 unlerp(this double2 a, double start, double end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double2 remap(this double2 a, double2 srcStart, double2 srcEnd, double2 dstStart, double2 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double2 remap(this double2 a, double srcStart, double srcEnd, double dstStart, double dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double dot(this double2 a, double2 b)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (double)(a.x * b.x + a.y * b.y);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double lengthsq(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double distancesq(this double2 a, double2 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static double2 square(this double2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double2 fma(this double2 a, double2 b, double2 c)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Fma(a.vector, b.vector, c.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y));
        #endif // NET8_0_OR_GREATER
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static double2 fms(this double2 a, double2 b, double2 c)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Fms(a.vector, b.vector, c.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y));
        #endif // NET8_0_OR_GREATER
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static double2 fnma(this double2 a, double2 b, double2 c)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Fnma(a.vector, b.vector, c.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y));
        #endif // NET8_0_OR_GREATER
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static double2 fsm(this double2 c, double2 a, double2 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double2 fam(this double2 c, double2 a, double2 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double2 mad(this double2 a, double2 b, double2 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static double csum(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Sum(a.vector);
        #else // NET8_0_OR_GREATER
        return (a.x + a.y);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double cmin(this double2 a)
    {
        return a.x.min(a.y);
    }

    [MethodImpl(256 | 512)]
    public static double cmax(this double2 a)
    {
        return a.x.max(a.y);
    }
}

#endregion // double2

#region double3

public partial struct double3
{
    [MethodImpl(256 | 512)]
    public static double3 operator +(double3 a) => a;
    [MethodImpl(256 | 512)]
    public static double3 operator -(double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector & Vector256.Create(-1, -1, -1, 0).AsDouble());
        #else // NET8_0_OR_GREATER
        return new((-a.x), (-a.y), (-a.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 operator +(double3 a, double3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x + b.x), (double)(a.y + b.y), (double)(a.z + b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 operator +(double3 a, double b) => a + new double3(b);

    [MethodImpl(256 | 512)]
    public static double3 operator +(double a, double3 b) => new double3(a) + b;

    [MethodImpl(256 | 512)]
    public static double3 operator -(double3 a, double3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x - b.x), (double)(a.y - b.y), (double)(a.z - b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 operator -(double3 a, double b) => a - new double3(b);

    [MethodImpl(256 | 512)]
    public static double3 operator -(double a, double3 b) => new double3(a) - b;

    [MethodImpl(256 | 512)]
    public static double3 operator *(double3 a, double3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x * b.x), (double)(a.y * b.y), (double)(a.z * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 operator *(double a, double3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a * b.x), (double)(a * b.y), (double)(a * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 operator *(double3 a, double b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x * b), (double)(a.y * b), (double)(a.z * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 operator /(double3 a, double3 b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b.vector) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        #else // NET8_0_OR_GREATER
        return new((double)(a.x / b.x), (double)(a.y / b.y), (double)(a.z / b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 operator /(double3 a, double b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        #else // NET8_0_OR_GREATER
        return new((double)(a.x / b), (double)(a.y / b), (double)(a.z / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 operator /(double a, double3 b) => new double3(a) / b;

    [MethodImpl(256 | 512)]
    public static double3 operator %(double3 a, double3 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Rem(a.vector, b.vector) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        #else // NET8_0_OR_GREATER
        return new((double)(a.x % b.x), (double)(a.y % b.y), (double)(a.z % b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 operator %(double3 a, double b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Rem(a.vector, b) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        #else // NET8_0_OR_GREATER
        return new((double)(a.x % b), (double)(a.y % b), (double)(a.z % b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 operator %(double a, double3 b) => new double3(a) % b;

    [MethodImpl(256 | 512)]
    public static double3 operator --(double3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static double3 operator ++(double3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double3 abs(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 sign(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignFloat(a.vector) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 min(this double3 a, double3 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 max(this double3 a, double3 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 clamp(this double3 v, double3 min, double3 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Max(min.vector, Vector256.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 clamp(this double3 v, double min, double max) => v.clamp(new double3(min), new double3(max));

    [MethodImpl(256 | 512)]
    public static double3 lerp(this double3 t, double3 start, double3 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 lerp(this double t, double3 start, double3 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(new(t), end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 lerp(this double3 t, double start, double end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, (end - start), new(start));
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 unlerp(this double3 a, double3 start, double3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double3 unlerp(this double a, double3 start, double3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double3 unlerp(this double3 a, double start, double end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double3 remap(this double3 a, double3 srcStart, double3 srcEnd, double3 dstStart, double3 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double3 remap(this double3 a, double srcStart, double srcEnd, double dstStart, double dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double dot(this double3 a, double3 b)
    {
        #if NET8_0_OR_GREATER
        return Vector256.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (double)(a.x * b.x + a.y * b.y + a.z * b.z);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 cross(this double3 a, double3 b) => (a * b.yzx - a.yzx * b).yzx;

    [MethodImpl(256 | 512)]
    public static double lengthsq(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return Vector256.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double distancesq(this double3 a, double3 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static double3 square(this double3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double3 fma(this double3 a, double3 b, double3 c)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Fma(a.vector, b.vector, c.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z));
        #endif // NET8_0_OR_GREATER
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static double3 fms(this double3 a, double3 b, double3 c)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Fms(a.vector, b.vector, c.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z));
        #endif // NET8_0_OR_GREATER
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static double3 fnma(this double3 a, double3 b, double3 c)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Fnma(a.vector, b.vector, c.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z));
        #endif // NET8_0_OR_GREATER
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static double3 fsm(this double3 c, double3 a, double3 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double3 fam(this double3 c, double3 a, double3 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double3 mad(this double3 a, double3 b, double3 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static double csum(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return Vector256.Sum(a.vector);
        #else // NET8_0_OR_GREATER
        return (a.x + a.y + a.z);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double cmin(this double3 a)
    {
        return a.x.min(a.y).min(a.z);
    }

    [MethodImpl(256 | 512)]
    public static double cmax(this double3 a)
    {
        return a.x.max(a.y).max(a.z);
    }
}

#endregion // double3

#region double4

public partial struct double4
{
    [MethodImpl(256 | 512)]
    public static double4 operator +(double4 a) => a;
    [MethodImpl(256 | 512)]
    public static double4 operator -(double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new((-a.x), (-a.y), (-a.z), (-a.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 operator +(double4 a, double4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x + b.x), (double)(a.y + b.y), (double)(a.z + b.z), (double)(a.w + b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 operator +(double4 a, double b) => a + new double4(b);

    [MethodImpl(256 | 512)]
    public static double4 operator +(double a, double4 b) => new double4(a) + b;

    [MethodImpl(256 | 512)]
    public static double4 operator -(double4 a, double4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x - b.x), (double)(a.y - b.y), (double)(a.z - b.z), (double)(a.w - b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 operator -(double4 a, double b) => a - new double4(b);

    [MethodImpl(256 | 512)]
    public static double4 operator -(double a, double4 b) => new double4(a) - b;

    [MethodImpl(256 | 512)]
    public static double4 operator *(double4 a, double4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x * b.x), (double)(a.y * b.y), (double)(a.z * b.z), (double)(a.w * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 operator *(double a, double4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((double)(a * b.x), (double)(a * b.y), (double)(a * b.z), (double)(a * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 operator *(double4 a, double b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((double)(a.x * b), (double)(a.y * b), (double)(a.z * b), (double)(a.w * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 operator /(double4 a, double4 b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b.vector));
        #else // NET8_0_OR_GREATER
        return new((double)(a.x / b.x), (double)(a.y / b.y), (double)(a.z / b.z), (double)(a.w / b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 operator /(double4 a, double b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b));
        #else // NET8_0_OR_GREATER
        return new((double)(a.x / b), (double)(a.y / b), (double)(a.z / b), (double)(a.w / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 operator /(double a, double4 b) => new double4(a) / b;

    [MethodImpl(256 | 512)]
    public static double4 operator %(double4 a, double4 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Rem(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new((double)(a.x % b.x), (double)(a.y % b.y), (double)(a.z % b.z), (double)(a.w % b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 operator %(double4 a, double b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Rem(a.vector, b));
        #else // NET8_0_OR_GREATER
        return new((double)(a.x % b), (double)(a.y % b), (double)(a.z % b), (double)(a.w % b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 operator %(double a, double4 b) => new double4(a) % b;

    [MethodImpl(256 | 512)]
    public static double4 operator --(double4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static double4 operator ++(double4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double4 abs(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 sign(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignFloat(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 min(this double4 a, double4 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z), a.w.min(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 max(this double4 a, double4 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z), a.w.max(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 clamp(this double4 v, double4 min, double4 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Max(min.vector, Vector256.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z), v.w.clamp(min.w, max.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 clamp(this double4 v, double min, double max) => v.clamp(new double4(min), new double4(max));

    [MethodImpl(256 | 512)]
    public static double4 lerp(this double4 t, double4 start, double4 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 lerp(this double t, double4 start, double4 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(new(t), end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 lerp(this double4 t, double start, double end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, (end - start), new(start));
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 unlerp(this double4 a, double4 start, double4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double4 unlerp(this double a, double4 start, double4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double4 unlerp(this double4 a, double start, double end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double4 remap(this double4 a, double4 srcStart, double4 srcEnd, double4 dstStart, double4 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double4 remap(this double4 a, double srcStart, double srcEnd, double dstStart, double dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double dot(this double4 a, double4 b)
    {
        #if NET8_0_OR_GREATER
        return Vector256.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (double)(a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double lengthsq(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return Vector256.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double distancesq(this double4 a, double4 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static double4 square(this double4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double4 fma(this double4 a, double4 b, double4 c)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Fma(a.vector, b.vector, c.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z), a.w.fma(b.w, c.w));
        #endif // NET8_0_OR_GREATER
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static double4 fms(this double4 a, double4 b, double4 c)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Fms(a.vector, b.vector, c.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z), a.w.fms(b.w, c.w));
        #endif // NET8_0_OR_GREATER
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static double4 fnma(this double4 a, double4 b, double4 c)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Fnma(a.vector, b.vector, c.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z), a.w.fnma(b.w, c.w));
        #endif // NET8_0_OR_GREATER
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static double4 fsm(this double4 c, double4 a, double4 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double4 fam(this double4 c, double4 a, double4 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double4 mad(this double4 a, double4 b, double4 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static double csum(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return Vector256.Sum(a.vector);
        #else // NET8_0_OR_GREATER
        return (a.x + a.y + a.z + a.w);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double cmin(this double4 a)
    {
        return a.x.min(a.y).min(a.z).min(a.w);
    }

    [MethodImpl(256 | 512)]
    public static double cmax(this double4 a)
    {
        return a.x.max(a.y).max(a.z).max(a.w);
    }
}

#endregion // double4

#region short2

public partial struct short2
{
    [MethodImpl(256 | 512)]
    public static short2 operator +(short2 a) => a;
    [MethodImpl(256 | 512)]
    public static short2 operator -(short2 a)
    {
        return new((short)(-a.x), (short)(-a.y));
    }

    [MethodImpl(256 | 512)]
    public static short2 operator +(short2 a, short2 b)
    {
        return new((short)(a.x + b.x), (short)(a.y + b.y));
    }

    [MethodImpl(256 | 512)]
    public static short2 operator +(short2 a, short b) => a + new short2(b);

    [MethodImpl(256 | 512)]
    public static short2 operator +(short a, short2 b) => new short2(a) + b;

    [MethodImpl(256 | 512)]
    public static short2 operator -(short2 a, short2 b)
    {
        return new((short)(a.x - b.x), (short)(a.y - b.y));
    }

    [MethodImpl(256 | 512)]
    public static short2 operator -(short2 a, short b) => a - new short2(b);

    [MethodImpl(256 | 512)]
    public static short2 operator -(short a, short2 b) => new short2(a) - b;

    [MethodImpl(256 | 512)]
    public static short2 operator *(short2 a, short2 b)
    {
        return new((short)(a.x * b.x), (short)(a.y * b.y));
    }

    [MethodImpl(256 | 512)]
    public static short2 operator *(short a, short2 b)
    {
        return new((short)(a * b.x), (short)(a * b.y));
    }

    [MethodImpl(256 | 512)]
    public static short2 operator *(short2 a, short b)
    {
        return new((short)(a.x * b), (short)(a.y * b));
    }

    [MethodImpl(256 | 512)]
    public static short2 operator /(short2 a, short2 b)
    {
        return new((short)(a.x / b.x), (short)(a.y / b.y));
    }

    [MethodImpl(256 | 512)]
    public static short2 operator /(short2 a, short b)
    {
        return new((short)(a.x / b), (short)(a.y / b));
    }

    [MethodImpl(256 | 512)]
    public static short2 operator /(short a, short2 b) => new short2(a) / b;

    [MethodImpl(256 | 512)]
    public static short2 operator %(short2 a, short2 b)
    {
        return new((short)(a.x % b.x), (short)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static short2 operator %(short2 a, short b)
    {
        return new((short)(a.x % b), (short)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static short2 operator %(short a, short2 b) => new short2(a) % b;

    [MethodImpl(256 | 512)]
    public static short2 operator --(short2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static short2 operator ++(short2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static short2 abs(this short2 a)
    {
        return new(a.x.abs(), a.y.abs());
    }

    [MethodImpl(256 | 512)]
    public static short2 sign(this short2 a)
    {
        return new(a.x.sign(), a.y.sign());
    }

    [MethodImpl(256 | 512)]
    public static short2 min(this short2 a, short2 b)
    {
        return new(a.x.min(b.x), a.y.min(b.y));
    }

    [MethodImpl(256 | 512)]
    public static short2 max(this short2 a, short2 b)
    {
        return new(a.x.max(b.x), a.y.max(b.y));
    }

    [MethodImpl(256 | 512)]
    public static short2 clamp(this short2 v, short2 min, short2 max)
    {
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y));
    }

    [MethodImpl(256 | 512)]
    public static short2 clamp(this short2 v, short min, short max) => v.clamp(new short2(min), new short2(max));

    [MethodImpl(256 | 512)]
    public static short2 lerp(this short2 t, short2 start, short2 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static short2 lerp(this short t, short2 start, short2 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static short2 lerp(this short2 t, short start, short end)
    {
        return start + t * (short)(end - start);
    }

    [MethodImpl(256 | 512)]
    public static short2 unlerp(this short2 a, short2 start, short2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static short2 unlerp(this short a, short2 start, short2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static short2 unlerp(this short2 a, short start, short end) => (a - start) / (short)(end - start);

    [MethodImpl(256 | 512)]
    public static short2 remap(this short2 a, short2 srcStart, short2 srcEnd, short2 dstStart, short2 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static short2 remap(this short2 a, short srcStart, short srcEnd, short dstStart, short dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static short dot(this short2 a, short2 b)
    {
        return (short)(a.x * b.x + a.y * b.y);
    }

    [MethodImpl(256 | 512)]
    public static short lengthsq(this short2 a)
    {
        return a.dot(a);
    }

    [MethodImpl(256 | 512)]
    public static short distancesq(this short2 a, short2 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static short2 square(this short2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static short2 fma(this short2 a, short2 b, short2 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static short2 fms(this short2 a, short2 b, short2 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static short2 fnma(this short2 a, short2 b, short2 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static short2 fsm(this short2 c, short2 a, short2 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static short2 fam(this short2 c, short2 a, short2 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static short2 mad(this short2 a, short2 b, short2 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static short csum(this short2 a)
    {
        return (short)(a.x + a.y);
    }

    [MethodImpl(256 | 512)]
    public static short cmin(this short2 a)
    {
        return a.x.min(a.y);
    }

    [MethodImpl(256 | 512)]
    public static short cmax(this short2 a)
    {
        return a.x.max(a.y);
    }
}

#endregion // short2

#region short3

public partial struct short3
{
    [MethodImpl(256 | 512)]
    public static short3 operator +(short3 a) => a;
    [MethodImpl(256 | 512)]
    public static short3 operator -(short3 a)
    {
        return new((short)(-a.x), (short)(-a.y), (short)(-a.z));
    }

    [MethodImpl(256 | 512)]
    public static short3 operator +(short3 a, short3 b)
    {
        return new((short)(a.x + b.x), (short)(a.y + b.y), (short)(a.z + b.z));
    }

    [MethodImpl(256 | 512)]
    public static short3 operator +(short3 a, short b) => a + new short3(b);

    [MethodImpl(256 | 512)]
    public static short3 operator +(short a, short3 b) => new short3(a) + b;

    [MethodImpl(256 | 512)]
    public static short3 operator -(short3 a, short3 b)
    {
        return new((short)(a.x - b.x), (short)(a.y - b.y), (short)(a.z - b.z));
    }

    [MethodImpl(256 | 512)]
    public static short3 operator -(short3 a, short b) => a - new short3(b);

    [MethodImpl(256 | 512)]
    public static short3 operator -(short a, short3 b) => new short3(a) - b;

    [MethodImpl(256 | 512)]
    public static short3 operator *(short3 a, short3 b)
    {
        return new((short)(a.x * b.x), (short)(a.y * b.y), (short)(a.z * b.z));
    }

    [MethodImpl(256 | 512)]
    public static short3 operator *(short a, short3 b)
    {
        return new((short)(a * b.x), (short)(a * b.y), (short)(a * b.z));
    }

    [MethodImpl(256 | 512)]
    public static short3 operator *(short3 a, short b)
    {
        return new((short)(a.x * b), (short)(a.y * b), (short)(a.z * b));
    }

    [MethodImpl(256 | 512)]
    public static short3 operator /(short3 a, short3 b)
    {
        return new((short)(a.x / b.x), (short)(a.y / b.y), (short)(a.z / b.z));
    }

    [MethodImpl(256 | 512)]
    public static short3 operator /(short3 a, short b)
    {
        return new((short)(a.x / b), (short)(a.y / b), (short)(a.z / b));
    }

    [MethodImpl(256 | 512)]
    public static short3 operator /(short a, short3 b) => new short3(a) / b;

    [MethodImpl(256 | 512)]
    public static short3 operator %(short3 a, short3 b)
    {
        return new((short)(a.x % b.x), (short)(a.y % b.y), (short)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static short3 operator %(short3 a, short b)
    {
        return new((short)(a.x % b), (short)(a.y % b), (short)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static short3 operator %(short a, short3 b) => new short3(a) % b;

    [MethodImpl(256 | 512)]
    public static short3 operator --(short3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static short3 operator ++(short3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static short3 abs(this short3 a)
    {
        return new(a.x.abs(), a.y.abs(), a.z.abs());
    }

    [MethodImpl(256 | 512)]
    public static short3 sign(this short3 a)
    {
        return new(a.x.sign(), a.y.sign(), a.z.sign());
    }

    [MethodImpl(256 | 512)]
    public static short3 min(this short3 a, short3 b)
    {
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z));
    }

    [MethodImpl(256 | 512)]
    public static short3 max(this short3 a, short3 b)
    {
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z));
    }

    [MethodImpl(256 | 512)]
    public static short3 clamp(this short3 v, short3 min, short3 max)
    {
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z));
    }

    [MethodImpl(256 | 512)]
    public static short3 clamp(this short3 v, short min, short max) => v.clamp(new short3(min), new short3(max));

    [MethodImpl(256 | 512)]
    public static short3 lerp(this short3 t, short3 start, short3 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static short3 lerp(this short t, short3 start, short3 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static short3 lerp(this short3 t, short start, short end)
    {
        return start + t * (short)(end - start);
    }

    [MethodImpl(256 | 512)]
    public static short3 unlerp(this short3 a, short3 start, short3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static short3 unlerp(this short a, short3 start, short3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static short3 unlerp(this short3 a, short start, short end) => (a - start) / (short)(end - start);

    [MethodImpl(256 | 512)]
    public static short3 remap(this short3 a, short3 srcStart, short3 srcEnd, short3 dstStart, short3 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static short3 remap(this short3 a, short srcStart, short srcEnd, short dstStart, short dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static short dot(this short3 a, short3 b)
    {
        return (short)(a.x * b.x + a.y * b.y + a.z * b.z);
    }

    [MethodImpl(256 | 512)]
    public static short3 cross(this short3 a, short3 b) => (a * b.yzx - a.yzx * b).yzx;

    [MethodImpl(256 | 512)]
    public static short lengthsq(this short3 a)
    {
        return a.dot(a);
    }

    [MethodImpl(256 | 512)]
    public static short distancesq(this short3 a, short3 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static short3 square(this short3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static short3 fma(this short3 a, short3 b, short3 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static short3 fms(this short3 a, short3 b, short3 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static short3 fnma(this short3 a, short3 b, short3 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static short3 fsm(this short3 c, short3 a, short3 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static short3 fam(this short3 c, short3 a, short3 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static short3 mad(this short3 a, short3 b, short3 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static short csum(this short3 a)
    {
        return (short)(a.x + a.y + a.z);
    }

    [MethodImpl(256 | 512)]
    public static short cmin(this short3 a)
    {
        return a.x.min(a.y).min(a.z);
    }

    [MethodImpl(256 | 512)]
    public static short cmax(this short3 a)
    {
        return a.x.max(a.y).max(a.z);
    }
}

#endregion // short3

#region short4

public partial struct short4
{
    [MethodImpl(256 | 512)]
    public static short4 operator +(short4 a) => a;
    [MethodImpl(256 | 512)]
    public static short4 operator -(short4 a)
    {
        return new((short)(-a.x), (short)(-a.y), (short)(-a.z), (short)(-a.w));
    }

    [MethodImpl(256 | 512)]
    public static short4 operator +(short4 a, short4 b)
    {
        return new((short)(a.x + b.x), (short)(a.y + b.y), (short)(a.z + b.z), (short)(a.w + b.w));
    }

    [MethodImpl(256 | 512)]
    public static short4 operator +(short4 a, short b) => a + new short4(b);

    [MethodImpl(256 | 512)]
    public static short4 operator +(short a, short4 b) => new short4(a) + b;

    [MethodImpl(256 | 512)]
    public static short4 operator -(short4 a, short4 b)
    {
        return new((short)(a.x - b.x), (short)(a.y - b.y), (short)(a.z - b.z), (short)(a.w - b.w));
    }

    [MethodImpl(256 | 512)]
    public static short4 operator -(short4 a, short b) => a - new short4(b);

    [MethodImpl(256 | 512)]
    public static short4 operator -(short a, short4 b) => new short4(a) - b;

    [MethodImpl(256 | 512)]
    public static short4 operator *(short4 a, short4 b)
    {
        return new((short)(a.x * b.x), (short)(a.y * b.y), (short)(a.z * b.z), (short)(a.w * b.w));
    }

    [MethodImpl(256 | 512)]
    public static short4 operator *(short a, short4 b)
    {
        return new((short)(a * b.x), (short)(a * b.y), (short)(a * b.z), (short)(a * b.w));
    }

    [MethodImpl(256 | 512)]
    public static short4 operator *(short4 a, short b)
    {
        return new((short)(a.x * b), (short)(a.y * b), (short)(a.z * b), (short)(a.w * b));
    }

    [MethodImpl(256 | 512)]
    public static short4 operator /(short4 a, short4 b)
    {
        return new((short)(a.x / b.x), (short)(a.y / b.y), (short)(a.z / b.z), (short)(a.w / b.w));
    }

    [MethodImpl(256 | 512)]
    public static short4 operator /(short4 a, short b)
    {
        return new((short)(a.x / b), (short)(a.y / b), (short)(a.z / b), (short)(a.w / b));
    }

    [MethodImpl(256 | 512)]
    public static short4 operator /(short a, short4 b) => new short4(a) / b;

    [MethodImpl(256 | 512)]
    public static short4 operator %(short4 a, short4 b)
    {
        return new((short)(a.x % b.x), (short)(a.y % b.y), (short)(a.z % b.z), (short)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static short4 operator %(short4 a, short b)
    {
        return new((short)(a.x % b), (short)(a.y % b), (short)(a.z % b), (short)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static short4 operator %(short a, short4 b) => new short4(a) % b;

    [MethodImpl(256 | 512)]
    public static short4 operator --(short4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static short4 operator ++(short4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static short4 abs(this short4 a)
    {
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
    }

    [MethodImpl(256 | 512)]
    public static short4 sign(this short4 a)
    {
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
    }

    [MethodImpl(256 | 512)]
    public static short4 min(this short4 a, short4 b)
    {
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z), a.w.min(b.w));
    }

    [MethodImpl(256 | 512)]
    public static short4 max(this short4 a, short4 b)
    {
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z), a.w.max(b.w));
    }

    [MethodImpl(256 | 512)]
    public static short4 clamp(this short4 v, short4 min, short4 max)
    {
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z), v.w.clamp(min.w, max.w));
    }

    [MethodImpl(256 | 512)]
    public static short4 clamp(this short4 v, short min, short max) => v.clamp(new short4(min), new short4(max));

    [MethodImpl(256 | 512)]
    public static short4 lerp(this short4 t, short4 start, short4 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static short4 lerp(this short t, short4 start, short4 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static short4 lerp(this short4 t, short start, short end)
    {
        return start + t * (short)(end - start);
    }

    [MethodImpl(256 | 512)]
    public static short4 unlerp(this short4 a, short4 start, short4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static short4 unlerp(this short a, short4 start, short4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static short4 unlerp(this short4 a, short start, short end) => (a - start) / (short)(end - start);

    [MethodImpl(256 | 512)]
    public static short4 remap(this short4 a, short4 srcStart, short4 srcEnd, short4 dstStart, short4 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static short4 remap(this short4 a, short srcStart, short srcEnd, short dstStart, short dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static short dot(this short4 a, short4 b)
    {
        return (short)(a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w);
    }

    [MethodImpl(256 | 512)]
    public static short lengthsq(this short4 a)
    {
        return a.dot(a);
    }

    [MethodImpl(256 | 512)]
    public static short distancesq(this short4 a, short4 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static short4 square(this short4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static short4 fma(this short4 a, short4 b, short4 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z), a.w.fma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static short4 fms(this short4 a, short4 b, short4 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z), a.w.fms(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static short4 fnma(this short4 a, short4 b, short4 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z), a.w.fnma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static short4 fsm(this short4 c, short4 a, short4 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static short4 fam(this short4 c, short4 a, short4 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static short4 mad(this short4 a, short4 b, short4 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static short csum(this short4 a)
    {
        return (short)(a.x + a.y + a.z + a.w);
    }

    [MethodImpl(256 | 512)]
    public static short cmin(this short4 a)
    {
        return a.x.min(a.y).min(a.z).min(a.w);
    }

    [MethodImpl(256 | 512)]
    public static short cmax(this short4 a)
    {
        return a.x.max(a.y).max(a.z).max(a.w);
    }
}

#endregion // short4

#region ushort2

public partial struct ushort2
{
    [MethodImpl(256 | 512)]
    public static ushort2 operator +(ushort2 a) => a;

    [MethodImpl(256 | 512)]
    public static ushort2 operator +(ushort2 a, ushort2 b)
    {
        return new((ushort)(a.x + b.x), (ushort)(a.y + b.y));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 operator +(ushort2 a, ushort b) => a + new ushort2(b);

    [MethodImpl(256 | 512)]
    public static ushort2 operator +(ushort a, ushort2 b) => new ushort2(a) + b;

    [MethodImpl(256 | 512)]
    public static ushort2 operator -(ushort2 a, ushort2 b)
    {
        return new((ushort)(a.x - b.x), (ushort)(a.y - b.y));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 operator -(ushort2 a, ushort b) => a - new ushort2(b);

    [MethodImpl(256 | 512)]
    public static ushort2 operator -(ushort a, ushort2 b) => new ushort2(a) - b;

    [MethodImpl(256 | 512)]
    public static ushort2 operator *(ushort2 a, ushort2 b)
    {
        return new((ushort)(a.x * b.x), (ushort)(a.y * b.y));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 operator *(ushort a, ushort2 b)
    {
        return new((ushort)(a * b.x), (ushort)(a * b.y));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 operator *(ushort2 a, ushort b)
    {
        return new((ushort)(a.x * b), (ushort)(a.y * b));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 operator /(ushort2 a, ushort2 b)
    {
        return new((ushort)(a.x / b.x), (ushort)(a.y / b.y));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 operator /(ushort2 a, ushort b)
    {
        return new((ushort)(a.x / b), (ushort)(a.y / b));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 operator /(ushort a, ushort2 b) => new ushort2(a) / b;

    [MethodImpl(256 | 512)]
    public static ushort2 operator %(ushort2 a, ushort2 b)
    {
        return new((ushort)(a.x % b.x), (ushort)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 operator %(ushort2 a, ushort b)
    {
        return new((ushort)(a.x % b), (ushort)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 operator %(ushort a, ushort2 b) => new ushort2(a) % b;

    [MethodImpl(256 | 512)]
    public static ushort2 operator --(ushort2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ushort2 operator ++(ushort2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ushort2 abs(this ushort2 a)
    {
        return new(a.x.abs(), a.y.abs());
    }

    [MethodImpl(256 | 512)]
    public static ushort2 sign(this ushort2 a)
    {
        return new(a.x.sign(), a.y.sign());
    }

    [MethodImpl(256 | 512)]
    public static ushort2 min(this ushort2 a, ushort2 b)
    {
        return new(a.x.min(b.x), a.y.min(b.y));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 max(this ushort2 a, ushort2 b)
    {
        return new(a.x.max(b.x), a.y.max(b.y));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 clamp(this ushort2 v, ushort2 min, ushort2 max)
    {
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 clamp(this ushort2 v, ushort min, ushort max) => v.clamp(new ushort2(min), new ushort2(max));

    [MethodImpl(256 | 512)]
    public static ushort2 lerp(this ushort2 t, ushort2 start, ushort2 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static ushort2 lerp(this ushort t, ushort2 start, ushort2 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static ushort2 lerp(this ushort2 t, ushort start, ushort end)
    {
        return start + t * (ushort)(end - start);
    }

    [MethodImpl(256 | 512)]
    public static ushort2 unlerp(this ushort2 a, ushort2 start, ushort2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ushort2 unlerp(this ushort a, ushort2 start, ushort2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ushort2 unlerp(this ushort2 a, ushort start, ushort end) => (a - start) / (ushort)(end - start);

    [MethodImpl(256 | 512)]
    public static ushort2 remap(this ushort2 a, ushort2 srcStart, ushort2 srcEnd, ushort2 dstStart, ushort2 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ushort2 remap(this ushort2 a, ushort srcStart, ushort srcEnd, ushort dstStart, ushort dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ushort dot(this ushort2 a, ushort2 b)
    {
        return (ushort)(a.x * b.x + a.y * b.y);
    }

    [MethodImpl(256 | 512)]
    public static ushort lengthsq(this ushort2 a)
    {
        return a.dot(a);
    }

    [MethodImpl(256 | 512)]
    public static ushort distancesq(this ushort2 a, ushort2 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static ushort2 square(this ushort2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ushort2 fma(this ushort2 a, ushort2 b, ushort2 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ushort2 fms(this ushort2 a, ushort2 b, ushort2 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ushort2 fnma(this ushort2 a, ushort2 b, ushort2 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ushort2 fsm(this ushort2 c, ushort2 a, ushort2 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ushort2 fam(this ushort2 c, ushort2 a, ushort2 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ushort2 mad(this ushort2 a, ushort2 b, ushort2 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static ushort csum(this ushort2 a)
    {
        return (ushort)(a.x + a.y);
    }

    [MethodImpl(256 | 512)]
    public static ushort cmin(this ushort2 a)
    {
        return a.x.min(a.y);
    }

    [MethodImpl(256 | 512)]
    public static ushort cmax(this ushort2 a)
    {
        return a.x.max(a.y);
    }
}

#endregion // ushort2

#region ushort3

public partial struct ushort3
{
    [MethodImpl(256 | 512)]
    public static ushort3 operator +(ushort3 a) => a;

    [MethodImpl(256 | 512)]
    public static ushort3 operator +(ushort3 a, ushort3 b)
    {
        return new((ushort)(a.x + b.x), (ushort)(a.y + b.y), (ushort)(a.z + b.z));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 operator +(ushort3 a, ushort b) => a + new ushort3(b);

    [MethodImpl(256 | 512)]
    public static ushort3 operator +(ushort a, ushort3 b) => new ushort3(a) + b;

    [MethodImpl(256 | 512)]
    public static ushort3 operator -(ushort3 a, ushort3 b)
    {
        return new((ushort)(a.x - b.x), (ushort)(a.y - b.y), (ushort)(a.z - b.z));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 operator -(ushort3 a, ushort b) => a - new ushort3(b);

    [MethodImpl(256 | 512)]
    public static ushort3 operator -(ushort a, ushort3 b) => new ushort3(a) - b;

    [MethodImpl(256 | 512)]
    public static ushort3 operator *(ushort3 a, ushort3 b)
    {
        return new((ushort)(a.x * b.x), (ushort)(a.y * b.y), (ushort)(a.z * b.z));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 operator *(ushort a, ushort3 b)
    {
        return new((ushort)(a * b.x), (ushort)(a * b.y), (ushort)(a * b.z));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 operator *(ushort3 a, ushort b)
    {
        return new((ushort)(a.x * b), (ushort)(a.y * b), (ushort)(a.z * b));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 operator /(ushort3 a, ushort3 b)
    {
        return new((ushort)(a.x / b.x), (ushort)(a.y / b.y), (ushort)(a.z / b.z));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 operator /(ushort3 a, ushort b)
    {
        return new((ushort)(a.x / b), (ushort)(a.y / b), (ushort)(a.z / b));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 operator /(ushort a, ushort3 b) => new ushort3(a) / b;

    [MethodImpl(256 | 512)]
    public static ushort3 operator %(ushort3 a, ushort3 b)
    {
        return new((ushort)(a.x % b.x), (ushort)(a.y % b.y), (ushort)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 operator %(ushort3 a, ushort b)
    {
        return new((ushort)(a.x % b), (ushort)(a.y % b), (ushort)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 operator %(ushort a, ushort3 b) => new ushort3(a) % b;

    [MethodImpl(256 | 512)]
    public static ushort3 operator --(ushort3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ushort3 operator ++(ushort3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ushort3 abs(this ushort3 a)
    {
        return new(a.x.abs(), a.y.abs(), a.z.abs());
    }

    [MethodImpl(256 | 512)]
    public static ushort3 sign(this ushort3 a)
    {
        return new(a.x.sign(), a.y.sign(), a.z.sign());
    }

    [MethodImpl(256 | 512)]
    public static ushort3 min(this ushort3 a, ushort3 b)
    {
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 max(this ushort3 a, ushort3 b)
    {
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 clamp(this ushort3 v, ushort3 min, ushort3 max)
    {
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 clamp(this ushort3 v, ushort min, ushort max) => v.clamp(new ushort3(min), new ushort3(max));

    [MethodImpl(256 | 512)]
    public static ushort3 lerp(this ushort3 t, ushort3 start, ushort3 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static ushort3 lerp(this ushort t, ushort3 start, ushort3 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static ushort3 lerp(this ushort3 t, ushort start, ushort end)
    {
        return start + t * (ushort)(end - start);
    }

    [MethodImpl(256 | 512)]
    public static ushort3 unlerp(this ushort3 a, ushort3 start, ushort3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ushort3 unlerp(this ushort a, ushort3 start, ushort3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ushort3 unlerp(this ushort3 a, ushort start, ushort end) => (a - start) / (ushort)(end - start);

    [MethodImpl(256 | 512)]
    public static ushort3 remap(this ushort3 a, ushort3 srcStart, ushort3 srcEnd, ushort3 dstStart, ushort3 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ushort3 remap(this ushort3 a, ushort srcStart, ushort srcEnd, ushort dstStart, ushort dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ushort dot(this ushort3 a, ushort3 b)
    {
        return (ushort)(a.x * b.x + a.y * b.y + a.z * b.z);
    }

    [MethodImpl(256 | 512)]
    public static ushort3 cross(this ushort3 a, ushort3 b) => (a * b.yzx - a.yzx * b).yzx;

    [MethodImpl(256 | 512)]
    public static ushort lengthsq(this ushort3 a)
    {
        return a.dot(a);
    }

    [MethodImpl(256 | 512)]
    public static ushort distancesq(this ushort3 a, ushort3 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static ushort3 square(this ushort3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ushort3 fma(this ushort3 a, ushort3 b, ushort3 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ushort3 fms(this ushort3 a, ushort3 b, ushort3 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ushort3 fnma(this ushort3 a, ushort3 b, ushort3 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ushort3 fsm(this ushort3 c, ushort3 a, ushort3 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ushort3 fam(this ushort3 c, ushort3 a, ushort3 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ushort3 mad(this ushort3 a, ushort3 b, ushort3 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static ushort csum(this ushort3 a)
    {
        return (ushort)(a.x + a.y + a.z);
    }

    [MethodImpl(256 | 512)]
    public static ushort cmin(this ushort3 a)
    {
        return a.x.min(a.y).min(a.z);
    }

    [MethodImpl(256 | 512)]
    public static ushort cmax(this ushort3 a)
    {
        return a.x.max(a.y).max(a.z);
    }
}

#endregion // ushort3

#region ushort4

public partial struct ushort4
{
    [MethodImpl(256 | 512)]
    public static ushort4 operator +(ushort4 a) => a;

    [MethodImpl(256 | 512)]
    public static ushort4 operator +(ushort4 a, ushort4 b)
    {
        return new((ushort)(a.x + b.x), (ushort)(a.y + b.y), (ushort)(a.z + b.z), (ushort)(a.w + b.w));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 operator +(ushort4 a, ushort b) => a + new ushort4(b);

    [MethodImpl(256 | 512)]
    public static ushort4 operator +(ushort a, ushort4 b) => new ushort4(a) + b;

    [MethodImpl(256 | 512)]
    public static ushort4 operator -(ushort4 a, ushort4 b)
    {
        return new((ushort)(a.x - b.x), (ushort)(a.y - b.y), (ushort)(a.z - b.z), (ushort)(a.w - b.w));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 operator -(ushort4 a, ushort b) => a - new ushort4(b);

    [MethodImpl(256 | 512)]
    public static ushort4 operator -(ushort a, ushort4 b) => new ushort4(a) - b;

    [MethodImpl(256 | 512)]
    public static ushort4 operator *(ushort4 a, ushort4 b)
    {
        return new((ushort)(a.x * b.x), (ushort)(a.y * b.y), (ushort)(a.z * b.z), (ushort)(a.w * b.w));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 operator *(ushort a, ushort4 b)
    {
        return new((ushort)(a * b.x), (ushort)(a * b.y), (ushort)(a * b.z), (ushort)(a * b.w));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 operator *(ushort4 a, ushort b)
    {
        return new((ushort)(a.x * b), (ushort)(a.y * b), (ushort)(a.z * b), (ushort)(a.w * b));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 operator /(ushort4 a, ushort4 b)
    {
        return new((ushort)(a.x / b.x), (ushort)(a.y / b.y), (ushort)(a.z / b.z), (ushort)(a.w / b.w));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 operator /(ushort4 a, ushort b)
    {
        return new((ushort)(a.x / b), (ushort)(a.y / b), (ushort)(a.z / b), (ushort)(a.w / b));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 operator /(ushort a, ushort4 b) => new ushort4(a) / b;

    [MethodImpl(256 | 512)]
    public static ushort4 operator %(ushort4 a, ushort4 b)
    {
        return new((ushort)(a.x % b.x), (ushort)(a.y % b.y), (ushort)(a.z % b.z), (ushort)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 operator %(ushort4 a, ushort b)
    {
        return new((ushort)(a.x % b), (ushort)(a.y % b), (ushort)(a.z % b), (ushort)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 operator %(ushort a, ushort4 b) => new ushort4(a) % b;

    [MethodImpl(256 | 512)]
    public static ushort4 operator --(ushort4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ushort4 operator ++(ushort4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ushort4 abs(this ushort4 a)
    {
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
    }

    [MethodImpl(256 | 512)]
    public static ushort4 sign(this ushort4 a)
    {
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
    }

    [MethodImpl(256 | 512)]
    public static ushort4 min(this ushort4 a, ushort4 b)
    {
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z), a.w.min(b.w));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 max(this ushort4 a, ushort4 b)
    {
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z), a.w.max(b.w));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 clamp(this ushort4 v, ushort4 min, ushort4 max)
    {
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z), v.w.clamp(min.w, max.w));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 clamp(this ushort4 v, ushort min, ushort max) => v.clamp(new ushort4(min), new ushort4(max));

    [MethodImpl(256 | 512)]
    public static ushort4 lerp(this ushort4 t, ushort4 start, ushort4 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static ushort4 lerp(this ushort t, ushort4 start, ushort4 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static ushort4 lerp(this ushort4 t, ushort start, ushort end)
    {
        return start + t * (ushort)(end - start);
    }

    [MethodImpl(256 | 512)]
    public static ushort4 unlerp(this ushort4 a, ushort4 start, ushort4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ushort4 unlerp(this ushort a, ushort4 start, ushort4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ushort4 unlerp(this ushort4 a, ushort start, ushort end) => (a - start) / (ushort)(end - start);

    [MethodImpl(256 | 512)]
    public static ushort4 remap(this ushort4 a, ushort4 srcStart, ushort4 srcEnd, ushort4 dstStart, ushort4 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ushort4 remap(this ushort4 a, ushort srcStart, ushort srcEnd, ushort dstStart, ushort dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ushort dot(this ushort4 a, ushort4 b)
    {
        return (ushort)(a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w);
    }

    [MethodImpl(256 | 512)]
    public static ushort lengthsq(this ushort4 a)
    {
        return a.dot(a);
    }

    [MethodImpl(256 | 512)]
    public static ushort distancesq(this ushort4 a, ushort4 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static ushort4 square(this ushort4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ushort4 fma(this ushort4 a, ushort4 b, ushort4 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z), a.w.fma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ushort4 fms(this ushort4 a, ushort4 b, ushort4 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z), a.w.fms(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ushort4 fnma(this ushort4 a, ushort4 b, ushort4 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z), a.w.fnma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ushort4 fsm(this ushort4 c, ushort4 a, ushort4 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ushort4 fam(this ushort4 c, ushort4 a, ushort4 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ushort4 mad(this ushort4 a, ushort4 b, ushort4 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static ushort csum(this ushort4 a)
    {
        return (ushort)(a.x + a.y + a.z + a.w);
    }

    [MethodImpl(256 | 512)]
    public static ushort cmin(this ushort4 a)
    {
        return a.x.min(a.y).min(a.z).min(a.w);
    }

    [MethodImpl(256 | 512)]
    public static ushort cmax(this ushort4 a)
    {
        return a.x.max(a.y).max(a.z).max(a.w);
    }
}

#endregion // ushort4

#region int2

public partial struct int2
{
    [MethodImpl(256 | 512)]
    public static int2 operator +(int2 a) => a;
    [MethodImpl(256 | 512)]
    public static int2 operator -(int2 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new((-a.x), (-a.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 operator +(int2 a, int2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x + b.x), (int)(a.y + b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 operator +(int2 a, int b) => a + new int2(b);

    [MethodImpl(256 | 512)]
    public static int2 operator +(int a, int2 b) => new int2(a) + b;

    [MethodImpl(256 | 512)]
    public static int2 operator -(int2 a, int2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x - b.x), (int)(a.y - b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 operator -(int2 a, int b) => a - new int2(b);

    [MethodImpl(256 | 512)]
    public static int2 operator -(int a, int2 b) => new int2(a) - b;

    [MethodImpl(256 | 512)]
    public static int2 operator *(int2 a, int2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x * b.x), (int)(a.y * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 operator *(int a, int2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a * b.x), (int)(a * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 operator *(int2 a, int b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x * b), (int)(a.y * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 operator /(int2 a, int2 b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b.vector));
        #else // NET8_0_OR_GREATER
        return new((int)(a.x / b.x), (int)(a.y / b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 operator /(int2 a, int b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b));
        #else // NET8_0_OR_GREATER
        return new((int)(a.x / b), (int)(a.y / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 operator /(int a, int2 b) => new int2(a) / b;

    [MethodImpl(256 | 512)]
    public static int2 operator %(int2 a, int2 b)
    {
        return new((int)(a.x % b.x), (int)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static int2 operator %(int2 a, int b)
    {
        return new((int)(a.x % b), (int)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static int2 operator %(int a, int2 b) => new int2(a) % b;

    [MethodImpl(256 | 512)]
    public static int2 operator --(int2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static int2 operator ++(int2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int2 abs(this int2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 sign(this int2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignInt(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 min(this int2 a, int2 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 max(this int2 a, int2 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 clamp(this int2 v, int2 min, int2 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Max(min.vector, Vector64.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 clamp(this int2 v, int min, int max) => v.clamp(new int2(min), new int2(max));

    [MethodImpl(256 | 512)]
    public static int2 lerp(this int2 t, int2 start, int2 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 lerp(this int t, int2 start, int2 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(new(t), end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 lerp(this int2 t, int start, int end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, (end - start), new(start));
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 unlerp(this int2 a, int2 start, int2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int2 unlerp(this int a, int2 start, int2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int2 unlerp(this int2 a, int start, int end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int2 remap(this int2 a, int2 srcStart, int2 srcEnd, int2 dstStart, int2 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static int2 remap(this int2 a, int srcStart, int srcEnd, int dstStart, int dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static int dot(this int2 a, int2 b)
    {
        #if NET8_0_OR_GREATER
        return Vector64.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (int)(a.x * b.x + a.y * b.y);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int lengthsq(this int2 a)
    {
        #if NET8_0_OR_GREATER
        return Vector64.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int distancesq(this int2 a, int2 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static int2 square(this int2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int2 fma(this int2 a, int2 b, int2 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static int2 fms(this int2 a, int2 b, int2 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static int2 fnma(this int2 a, int2 b, int2 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static int2 fsm(this int2 c, int2 a, int2 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int2 fam(this int2 c, int2 a, int2 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int2 mad(this int2 a, int2 b, int2 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static int csum(this int2 a)
    {
        #if NET8_0_OR_GREATER
        return Vector64.Sum(a.vector);
        #else // NET8_0_OR_GREATER
        return (a.x + a.y);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int cmin(this int2 a)
    {
        return a.x.min(a.y);
    }

    [MethodImpl(256 | 512)]
    public static int cmax(this int2 a)
    {
        return a.x.max(a.y);
    }
}

#endregion // int2

#region int3

public partial struct int3
{
    [MethodImpl(256 | 512)]
    public static int3 operator +(int3 a) => a;
    [MethodImpl(256 | 512)]
    public static int3 operator -(int3 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector & Vector128.Create(-1, -1, -1, 0).AsInt32());
        #else // NET8_0_OR_GREATER
        return new((-a.x), (-a.y), (-a.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 operator +(int3 a, int3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x + b.x), (int)(a.y + b.y), (int)(a.z + b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 operator +(int3 a, int b) => a + new int3(b);

    [MethodImpl(256 | 512)]
    public static int3 operator +(int a, int3 b) => new int3(a) + b;

    [MethodImpl(256 | 512)]
    public static int3 operator -(int3 a, int3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x - b.x), (int)(a.y - b.y), (int)(a.z - b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 operator -(int3 a, int b) => a - new int3(b);

    [MethodImpl(256 | 512)]
    public static int3 operator -(int a, int3 b) => new int3(a) - b;

    [MethodImpl(256 | 512)]
    public static int3 operator *(int3 a, int3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x * b.x), (int)(a.y * b.y), (int)(a.z * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 operator *(int a, int3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a * b.x), (int)(a * b.y), (int)(a * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 operator *(int3 a, int b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x * b), (int)(a.y * b), (int)(a.z * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 operator /(int3 a, int3 b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b.vector));
        #else // NET8_0_OR_GREATER
        return new((int)(a.x / b.x), (int)(a.y / b.y), (int)(a.z / b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 operator /(int3 a, int b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b));
        #else // NET8_0_OR_GREATER
        return new((int)(a.x / b), (int)(a.y / b), (int)(a.z / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 operator /(int a, int3 b) => new int3(a) / b;

    [MethodImpl(256 | 512)]
    public static int3 operator %(int3 a, int3 b)
    {
        return new((int)(a.x % b.x), (int)(a.y % b.y), (int)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static int3 operator %(int3 a, int b)
    {
        return new((int)(a.x % b), (int)(a.y % b), (int)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static int3 operator %(int a, int3 b) => new int3(a) % b;

    [MethodImpl(256 | 512)]
    public static int3 operator --(int3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static int3 operator ++(int3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int3 abs(this int3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 sign(this int3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignInt(a.vector) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 min(this int3 a, int3 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 max(this int3 a, int3 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 clamp(this int3 v, int3 min, int3 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(min.vector, Vector128.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 clamp(this int3 v, int min, int max) => v.clamp(new int3(min), new int3(max));

    [MethodImpl(256 | 512)]
    public static int3 lerp(this int3 t, int3 start, int3 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 lerp(this int t, int3 start, int3 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(new(t), end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 lerp(this int3 t, int start, int end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, (end - start), new(start));
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 unlerp(this int3 a, int3 start, int3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int3 unlerp(this int a, int3 start, int3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int3 unlerp(this int3 a, int start, int end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int3 remap(this int3 a, int3 srcStart, int3 srcEnd, int3 dstStart, int3 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static int3 remap(this int3 a, int srcStart, int srcEnd, int dstStart, int dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static int dot(this int3 a, int3 b)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (int)(a.x * b.x + a.y * b.y + a.z * b.z);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 cross(this int3 a, int3 b) => (a * b.yzx - a.yzx * b).yzx;

    [MethodImpl(256 | 512)]
    public static int lengthsq(this int3 a)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int distancesq(this int3 a, int3 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static int3 square(this int3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int3 fma(this int3 a, int3 b, int3 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static int3 fms(this int3 a, int3 b, int3 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static int3 fnma(this int3 a, int3 b, int3 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static int3 fsm(this int3 c, int3 a, int3 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int3 fam(this int3 c, int3 a, int3 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int3 mad(this int3 a, int3 b, int3 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static int csum(this int3 a)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Sum(a.vector);
        #else // NET8_0_OR_GREATER
        return (a.x + a.y + a.z);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int cmin(this int3 a)
    {
        return a.x.min(a.y).min(a.z);
    }

    [MethodImpl(256 | 512)]
    public static int cmax(this int3 a)
    {
        return a.x.max(a.y).max(a.z);
    }
}

#endregion // int3

#region int4

public partial struct int4
{
    [MethodImpl(256 | 512)]
    public static int4 operator +(int4 a) => a;
    [MethodImpl(256 | 512)]
    public static int4 operator -(int4 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new((-a.x), (-a.y), (-a.z), (-a.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 operator +(int4 a, int4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x + b.x), (int)(a.y + b.y), (int)(a.z + b.z), (int)(a.w + b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 operator +(int4 a, int b) => a + new int4(b);

    [MethodImpl(256 | 512)]
    public static int4 operator +(int a, int4 b) => new int4(a) + b;

    [MethodImpl(256 | 512)]
    public static int4 operator -(int4 a, int4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x - b.x), (int)(a.y - b.y), (int)(a.z - b.z), (int)(a.w - b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 operator -(int4 a, int b) => a - new int4(b);

    [MethodImpl(256 | 512)]
    public static int4 operator -(int a, int4 b) => new int4(a) - b;

    [MethodImpl(256 | 512)]
    public static int4 operator *(int4 a, int4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x * b.x), (int)(a.y * b.y), (int)(a.z * b.z), (int)(a.w * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 operator *(int a, int4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((int)(a * b.x), (int)(a * b.y), (int)(a * b.z), (int)(a * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 operator *(int4 a, int b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((int)(a.x * b), (int)(a.y * b), (int)(a.z * b), (int)(a.w * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 operator /(int4 a, int4 b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b.vector));
        #else // NET8_0_OR_GREATER
        return new((int)(a.x / b.x), (int)(a.y / b.y), (int)(a.z / b.z), (int)(a.w / b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 operator /(int4 a, int b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b));
        #else // NET8_0_OR_GREATER
        return new((int)(a.x / b), (int)(a.y / b), (int)(a.z / b), (int)(a.w / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 operator /(int a, int4 b) => new int4(a) / b;

    [MethodImpl(256 | 512)]
    public static int4 operator %(int4 a, int4 b)
    {
        return new((int)(a.x % b.x), (int)(a.y % b.y), (int)(a.z % b.z), (int)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static int4 operator %(int4 a, int b)
    {
        return new((int)(a.x % b), (int)(a.y % b), (int)(a.z % b), (int)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static int4 operator %(int a, int4 b) => new int4(a) % b;

    [MethodImpl(256 | 512)]
    public static int4 operator --(int4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static int4 operator ++(int4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int4 abs(this int4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 sign(this int4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignInt(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 min(this int4 a, int4 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z), a.w.min(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 max(this int4 a, int4 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z), a.w.max(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 clamp(this int4 v, int4 min, int4 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(min.vector, Vector128.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z), v.w.clamp(min.w, max.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 clamp(this int4 v, int min, int max) => v.clamp(new int4(min), new int4(max));

    [MethodImpl(256 | 512)]
    public static int4 lerp(this int4 t, int4 start, int4 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 lerp(this int t, int4 start, int4 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(new(t), end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 lerp(this int4 t, int start, int end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, (end - start), new(start));
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 unlerp(this int4 a, int4 start, int4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int4 unlerp(this int a, int4 start, int4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int4 unlerp(this int4 a, int start, int end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int4 remap(this int4 a, int4 srcStart, int4 srcEnd, int4 dstStart, int4 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static int4 remap(this int4 a, int srcStart, int srcEnd, int dstStart, int dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static int dot(this int4 a, int4 b)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (int)(a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int lengthsq(this int4 a)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int distancesq(this int4 a, int4 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static int4 square(this int4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int4 fma(this int4 a, int4 b, int4 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z), a.w.fma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static int4 fms(this int4 a, int4 b, int4 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z), a.w.fms(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static int4 fnma(this int4 a, int4 b, int4 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z), a.w.fnma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static int4 fsm(this int4 c, int4 a, int4 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int4 fam(this int4 c, int4 a, int4 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int4 mad(this int4 a, int4 b, int4 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static int csum(this int4 a)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Sum(a.vector);
        #else // NET8_0_OR_GREATER
        return (a.x + a.y + a.z + a.w);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int cmin(this int4 a)
    {
        return a.x.min(a.y).min(a.z).min(a.w);
    }

    [MethodImpl(256 | 512)]
    public static int cmax(this int4 a)
    {
        return a.x.max(a.y).max(a.z).max(a.w);
    }
}

#endregion // int4

#region uint2

public partial struct uint2
{
    [MethodImpl(256 | 512)]
    public static uint2 operator +(uint2 a) => a;

    [MethodImpl(256 | 512)]
    public static uint2 operator +(uint2 a, uint2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x + b.x), (uint)(a.y + b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator +(uint2 a, uint b) => a + new uint2(b);

    [MethodImpl(256 | 512)]
    public static uint2 operator +(uint a, uint2 b) => new uint2(a) + b;

    [MethodImpl(256 | 512)]
    public static uint2 operator -(uint2 a, uint2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x - b.x), (uint)(a.y - b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator -(uint2 a, uint b) => a - new uint2(b);

    [MethodImpl(256 | 512)]
    public static uint2 operator -(uint a, uint2 b) => new uint2(a) - b;

    [MethodImpl(256 | 512)]
    public static uint2 operator *(uint2 a, uint2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x * b.x), (uint)(a.y * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator *(uint a, uint2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a * b.x), (uint)(a * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator *(uint2 a, uint b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x * b), (uint)(a.y * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator /(uint2 a, uint2 b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b.vector));
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x / b.x), (uint)(a.y / b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator /(uint2 a, uint b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b));
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x / b), (uint)(a.y / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator /(uint a, uint2 b) => new uint2(a) / b;

    [MethodImpl(256 | 512)]
    public static uint2 operator %(uint2 a, uint2 b)
    {
        return new((uint)(a.x % b.x), (uint)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator %(uint2 a, uint b)
    {
        return new((uint)(a.x % b), (uint)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator %(uint a, uint2 b) => new uint2(a) % b;

    [MethodImpl(256 | 512)]
    public static uint2 operator --(uint2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static uint2 operator ++(uint2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint2 abs(this uint2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 sign(this uint2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignUInt(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 min(this uint2 a, uint2 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 max(this uint2 a, uint2 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 clamp(this uint2 v, uint2 min, uint2 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Max(min.vector, Vector64.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 clamp(this uint2 v, uint min, uint max) => v.clamp(new uint2(min), new uint2(max));

    [MethodImpl(256 | 512)]
    public static uint2 lerp(this uint2 t, uint2 start, uint2 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 lerp(this uint t, uint2 start, uint2 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(new(t), end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 lerp(this uint2 t, uint start, uint end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, (end - start), new(start));
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 unlerp(this uint2 a, uint2 start, uint2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint2 unlerp(this uint a, uint2 start, uint2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint2 unlerp(this uint2 a, uint start, uint end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint2 remap(this uint2 a, uint2 srcStart, uint2 srcEnd, uint2 dstStart, uint2 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static uint2 remap(this uint2 a, uint srcStart, uint srcEnd, uint dstStart, uint dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static uint dot(this uint2 a, uint2 b)
    {
        #if NET8_0_OR_GREATER
        return Vector64.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (uint)(a.x * b.x + a.y * b.y);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint lengthsq(this uint2 a)
    {
        #if NET8_0_OR_GREATER
        return Vector64.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint distancesq(this uint2 a, uint2 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static uint2 square(this uint2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint2 fma(this uint2 a, uint2 b, uint2 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static uint2 fms(this uint2 a, uint2 b, uint2 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static uint2 fnma(this uint2 a, uint2 b, uint2 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static uint2 fsm(this uint2 c, uint2 a, uint2 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint2 fam(this uint2 c, uint2 a, uint2 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint2 mad(this uint2 a, uint2 b, uint2 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static uint csum(this uint2 a)
    {
        #if NET8_0_OR_GREATER
        return Vector64.Sum(a.vector);
        #else // NET8_0_OR_GREATER
        return (a.x + a.y);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint cmin(this uint2 a)
    {
        return a.x.min(a.y);
    }

    [MethodImpl(256 | 512)]
    public static uint cmax(this uint2 a)
    {
        return a.x.max(a.y);
    }
}

#endregion // uint2

#region uint3

public partial struct uint3
{
    [MethodImpl(256 | 512)]
    public static uint3 operator +(uint3 a) => a;

    [MethodImpl(256 | 512)]
    public static uint3 operator +(uint3 a, uint3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x + b.x), (uint)(a.y + b.y), (uint)(a.z + b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator +(uint3 a, uint b) => a + new uint3(b);

    [MethodImpl(256 | 512)]
    public static uint3 operator +(uint a, uint3 b) => new uint3(a) + b;

    [MethodImpl(256 | 512)]
    public static uint3 operator -(uint3 a, uint3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x - b.x), (uint)(a.y - b.y), (uint)(a.z - b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator -(uint3 a, uint b) => a - new uint3(b);

    [MethodImpl(256 | 512)]
    public static uint3 operator -(uint a, uint3 b) => new uint3(a) - b;

    [MethodImpl(256 | 512)]
    public static uint3 operator *(uint3 a, uint3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x * b.x), (uint)(a.y * b.y), (uint)(a.z * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator *(uint a, uint3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a * b.x), (uint)(a * b.y), (uint)(a * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator *(uint3 a, uint b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x * b), (uint)(a.y * b), (uint)(a.z * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator /(uint3 a, uint3 b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b.vector));
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x / b.x), (uint)(a.y / b.y), (uint)(a.z / b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator /(uint3 a, uint b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b));
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x / b), (uint)(a.y / b), (uint)(a.z / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator /(uint a, uint3 b) => new uint3(a) / b;

    [MethodImpl(256 | 512)]
    public static uint3 operator %(uint3 a, uint3 b)
    {
        return new((uint)(a.x % b.x), (uint)(a.y % b.y), (uint)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator %(uint3 a, uint b)
    {
        return new((uint)(a.x % b), (uint)(a.y % b), (uint)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator %(uint a, uint3 b) => new uint3(a) % b;

    [MethodImpl(256 | 512)]
    public static uint3 operator --(uint3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static uint3 operator ++(uint3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint3 abs(this uint3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 sign(this uint3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignUInt(a.vector) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 min(this uint3 a, uint3 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 max(this uint3 a, uint3 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 clamp(this uint3 v, uint3 min, uint3 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(min.vector, Vector128.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 clamp(this uint3 v, uint min, uint max) => v.clamp(new uint3(min), new uint3(max));

    [MethodImpl(256 | 512)]
    public static uint3 lerp(this uint3 t, uint3 start, uint3 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 lerp(this uint t, uint3 start, uint3 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(new(t), end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 lerp(this uint3 t, uint start, uint end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, (end - start), new(start));
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 unlerp(this uint3 a, uint3 start, uint3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint3 unlerp(this uint a, uint3 start, uint3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint3 unlerp(this uint3 a, uint start, uint end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint3 remap(this uint3 a, uint3 srcStart, uint3 srcEnd, uint3 dstStart, uint3 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static uint3 remap(this uint3 a, uint srcStart, uint srcEnd, uint dstStart, uint dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static uint dot(this uint3 a, uint3 b)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (uint)(a.x * b.x + a.y * b.y + a.z * b.z);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 cross(this uint3 a, uint3 b) => (a * b.yzx - a.yzx * b).yzx;

    [MethodImpl(256 | 512)]
    public static uint lengthsq(this uint3 a)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint distancesq(this uint3 a, uint3 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static uint3 square(this uint3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint3 fma(this uint3 a, uint3 b, uint3 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static uint3 fms(this uint3 a, uint3 b, uint3 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static uint3 fnma(this uint3 a, uint3 b, uint3 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static uint3 fsm(this uint3 c, uint3 a, uint3 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint3 fam(this uint3 c, uint3 a, uint3 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint3 mad(this uint3 a, uint3 b, uint3 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static uint csum(this uint3 a)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Sum(a.vector);
        #else // NET8_0_OR_GREATER
        return (a.x + a.y + a.z);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint cmin(this uint3 a)
    {
        return a.x.min(a.y).min(a.z);
    }

    [MethodImpl(256 | 512)]
    public static uint cmax(this uint3 a)
    {
        return a.x.max(a.y).max(a.z);
    }
}

#endregion // uint3

#region uint4

public partial struct uint4
{
    [MethodImpl(256 | 512)]
    public static uint4 operator +(uint4 a) => a;

    [MethodImpl(256 | 512)]
    public static uint4 operator +(uint4 a, uint4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x + b.x), (uint)(a.y + b.y), (uint)(a.z + b.z), (uint)(a.w + b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator +(uint4 a, uint b) => a + new uint4(b);

    [MethodImpl(256 | 512)]
    public static uint4 operator +(uint a, uint4 b) => new uint4(a) + b;

    [MethodImpl(256 | 512)]
    public static uint4 operator -(uint4 a, uint4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x - b.x), (uint)(a.y - b.y), (uint)(a.z - b.z), (uint)(a.w - b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator -(uint4 a, uint b) => a - new uint4(b);

    [MethodImpl(256 | 512)]
    public static uint4 operator -(uint a, uint4 b) => new uint4(a) - b;

    [MethodImpl(256 | 512)]
    public static uint4 operator *(uint4 a, uint4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x * b.x), (uint)(a.y * b.y), (uint)(a.z * b.z), (uint)(a.w * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator *(uint a, uint4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((uint)(a * b.x), (uint)(a * b.y), (uint)(a * b.z), (uint)(a * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator *(uint4 a, uint b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x * b), (uint)(a.y * b), (uint)(a.z * b), (uint)(a.w * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator /(uint4 a, uint4 b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b.vector));
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x / b.x), (uint)(a.y / b.y), (uint)(a.z / b.z), (uint)(a.w / b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator /(uint4 a, uint b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b));
        #else // NET8_0_OR_GREATER
        return new((uint)(a.x / b), (uint)(a.y / b), (uint)(a.z / b), (uint)(a.w / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator /(uint a, uint4 b) => new uint4(a) / b;

    [MethodImpl(256 | 512)]
    public static uint4 operator %(uint4 a, uint4 b)
    {
        return new((uint)(a.x % b.x), (uint)(a.y % b.y), (uint)(a.z % b.z), (uint)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator %(uint4 a, uint b)
    {
        return new((uint)(a.x % b), (uint)(a.y % b), (uint)(a.z % b), (uint)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator %(uint a, uint4 b) => new uint4(a) % b;

    [MethodImpl(256 | 512)]
    public static uint4 operator --(uint4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static uint4 operator ++(uint4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint4 abs(this uint4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 sign(this uint4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignUInt(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 min(this uint4 a, uint4 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z), a.w.min(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 max(this uint4 a, uint4 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z), a.w.max(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 clamp(this uint4 v, uint4 min, uint4 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(min.vector, Vector128.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z), v.w.clamp(min.w, max.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 clamp(this uint4 v, uint min, uint max) => v.clamp(new uint4(min), new uint4(max));

    [MethodImpl(256 | 512)]
    public static uint4 lerp(this uint4 t, uint4 start, uint4 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 lerp(this uint t, uint4 start, uint4 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(new(t), end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 lerp(this uint4 t, uint start, uint end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, (end - start), new(start));
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 unlerp(this uint4 a, uint4 start, uint4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint4 unlerp(this uint a, uint4 start, uint4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint4 unlerp(this uint4 a, uint start, uint end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint4 remap(this uint4 a, uint4 srcStart, uint4 srcEnd, uint4 dstStart, uint4 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static uint4 remap(this uint4 a, uint srcStart, uint srcEnd, uint dstStart, uint dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static uint dot(this uint4 a, uint4 b)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (uint)(a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint lengthsq(this uint4 a)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint distancesq(this uint4 a, uint4 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static uint4 square(this uint4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint4 fma(this uint4 a, uint4 b, uint4 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z), a.w.fma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static uint4 fms(this uint4 a, uint4 b, uint4 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z), a.w.fms(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static uint4 fnma(this uint4 a, uint4 b, uint4 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z), a.w.fnma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static uint4 fsm(this uint4 c, uint4 a, uint4 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint4 fam(this uint4 c, uint4 a, uint4 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint4 mad(this uint4 a, uint4 b, uint4 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static uint csum(this uint4 a)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Sum(a.vector);
        #else // NET8_0_OR_GREATER
        return (a.x + a.y + a.z + a.w);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint cmin(this uint4 a)
    {
        return a.x.min(a.y).min(a.z).min(a.w);
    }

    [MethodImpl(256 | 512)]
    public static uint cmax(this uint4 a)
    {
        return a.x.max(a.y).max(a.z).max(a.w);
    }
}

#endregion // uint4

#region long2

public partial struct long2
{
    [MethodImpl(256 | 512)]
    public static long2 operator +(long2 a) => a;
    [MethodImpl(256 | 512)]
    public static long2 operator -(long2 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new((-a.x), (-a.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 operator +(long2 a, long2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x + b.x), (long)(a.y + b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 operator +(long2 a, long b) => a + new long2(b);

    [MethodImpl(256 | 512)]
    public static long2 operator +(long a, long2 b) => new long2(a) + b;

    [MethodImpl(256 | 512)]
    public static long2 operator -(long2 a, long2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x - b.x), (long)(a.y - b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 operator -(long2 a, long b) => a - new long2(b);

    [MethodImpl(256 | 512)]
    public static long2 operator -(long a, long2 b) => new long2(a) - b;

    [MethodImpl(256 | 512)]
    public static long2 operator *(long2 a, long2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x * b.x), (long)(a.y * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 operator *(long a, long2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a * b.x), (long)(a * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 operator *(long2 a, long b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x * b), (long)(a.y * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 operator /(long2 a, long2 b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b.vector));
        #else // NET8_0_OR_GREATER
        return new((long)(a.x / b.x), (long)(a.y / b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 operator /(long2 a, long b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b));
        #else // NET8_0_OR_GREATER
        return new((long)(a.x / b), (long)(a.y / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 operator /(long a, long2 b) => new long2(a) / b;

    [MethodImpl(256 | 512)]
    public static long2 operator %(long2 a, long2 b)
    {
        return new((long)(a.x % b.x), (long)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static long2 operator %(long2 a, long b)
    {
        return new((long)(a.x % b), (long)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static long2 operator %(long a, long2 b) => new long2(a) % b;

    [MethodImpl(256 | 512)]
    public static long2 operator --(long2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static long2 operator ++(long2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long2 abs(this long2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 sign(this long2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignInt(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 min(this long2 a, long2 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 max(this long2 a, long2 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 clamp(this long2 v, long2 min, long2 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(min.vector, Vector128.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 clamp(this long2 v, long min, long max) => v.clamp(new long2(min), new long2(max));

    [MethodImpl(256 | 512)]
    public static long2 lerp(this long2 t, long2 start, long2 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 lerp(this long t, long2 start, long2 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(new(t), end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 lerp(this long2 t, long start, long end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, (end - start), new(start));
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 unlerp(this long2 a, long2 start, long2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long2 unlerp(this long a, long2 start, long2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long2 unlerp(this long2 a, long start, long end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long2 remap(this long2 a, long2 srcStart, long2 srcEnd, long2 dstStart, long2 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static long2 remap(this long2 a, long srcStart, long srcEnd, long dstStart, long dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static long dot(this long2 a, long2 b)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (long)(a.x * b.x + a.y * b.y);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long lengthsq(this long2 a)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long distancesq(this long2 a, long2 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static long2 square(this long2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long2 fma(this long2 a, long2 b, long2 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static long2 fms(this long2 a, long2 b, long2 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static long2 fnma(this long2 a, long2 b, long2 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static long2 fsm(this long2 c, long2 a, long2 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long2 fam(this long2 c, long2 a, long2 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long2 mad(this long2 a, long2 b, long2 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static long csum(this long2 a)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Sum(a.vector);
        #else // NET8_0_OR_GREATER
        return (a.x + a.y);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long cmin(this long2 a)
    {
        return a.x.min(a.y);
    }

    [MethodImpl(256 | 512)]
    public static long cmax(this long2 a)
    {
        return a.x.max(a.y);
    }
}

#endregion // long2

#region long3

public partial struct long3
{
    [MethodImpl(256 | 512)]
    public static long3 operator +(long3 a) => a;
    [MethodImpl(256 | 512)]
    public static long3 operator -(long3 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector & Vector256.Create(-1, -1, -1, 0).AsInt64());
        #else // NET8_0_OR_GREATER
        return new((-a.x), (-a.y), (-a.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 operator +(long3 a, long3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x + b.x), (long)(a.y + b.y), (long)(a.z + b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 operator +(long3 a, long b) => a + new long3(b);

    [MethodImpl(256 | 512)]
    public static long3 operator +(long a, long3 b) => new long3(a) + b;

    [MethodImpl(256 | 512)]
    public static long3 operator -(long3 a, long3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x - b.x), (long)(a.y - b.y), (long)(a.z - b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 operator -(long3 a, long b) => a - new long3(b);

    [MethodImpl(256 | 512)]
    public static long3 operator -(long a, long3 b) => new long3(a) - b;

    [MethodImpl(256 | 512)]
    public static long3 operator *(long3 a, long3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x * b.x), (long)(a.y * b.y), (long)(a.z * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 operator *(long a, long3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a * b.x), (long)(a * b.y), (long)(a * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 operator *(long3 a, long b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x * b), (long)(a.y * b), (long)(a.z * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 operator /(long3 a, long3 b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b.vector));
        #else // NET8_0_OR_GREATER
        return new((long)(a.x / b.x), (long)(a.y / b.y), (long)(a.z / b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 operator /(long3 a, long b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b));
        #else // NET8_0_OR_GREATER
        return new((long)(a.x / b), (long)(a.y / b), (long)(a.z / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 operator /(long a, long3 b) => new long3(a) / b;

    [MethodImpl(256 | 512)]
    public static long3 operator %(long3 a, long3 b)
    {
        return new((long)(a.x % b.x), (long)(a.y % b.y), (long)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static long3 operator %(long3 a, long b)
    {
        return new((long)(a.x % b), (long)(a.y % b), (long)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static long3 operator %(long a, long3 b) => new long3(a) % b;

    [MethodImpl(256 | 512)]
    public static long3 operator --(long3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static long3 operator ++(long3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long3 abs(this long3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 sign(this long3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignInt(a.vector) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 min(this long3 a, long3 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 max(this long3 a, long3 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 clamp(this long3 v, long3 min, long3 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Max(min.vector, Vector256.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 clamp(this long3 v, long min, long max) => v.clamp(new long3(min), new long3(max));

    [MethodImpl(256 | 512)]
    public static long3 lerp(this long3 t, long3 start, long3 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 lerp(this long t, long3 start, long3 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(new(t), end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 lerp(this long3 t, long start, long end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, (end - start), new(start));
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 unlerp(this long3 a, long3 start, long3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long3 unlerp(this long a, long3 start, long3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long3 unlerp(this long3 a, long start, long end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long3 remap(this long3 a, long3 srcStart, long3 srcEnd, long3 dstStart, long3 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static long3 remap(this long3 a, long srcStart, long srcEnd, long dstStart, long dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static long dot(this long3 a, long3 b)
    {
        #if NET8_0_OR_GREATER
        return Vector256.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (long)(a.x * b.x + a.y * b.y + a.z * b.z);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 cross(this long3 a, long3 b) => (a * b.yzx - a.yzx * b).yzx;

    [MethodImpl(256 | 512)]
    public static long lengthsq(this long3 a)
    {
        #if NET8_0_OR_GREATER
        return Vector256.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long distancesq(this long3 a, long3 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static long3 square(this long3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long3 fma(this long3 a, long3 b, long3 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static long3 fms(this long3 a, long3 b, long3 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static long3 fnma(this long3 a, long3 b, long3 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static long3 fsm(this long3 c, long3 a, long3 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long3 fam(this long3 c, long3 a, long3 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long3 mad(this long3 a, long3 b, long3 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static long csum(this long3 a)
    {
        #if NET8_0_OR_GREATER
        return Vector256.Sum(a.vector);
        #else // NET8_0_OR_GREATER
        return (a.x + a.y + a.z);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long cmin(this long3 a)
    {
        return a.x.min(a.y).min(a.z);
    }

    [MethodImpl(256 | 512)]
    public static long cmax(this long3 a)
    {
        return a.x.max(a.y).max(a.z);
    }
}

#endregion // long3

#region long4

public partial struct long4
{
    [MethodImpl(256 | 512)]
    public static long4 operator +(long4 a) => a;
    [MethodImpl(256 | 512)]
    public static long4 operator -(long4 a)
    {
        #if NET8_0_OR_GREATER
        return new(-a.vector);
        #else // NET8_0_OR_GREATER
        return new((-a.x), (-a.y), (-a.z), (-a.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 operator +(long4 a, long4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x + b.x), (long)(a.y + b.y), (long)(a.z + b.z), (long)(a.w + b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 operator +(long4 a, long b) => a + new long4(b);

    [MethodImpl(256 | 512)]
    public static long4 operator +(long a, long4 b) => new long4(a) + b;

    [MethodImpl(256 | 512)]
    public static long4 operator -(long4 a, long4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x - b.x), (long)(a.y - b.y), (long)(a.z - b.z), (long)(a.w - b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 operator -(long4 a, long b) => a - new long4(b);

    [MethodImpl(256 | 512)]
    public static long4 operator -(long a, long4 b) => new long4(a) - b;

    [MethodImpl(256 | 512)]
    public static long4 operator *(long4 a, long4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x * b.x), (long)(a.y * b.y), (long)(a.z * b.z), (long)(a.w * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 operator *(long a, long4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((long)(a * b.x), (long)(a * b.y), (long)(a * b.z), (long)(a * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 operator *(long4 a, long b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((long)(a.x * b), (long)(a.y * b), (long)(a.z * b), (long)(a.w * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 operator /(long4 a, long4 b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b.vector));
        #else // NET8_0_OR_GREATER
        return new((long)(a.x / b.x), (long)(a.y / b.y), (long)(a.z / b.z), (long)(a.w / b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 operator /(long4 a, long b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b));
        #else // NET8_0_OR_GREATER
        return new((long)(a.x / b), (long)(a.y / b), (long)(a.z / b), (long)(a.w / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 operator /(long a, long4 b) => new long4(a) / b;

    [MethodImpl(256 | 512)]
    public static long4 operator %(long4 a, long4 b)
    {
        return new((long)(a.x % b.x), (long)(a.y % b.y), (long)(a.z % b.z), (long)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static long4 operator %(long4 a, long b)
    {
        return new((long)(a.x % b), (long)(a.y % b), (long)(a.z % b), (long)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static long4 operator %(long a, long4 b) => new long4(a) % b;

    [MethodImpl(256 | 512)]
    public static long4 operator --(long4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static long4 operator ++(long4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long4 abs(this long4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 sign(this long4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignInt(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 min(this long4 a, long4 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z), a.w.min(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 max(this long4 a, long4 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z), a.w.max(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 clamp(this long4 v, long4 min, long4 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Max(min.vector, Vector256.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z), v.w.clamp(min.w, max.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 clamp(this long4 v, long min, long max) => v.clamp(new long4(min), new long4(max));

    [MethodImpl(256 | 512)]
    public static long4 lerp(this long4 t, long4 start, long4 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 lerp(this long t, long4 start, long4 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(new(t), end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 lerp(this long4 t, long start, long end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, (end - start), new(start));
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 unlerp(this long4 a, long4 start, long4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long4 unlerp(this long a, long4 start, long4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long4 unlerp(this long4 a, long start, long end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long4 remap(this long4 a, long4 srcStart, long4 srcEnd, long4 dstStart, long4 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static long4 remap(this long4 a, long srcStart, long srcEnd, long dstStart, long dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static long dot(this long4 a, long4 b)
    {
        #if NET8_0_OR_GREATER
        return Vector256.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (long)(a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long lengthsq(this long4 a)
    {
        #if NET8_0_OR_GREATER
        return Vector256.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long distancesq(this long4 a, long4 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static long4 square(this long4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long4 fma(this long4 a, long4 b, long4 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z), a.w.fma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static long4 fms(this long4 a, long4 b, long4 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z), a.w.fms(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static long4 fnma(this long4 a, long4 b, long4 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z), a.w.fnma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static long4 fsm(this long4 c, long4 a, long4 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long4 fam(this long4 c, long4 a, long4 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long4 mad(this long4 a, long4 b, long4 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static long csum(this long4 a)
    {
        #if NET8_0_OR_GREATER
        return Vector256.Sum(a.vector);
        #else // NET8_0_OR_GREATER
        return (a.x + a.y + a.z + a.w);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long cmin(this long4 a)
    {
        return a.x.min(a.y).min(a.z).min(a.w);
    }

    [MethodImpl(256 | 512)]
    public static long cmax(this long4 a)
    {
        return a.x.max(a.y).max(a.z).max(a.w);
    }
}

#endregion // long4

#region ulong2

public partial struct ulong2
{
    [MethodImpl(256 | 512)]
    public static ulong2 operator +(ulong2 a) => a;

    [MethodImpl(256 | 512)]
    public static ulong2 operator +(ulong2 a, ulong2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x + b.x), (ulong)(a.y + b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator +(ulong2 a, ulong b) => a + new ulong2(b);

    [MethodImpl(256 | 512)]
    public static ulong2 operator +(ulong a, ulong2 b) => new ulong2(a) + b;

    [MethodImpl(256 | 512)]
    public static ulong2 operator -(ulong2 a, ulong2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x - b.x), (ulong)(a.y - b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator -(ulong2 a, ulong b) => a - new ulong2(b);

    [MethodImpl(256 | 512)]
    public static ulong2 operator -(ulong a, ulong2 b) => new ulong2(a) - b;

    [MethodImpl(256 | 512)]
    public static ulong2 operator *(ulong2 a, ulong2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x * b.x), (ulong)(a.y * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator *(ulong a, ulong2 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a * b.x), (ulong)(a * b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator *(ulong2 a, ulong b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x * b), (ulong)(a.y * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator /(ulong2 a, ulong2 b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b.vector));
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x / b.x), (ulong)(a.y / b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator /(ulong2 a, ulong b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b));
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x / b), (ulong)(a.y / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator /(ulong a, ulong2 b) => new ulong2(a) / b;

    [MethodImpl(256 | 512)]
    public static ulong2 operator %(ulong2 a, ulong2 b)
    {
        return new((ulong)(a.x % b.x), (ulong)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator %(ulong2 a, ulong b)
    {
        return new((ulong)(a.x % b), (ulong)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator %(ulong a, ulong2 b) => new ulong2(a) % b;

    [MethodImpl(256 | 512)]
    public static ulong2 operator --(ulong2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ulong2 operator ++(ulong2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong2 abs(this ulong2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 sign(this ulong2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignUInt(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 min(this ulong2 a, ulong2 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 max(this ulong2 a, ulong2 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 clamp(this ulong2 v, ulong2 min, ulong2 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Max(min.vector, Vector128.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 clamp(this ulong2 v, ulong min, ulong max) => v.clamp(new ulong2(min), new ulong2(max));

    [MethodImpl(256 | 512)]
    public static ulong2 lerp(this ulong2 t, ulong2 start, ulong2 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 lerp(this ulong t, ulong2 start, ulong2 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(new(t), end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 lerp(this ulong2 t, ulong start, ulong end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, (end - start), new(start));
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 unlerp(this ulong2 a, ulong2 start, ulong2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong2 unlerp(this ulong a, ulong2 start, ulong2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong2 unlerp(this ulong2 a, ulong start, ulong end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong2 remap(this ulong2 a, ulong2 srcStart, ulong2 srcEnd, ulong2 dstStart, ulong2 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ulong2 remap(this ulong2 a, ulong srcStart, ulong srcEnd, ulong dstStart, ulong dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ulong dot(this ulong2 a, ulong2 b)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (ulong)(a.x * b.x + a.y * b.y);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong lengthsq(this ulong2 a)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong distancesq(this ulong2 a, ulong2 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static ulong2 square(this ulong2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong2 fma(this ulong2 a, ulong2 b, ulong2 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ulong2 fms(this ulong2 a, ulong2 b, ulong2 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ulong2 fnma(this ulong2 a, ulong2 b, ulong2 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ulong2 fsm(this ulong2 c, ulong2 a, ulong2 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong2 fam(this ulong2 c, ulong2 a, ulong2 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong2 mad(this ulong2 a, ulong2 b, ulong2 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static ulong csum(this ulong2 a)
    {
        #if NET8_0_OR_GREATER
        return Vector128.Sum(a.vector);
        #else // NET8_0_OR_GREATER
        return (a.x + a.y);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong cmin(this ulong2 a)
    {
        return a.x.min(a.y);
    }

    [MethodImpl(256 | 512)]
    public static ulong cmax(this ulong2 a)
    {
        return a.x.max(a.y);
    }
}

#endregion // ulong2

#region ulong3

public partial struct ulong3
{
    [MethodImpl(256 | 512)]
    public static ulong3 operator +(ulong3 a) => a;

    [MethodImpl(256 | 512)]
    public static ulong3 operator +(ulong3 a, ulong3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x + b.x), (ulong)(a.y + b.y), (ulong)(a.z + b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator +(ulong3 a, ulong b) => a + new ulong3(b);

    [MethodImpl(256 | 512)]
    public static ulong3 operator +(ulong a, ulong3 b) => new ulong3(a) + b;

    [MethodImpl(256 | 512)]
    public static ulong3 operator -(ulong3 a, ulong3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x - b.x), (ulong)(a.y - b.y), (ulong)(a.z - b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator -(ulong3 a, ulong b) => a - new ulong3(b);

    [MethodImpl(256 | 512)]
    public static ulong3 operator -(ulong a, ulong3 b) => new ulong3(a) - b;

    [MethodImpl(256 | 512)]
    public static ulong3 operator *(ulong3 a, ulong3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x * b.x), (ulong)(a.y * b.y), (ulong)(a.z * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator *(ulong a, ulong3 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a * b.x), (ulong)(a * b.y), (ulong)(a * b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator *(ulong3 a, ulong b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x * b), (ulong)(a.y * b), (ulong)(a.z * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator /(ulong3 a, ulong3 b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b.vector));
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x / b.x), (ulong)(a.y / b.y), (ulong)(a.z / b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator /(ulong3 a, ulong b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b));
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x / b), (ulong)(a.y / b), (ulong)(a.z / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator /(ulong a, ulong3 b) => new ulong3(a) / b;

    [MethodImpl(256 | 512)]
    public static ulong3 operator %(ulong3 a, ulong3 b)
    {
        return new((ulong)(a.x % b.x), (ulong)(a.y % b.y), (ulong)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator %(ulong3 a, ulong b)
    {
        return new((ulong)(a.x % b), (ulong)(a.y % b), (ulong)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator %(ulong a, ulong3 b) => new ulong3(a) % b;

    [MethodImpl(256 | 512)]
    public static ulong3 operator --(ulong3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ulong3 operator ++(ulong3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong3 abs(this ulong3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 sign(this ulong3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignUInt(a.vector) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 min(this ulong3 a, ulong3 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 max(this ulong3 a, ulong3 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 clamp(this ulong3 v, ulong3 min, ulong3 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Max(min.vector, Vector256.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 clamp(this ulong3 v, ulong min, ulong max) => v.clamp(new ulong3(min), new ulong3(max));

    [MethodImpl(256 | 512)]
    public static ulong3 lerp(this ulong3 t, ulong3 start, ulong3 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 lerp(this ulong t, ulong3 start, ulong3 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(new(t), end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 lerp(this ulong3 t, ulong start, ulong end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, (end - start), new(start));
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 unlerp(this ulong3 a, ulong3 start, ulong3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong3 unlerp(this ulong a, ulong3 start, ulong3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong3 unlerp(this ulong3 a, ulong start, ulong end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong3 remap(this ulong3 a, ulong3 srcStart, ulong3 srcEnd, ulong3 dstStart, ulong3 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ulong3 remap(this ulong3 a, ulong srcStart, ulong srcEnd, ulong dstStart, ulong dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ulong dot(this ulong3 a, ulong3 b)
    {
        #if NET8_0_OR_GREATER
        return Vector256.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (ulong)(a.x * b.x + a.y * b.y + a.z * b.z);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 cross(this ulong3 a, ulong3 b) => (a * b.yzx - a.yzx * b).yzx;

    [MethodImpl(256 | 512)]
    public static ulong lengthsq(this ulong3 a)
    {
        #if NET8_0_OR_GREATER
        return Vector256.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong distancesq(this ulong3 a, ulong3 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static ulong3 square(this ulong3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong3 fma(this ulong3 a, ulong3 b, ulong3 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ulong3 fms(this ulong3 a, ulong3 b, ulong3 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ulong3 fnma(this ulong3 a, ulong3 b, ulong3 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ulong3 fsm(this ulong3 c, ulong3 a, ulong3 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong3 fam(this ulong3 c, ulong3 a, ulong3 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong3 mad(this ulong3 a, ulong3 b, ulong3 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static ulong csum(this ulong3 a)
    {
        #if NET8_0_OR_GREATER
        return Vector256.Sum(a.vector);
        #else // NET8_0_OR_GREATER
        return (a.x + a.y + a.z);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong cmin(this ulong3 a)
    {
        return a.x.min(a.y).min(a.z);
    }

    [MethodImpl(256 | 512)]
    public static ulong cmax(this ulong3 a)
    {
        return a.x.max(a.y).max(a.z);
    }
}

#endregion // ulong3

#region ulong4

public partial struct ulong4
{
    [MethodImpl(256 | 512)]
    public static ulong4 operator +(ulong4 a) => a;

    [MethodImpl(256 | 512)]
    public static ulong4 operator +(ulong4 a, ulong4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x + b.x), (ulong)(a.y + b.y), (ulong)(a.z + b.z), (ulong)(a.w + b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator +(ulong4 a, ulong b) => a + new ulong4(b);

    [MethodImpl(256 | 512)]
    public static ulong4 operator +(ulong a, ulong4 b) => new ulong4(a) + b;

    [MethodImpl(256 | 512)]
    public static ulong4 operator -(ulong4 a, ulong4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x - b.x), (ulong)(a.y - b.y), (ulong)(a.z - b.z), (ulong)(a.w - b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator -(ulong4 a, ulong b) => a - new ulong4(b);

    [MethodImpl(256 | 512)]
    public static ulong4 operator -(ulong a, ulong4 b) => new ulong4(a) - b;

    [MethodImpl(256 | 512)]
    public static ulong4 operator *(ulong4 a, ulong4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x * b.x), (ulong)(a.y * b.y), (ulong)(a.z * b.z), (ulong)(a.w * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator *(ulong a, ulong4 b)
    {
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a * b.x), (ulong)(a * b.y), (ulong)(a * b.z), (ulong)(a * b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator *(ulong4 a, ulong b)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x * b), (ulong)(a.y * b), (ulong)(a.z * b), (ulong)(a.w * b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator /(ulong4 a, ulong4 b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b.vector));
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x / b.x), (ulong)(a.y / b.y), (ulong)(a.z / b.z), (ulong)(a.w / b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator /(ulong4 a, ulong b)
    {
        #if NET8_0_OR_GREATER
        return new((a.vector / b));
        #else // NET8_0_OR_GREATER
        return new((ulong)(a.x / b), (ulong)(a.y / b), (ulong)(a.z / b), (ulong)(a.w / b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator /(ulong a, ulong4 b) => new ulong4(a) / b;

    [MethodImpl(256 | 512)]
    public static ulong4 operator %(ulong4 a, ulong4 b)
    {
        return new((ulong)(a.x % b.x), (ulong)(a.y % b.y), (ulong)(a.z % b.z), (ulong)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator %(ulong4 a, ulong b)
    {
        return new((ulong)(a.x % b), (ulong)(a.y % b), (ulong)(a.z % b), (ulong)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator %(ulong a, ulong4 b) => new ulong4(a) % b;

    [MethodImpl(256 | 512)]
    public static ulong4 operator --(ulong4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ulong4 operator ++(ulong4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong4 abs(this ulong4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Abs(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 sign(this ulong4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.SignUInt(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 min(this ulong4 a, ulong4 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z), a.w.min(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 max(this ulong4 a, ulong4 b)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z), a.w.max(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 clamp(this ulong4 v, ulong4 min, ulong4 max)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Max(min.vector, Vector256.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z), v.w.clamp(min.w, max.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 clamp(this ulong4 v, ulong min, ulong max) => v.clamp(new ulong4(min), new ulong4(max));

    [MethodImpl(256 | 512)]
    public static ulong4 lerp(this ulong4 t, ulong4 start, ulong4 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 lerp(this ulong t, ulong4 start, ulong4 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(new(t), end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 lerp(this ulong4 t, ulong start, ulong end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, (end - start), new(start));
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 unlerp(this ulong4 a, ulong4 start, ulong4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong4 unlerp(this ulong a, ulong4 start, ulong4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong4 unlerp(this ulong4 a, ulong start, ulong end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong4 remap(this ulong4 a, ulong4 srcStart, ulong4 srcEnd, ulong4 dstStart, ulong4 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ulong4 remap(this ulong4 a, ulong srcStart, ulong srcEnd, ulong dstStart, ulong dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ulong dot(this ulong4 a, ulong4 b)
    {
        #if NET8_0_OR_GREATER
        return Vector256.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
        return (ulong)(a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong lengthsq(this ulong4 a)
    {
        #if NET8_0_OR_GREATER
        return Vector256.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
        return a.dot(a);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong distancesq(this ulong4 a, ulong4 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static ulong4 square(this ulong4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong4 fma(this ulong4 a, ulong4 b, ulong4 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z), a.w.fma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ulong4 fms(this ulong4 a, ulong4 b, ulong4 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z), a.w.fms(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ulong4 fnma(this ulong4 a, ulong4 b, ulong4 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z), a.w.fnma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ulong4 fsm(this ulong4 c, ulong4 a, ulong4 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong4 fam(this ulong4 c, ulong4 a, ulong4 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong4 mad(this ulong4 a, ulong4 b, ulong4 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static ulong csum(this ulong4 a)
    {
        #if NET8_0_OR_GREATER
        return Vector256.Sum(a.vector);
        #else // NET8_0_OR_GREATER
        return (a.x + a.y + a.z + a.w);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong cmin(this ulong4 a)
    {
        return a.x.min(a.y).min(a.z).min(a.w);
    }

    [MethodImpl(256 | 512)]
    public static ulong cmax(this ulong4 a)
    {
        return a.x.max(a.y).max(a.z).max(a.w);
    }
}

#endregion // ulong4

#region decimal2

public partial struct decimal2
{
    [MethodImpl(256 | 512)]
    public static decimal2 operator +(decimal2 a) => a;
    [MethodImpl(256 | 512)]
    public static decimal2 operator -(decimal2 a)
    {
        return new((-a.x), (-a.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator +(decimal2 a, decimal2 b)
    {
        return new((decimal)(a.x + b.x), (decimal)(a.y + b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator +(decimal2 a, decimal b) => a + new decimal2(b);

    [MethodImpl(256 | 512)]
    public static decimal2 operator +(decimal a, decimal2 b) => new decimal2(a) + b;

    [MethodImpl(256 | 512)]
    public static decimal2 operator -(decimal2 a, decimal2 b)
    {
        return new((decimal)(a.x - b.x), (decimal)(a.y - b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator -(decimal2 a, decimal b) => a - new decimal2(b);

    [MethodImpl(256 | 512)]
    public static decimal2 operator -(decimal a, decimal2 b) => new decimal2(a) - b;

    [MethodImpl(256 | 512)]
    public static decimal2 operator *(decimal2 a, decimal2 b)
    {
        return new((decimal)(a.x * b.x), (decimal)(a.y * b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator *(decimal a, decimal2 b)
    {
        return new((decimal)(a * b.x), (decimal)(a * b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator *(decimal2 a, decimal b)
    {
        return new((decimal)(a.x * b), (decimal)(a.y * b));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator /(decimal2 a, decimal2 b)
    {
        return new((decimal)(a.x / b.x), (decimal)(a.y / b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator /(decimal2 a, decimal b)
    {
        return new((decimal)(a.x / b), (decimal)(a.y / b));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator /(decimal a, decimal2 b) => new decimal2(a) / b;

    [MethodImpl(256 | 512)]
    public static decimal2 operator %(decimal2 a, decimal2 b)
    {
        return new((decimal)(a.x % b.x), (decimal)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator %(decimal2 a, decimal b)
    {
        return new((decimal)(a.x % b), (decimal)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator %(decimal a, decimal2 b) => new decimal2(a) % b;

    [MethodImpl(256 | 512)]
    public static decimal2 operator --(decimal2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static decimal2 operator ++(decimal2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static decimal2 abs(this decimal2 a)
    {
        return new(a.x.abs(), a.y.abs());
    }

    [MethodImpl(256 | 512)]
    public static decimal2 sign(this decimal2 a)
    {
        return new(a.x.sign(), a.y.sign());
    }

    [MethodImpl(256 | 512)]
    public static decimal2 min(this decimal2 a, decimal2 b)
    {
        return new(a.x.min(b.x), a.y.min(b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 max(this decimal2 a, decimal2 b)
    {
        return new(a.x.max(b.x), a.y.max(b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 clamp(this decimal2 v, decimal2 min, decimal2 max)
    {
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 clamp(this decimal2 v, decimal min, decimal max) => v.clamp(new decimal2(min), new decimal2(max));

    [MethodImpl(256 | 512)]
    public static decimal2 lerp(this decimal2 t, decimal2 start, decimal2 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static decimal2 lerp(this decimal t, decimal2 start, decimal2 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static decimal2 lerp(this decimal2 t, decimal start, decimal end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static decimal2 unlerp(this decimal2 a, decimal2 start, decimal2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static decimal2 unlerp(this decimal a, decimal2 start, decimal2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static decimal2 unlerp(this decimal2 a, decimal start, decimal end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static decimal2 remap(this decimal2 a, decimal2 srcStart, decimal2 srcEnd, decimal2 dstStart, decimal2 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static decimal2 remap(this decimal2 a, decimal srcStart, decimal srcEnd, decimal dstStart, decimal dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static decimal dot(this decimal2 a, decimal2 b)
    {
        return (decimal)(a.x * b.x + a.y * b.y);
    }

    [MethodImpl(256 | 512)]
    public static decimal lengthsq(this decimal2 a)
    {
        return a.dot(a);
    }

    [MethodImpl(256 | 512)]
    public static decimal distancesq(this decimal2 a, decimal2 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static decimal2 square(this decimal2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static decimal2 fma(this decimal2 a, decimal2 b, decimal2 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static decimal2 fms(this decimal2 a, decimal2 b, decimal2 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static decimal2 fnma(this decimal2 a, decimal2 b, decimal2 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static decimal2 fsm(this decimal2 c, decimal2 a, decimal2 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static decimal2 fam(this decimal2 c, decimal2 a, decimal2 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static decimal2 mad(this decimal2 a, decimal2 b, decimal2 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static decimal csum(this decimal2 a)
    {
        return (a.x + a.y);
    }

    [MethodImpl(256 | 512)]
    public static decimal cmin(this decimal2 a)
    {
        return a.x.min(a.y);
    }

    [MethodImpl(256 | 512)]
    public static decimal cmax(this decimal2 a)
    {
        return a.x.max(a.y);
    }
}

#endregion // decimal2

#region decimal3

public partial struct decimal3
{
    [MethodImpl(256 | 512)]
    public static decimal3 operator +(decimal3 a) => a;
    [MethodImpl(256 | 512)]
    public static decimal3 operator -(decimal3 a)
    {
        return new((-a.x), (-a.y), (-a.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator +(decimal3 a, decimal3 b)
    {
        return new((decimal)(a.x + b.x), (decimal)(a.y + b.y), (decimal)(a.z + b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator +(decimal3 a, decimal b) => a + new decimal3(b);

    [MethodImpl(256 | 512)]
    public static decimal3 operator +(decimal a, decimal3 b) => new decimal3(a) + b;

    [MethodImpl(256 | 512)]
    public static decimal3 operator -(decimal3 a, decimal3 b)
    {
        return new((decimal)(a.x - b.x), (decimal)(a.y - b.y), (decimal)(a.z - b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator -(decimal3 a, decimal b) => a - new decimal3(b);

    [MethodImpl(256 | 512)]
    public static decimal3 operator -(decimal a, decimal3 b) => new decimal3(a) - b;

    [MethodImpl(256 | 512)]
    public static decimal3 operator *(decimal3 a, decimal3 b)
    {
        return new((decimal)(a.x * b.x), (decimal)(a.y * b.y), (decimal)(a.z * b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator *(decimal a, decimal3 b)
    {
        return new((decimal)(a * b.x), (decimal)(a * b.y), (decimal)(a * b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator *(decimal3 a, decimal b)
    {
        return new((decimal)(a.x * b), (decimal)(a.y * b), (decimal)(a.z * b));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator /(decimal3 a, decimal3 b)
    {
        return new((decimal)(a.x / b.x), (decimal)(a.y / b.y), (decimal)(a.z / b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator /(decimal3 a, decimal b)
    {
        return new((decimal)(a.x / b), (decimal)(a.y / b), (decimal)(a.z / b));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator /(decimal a, decimal3 b) => new decimal3(a) / b;

    [MethodImpl(256 | 512)]
    public static decimal3 operator %(decimal3 a, decimal3 b)
    {
        return new((decimal)(a.x % b.x), (decimal)(a.y % b.y), (decimal)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator %(decimal3 a, decimal b)
    {
        return new((decimal)(a.x % b), (decimal)(a.y % b), (decimal)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator %(decimal a, decimal3 b) => new decimal3(a) % b;

    [MethodImpl(256 | 512)]
    public static decimal3 operator --(decimal3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static decimal3 operator ++(decimal3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static decimal3 abs(this decimal3 a)
    {
        return new(a.x.abs(), a.y.abs(), a.z.abs());
    }

    [MethodImpl(256 | 512)]
    public static decimal3 sign(this decimal3 a)
    {
        return new(a.x.sign(), a.y.sign(), a.z.sign());
    }

    [MethodImpl(256 | 512)]
    public static decimal3 min(this decimal3 a, decimal3 b)
    {
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 max(this decimal3 a, decimal3 b)
    {
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 clamp(this decimal3 v, decimal3 min, decimal3 max)
    {
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 clamp(this decimal3 v, decimal min, decimal max) => v.clamp(new decimal3(min), new decimal3(max));

    [MethodImpl(256 | 512)]
    public static decimal3 lerp(this decimal3 t, decimal3 start, decimal3 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static decimal3 lerp(this decimal t, decimal3 start, decimal3 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static decimal3 lerp(this decimal3 t, decimal start, decimal end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static decimal3 unlerp(this decimal3 a, decimal3 start, decimal3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static decimal3 unlerp(this decimal a, decimal3 start, decimal3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static decimal3 unlerp(this decimal3 a, decimal start, decimal end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static decimal3 remap(this decimal3 a, decimal3 srcStart, decimal3 srcEnd, decimal3 dstStart, decimal3 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static decimal3 remap(this decimal3 a, decimal srcStart, decimal srcEnd, decimal dstStart, decimal dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static decimal dot(this decimal3 a, decimal3 b)
    {
        return (decimal)(a.x * b.x + a.y * b.y + a.z * b.z);
    }

    [MethodImpl(256 | 512)]
    public static decimal3 cross(this decimal3 a, decimal3 b) => (a * b.yzx - a.yzx * b).yzx;

    [MethodImpl(256 | 512)]
    public static decimal lengthsq(this decimal3 a)
    {
        return a.dot(a);
    }

    [MethodImpl(256 | 512)]
    public static decimal distancesq(this decimal3 a, decimal3 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static decimal3 square(this decimal3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static decimal3 fma(this decimal3 a, decimal3 b, decimal3 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static decimal3 fms(this decimal3 a, decimal3 b, decimal3 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static decimal3 fnma(this decimal3 a, decimal3 b, decimal3 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static decimal3 fsm(this decimal3 c, decimal3 a, decimal3 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static decimal3 fam(this decimal3 c, decimal3 a, decimal3 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static decimal3 mad(this decimal3 a, decimal3 b, decimal3 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static decimal csum(this decimal3 a)
    {
        return (a.x + a.y + a.z);
    }

    [MethodImpl(256 | 512)]
    public static decimal cmin(this decimal3 a)
    {
        return a.x.min(a.y).min(a.z);
    }

    [MethodImpl(256 | 512)]
    public static decimal cmax(this decimal3 a)
    {
        return a.x.max(a.y).max(a.z);
    }
}

#endregion // decimal3

#region decimal4

public partial struct decimal4
{
    [MethodImpl(256 | 512)]
    public static decimal4 operator +(decimal4 a) => a;
    [MethodImpl(256 | 512)]
    public static decimal4 operator -(decimal4 a)
    {
        return new((-a.x), (-a.y), (-a.z), (-a.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator +(decimal4 a, decimal4 b)
    {
        return new((decimal)(a.x + b.x), (decimal)(a.y + b.y), (decimal)(a.z + b.z), (decimal)(a.w + b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator +(decimal4 a, decimal b) => a + new decimal4(b);

    [MethodImpl(256 | 512)]
    public static decimal4 operator +(decimal a, decimal4 b) => new decimal4(a) + b;

    [MethodImpl(256 | 512)]
    public static decimal4 operator -(decimal4 a, decimal4 b)
    {
        return new((decimal)(a.x - b.x), (decimal)(a.y - b.y), (decimal)(a.z - b.z), (decimal)(a.w - b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator -(decimal4 a, decimal b) => a - new decimal4(b);

    [MethodImpl(256 | 512)]
    public static decimal4 operator -(decimal a, decimal4 b) => new decimal4(a) - b;

    [MethodImpl(256 | 512)]
    public static decimal4 operator *(decimal4 a, decimal4 b)
    {
        return new((decimal)(a.x * b.x), (decimal)(a.y * b.y), (decimal)(a.z * b.z), (decimal)(a.w * b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator *(decimal a, decimal4 b)
    {
        return new((decimal)(a * b.x), (decimal)(a * b.y), (decimal)(a * b.z), (decimal)(a * b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator *(decimal4 a, decimal b)
    {
        return new((decimal)(a.x * b), (decimal)(a.y * b), (decimal)(a.z * b), (decimal)(a.w * b));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator /(decimal4 a, decimal4 b)
    {
        return new((decimal)(a.x / b.x), (decimal)(a.y / b.y), (decimal)(a.z / b.z), (decimal)(a.w / b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator /(decimal4 a, decimal b)
    {
        return new((decimal)(a.x / b), (decimal)(a.y / b), (decimal)(a.z / b), (decimal)(a.w / b));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator /(decimal a, decimal4 b) => new decimal4(a) / b;

    [MethodImpl(256 | 512)]
    public static decimal4 operator %(decimal4 a, decimal4 b)
    {
        return new((decimal)(a.x % b.x), (decimal)(a.y % b.y), (decimal)(a.z % b.z), (decimal)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator %(decimal4 a, decimal b)
    {
        return new((decimal)(a.x % b), (decimal)(a.y % b), (decimal)(a.z % b), (decimal)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator %(decimal a, decimal4 b) => new decimal4(a) % b;

    [MethodImpl(256 | 512)]
    public static decimal4 operator --(decimal4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static decimal4 operator ++(decimal4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static decimal4 abs(this decimal4 a)
    {
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
    }

    [MethodImpl(256 | 512)]
    public static decimal4 sign(this decimal4 a)
    {
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
    }

    [MethodImpl(256 | 512)]
    public static decimal4 min(this decimal4 a, decimal4 b)
    {
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z), a.w.min(b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 max(this decimal4 a, decimal4 b)
    {
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z), a.w.max(b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 clamp(this decimal4 v, decimal4 min, decimal4 max)
    {
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z), v.w.clamp(min.w, max.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 clamp(this decimal4 v, decimal min, decimal max) => v.clamp(new decimal4(min), new decimal4(max));

    [MethodImpl(256 | 512)]
    public static decimal4 lerp(this decimal4 t, decimal4 start, decimal4 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static decimal4 lerp(this decimal t, decimal4 start, decimal4 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static decimal4 lerp(this decimal4 t, decimal start, decimal end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static decimal4 unlerp(this decimal4 a, decimal4 start, decimal4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static decimal4 unlerp(this decimal a, decimal4 start, decimal4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static decimal4 unlerp(this decimal4 a, decimal start, decimal end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static decimal4 remap(this decimal4 a, decimal4 srcStart, decimal4 srcEnd, decimal4 dstStart, decimal4 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static decimal4 remap(this decimal4 a, decimal srcStart, decimal srcEnd, decimal dstStart, decimal dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static decimal dot(this decimal4 a, decimal4 b)
    {
        return (decimal)(a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w);
    }

    [MethodImpl(256 | 512)]
    public static decimal lengthsq(this decimal4 a)
    {
        return a.dot(a);
    }

    [MethodImpl(256 | 512)]
    public static decimal distancesq(this decimal4 a, decimal4 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static decimal4 square(this decimal4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static decimal4 fma(this decimal4 a, decimal4 b, decimal4 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z), a.w.fma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static decimal4 fms(this decimal4 a, decimal4 b, decimal4 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z), a.w.fms(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static decimal4 fnma(this decimal4 a, decimal4 b, decimal4 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z), a.w.fnma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static decimal4 fsm(this decimal4 c, decimal4 a, decimal4 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static decimal4 fam(this decimal4 c, decimal4 a, decimal4 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static decimal4 mad(this decimal4 a, decimal4 b, decimal4 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static decimal csum(this decimal4 a)
    {
        return (a.x + a.y + a.z + a.w);
    }

    [MethodImpl(256 | 512)]
    public static decimal cmin(this decimal4 a)
    {
        return a.x.min(a.y).min(a.z).min(a.w);
    }

    [MethodImpl(256 | 512)]
    public static decimal cmax(this decimal4 a)
    {
        return a.x.max(a.y).max(a.z).max(a.w);
    }
}

#endregion // decimal4

#region half2

public partial struct half2
{
    [MethodImpl(256 | 512)]
    public static half2 operator +(half2 a) => a;
    [MethodImpl(256 | 512)]
    public static half2 operator -(half2 a)
    {
        return new((half)(-a.x), (half)(-a.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator +(half2 a, half2 b)
    {
        return new((half)(a.x + b.x), (half)(a.y + b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator +(half2 a, half b) => a + new half2(b);

    [MethodImpl(256 | 512)]
    public static half2 operator +(half a, half2 b) => new half2(a) + b;

    [MethodImpl(256 | 512)]
    public static half2 operator -(half2 a, half2 b)
    {
        return new((half)(a.x - b.x), (half)(a.y - b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator -(half2 a, half b) => a - new half2(b);

    [MethodImpl(256 | 512)]
    public static half2 operator -(half a, half2 b) => new half2(a) - b;

    [MethodImpl(256 | 512)]
    public static half2 operator *(half2 a, half2 b)
    {
        return new((half)(a.x * b.x), (half)(a.y * b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator *(half a, half2 b)
    {
        return new((half)(a * b.x), (half)(a * b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator *(half2 a, half b)
    {
        return new((half)(a.x * b), (half)(a.y * b));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator /(half2 a, half2 b)
    {
        return new((half)(a.x / b.x), (half)(a.y / b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator /(half2 a, half b)
    {
        return new((half)(a.x / b), (half)(a.y / b));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator /(half a, half2 b) => new half2(a) / b;

    [MethodImpl(256 | 512)]
    public static half2 operator %(half2 a, half2 b)
    {
        return new((half)(a.x % b.x), (half)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator %(half2 a, half b)
    {
        return new((half)(a.x % b), (half)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator %(half a, half2 b) => new half2(a) % b;

    [MethodImpl(256 | 512)]
    public static half2 operator --(half2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static half2 operator ++(half2 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half2 abs(this half2 a)
    {
        return new(a.x.abs(), a.y.abs());
    }

    [MethodImpl(256 | 512)]
    public static half2 sign(this half2 a)
    {
        return new(a.x.sign(), a.y.sign());
    }

    [MethodImpl(256 | 512)]
    public static half2 min(this half2 a, half2 b)
    {
        return new(a.x.min(b.x), a.y.min(b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 max(this half2 a, half2 b)
    {
        return new(a.x.max(b.x), a.y.max(b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 clamp(this half2 v, half2 min, half2 max)
    {
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 clamp(this half2 v, half min, half max) => v.clamp(new half2(min), new half2(max));

    [MethodImpl(256 | 512)]
    public static half2 lerp(this half2 t, half2 start, half2 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static half2 lerp(this half t, half2 start, half2 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static half2 lerp(this half2 t, half start, half end)
    {
        return start + t * (half)(end - start);
    }

    [MethodImpl(256 | 512)]
    public static half2 unlerp(this half2 a, half2 start, half2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static half2 unlerp(this half a, half2 start, half2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static half2 unlerp(this half2 a, half start, half end) => (a - start) / (half)(end - start);

    [MethodImpl(256 | 512)]
    public static half2 remap(this half2 a, half2 srcStart, half2 srcEnd, half2 dstStart, half2 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static half2 remap(this half2 a, half srcStart, half srcEnd, half dstStart, half dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static half dot(this half2 a, half2 b)
    {
        return (half)(a.x * b.x + a.y * b.y);
    }

    [MethodImpl(256 | 512)]
    public static half lengthsq(this half2 a)
    {
        return a.dot(a);
    }

    [MethodImpl(256 | 512)]
    public static half distancesq(this half2 a, half2 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static half2 square(this half2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static half2 fma(this half2 a, half2 b, half2 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static half2 fms(this half2 a, half2 b, half2 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static half2 fnma(this half2 a, half2 b, half2 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static half2 fsm(this half2 c, half2 a, half2 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static half2 fam(this half2 c, half2 a, half2 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static half2 mad(this half2 a, half2 b, half2 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static half csum(this half2 a)
    {
        return (half)(a.x + a.y);
    }

    [MethodImpl(256 | 512)]
    public static half cmin(this half2 a)
    {
        return a.x.min(a.y);
    }

    [MethodImpl(256 | 512)]
    public static half cmax(this half2 a)
    {
        return a.x.max(a.y);
    }
}

#endregion // half2

#region half3

public partial struct half3
{
    [MethodImpl(256 | 512)]
    public static half3 operator +(half3 a) => a;
    [MethodImpl(256 | 512)]
    public static half3 operator -(half3 a)
    {
        return new((half)(-a.x), (half)(-a.y), (half)(-a.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator +(half3 a, half3 b)
    {
        return new((half)(a.x + b.x), (half)(a.y + b.y), (half)(a.z + b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator +(half3 a, half b) => a + new half3(b);

    [MethodImpl(256 | 512)]
    public static half3 operator +(half a, half3 b) => new half3(a) + b;

    [MethodImpl(256 | 512)]
    public static half3 operator -(half3 a, half3 b)
    {
        return new((half)(a.x - b.x), (half)(a.y - b.y), (half)(a.z - b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator -(half3 a, half b) => a - new half3(b);

    [MethodImpl(256 | 512)]
    public static half3 operator -(half a, half3 b) => new half3(a) - b;

    [MethodImpl(256 | 512)]
    public static half3 operator *(half3 a, half3 b)
    {
        return new((half)(a.x * b.x), (half)(a.y * b.y), (half)(a.z * b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator *(half a, half3 b)
    {
        return new((half)(a * b.x), (half)(a * b.y), (half)(a * b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator *(half3 a, half b)
    {
        return new((half)(a.x * b), (half)(a.y * b), (half)(a.z * b));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator /(half3 a, half3 b)
    {
        return new((half)(a.x / b.x), (half)(a.y / b.y), (half)(a.z / b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator /(half3 a, half b)
    {
        return new((half)(a.x / b), (half)(a.y / b), (half)(a.z / b));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator /(half a, half3 b) => new half3(a) / b;

    [MethodImpl(256 | 512)]
    public static half3 operator %(half3 a, half3 b)
    {
        return new((half)(a.x % b.x), (half)(a.y % b.y), (half)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator %(half3 a, half b)
    {
        return new((half)(a.x % b), (half)(a.y % b), (half)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator %(half a, half3 b) => new half3(a) % b;

    [MethodImpl(256 | 512)]
    public static half3 operator --(half3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static half3 operator ++(half3 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half3 abs(this half3 a)
    {
        return new(a.x.abs(), a.y.abs(), a.z.abs());
    }

    [MethodImpl(256 | 512)]
    public static half3 sign(this half3 a)
    {
        return new(a.x.sign(), a.y.sign(), a.z.sign());
    }

    [MethodImpl(256 | 512)]
    public static half3 min(this half3 a, half3 b)
    {
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 max(this half3 a, half3 b)
    {
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 clamp(this half3 v, half3 min, half3 max)
    {
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 clamp(this half3 v, half min, half max) => v.clamp(new half3(min), new half3(max));

    [MethodImpl(256 | 512)]
    public static half3 lerp(this half3 t, half3 start, half3 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static half3 lerp(this half t, half3 start, half3 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static half3 lerp(this half3 t, half start, half end)
    {
        return start + t * (half)(end - start);
    }

    [MethodImpl(256 | 512)]
    public static half3 unlerp(this half3 a, half3 start, half3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static half3 unlerp(this half a, half3 start, half3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static half3 unlerp(this half3 a, half start, half end) => (a - start) / (half)(end - start);

    [MethodImpl(256 | 512)]
    public static half3 remap(this half3 a, half3 srcStart, half3 srcEnd, half3 dstStart, half3 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static half3 remap(this half3 a, half srcStart, half srcEnd, half dstStart, half dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static half dot(this half3 a, half3 b)
    {
        return (half)(a.x * b.x + a.y * b.y + a.z * b.z);
    }

    [MethodImpl(256 | 512)]
    public static half3 cross(this half3 a, half3 b) => (a * b.yzx - a.yzx * b).yzx;

    [MethodImpl(256 | 512)]
    public static half lengthsq(this half3 a)
    {
        return a.dot(a);
    }

    [MethodImpl(256 | 512)]
    public static half distancesq(this half3 a, half3 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static half3 square(this half3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static half3 fma(this half3 a, half3 b, half3 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static half3 fms(this half3 a, half3 b, half3 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static half3 fnma(this half3 a, half3 b, half3 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static half3 fsm(this half3 c, half3 a, half3 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static half3 fam(this half3 c, half3 a, half3 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static half3 mad(this half3 a, half3 b, half3 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static half csum(this half3 a)
    {
        return (half)(a.x + a.y + a.z);
    }

    [MethodImpl(256 | 512)]
    public static half cmin(this half3 a)
    {
        return a.x.min(a.y).min(a.z);
    }

    [MethodImpl(256 | 512)]
    public static half cmax(this half3 a)
    {
        return a.x.max(a.y).max(a.z);
    }
}

#endregion // half3

#region half4

public partial struct half4
{
    [MethodImpl(256 | 512)]
    public static half4 operator +(half4 a) => a;
    [MethodImpl(256 | 512)]
    public static half4 operator -(half4 a)
    {
        return new((half)(-a.x), (half)(-a.y), (half)(-a.z), (half)(-a.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator +(half4 a, half4 b)
    {
        return new((half)(a.x + b.x), (half)(a.y + b.y), (half)(a.z + b.z), (half)(a.w + b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator +(half4 a, half b) => a + new half4(b);

    [MethodImpl(256 | 512)]
    public static half4 operator +(half a, half4 b) => new half4(a) + b;

    [MethodImpl(256 | 512)]
    public static half4 operator -(half4 a, half4 b)
    {
        return new((half)(a.x - b.x), (half)(a.y - b.y), (half)(a.z - b.z), (half)(a.w - b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator -(half4 a, half b) => a - new half4(b);

    [MethodImpl(256 | 512)]
    public static half4 operator -(half a, half4 b) => new half4(a) - b;

    [MethodImpl(256 | 512)]
    public static half4 operator *(half4 a, half4 b)
    {
        return new((half)(a.x * b.x), (half)(a.y * b.y), (half)(a.z * b.z), (half)(a.w * b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator *(half a, half4 b)
    {
        return new((half)(a * b.x), (half)(a * b.y), (half)(a * b.z), (half)(a * b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator *(half4 a, half b)
    {
        return new((half)(a.x * b), (half)(a.y * b), (half)(a.z * b), (half)(a.w * b));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator /(half4 a, half4 b)
    {
        return new((half)(a.x / b.x), (half)(a.y / b.y), (half)(a.z / b.z), (half)(a.w / b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator /(half4 a, half b)
    {
        return new((half)(a.x / b), (half)(a.y / b), (half)(a.z / b), (half)(a.w / b));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator /(half a, half4 b) => new half4(a) / b;

    [MethodImpl(256 | 512)]
    public static half4 operator %(half4 a, half4 b)
    {
        return new((half)(a.x % b.x), (half)(a.y % b.y), (half)(a.z % b.z), (half)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator %(half4 a, half b)
    {
        return new((half)(a.x % b), (half)(a.y % b), (half)(a.z % b), (half)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator %(half a, half4 b) => new half4(a) % b;

    [MethodImpl(256 | 512)]
    public static half4 operator --(half4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static half4 operator ++(half4 a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half4 abs(this half4 a)
    {
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
    }

    [MethodImpl(256 | 512)]
    public static half4 sign(this half4 a)
    {
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
    }

    [MethodImpl(256 | 512)]
    public static half4 min(this half4 a, half4 b)
    {
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z), a.w.min(b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 max(this half4 a, half4 b)
    {
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z), a.w.max(b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 clamp(this half4 v, half4 min, half4 max)
    {
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z), v.w.clamp(min.w, max.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 clamp(this half4 v, half min, half max) => v.clamp(new half4(min), new half4(max));

    [MethodImpl(256 | 512)]
    public static half4 lerp(this half4 t, half4 start, half4 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static half4 lerp(this half t, half4 start, half4 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static half4 lerp(this half4 t, half start, half end)
    {
        return start + t * (half)(end - start);
    }

    [MethodImpl(256 | 512)]
    public static half4 unlerp(this half4 a, half4 start, half4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static half4 unlerp(this half a, half4 start, half4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static half4 unlerp(this half4 a, half start, half end) => (a - start) / (half)(end - start);

    [MethodImpl(256 | 512)]
    public static half4 remap(this half4 a, half4 srcStart, half4 srcEnd, half4 dstStart, half4 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static half4 remap(this half4 a, half srcStart, half srcEnd, half dstStart, half dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static half dot(this half4 a, half4 b)
    {
        return (half)(a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w);
    }

    [MethodImpl(256 | 512)]
    public static half lengthsq(this half4 a)
    {
        return a.dot(a);
    }

    [MethodImpl(256 | 512)]
    public static half distancesq(this half4 a, half4 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static half4 square(this half4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static half4 fma(this half4 a, half4 b, half4 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z), a.w.fma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static half4 fms(this half4 a, half4 b, half4 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z), a.w.fms(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static half4 fnma(this half4 a, half4 b, half4 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z), a.w.fnma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static half4 fsm(this half4 c, half4 a, half4 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static half4 fam(this half4 c, half4 a, half4 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static half4 mad(this half4 a, half4 b, half4 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static half csum(this half4 a)
    {
        return (half)(a.x + a.y + a.z + a.w);
    }

    [MethodImpl(256 | 512)]
    public static half cmin(this half4 a)
    {
        return a.x.min(a.y).min(a.z).min(a.w);
    }

    [MethodImpl(256 | 512)]
    public static half cmax(this half4 a)
    {
        return a.x.max(a.y).max(a.z).max(a.w);
    }
}

#endregion // half4
