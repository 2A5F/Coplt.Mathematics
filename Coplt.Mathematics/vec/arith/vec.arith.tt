<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="../../types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics;
<#
    foreach (var typ in Typ.Typs)
    {
        if (!typ.arith) continue;

        for (var i = 2; i <= 4; i++)
        {
            var typeName = $"{typ.name}{i}";

            var byteSize = typ.size * (i is 3 ? 4 : i);
            var bitSize = 8 * byteSize;
#>

#region <#= typeName #>

public partial struct <#= typeName #>
{
    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator +(<#= typeName #> a) => a;
<#
            if (typ.sig)
            {
#>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator -(<#= typeName #> a)
    {
<#
                if (typ.simd)
                {
#>
        #if NET8_0_OR_GREATER
        return new(-a.vector<#
                    if (i == 3)
                    {
#> & Vector<#= bitSize #>.Create(-1, -1, -1, 0).As<#= typ.Type #>()<#
                    }
#>);
        #else // NET8_0_OR_GREATER
<#
                }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"{typ.arithCast}(-a.{Typ.xyzw[n]})")) #>);
<#
                if (typ.simd)
                {
#>
        #endif // NET8_0_OR_GREATER
<#
                }
#>
    }
<#
            }
#>

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator +(<#= typeName #> a, <#= typeName #> b)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"({typ.compType})(a.{Typ.xyzw[n]} + b.{Typ.xyzw[n]})")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator +(<#= typeName #> a, <#= typ.compType #> b) => a + new <#= typeName #>(b);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator +(<#= typ.compType #> a, <#= typeName #> b) => new <#= typeName #>(a) + b;

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator -(<#= typeName #> a, <#= typeName #> b)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"({typ.compType})(a.{Typ.xyzw[n]} - b.{Typ.xyzw[n]})")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator -(<#= typeName #> a, <#= typ.compType #> b) => a - new <#= typeName #>(b);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator -(<#= typ.compType #> a, <#= typeName #> b) => new <#= typeName #>(a) - b;

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator *(<#= typeName #> a, <#= typeName #> b)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"({typ.compType})(a.{Typ.xyzw[n]} * b.{Typ.xyzw[n]})")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator *(<#= typ.compType #> a, <#= typeName #> b)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"({typ.compType})(a * b.{Typ.xyzw[n]})")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator *(<#= typeName #> a, <#= typ.compType #> b)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"({typ.compType})(a.{Typ.xyzw[n]} * b)")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator /(<#= typeName #> a, <#= typeName #> b)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new((a.vector / b.vector)<#
                if (i == 3 && typ.f)
                {
#> & Vector<#= bitSize #>.Create(-1, -1, -1, 0).As<#= typ.Type #>()<#
                }
#>);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"({typ.compType})(a.{Typ.xyzw[n]} / b.{Typ.xyzw[n]})")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator /(<#= typeName #> a, <#= typ.compType #> b)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new((a.vector / b)<#
                if (i == 3 && typ.f)
                {
#> & Vector<#= bitSize #>.Create(-1, -1, -1, 0).As<#= typ.Type #>()<#
                }
#>);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"({typ.compType})(a.{Typ.xyzw[n]} / b)")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator /(<#= typ.compType #> a, <#= typeName #> b) => new <#= typeName #>(a) / b;

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator %(<#= typeName #> a, <#= typeName #> b)
    {
<#
            if (typ.simd && typ.f)
            {
#>
        #if NET8_0_OR_GREATER
        return new(simd.Rem(a.vector, b.vector)<#
                if (i == 3 && typ.f)
                {
#> & Vector<#= bitSize #>.Create(-1, -1, -1, 0).As<#= typ.Type #>()<#
                }
#>);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"({typ.compType})(a.{Typ.xyzw[n]} % b.{Typ.xyzw[n]})")) #>);
<#
            if (typ.simd && typ.f)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator %(<#= typeName #> a, <#= typ.compType #> b)
    {
<#
            if (typ.simd && typ.f)
            {
#>
        #if NET8_0_OR_GREATER
        return new(simd.Rem(a.vector, b)<#
                if (i == 3 && typ.f)
                {
#> & Vector<#= bitSize #>.Create(-1, -1, -1, 0).As<#= typ.Type #>()<#
                }
#>);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"({typ.compType})(a.{Typ.xyzw[n]} % b)")) #>);
<#
            if (typ.simd && typ.f)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator %(<#= typ.compType #> a, <#= typeName #> b) => new <#= typeName #>(a) % b;

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator --(<#= typeName #> a) => a - One;

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator ++(<#= typeName #> a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static <#= typeName #> abs(this <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(Vector<#= bitSize #>.Abs(a.vector));
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.abs()")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> sign(this <#= typeName #> a)
    {
<#
            if (typ.simd && (typ.f || typ.i))
            {
#>
        #if NET8_0_OR_GREATER
        return new(<#
                if (typ.f)
                {
#>simd.SignFloat(a.vector)<#
                }
                else if (typ.sig)
                {
#>simd.SignInt(a.vector)<#
                }
                else
                {
#>simd.SignUInt(a.vector)<#
                }
#><#
                if (i == 3)
                {
#> & Vector<#= bitSize #>.Create(-1, -1, -1, 0).As<#= typ.Type #>()<#
                }
#>);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.sign()")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> min(this <#= typeName #> a, <#= typeName #> b)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(Vector<#= bitSize #>.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.min(b.{Typ.xyzw[n]})")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> max(this <#= typeName #> a, <#= typeName #> b)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(Vector<#= bitSize #>.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.max(b.{Typ.xyzw[n]})")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> clamp(this <#= typeName #> v, <#= typeName #> min, <#= typeName #> max)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(Vector<#= bitSize #>.Max(min.vector, Vector<#= bitSize #>.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"v.{Typ.xyzw[n]}.clamp(min.{Typ.xyzw[n]}, max.{Typ.xyzw[n]})")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> clamp(this <#= typeName #> v, <#= typ.simdComp #> min, <#= typ.simdComp #> max) => v.clamp(new <#= typeName #>(min), new <#= typeName #>(max));

    [MethodImpl(256 | 512)]
    public static <#= typeName #> lerp(this <#= typeName #> t, <#= typeName #> start, <#= typeName #> end)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, end - start, start);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return start + t * (end - start);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> lerp(this <#= typ.simdComp #> t, <#= typeName #> start, <#= typeName #> end)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(new(t), end - start, start);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return start + t * (end - start);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> lerp(this <#= typeName #> t, <#= typ.simdComp #> start, <#= typ.simdComp #> end)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, <#= typ.arithCast #>(end - start), new(start));
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return start + t * <#= typ.arithCast #>(end - start);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> unlerp(this <#= typeName #> a, <#= typeName #> start, <#= typeName #> end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> unlerp(this <#= typ.simdComp #> a, <#= typeName #> start, <#= typeName #> end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> unlerp(this <#= typeName #> a, <#= typ.simdComp #> start, <#= typ.simdComp #> end) => (a - start) / <#= typ.arithCast #>(end - start);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> remap(this <#= typeName #> a, <#= typeName #> srcStart, <#= typeName #> srcEnd, <#= typeName #> dstStart, <#= typeName #> dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> remap(this <#= typeName #> a, <#= typ.simdComp #> srcStart, <#= typ.simdComp #> srcEnd, <#= typ.simdComp #> dstStart, <#= typ.simdComp #> dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static <#= typ.simdComp #> dot(this <#= typeName #> a, <#= typeName #> b)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return Vector<#= bitSize #>.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return (<#= typ.simdComp #>)(<#= string.Join(" + ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]} * b.{Typ.xyzw[n]}")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }
<#
            if (i == 3)
            {
#>

    [MethodImpl(256 | 512)]
    public static <#= typeName #> cross(this <#= typeName #> a, <#= typeName #> b) => (a * b.yzx - a.yzx * b).yzx;
<#
            }
#>

    [MethodImpl(256 | 512)]
    public static <#= typ.simdComp #> lengthsq(this <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return Vector<#= bitSize #>.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return a.dot(a);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typ.simdComp #> distancesq(this <#= typeName #> a, <#= typeName #> b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> square(this <#= typeName #> a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> fma(this <#= typeName #> a, <#= typeName #> b, <#= typeName #> c)
    {
<#
            if (typ.simd && typ.f && typ.bin)
            {
#>
        #if NET8_0_OR_GREATER
        return new(simd.Fma(a.vector, b.vector, c.vector));
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.fma(b.{Typ.xyzw[n]}, c.{Typ.xyzw[n]})")) #>);
<#
            if (typ.simd && typ.f && typ.bin)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> fms(this <#= typeName #> a, <#= typeName #> b, <#= typeName #> c)
    {
<#
            if (typ.simd && typ.f && typ.bin)
            {
#>
        #if NET8_0_OR_GREATER
        return new(simd.Fms(a.vector, b.vector, c.vector));
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.fms(b.{Typ.xyzw[n]}, c.{Typ.xyzw[n]})")) #>);
<#
            if (typ.simd && typ.f && typ.bin)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> fnma(this <#= typeName #> a, <#= typeName #> b, <#= typeName #> c)
    {
<#
            if (typ.simd && typ.f && typ.bin)
            {
#>
        #if NET8_0_OR_GREATER
        return new(simd.Fnma(a.vector, b.vector, c.vector));
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.fnma(b.{Typ.xyzw[n]}, c.{Typ.xyzw[n]})")) #>);
<#
            if (typ.simd && typ.f && typ.bin)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> fsm(this <#= typeName #> c, <#= typeName #> a, <#= typeName #> b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> fam(this <#= typeName #> c, <#= typeName #> a, <#= typeName #> b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> mad(this <#= typeName #> a, <#= typeName #> b, <#= typeName #> c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static <#= typ.compType #> csum(this <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return Vector<#= bitSize #>.Sum(a.vector);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return <#= typ.arithCast #>(<#= string.Join(" + ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typ.compType #> cmin(this <#= typeName #> a)
    {
        return a.x<#= string.Join("", Enumerable.Range(1, i - 1).Select(n => $".min(a.{Typ.xyzw[n]})")) #>;
    }

    [MethodImpl(256 | 512)]
    public static <#= typ.compType #> cmax(this <#= typeName #> a)
    {
        return a.x<#= string.Join("", Enumerable.Range(1, i - 1).Select(n => $".max(a.{Typ.xyzw[n]})")) #>;
    }
}

#endregion // <#= typeName #>
<#
        }
    }
#>
