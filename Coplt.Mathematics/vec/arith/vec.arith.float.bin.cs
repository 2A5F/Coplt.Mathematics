// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region float2

public static partial class math
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b32v2 isNaN(this float2 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static b32v2 isFinite(this float2 a) => abs(a) < float.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static b32v2 isInf(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.IsInfinity(a.vector).AsUInt32());
        #else // NET8_0_OR_GREATER
        return new(a.x.isInf(), a.y.isInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b32v2 isPosInf(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Equals(a.vector, Vector64.Create(float.PositiveInfinity)).AsUInt32());
        #else // NET8_0_OR_GREATER
        return new(a.x.isPosInf(), a.y.isPosInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b32v2 isNegInf(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Equals(a.vector, Vector64.Create(float.NegativeInfinity)).AsUInt32());
        #else // NET8_0_OR_GREATER
        return new(a.x.isNegInf(), a.y.isNegInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 log(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log(), a.y.log());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 log2(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log2(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log2(), a.y.log2());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 log(this float2 a, float2 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log(a.vector) / simd.Log(b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log(b.x), a.y.log(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 log10(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log10(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log10(), a.y.log10());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 exp(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Exp(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.exp(), a.y.exp());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 exp2(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Exp2(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.exp2(), a.y.exp2());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 exp10(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Exp10(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.exp10(), a.y.exp10());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 pow(this float2 a, float2 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Pow(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.pow(b.x), a.y.pow(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 pow(this float2 a, float b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Pow(a.vector, b));
        #else // NET8_0_OR_GREATER
        return new(a.x.pow(b), a.y.pow(b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 sqrt(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Sqrt(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sqrt(), a.y.sqrt());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 rsqrt(this float2 a) => float2.One / sqrt(a);

    [MethodImpl(256 | 512)]
    public static float length(this float2 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static float distance(this float2 a, float2 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static float2 normalize(this float2 a) => a * dot(a, a).rsqrt();

    [MethodImpl(256 | 512)]
    public static float2 normalizeSafe(this float2 a, float2 defaultvalue = default)
    {
        var len = dot(a, a);
        return select(len > 1.175494351e-38f, a * rsqrt(len), defaultvalue);
    }

    [MethodImpl(256 | 512)]
    public static float2 step(this float2 a, float2 threshold) =>
        select(a >= threshold, float2.One, default);

    [MethodImpl(256 | 512)]
    public static float2 refract(this float2 i, float2 n, float indexOfRefraction)
    {
        var ni = dot(n, i);
        var k = (float)(1.0f - indexOfRefraction * indexOfRefraction * (1.0f - ni * ni));
        return select(k >= 0.0f, indexOfRefraction * i - (float)((float)(indexOfRefraction * ni) + sqrt(k)) * n, default);
    }

    [MethodImpl(256 | 512)]
    public static float2 projectSafe(this float2 a, float2 onto, float2 defaultValue = default) 
    {
        var proj = project(a, onto);
        return select(all(isFinite(proj)), proj, defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static float2 faceForward(this float2 n, float2 i, float2 ng) =>
        select(dot(ng, i) >= 0.0f, -n, n);

    [MethodImpl(256 | 512)]
    public static float2 sin(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Sin(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sin(), a.y.sin());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 cos(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Cos(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.cos(), a.y.cos());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static (float2 sin, float2 cos) sincos(this float2 a)
    {
        #if NET8_0_OR_GREATER
        var (sin, cos) = simd.SinCos(a.vector);
        return (new(sin), new(cos));
        #else // NET8_0_OR_GREATER
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        return (
            new(sin0, sin1),
            new(cos0, cos1)
        );
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static void sincos(this float2 a, out float2 sin, out float2 cos)
    {
        #if NET8_0_OR_GREATER
        var (v_sin, v_cos) = simd.SinCos(a.vector);
        sin = new(v_sin);
        cos = new(v_cos);
        #else // NET8_0_OR_GREATER
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        sin = new(sin0, sin1);
        cos = new(cos0, cos1);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 tan(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Tan(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.tan(), a.y.tan());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 asin(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Asin(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.asin(), a.y.asin());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 acos(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Acos(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.acos(), a.y.acos());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 atan(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Atan(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.atan(), a.y.atan());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 atan2(this float2 a, float2 b)
    {
        #if NET8_0_OR_GREATER && false // todo
        return new(simd.Atan2(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.atan2(b.x), a.y.atan2(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 sinh(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Sinh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sinh(), a.y.sinh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 cosh(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Cosh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.cosh(), a.y.cosh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 tanh(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Tanh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.tanh(), a.y.tanh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 asinh(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Asinh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.asinh(), a.y.asinh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 acosh(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Acosh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.acosh(), a.y.acosh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 atanh(this float2 a)
    {
        #if NET8_0_OR_GREATER && false // todo
        return new(simd.Atanh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.atanh(), a.y.atanh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 chgsign(this float2 a, float2 b)
    {
        var sig = new uint2(0x8000_0000).asf();
        return (b & sig) ^ a;
    }

}

#endregion // float2

#region float3

public static partial class math
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b32v3 isNaN(this float3 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static b32v3 isFinite(this float3 a) => abs(a) < float.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static b32v3 isInf(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.IsInfinity(a.vector).AsUInt32());
        #else // NET8_0_OR_GREATER
        return new(a.x.isInf(), a.y.isInf(), a.z.isInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b32v3 isPosInf(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Equals(a.vector, Vector128.Create(float.PositiveInfinity)).AsUInt32());
        #else // NET8_0_OR_GREATER
        return new(a.x.isPosInf(), a.y.isPosInf(), a.z.isPosInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b32v3 isNegInf(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Equals(a.vector, Vector128.Create(float.NegativeInfinity)).AsUInt32());
        #else // NET8_0_OR_GREATER
        return new(a.x.isNegInf(), a.y.isNegInf(), a.z.isNegInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 log(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log(), a.y.log(), a.z.log());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 log2(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log2(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log2(), a.y.log2(), a.z.log2());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 log(this float3 a, float3 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log(a.vector) / simd.Log(b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log(b.x), a.y.log(b.y), a.z.log(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 log10(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log10(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log10(), a.y.log10(), a.z.log10());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 exp(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Exp(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.exp(), a.y.exp(), a.z.exp());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 exp2(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Exp2(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.exp2(), a.y.exp2(), a.z.exp2());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 exp10(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Exp10(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.exp10(), a.y.exp10(), a.z.exp10());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 pow(this float3 a, float3 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Pow(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.pow(b.x), a.y.pow(b.y), a.z.pow(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 pow(this float3 a, float b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Pow(a.vector, b));
        #else // NET8_0_OR_GREATER
        return new(a.x.pow(b), a.y.pow(b), a.z.pow(b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 sqrt(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Sqrt(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sqrt(), a.y.sqrt(), a.z.sqrt());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 rsqrt(this float3 a) => float3.One / sqrt(a);

    [MethodImpl(256 | 512)]
    public static float length(this float3 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static float distance(this float3 a, float3 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static float3 normalize(this float3 a) => a * dot(a, a).rsqrt();

    [MethodImpl(256 | 512)]
    public static float3 normalizeSafe(this float3 a, float3 defaultvalue = default)
    {
        var len = dot(a, a);
        return select(len > 1.175494351e-38f, a * rsqrt(len), defaultvalue);
    }

    [MethodImpl(256 | 512)]
    public static float3 step(this float3 a, float3 threshold) =>
        select(a >= threshold, float3.One, default);

    [MethodImpl(256 | 512)]
    public static float3 refract(this float3 i, float3 n, float indexOfRefraction)
    {
        var ni = dot(n, i);
        var k = (float)(1.0f - indexOfRefraction * indexOfRefraction * (1.0f - ni * ni));
        return select(k >= 0.0f, indexOfRefraction * i - (float)((float)(indexOfRefraction * ni) + sqrt(k)) * n, default);
    }

    [MethodImpl(256 | 512)]
    public static float3 projectSafe(this float3 a, float3 onto, float3 defaultValue = default) 
    {
        var proj = project(a, onto);
        return select(all(isFinite(proj)), proj, defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static float3 faceForward(this float3 n, float3 i, float3 ng) =>
        select(dot(ng, i) >= 0.0f, -n, n);

    [MethodImpl(256 | 512)]
    public static float3 sin(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Sin(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sin(), a.y.sin(), a.z.sin());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 cos(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Cos(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.cos(), a.y.cos(), a.z.cos());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static (float3 sin, float3 cos) sincos(this float3 a)
    {
        #if NET8_0_OR_GREATER
        var (sin, cos) = simd.SinCos(a.vector);
        return (new(sin), new(cos));
        #else // NET8_0_OR_GREATER
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        a.z.sincos(out var sin2, out var cos2);
        return (
            new(sin0, sin1, sin2),
            new(cos0, cos1, cos2)
        );
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static void sincos(this float3 a, out float3 sin, out float3 cos)
    {
        #if NET8_0_OR_GREATER
        var (v_sin, v_cos) = simd.SinCos(a.vector);
        sin = new(v_sin);
        cos = new(v_cos);
        #else // NET8_0_OR_GREATER
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        a.z.sincos(out var sin2, out var cos2);
        sin = new(sin0, sin1, sin2);
        cos = new(cos0, cos1, cos2);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 tan(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Tan(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.tan(), a.y.tan(), a.z.tan());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 asin(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Asin(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.asin(), a.y.asin(), a.z.asin());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 acos(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Acos(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.acos(), a.y.acos(), a.z.acos());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 atan(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Atan(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.atan(), a.y.atan(), a.z.atan());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 atan2(this float3 a, float3 b)
    {
        #if NET8_0_OR_GREATER && false // todo
        return new(simd.Atan2(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.atan2(b.x), a.y.atan2(b.y), a.z.atan2(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 sinh(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Sinh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sinh(), a.y.sinh(), a.z.sinh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 cosh(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Cosh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.cosh(), a.y.cosh(), a.z.cosh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 tanh(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Tanh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.tanh(), a.y.tanh(), a.z.tanh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 asinh(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Asinh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.asinh(), a.y.asinh(), a.z.asinh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 acosh(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Acosh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.acosh(), a.y.acosh(), a.z.acosh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 atanh(this float3 a)
    {
        #if NET8_0_OR_GREATER && false // todo
        return new(simd.Atanh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.atanh(), a.y.atanh(), a.z.atanh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 chgsign(this float3 a, float3 b)
    {
        var sig = new uint3(0x8000_0000).asf();
        return (b & sig) ^ a;
    }

}

#endregion // float3

#region float4

public static partial class math
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b32v4 isNaN(this float4 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static b32v4 isFinite(this float4 a) => abs(a) < float.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static b32v4 isInf(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.IsInfinity(a.vector).AsUInt32());
        #else // NET8_0_OR_GREATER
        return new(a.x.isInf(), a.y.isInf(), a.z.isInf(), a.w.isInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b32v4 isPosInf(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Equals(a.vector, Vector128.Create(float.PositiveInfinity)).AsUInt32());
        #else // NET8_0_OR_GREATER
        return new(a.x.isPosInf(), a.y.isPosInf(), a.z.isPosInf(), a.w.isPosInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b32v4 isNegInf(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Equals(a.vector, Vector128.Create(float.NegativeInfinity)).AsUInt32());
        #else // NET8_0_OR_GREATER
        return new(a.x.isNegInf(), a.y.isNegInf(), a.z.isNegInf(), a.w.isNegInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 log(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log(), a.y.log(), a.z.log(), a.w.log());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 log2(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log2(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log2(), a.y.log2(), a.z.log2(), a.w.log2());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 log(this float4 a, float4 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log(a.vector) / simd.Log(b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log(b.x), a.y.log(b.y), a.z.log(b.z), a.w.log(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 log10(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log10(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log10(), a.y.log10(), a.z.log10(), a.w.log10());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 exp(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Exp(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.exp(), a.y.exp(), a.z.exp(), a.w.exp());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 exp2(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Exp2(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.exp2(), a.y.exp2(), a.z.exp2(), a.w.exp2());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 exp10(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Exp10(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.exp10(), a.y.exp10(), a.z.exp10(), a.w.exp10());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 pow(this float4 a, float4 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Pow(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.pow(b.x), a.y.pow(b.y), a.z.pow(b.z), a.w.pow(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 pow(this float4 a, float b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Pow(a.vector, b));
        #else // NET8_0_OR_GREATER
        return new(a.x.pow(b), a.y.pow(b), a.z.pow(b), a.w.pow(b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 sqrt(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Sqrt(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sqrt(), a.y.sqrt(), a.z.sqrt(), a.w.sqrt());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 rsqrt(this float4 a) => float4.One / sqrt(a);

    [MethodImpl(256 | 512)]
    public static float length(this float4 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static float distance(this float4 a, float4 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static float4 normalize(this float4 a) => a * dot(a, a).rsqrt();

    [MethodImpl(256 | 512)]
    public static float4 normalizeSafe(this float4 a, float4 defaultvalue = default)
    {
        var len = dot(a, a);
        return select(len > 1.175494351e-38f, a * rsqrt(len), defaultvalue);
    }

    [MethodImpl(256 | 512)]
    public static float4 step(this float4 a, float4 threshold) =>
        select(a >= threshold, float4.One, default);

    [MethodImpl(256 | 512)]
    public static float4 refract(this float4 i, float4 n, float indexOfRefraction)
    {
        var ni = dot(n, i);
        var k = (float)(1.0f - indexOfRefraction * indexOfRefraction * (1.0f - ni * ni));
        return select(k >= 0.0f, indexOfRefraction * i - (float)((float)(indexOfRefraction * ni) + sqrt(k)) * n, default);
    }

    [MethodImpl(256 | 512)]
    public static float4 projectSafe(this float4 a, float4 onto, float4 defaultValue = default) 
    {
        var proj = project(a, onto);
        return select(all(isFinite(proj)), proj, defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static float4 faceForward(this float4 n, float4 i, float4 ng) =>
        select(dot(ng, i) >= 0.0f, -n, n);

    [MethodImpl(256 | 512)]
    public static float4 sin(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Sin(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sin(), a.y.sin(), a.z.sin(), a.w.sin());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 cos(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Cos(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.cos(), a.y.cos(), a.z.cos(), a.w.cos());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static (float4 sin, float4 cos) sincos(this float4 a)
    {
        #if NET8_0_OR_GREATER
        var (sin, cos) = simd.SinCos(a.vector);
        return (new(sin), new(cos));
        #else // NET8_0_OR_GREATER
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        a.z.sincos(out var sin2, out var cos2);
        a.w.sincos(out var sin3, out var cos3);
        return (
            new(sin0, sin1, sin2, sin3),
            new(cos0, cos1, cos2, cos3)
        );
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static void sincos(this float4 a, out float4 sin, out float4 cos)
    {
        #if NET8_0_OR_GREATER
        var (v_sin, v_cos) = simd.SinCos(a.vector);
        sin = new(v_sin);
        cos = new(v_cos);
        #else // NET8_0_OR_GREATER
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        a.z.sincos(out var sin2, out var cos2);
        a.w.sincos(out var sin3, out var cos3);
        sin = new(sin0, sin1, sin2, sin3);
        cos = new(cos0, cos1, cos2, cos3);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 tan(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Tan(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.tan(), a.y.tan(), a.z.tan(), a.w.tan());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 asin(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Asin(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.asin(), a.y.asin(), a.z.asin(), a.w.asin());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 acos(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Acos(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.acos(), a.y.acos(), a.z.acos(), a.w.acos());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 atan(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Atan(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.atan(), a.y.atan(), a.z.atan(), a.w.atan());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 atan2(this float4 a, float4 b)
    {
        #if NET8_0_OR_GREATER && false // todo
        return new(simd.Atan2(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.atan2(b.x), a.y.atan2(b.y), a.z.atan2(b.z), a.w.atan2(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 sinh(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Sinh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sinh(), a.y.sinh(), a.z.sinh(), a.w.sinh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 cosh(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Cosh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.cosh(), a.y.cosh(), a.z.cosh(), a.w.cosh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 tanh(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Tanh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.tanh(), a.y.tanh(), a.z.tanh(), a.w.tanh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 asinh(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Asinh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.asinh(), a.y.asinh(), a.z.asinh(), a.w.asinh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 acosh(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Acosh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.acosh(), a.y.acosh(), a.z.acosh(), a.w.acosh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 atanh(this float4 a)
    {
        #if NET8_0_OR_GREATER && false // todo
        return new(simd.Atanh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.atanh(), a.y.atanh(), a.z.atanh(), a.w.atanh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 chgsign(this float4 a, float4 b)
    {
        var sig = new uint4(0x8000_0000).asf();
        return (b & sig) ^ a;
    }

}

#endregion // float4

#region double2

public static partial class math
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b64v2 isNaN(this double2 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static b64v2 isFinite(this double2 a) => abs(a) < double.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static b64v2 isInf(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.IsInfinity(a.vector).AsUInt64());
        #else // NET8_0_OR_GREATER
        return new(a.x.isInf(), a.y.isInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b64v2 isPosInf(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Equals(a.vector, Vector128.Create(double.PositiveInfinity)).AsUInt64());
        #else // NET8_0_OR_GREATER
        return new(a.x.isPosInf(), a.y.isPosInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b64v2 isNegInf(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Equals(a.vector, Vector128.Create(double.NegativeInfinity)).AsUInt64());
        #else // NET8_0_OR_GREATER
        return new(a.x.isNegInf(), a.y.isNegInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 log(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log(), a.y.log());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 log2(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log2(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log2(), a.y.log2());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 log(this double2 a, double2 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log(a.vector) / simd.Log(b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log(b.x), a.y.log(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 log10(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log10(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log10(), a.y.log10());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 exp(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Exp(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.exp(), a.y.exp());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 exp2(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Exp2(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.exp2(), a.y.exp2());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 exp10(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Exp10(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.exp10(), a.y.exp10());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 pow(this double2 a, double2 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Pow(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.pow(b.x), a.y.pow(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 pow(this double2 a, double b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Pow(a.vector, b));
        #else // NET8_0_OR_GREATER
        return new(a.x.pow(b), a.y.pow(b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 sqrt(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Sqrt(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sqrt(), a.y.sqrt());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 rsqrt(this double2 a) => double2.One / sqrt(a);

    [MethodImpl(256 | 512)]
    public static double length(this double2 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static double distance(this double2 a, double2 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static double2 normalize(this double2 a) => a * dot(a, a).rsqrt();

    [MethodImpl(256 | 512)]
    public static double2 normalizeSafe(this double2 a, double2 defaultvalue = default)
    {
        var len = dot(a, a);
        return select(len > 1.175494351e-38, a * rsqrt(len), defaultvalue);
    }

    [MethodImpl(256 | 512)]
    public static double2 step(this double2 a, double2 threshold) =>
        select(a >= threshold, double2.One, default);

    [MethodImpl(256 | 512)]
    public static double2 refract(this double2 i, double2 n, double indexOfRefraction)
    {
        var ni = dot(n, i);
        var k = (double)(1.0 - indexOfRefraction * indexOfRefraction * (1.0 - ni * ni));
        return select(k >= 0.0, indexOfRefraction * i - (double)((double)(indexOfRefraction * ni) + sqrt(k)) * n, default);
    }

    [MethodImpl(256 | 512)]
    public static double2 projectSafe(this double2 a, double2 onto, double2 defaultValue = default) 
    {
        var proj = project(a, onto);
        return select(all(isFinite(proj)), proj, defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static double2 faceForward(this double2 n, double2 i, double2 ng) =>
        select(dot(ng, i) >= 0.0, -n, n);

    [MethodImpl(256 | 512)]
    public static double2 sin(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Sin(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sin(), a.y.sin());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 cos(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Cos(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.cos(), a.y.cos());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static (double2 sin, double2 cos) sincos(this double2 a)
    {
        #if NET8_0_OR_GREATER
        var (sin, cos) = simd.SinCos(a.vector);
        return (new(sin), new(cos));
        #else // NET8_0_OR_GREATER
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        return (
            new(sin0, sin1),
            new(cos0, cos1)
        );
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static void sincos(this double2 a, out double2 sin, out double2 cos)
    {
        #if NET8_0_OR_GREATER
        var (v_sin, v_cos) = simd.SinCos(a.vector);
        sin = new(v_sin);
        cos = new(v_cos);
        #else // NET8_0_OR_GREATER
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        sin = new(sin0, sin1);
        cos = new(cos0, cos1);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 tan(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Tan(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.tan(), a.y.tan());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 asin(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Asin(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.asin(), a.y.asin());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 acos(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Acos(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.acos(), a.y.acos());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 atan(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Atan(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.atan(), a.y.atan());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 atan2(this double2 a, double2 b)
    {
        #if NET8_0_OR_GREATER && false // todo
        return new(simd.Atan2(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.atan2(b.x), a.y.atan2(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 sinh(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Sinh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sinh(), a.y.sinh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 cosh(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Cosh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.cosh(), a.y.cosh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 tanh(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Tanh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.tanh(), a.y.tanh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 asinh(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Asinh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.asinh(), a.y.asinh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 acosh(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Acosh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.acosh(), a.y.acosh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 atanh(this double2 a)
    {
        #if NET8_0_OR_GREATER && false // todo
        return new(simd.Atanh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.atanh(), a.y.atanh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 chgsign(this double2 a, double2 b)
    {
        var sig = new ulong2(0x8000_0000_0000_0000).asf();
        return (b & sig) ^ a;
    }

}

#endregion // double2

#region double3

public static partial class math
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b64v3 isNaN(this double3 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static b64v3 isFinite(this double3 a) => abs(a) < double.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static b64v3 isInf(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.IsInfinity(a.vector).AsUInt64());
        #else // NET8_0_OR_GREATER
        return new(a.x.isInf(), a.y.isInf(), a.z.isInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b64v3 isPosInf(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Equals(a.vector, Vector256.Create(double.PositiveInfinity)).AsUInt64());
        #else // NET8_0_OR_GREATER
        return new(a.x.isPosInf(), a.y.isPosInf(), a.z.isPosInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b64v3 isNegInf(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Equals(a.vector, Vector256.Create(double.NegativeInfinity)).AsUInt64());
        #else // NET8_0_OR_GREATER
        return new(a.x.isNegInf(), a.y.isNegInf(), a.z.isNegInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 log(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log(), a.y.log(), a.z.log());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 log2(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log2(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log2(), a.y.log2(), a.z.log2());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 log(this double3 a, double3 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log(a.vector) / simd.Log(b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log(b.x), a.y.log(b.y), a.z.log(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 log10(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log10(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log10(), a.y.log10(), a.z.log10());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 exp(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Exp(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.exp(), a.y.exp(), a.z.exp());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 exp2(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Exp2(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.exp2(), a.y.exp2(), a.z.exp2());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 exp10(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Exp10(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.exp10(), a.y.exp10(), a.z.exp10());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 pow(this double3 a, double3 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Pow(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.pow(b.x), a.y.pow(b.y), a.z.pow(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 pow(this double3 a, double b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Pow(a.vector, b));
        #else // NET8_0_OR_GREATER
        return new(a.x.pow(b), a.y.pow(b), a.z.pow(b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 sqrt(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Sqrt(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sqrt(), a.y.sqrt(), a.z.sqrt());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 rsqrt(this double3 a) => double3.One / sqrt(a);

    [MethodImpl(256 | 512)]
    public static double length(this double3 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static double distance(this double3 a, double3 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static double3 normalize(this double3 a) => a * dot(a, a).rsqrt();

    [MethodImpl(256 | 512)]
    public static double3 normalizeSafe(this double3 a, double3 defaultvalue = default)
    {
        var len = dot(a, a);
        return select(len > 1.175494351e-38, a * rsqrt(len), defaultvalue);
    }

    [MethodImpl(256 | 512)]
    public static double3 step(this double3 a, double3 threshold) =>
        select(a >= threshold, double3.One, default);

    [MethodImpl(256 | 512)]
    public static double3 refract(this double3 i, double3 n, double indexOfRefraction)
    {
        var ni = dot(n, i);
        var k = (double)(1.0 - indexOfRefraction * indexOfRefraction * (1.0 - ni * ni));
        return select(k >= 0.0, indexOfRefraction * i - (double)((double)(indexOfRefraction * ni) + sqrt(k)) * n, default);
    }

    [MethodImpl(256 | 512)]
    public static double3 projectSafe(this double3 a, double3 onto, double3 defaultValue = default) 
    {
        var proj = project(a, onto);
        return select(all(isFinite(proj)), proj, defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static double3 faceForward(this double3 n, double3 i, double3 ng) =>
        select(dot(ng, i) >= 0.0, -n, n);

    [MethodImpl(256 | 512)]
    public static double3 sin(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Sin(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sin(), a.y.sin(), a.z.sin());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 cos(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Cos(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.cos(), a.y.cos(), a.z.cos());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static (double3 sin, double3 cos) sincos(this double3 a)
    {
        #if NET8_0_OR_GREATER
        var (sin, cos) = simd.SinCos(a.vector);
        return (new(sin), new(cos));
        #else // NET8_0_OR_GREATER
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        a.z.sincos(out var sin2, out var cos2);
        return (
            new(sin0, sin1, sin2),
            new(cos0, cos1, cos2)
        );
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static void sincos(this double3 a, out double3 sin, out double3 cos)
    {
        #if NET8_0_OR_GREATER
        var (v_sin, v_cos) = simd.SinCos(a.vector);
        sin = new(v_sin);
        cos = new(v_cos);
        #else // NET8_0_OR_GREATER
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        a.z.sincos(out var sin2, out var cos2);
        sin = new(sin0, sin1, sin2);
        cos = new(cos0, cos1, cos2);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 tan(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Tan(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.tan(), a.y.tan(), a.z.tan());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 asin(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Asin(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.asin(), a.y.asin(), a.z.asin());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 acos(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Acos(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.acos(), a.y.acos(), a.z.acos());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 atan(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Atan(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.atan(), a.y.atan(), a.z.atan());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 atan2(this double3 a, double3 b)
    {
        #if NET8_0_OR_GREATER && false // todo
        return new(simd.Atan2(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.atan2(b.x), a.y.atan2(b.y), a.z.atan2(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 sinh(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Sinh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sinh(), a.y.sinh(), a.z.sinh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 cosh(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Cosh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.cosh(), a.y.cosh(), a.z.cosh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 tanh(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Tanh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.tanh(), a.y.tanh(), a.z.tanh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 asinh(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Asinh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.asinh(), a.y.asinh(), a.z.asinh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 acosh(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Acosh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.acosh(), a.y.acosh(), a.z.acosh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 atanh(this double3 a)
    {
        #if NET8_0_OR_GREATER && false // todo
        return new(simd.Atanh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.atanh(), a.y.atanh(), a.z.atanh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 chgsign(this double3 a, double3 b)
    {
        var sig = new ulong3(0x8000_0000_0000_0000).asf();
        return (b & sig) ^ a;
    }

}

#endregion // double3

#region double4

public static partial class math
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b64v4 isNaN(this double4 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static b64v4 isFinite(this double4 a) => abs(a) < double.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static b64v4 isInf(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.IsInfinity(a.vector).AsUInt64());
        #else // NET8_0_OR_GREATER
        return new(a.x.isInf(), a.y.isInf(), a.z.isInf(), a.w.isInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b64v4 isPosInf(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Equals(a.vector, Vector256.Create(double.PositiveInfinity)).AsUInt64());
        #else // NET8_0_OR_GREATER
        return new(a.x.isPosInf(), a.y.isPosInf(), a.z.isPosInf(), a.w.isPosInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b64v4 isNegInf(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Equals(a.vector, Vector256.Create(double.NegativeInfinity)).AsUInt64());
        #else // NET8_0_OR_GREATER
        return new(a.x.isNegInf(), a.y.isNegInf(), a.z.isNegInf(), a.w.isNegInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 log(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log(), a.y.log(), a.z.log(), a.w.log());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 log2(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log2(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log2(), a.y.log2(), a.z.log2(), a.w.log2());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 log(this double4 a, double4 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log(a.vector) / simd.Log(b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log(b.x), a.y.log(b.y), a.z.log(b.z), a.w.log(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 log10(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log10(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log10(), a.y.log10(), a.z.log10(), a.w.log10());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 exp(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Exp(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.exp(), a.y.exp(), a.z.exp(), a.w.exp());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 exp2(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Exp2(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.exp2(), a.y.exp2(), a.z.exp2(), a.w.exp2());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 exp10(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Exp10(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.exp10(), a.y.exp10(), a.z.exp10(), a.w.exp10());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 pow(this double4 a, double4 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Pow(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.pow(b.x), a.y.pow(b.y), a.z.pow(b.z), a.w.pow(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 pow(this double4 a, double b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Pow(a.vector, b));
        #else // NET8_0_OR_GREATER
        return new(a.x.pow(b), a.y.pow(b), a.z.pow(b), a.w.pow(b));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 sqrt(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Sqrt(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sqrt(), a.y.sqrt(), a.z.sqrt(), a.w.sqrt());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 rsqrt(this double4 a) => double4.One / sqrt(a);

    [MethodImpl(256 | 512)]
    public static double length(this double4 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static double distance(this double4 a, double4 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static double4 normalize(this double4 a) => a * dot(a, a).rsqrt();

    [MethodImpl(256 | 512)]
    public static double4 normalizeSafe(this double4 a, double4 defaultvalue = default)
    {
        var len = dot(a, a);
        return select(len > 1.175494351e-38, a * rsqrt(len), defaultvalue);
    }

    [MethodImpl(256 | 512)]
    public static double4 step(this double4 a, double4 threshold) =>
        select(a >= threshold, double4.One, default);

    [MethodImpl(256 | 512)]
    public static double4 refract(this double4 i, double4 n, double indexOfRefraction)
    {
        var ni = dot(n, i);
        var k = (double)(1.0 - indexOfRefraction * indexOfRefraction * (1.0 - ni * ni));
        return select(k >= 0.0, indexOfRefraction * i - (double)((double)(indexOfRefraction * ni) + sqrt(k)) * n, default);
    }

    [MethodImpl(256 | 512)]
    public static double4 projectSafe(this double4 a, double4 onto, double4 defaultValue = default) 
    {
        var proj = project(a, onto);
        return select(all(isFinite(proj)), proj, defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static double4 faceForward(this double4 n, double4 i, double4 ng) =>
        select(dot(ng, i) >= 0.0, -n, n);

    [MethodImpl(256 | 512)]
    public static double4 sin(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Sin(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sin(), a.y.sin(), a.z.sin(), a.w.sin());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 cos(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Cos(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.cos(), a.y.cos(), a.z.cos(), a.w.cos());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static (double4 sin, double4 cos) sincos(this double4 a)
    {
        #if NET8_0_OR_GREATER
        var (sin, cos) = simd.SinCos(a.vector);
        return (new(sin), new(cos));
        #else // NET8_0_OR_GREATER
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        a.z.sincos(out var sin2, out var cos2);
        a.w.sincos(out var sin3, out var cos3);
        return (
            new(sin0, sin1, sin2, sin3),
            new(cos0, cos1, cos2, cos3)
        );
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static void sincos(this double4 a, out double4 sin, out double4 cos)
    {
        #if NET8_0_OR_GREATER
        var (v_sin, v_cos) = simd.SinCos(a.vector);
        sin = new(v_sin);
        cos = new(v_cos);
        #else // NET8_0_OR_GREATER
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        a.z.sincos(out var sin2, out var cos2);
        a.w.sincos(out var sin3, out var cos3);
        sin = new(sin0, sin1, sin2, sin3);
        cos = new(cos0, cos1, cos2, cos3);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 tan(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Tan(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.tan(), a.y.tan(), a.z.tan(), a.w.tan());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 asin(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Asin(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.asin(), a.y.asin(), a.z.asin(), a.w.asin());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 acos(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Acos(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.acos(), a.y.acos(), a.z.acos(), a.w.acos());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 atan(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Atan(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.atan(), a.y.atan(), a.z.atan(), a.w.atan());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 atan2(this double4 a, double4 b)
    {
        #if NET8_0_OR_GREATER && false // todo
        return new(simd.Atan2(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.atan2(b.x), a.y.atan2(b.y), a.z.atan2(b.z), a.w.atan2(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 sinh(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Sinh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.sinh(), a.y.sinh(), a.z.sinh(), a.w.sinh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 cosh(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Cosh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.cosh(), a.y.cosh(), a.z.cosh(), a.w.cosh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 tanh(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Tanh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.tanh(), a.y.tanh(), a.z.tanh(), a.w.tanh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 asinh(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Asinh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.asinh(), a.y.asinh(), a.z.asinh(), a.w.asinh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 acosh(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Acosh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.acosh(), a.y.acosh(), a.z.acosh(), a.w.acosh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 atanh(this double4 a)
    {
        #if NET8_0_OR_GREATER && false // todo
        return new(simd.Atanh(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.atanh(), a.y.atanh(), a.z.atanh(), a.w.atanh());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 chgsign(this double4 a, double4 b)
    {
        var sig = new ulong4(0x8000_0000_0000_0000).asf();
        return (b & sig) ^ a;
    }

}

#endregion // double4

#region half2

public static partial class math
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b16v2 isNaN(this half2 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static b16v2 isFinite(this half2 a) => abs(a) < half.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static b16v2 isInf(this half2 a)
    {
        return new(a.x.isInf(), a.y.isInf());
    }

    [MethodImpl(256 | 512)]
    public static b16v2 isPosInf(this half2 a)
    {
        return new(a.x.isPosInf(), a.y.isPosInf());
    }

    [MethodImpl(256 | 512)]
    public static b16v2 isNegInf(this half2 a)
    {
        return new(a.x.isNegInf(), a.y.isNegInf());
    }

    [MethodImpl(256 | 512)]
    public static half2 log(this half2 a)
    {
        return new(a.x.log(), a.y.log());
    }

    [MethodImpl(256 | 512)]
    public static half2 log2(this half2 a)
    {
        return new(a.x.log2(), a.y.log2());
    }

    [MethodImpl(256 | 512)]
    public static half2 log(this half2 a, half2 b)
    {
        return new(a.x.log(b.x), a.y.log(b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 log10(this half2 a)
    {
        return new(a.x.log10(), a.y.log10());
    }

    [MethodImpl(256 | 512)]
    public static half2 exp(this half2 a)
    {
        return new(a.x.exp(), a.y.exp());
    }

    [MethodImpl(256 | 512)]
    public static half2 exp2(this half2 a)
    {
        return new(a.x.exp2(), a.y.exp2());
    }

    [MethodImpl(256 | 512)]
    public static half2 exp10(this half2 a)
    {
        return new(a.x.exp10(), a.y.exp10());
    }

    [MethodImpl(256 | 512)]
    public static half2 pow(this half2 a, half2 b)
    {
        return new(a.x.pow(b.x), a.y.pow(b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 pow(this half2 a, half b)
    {
        return new(a.x.pow(b), a.y.pow(b));
    }

    [MethodImpl(256 | 512)]
    public static half2 sqrt(this half2 a)
    {
        return new(a.x.sqrt(), a.y.sqrt());
    }

    [MethodImpl(256 | 512)]
    public static half2 rsqrt(this half2 a) => half2.One / sqrt(a);

    [MethodImpl(256 | 512)]
    public static half length(this half2 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static half distance(this half2 a, half2 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static half2 normalize(this half2 a) => a * dot(a, a).rsqrt();

    [MethodImpl(256 | 512)]
    public static half2 normalizeSafe(this half2 a, half2 defaultvalue = default)
    {
        var len = dot(a, a);
        return select(len > 1.175494351e-38f.half(), a * rsqrt(len), defaultvalue);
    }

    [MethodImpl(256 | 512)]
    public static half2 step(this half2 a, half2 threshold) =>
        select(a >= threshold, half2.One, default);

    [MethodImpl(256 | 512)]
    public static half2 refract(this half2 i, half2 n, half indexOfRefraction)
    {
        var ni = dot(n, i);
        var k = (half)(1.0f.half() - indexOfRefraction * indexOfRefraction * (1.0f.half() - ni * ni));
        return select(k >= 0.0f.half(), indexOfRefraction * i - (half)((half)(indexOfRefraction * ni) + sqrt(k)) * n, default);
    }

    [MethodImpl(256 | 512)]
    public static half2 projectSafe(this half2 a, half2 onto, half2 defaultValue = default) 
    {
        var proj = project(a, onto);
        return select(all(isFinite(proj)), proj, defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static half2 faceForward(this half2 n, half2 i, half2 ng) =>
        select(dot(ng, i) >= 0.0f.half(), -n, n);

    [MethodImpl(256 | 512)]
    public static half2 sin(this half2 a)
    {
        return new(a.x.sin(), a.y.sin());
    }

    [MethodImpl(256 | 512)]
    public static half2 cos(this half2 a)
    {
        return new(a.x.cos(), a.y.cos());
    }

    [MethodImpl(256 | 512)]
    public static (half2 sin, half2 cos) sincos(this half2 a)
    {
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        return (
            new(sin0, sin1),
            new(cos0, cos1)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos(this half2 a, out half2 sin, out half2 cos)
    {
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        sin = new(sin0, sin1);
        cos = new(cos0, cos1);
    }

    [MethodImpl(256 | 512)]
    public static half2 tan(this half2 a)
    {
        return new(a.x.tan(), a.y.tan());
    }

    [MethodImpl(256 | 512)]
    public static half2 asin(this half2 a)
    {
        return new(a.x.asin(), a.y.asin());
    }

    [MethodImpl(256 | 512)]
    public static half2 acos(this half2 a)
    {
        return new(a.x.acos(), a.y.acos());
    }

    [MethodImpl(256 | 512)]
    public static half2 atan(this half2 a)
    {
        return new(a.x.atan(), a.y.atan());
    }

    [MethodImpl(256 | 512)]
    public static half2 atan2(this half2 a, half2 b)
    {
        return new(a.x.atan2(b.x), a.y.atan2(b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 sinh(this half2 a)
    {
        return new(a.x.sinh(), a.y.sinh());
    }

    [MethodImpl(256 | 512)]
    public static half2 cosh(this half2 a)
    {
        return new(a.x.cosh(), a.y.cosh());
    }

    [MethodImpl(256 | 512)]
    public static half2 tanh(this half2 a)
    {
        return new(a.x.tanh(), a.y.tanh());
    }

    [MethodImpl(256 | 512)]
    public static half2 asinh(this half2 a)
    {
        return new(a.x.asinh(), a.y.asinh());
    }

    [MethodImpl(256 | 512)]
    public static half2 acosh(this half2 a)
    {
        return new(a.x.acosh(), a.y.acosh());
    }

    [MethodImpl(256 | 512)]
    public static half2 atanh(this half2 a)
    {
        return new(a.x.atanh(), a.y.atanh());
    }

    [MethodImpl(256 | 512)]
    public static half2 chgsign(this half2 a, half2 b)
    {
        var sig = new ushort2(0x8000).asf();
        return (b & sig) ^ a;
    }

}

#endregion // half2

#region half3

public static partial class math
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b16v3 isNaN(this half3 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static b16v3 isFinite(this half3 a) => abs(a) < half.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static b16v3 isInf(this half3 a)
    {
        return new(a.x.isInf(), a.y.isInf(), a.z.isInf());
    }

    [MethodImpl(256 | 512)]
    public static b16v3 isPosInf(this half3 a)
    {
        return new(a.x.isPosInf(), a.y.isPosInf(), a.z.isPosInf());
    }

    [MethodImpl(256 | 512)]
    public static b16v3 isNegInf(this half3 a)
    {
        return new(a.x.isNegInf(), a.y.isNegInf(), a.z.isNegInf());
    }

    [MethodImpl(256 | 512)]
    public static half3 log(this half3 a)
    {
        return new(a.x.log(), a.y.log(), a.z.log());
    }

    [MethodImpl(256 | 512)]
    public static half3 log2(this half3 a)
    {
        return new(a.x.log2(), a.y.log2(), a.z.log2());
    }

    [MethodImpl(256 | 512)]
    public static half3 log(this half3 a, half3 b)
    {
        return new(a.x.log(b.x), a.y.log(b.y), a.z.log(b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 log10(this half3 a)
    {
        return new(a.x.log10(), a.y.log10(), a.z.log10());
    }

    [MethodImpl(256 | 512)]
    public static half3 exp(this half3 a)
    {
        return new(a.x.exp(), a.y.exp(), a.z.exp());
    }

    [MethodImpl(256 | 512)]
    public static half3 exp2(this half3 a)
    {
        return new(a.x.exp2(), a.y.exp2(), a.z.exp2());
    }

    [MethodImpl(256 | 512)]
    public static half3 exp10(this half3 a)
    {
        return new(a.x.exp10(), a.y.exp10(), a.z.exp10());
    }

    [MethodImpl(256 | 512)]
    public static half3 pow(this half3 a, half3 b)
    {
        return new(a.x.pow(b.x), a.y.pow(b.y), a.z.pow(b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 pow(this half3 a, half b)
    {
        return new(a.x.pow(b), a.y.pow(b), a.z.pow(b));
    }

    [MethodImpl(256 | 512)]
    public static half3 sqrt(this half3 a)
    {
        return new(a.x.sqrt(), a.y.sqrt(), a.z.sqrt());
    }

    [MethodImpl(256 | 512)]
    public static half3 rsqrt(this half3 a) => half3.One / sqrt(a);

    [MethodImpl(256 | 512)]
    public static half length(this half3 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static half distance(this half3 a, half3 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static half3 normalize(this half3 a) => a * dot(a, a).rsqrt();

    [MethodImpl(256 | 512)]
    public static half3 normalizeSafe(this half3 a, half3 defaultvalue = default)
    {
        var len = dot(a, a);
        return select(len > 1.175494351e-38f.half(), a * rsqrt(len), defaultvalue);
    }

    [MethodImpl(256 | 512)]
    public static half3 step(this half3 a, half3 threshold) =>
        select(a >= threshold, half3.One, default);

    [MethodImpl(256 | 512)]
    public static half3 refract(this half3 i, half3 n, half indexOfRefraction)
    {
        var ni = dot(n, i);
        var k = (half)(1.0f.half() - indexOfRefraction * indexOfRefraction * (1.0f.half() - ni * ni));
        return select(k >= 0.0f.half(), indexOfRefraction * i - (half)((half)(indexOfRefraction * ni) + sqrt(k)) * n, default);
    }

    [MethodImpl(256 | 512)]
    public static half3 projectSafe(this half3 a, half3 onto, half3 defaultValue = default) 
    {
        var proj = project(a, onto);
        return select(all(isFinite(proj)), proj, defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static half3 faceForward(this half3 n, half3 i, half3 ng) =>
        select(dot(ng, i) >= 0.0f.half(), -n, n);

    [MethodImpl(256 | 512)]
    public static half3 sin(this half3 a)
    {
        return new(a.x.sin(), a.y.sin(), a.z.sin());
    }

    [MethodImpl(256 | 512)]
    public static half3 cos(this half3 a)
    {
        return new(a.x.cos(), a.y.cos(), a.z.cos());
    }

    [MethodImpl(256 | 512)]
    public static (half3 sin, half3 cos) sincos(this half3 a)
    {
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        a.z.sincos(out var sin2, out var cos2);
        return (
            new(sin0, sin1, sin2),
            new(cos0, cos1, cos2)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos(this half3 a, out half3 sin, out half3 cos)
    {
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        a.z.sincos(out var sin2, out var cos2);
        sin = new(sin0, sin1, sin2);
        cos = new(cos0, cos1, cos2);
    }

    [MethodImpl(256 | 512)]
    public static half3 tan(this half3 a)
    {
        return new(a.x.tan(), a.y.tan(), a.z.tan());
    }

    [MethodImpl(256 | 512)]
    public static half3 asin(this half3 a)
    {
        return new(a.x.asin(), a.y.asin(), a.z.asin());
    }

    [MethodImpl(256 | 512)]
    public static half3 acos(this half3 a)
    {
        return new(a.x.acos(), a.y.acos(), a.z.acos());
    }

    [MethodImpl(256 | 512)]
    public static half3 atan(this half3 a)
    {
        return new(a.x.atan(), a.y.atan(), a.z.atan());
    }

    [MethodImpl(256 | 512)]
    public static half3 atan2(this half3 a, half3 b)
    {
        return new(a.x.atan2(b.x), a.y.atan2(b.y), a.z.atan2(b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 sinh(this half3 a)
    {
        return new(a.x.sinh(), a.y.sinh(), a.z.sinh());
    }

    [MethodImpl(256 | 512)]
    public static half3 cosh(this half3 a)
    {
        return new(a.x.cosh(), a.y.cosh(), a.z.cosh());
    }

    [MethodImpl(256 | 512)]
    public static half3 tanh(this half3 a)
    {
        return new(a.x.tanh(), a.y.tanh(), a.z.tanh());
    }

    [MethodImpl(256 | 512)]
    public static half3 asinh(this half3 a)
    {
        return new(a.x.asinh(), a.y.asinh(), a.z.asinh());
    }

    [MethodImpl(256 | 512)]
    public static half3 acosh(this half3 a)
    {
        return new(a.x.acosh(), a.y.acosh(), a.z.acosh());
    }

    [MethodImpl(256 | 512)]
    public static half3 atanh(this half3 a)
    {
        return new(a.x.atanh(), a.y.atanh(), a.z.atanh());
    }

    [MethodImpl(256 | 512)]
    public static half3 chgsign(this half3 a, half3 b)
    {
        var sig = new ushort3(0x8000).asf();
        return (b & sig) ^ a;
    }

}

#endregion // half3

#region half4

public static partial class math
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b16v4 isNaN(this half4 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static b16v4 isFinite(this half4 a) => abs(a) < half.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static b16v4 isInf(this half4 a)
    {
        return new(a.x.isInf(), a.y.isInf(), a.z.isInf(), a.w.isInf());
    }

    [MethodImpl(256 | 512)]
    public static b16v4 isPosInf(this half4 a)
    {
        return new(a.x.isPosInf(), a.y.isPosInf(), a.z.isPosInf(), a.w.isPosInf());
    }

    [MethodImpl(256 | 512)]
    public static b16v4 isNegInf(this half4 a)
    {
        return new(a.x.isNegInf(), a.y.isNegInf(), a.z.isNegInf(), a.w.isNegInf());
    }

    [MethodImpl(256 | 512)]
    public static half4 log(this half4 a)
    {
        return new(a.x.log(), a.y.log(), a.z.log(), a.w.log());
    }

    [MethodImpl(256 | 512)]
    public static half4 log2(this half4 a)
    {
        return new(a.x.log2(), a.y.log2(), a.z.log2(), a.w.log2());
    }

    [MethodImpl(256 | 512)]
    public static half4 log(this half4 a, half4 b)
    {
        return new(a.x.log(b.x), a.y.log(b.y), a.z.log(b.z), a.w.log(b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 log10(this half4 a)
    {
        return new(a.x.log10(), a.y.log10(), a.z.log10(), a.w.log10());
    }

    [MethodImpl(256 | 512)]
    public static half4 exp(this half4 a)
    {
        return new(a.x.exp(), a.y.exp(), a.z.exp(), a.w.exp());
    }

    [MethodImpl(256 | 512)]
    public static half4 exp2(this half4 a)
    {
        return new(a.x.exp2(), a.y.exp2(), a.z.exp2(), a.w.exp2());
    }

    [MethodImpl(256 | 512)]
    public static half4 exp10(this half4 a)
    {
        return new(a.x.exp10(), a.y.exp10(), a.z.exp10(), a.w.exp10());
    }

    [MethodImpl(256 | 512)]
    public static half4 pow(this half4 a, half4 b)
    {
        return new(a.x.pow(b.x), a.y.pow(b.y), a.z.pow(b.z), a.w.pow(b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 pow(this half4 a, half b)
    {
        return new(a.x.pow(b), a.y.pow(b), a.z.pow(b), a.w.pow(b));
    }

    [MethodImpl(256 | 512)]
    public static half4 sqrt(this half4 a)
    {
        return new(a.x.sqrt(), a.y.sqrt(), a.z.sqrt(), a.w.sqrt());
    }

    [MethodImpl(256 | 512)]
    public static half4 rsqrt(this half4 a) => half4.One / sqrt(a);

    [MethodImpl(256 | 512)]
    public static half length(this half4 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static half distance(this half4 a, half4 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static half4 normalize(this half4 a) => a * dot(a, a).rsqrt();

    [MethodImpl(256 | 512)]
    public static half4 normalizeSafe(this half4 a, half4 defaultvalue = default)
    {
        var len = dot(a, a);
        return select(len > 1.175494351e-38f.half(), a * rsqrt(len), defaultvalue);
    }

    [MethodImpl(256 | 512)]
    public static half4 step(this half4 a, half4 threshold) =>
        select(a >= threshold, half4.One, default);

    [MethodImpl(256 | 512)]
    public static half4 refract(this half4 i, half4 n, half indexOfRefraction)
    {
        var ni = dot(n, i);
        var k = (half)(1.0f.half() - indexOfRefraction * indexOfRefraction * (1.0f.half() - ni * ni));
        return select(k >= 0.0f.half(), indexOfRefraction * i - (half)((half)(indexOfRefraction * ni) + sqrt(k)) * n, default);
    }

    [MethodImpl(256 | 512)]
    public static half4 projectSafe(this half4 a, half4 onto, half4 defaultValue = default) 
    {
        var proj = project(a, onto);
        return select(all(isFinite(proj)), proj, defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static half4 faceForward(this half4 n, half4 i, half4 ng) =>
        select(dot(ng, i) >= 0.0f.half(), -n, n);

    [MethodImpl(256 | 512)]
    public static half4 sin(this half4 a)
    {
        return new(a.x.sin(), a.y.sin(), a.z.sin(), a.w.sin());
    }

    [MethodImpl(256 | 512)]
    public static half4 cos(this half4 a)
    {
        return new(a.x.cos(), a.y.cos(), a.z.cos(), a.w.cos());
    }

    [MethodImpl(256 | 512)]
    public static (half4 sin, half4 cos) sincos(this half4 a)
    {
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        a.z.sincos(out var sin2, out var cos2);
        a.w.sincos(out var sin3, out var cos3);
        return (
            new(sin0, sin1, sin2, sin3),
            new(cos0, cos1, cos2, cos3)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos(this half4 a, out half4 sin, out half4 cos)
    {
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        a.z.sincos(out var sin2, out var cos2);
        a.w.sincos(out var sin3, out var cos3);
        sin = new(sin0, sin1, sin2, sin3);
        cos = new(cos0, cos1, cos2, cos3);
    }

    [MethodImpl(256 | 512)]
    public static half4 tan(this half4 a)
    {
        return new(a.x.tan(), a.y.tan(), a.z.tan(), a.w.tan());
    }

    [MethodImpl(256 | 512)]
    public static half4 asin(this half4 a)
    {
        return new(a.x.asin(), a.y.asin(), a.z.asin(), a.w.asin());
    }

    [MethodImpl(256 | 512)]
    public static half4 acos(this half4 a)
    {
        return new(a.x.acos(), a.y.acos(), a.z.acos(), a.w.acos());
    }

    [MethodImpl(256 | 512)]
    public static half4 atan(this half4 a)
    {
        return new(a.x.atan(), a.y.atan(), a.z.atan(), a.w.atan());
    }

    [MethodImpl(256 | 512)]
    public static half4 atan2(this half4 a, half4 b)
    {
        return new(a.x.atan2(b.x), a.y.atan2(b.y), a.z.atan2(b.z), a.w.atan2(b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 sinh(this half4 a)
    {
        return new(a.x.sinh(), a.y.sinh(), a.z.sinh(), a.w.sinh());
    }

    [MethodImpl(256 | 512)]
    public static half4 cosh(this half4 a)
    {
        return new(a.x.cosh(), a.y.cosh(), a.z.cosh(), a.w.cosh());
    }

    [MethodImpl(256 | 512)]
    public static half4 tanh(this half4 a)
    {
        return new(a.x.tanh(), a.y.tanh(), a.z.tanh(), a.w.tanh());
    }

    [MethodImpl(256 | 512)]
    public static half4 asinh(this half4 a)
    {
        return new(a.x.asinh(), a.y.asinh(), a.z.asinh(), a.w.asinh());
    }

    [MethodImpl(256 | 512)]
    public static half4 acosh(this half4 a)
    {
        return new(a.x.acosh(), a.y.acosh(), a.z.acosh(), a.w.acosh());
    }

    [MethodImpl(256 | 512)]
    public static half4 atanh(this half4 a)
    {
        return new(a.x.atanh(), a.y.atanh(), a.z.atanh(), a.w.atanh());
    }

    [MethodImpl(256 | 512)]
    public static half4 chgsign(this half4 a, half4 b)
    {
        var sig = new ushort4(0x8000).asf();
        return (b & sig) ^ a;
    }

}

#endregion // half4
