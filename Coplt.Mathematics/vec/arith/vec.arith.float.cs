// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region float2

public partial struct float2
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static float2 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static float2 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static float2 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static float2 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static float2 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static float2 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static float2 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f);
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float2 mod(this float2 a, float2 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Mod(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.mod(b.x), a.y.mod(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 ceil(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Ceiling(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.ceil(), a.y.ceil());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 floor(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Floor(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.floor(), a.y.floor());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 round(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Round(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.round(), a.y.round());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 trunc(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.RoundToZero(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.trunc(), a.y.trunc());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 frac(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - Vector64.Floor(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.frac(), a.y.frac());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 modf(this float2 a, out float2 i)
    {
        #if NET8_0_OR_GREATER
        var r = simd.ModF(a.vector, out var iv);
        i = new(iv);
        return new(r);
        #else // NET8_0_OR_GREATER
        float2 r = new(a.x.modf(out var i0), a.y.modf(out var i1));
        i = new(i0, i1);
        return r;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 rcp(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return float2.One / a;
        #else // NET8_0_OR_GREATER
        return new(a.x.rcp(), a.y.rcp());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 saturate(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return a.clamp(default, float2.One);
        #else // NET8_0_OR_GREATER
        return new(a.x.saturate(), a.y.saturate());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 smoothstep(this float2 a, float2 min, float2 max)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * (3.0f - (2.0f * t));
    }

    [MethodImpl(256 | 512)]
    public static float2 reflect(this float2 i, float2 n) => i - 2f * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static float2 project(this float2 a, float2 onto) =>
        (float)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static float2 projectOnPlane(this float2 a, float2 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float2 projectNormalized(this float2 a, float2 onto) =>
        (float)(dot(a, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static float2 projectOnPlaneNormalized(this float2 a, float2 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float2 radians(this float2 a) => a * float2.DegToRad;

    [MethodImpl(256 | 512)]
    public static float2 degrees(this float2 a) => a * float2.RadToDeg;
}

#endregion // float2

#region float3

public partial struct float3
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static float3 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static float3 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static float3 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static float3 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static float3 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static float3 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static float3 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f);
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float3 mod(this float3 a, float3 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Mod(a.vector, b.vector) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        #else // NET8_0_OR_GREATER
        return new(a.x.mod(b.x), a.y.mod(b.y), a.z.mod(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 ceil(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Ceiling(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.ceil(), a.y.ceil(), a.z.ceil());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 floor(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Floor(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.floor(), a.y.floor(), a.z.floor());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 round(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Round(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.round(), a.y.round(), a.z.round());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 trunc(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.RoundToZero(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.trunc(), a.y.trunc(), a.z.trunc());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 frac(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - Vector128.Floor(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.frac(), a.y.frac(), a.z.frac());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 modf(this float3 a, out float3 i)
    {
        #if NET8_0_OR_GREATER
        var r = simd.ModF(a.vector, out var iv);
        i = new(iv);
        return new(r);
        #else // NET8_0_OR_GREATER
        float3 r = new(a.x.modf(out var i0), a.y.modf(out var i1), a.z.modf(out var i2));
        i = new(i0, i1, i2);
        return r;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 rcp(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return float3.One / a;
        #else // NET8_0_OR_GREATER
        return new(a.x.rcp(), a.y.rcp(), a.z.rcp());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 saturate(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return a.clamp(default, float3.One);
        #else // NET8_0_OR_GREATER
        return new(a.x.saturate(), a.y.saturate(), a.z.saturate());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 smoothstep(this float3 a, float3 min, float3 max)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * (3.0f - (2.0f * t));
    }

    [MethodImpl(256 | 512)]
    public static float3 reflect(this float3 i, float3 n) => i - 2f * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static float3 project(this float3 a, float3 onto) =>
        (float)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static float3 projectOnPlane(this float3 a, float3 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float3 projectNormalized(this float3 a, float3 onto) =>
        (float)(dot(a, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static float3 projectOnPlaneNormalized(this float3 a, float3 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float3 radians(this float3 a) => a * float3.DegToRad;

    [MethodImpl(256 | 512)]
    public static float3 degrees(this float3 a) => a * float3.RadToDeg;
}

#endregion // float3

#region float4

public partial struct float4
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static float4 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static float4 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static float4 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static float4 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static float4 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static float4 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static float4 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f);
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float4 mod(this float4 a, float4 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Mod(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.mod(b.x), a.y.mod(b.y), a.z.mod(b.z), a.w.mod(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 ceil(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Ceiling(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.ceil(), a.y.ceil(), a.z.ceil(), a.w.ceil());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 floor(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Floor(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 round(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Round(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.round(), a.y.round(), a.z.round(), a.w.round());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 trunc(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.RoundToZero(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.trunc(), a.y.trunc(), a.z.trunc(), a.w.trunc());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 frac(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - Vector128.Floor(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.frac(), a.y.frac(), a.z.frac(), a.w.frac());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 modf(this float4 a, out float4 i)
    {
        #if NET8_0_OR_GREATER
        var r = simd.ModF(a.vector, out var iv);
        i = new(iv);
        return new(r);
        #else // NET8_0_OR_GREATER
        float4 r = new(a.x.modf(out var i0), a.y.modf(out var i1), a.z.modf(out var i2), a.w.modf(out var i3));
        i = new(i0, i1, i2, i3);
        return r;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 rcp(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return float4.One / a;
        #else // NET8_0_OR_GREATER
        return new(a.x.rcp(), a.y.rcp(), a.z.rcp(), a.w.rcp());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 saturate(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return a.clamp(default, float4.One);
        #else // NET8_0_OR_GREATER
        return new(a.x.saturate(), a.y.saturate(), a.z.saturate(), a.w.saturate());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 smoothstep(this float4 a, float4 min, float4 max)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * (3.0f - (2.0f * t));
    }

    [MethodImpl(256 | 512)]
    public static float4 reflect(this float4 i, float4 n) => i - 2f * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static float4 project(this float4 a, float4 onto) =>
        (float)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static float4 projectOnPlane(this float4 a, float4 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float4 projectNormalized(this float4 a, float4 onto) =>
        (float)(dot(a, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static float4 projectOnPlaneNormalized(this float4 a, float4 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float4 radians(this float4 a) => a * float4.DegToRad;

    [MethodImpl(256 | 512)]
    public static float4 degrees(this float4 a) => a * float4.RadToDeg;
}

#endregion // float4

#region double2

public partial struct double2
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static double2 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static double2 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static double2 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static double2 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static double2 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static double2 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static double2 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144);
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double2 mod(this double2 a, double2 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Mod(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.mod(b.x), a.y.mod(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 ceil(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Ceiling(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.ceil(), a.y.ceil());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 floor(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Floor(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.floor(), a.y.floor());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 round(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Round(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.round(), a.y.round());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 trunc(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.RoundToZero(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.trunc(), a.y.trunc());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 frac(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - Vector128.Floor(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.frac(), a.y.frac());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 modf(this double2 a, out double2 i)
    {
        #if NET8_0_OR_GREATER
        var r = simd.ModF(a.vector, out var iv);
        i = new(iv);
        return new(r);
        #else // NET8_0_OR_GREATER
        double2 r = new(a.x.modf(out var i0), a.y.modf(out var i1));
        i = new(i0, i1);
        return r;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 rcp(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return double2.One / a;
        #else // NET8_0_OR_GREATER
        return new(a.x.rcp(), a.y.rcp());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 saturate(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return a.clamp(default, double2.One);
        #else // NET8_0_OR_GREATER
        return new(a.x.saturate(), a.y.saturate());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 smoothstep(this double2 a, double2 min, double2 max)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * (3.0 - (2.0 * t));
    }

    [MethodImpl(256 | 512)]
    public static double2 reflect(this double2 i, double2 n) => i - 2 * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static double2 project(this double2 a, double2 onto) =>
        (double)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static double2 projectOnPlane(this double2 a, double2 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double2 projectNormalized(this double2 a, double2 onto) =>
        (double)(dot(a, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static double2 projectOnPlaneNormalized(this double2 a, double2 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double2 radians(this double2 a) => a * double2.DegToRad;

    [MethodImpl(256 | 512)]
    public static double2 degrees(this double2 a) => a * double2.RadToDeg;
}

#endregion // double2

#region double3

public partial struct double3
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static double3 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static double3 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static double3 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static double3 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static double3 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static double3 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static double3 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144);
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double3 mod(this double3 a, double3 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Mod(a.vector, b.vector) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        #else // NET8_0_OR_GREATER
        return new(a.x.mod(b.x), a.y.mod(b.y), a.z.mod(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 ceil(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Ceiling(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.ceil(), a.y.ceil(), a.z.ceil());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 floor(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Floor(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.floor(), a.y.floor(), a.z.floor());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 round(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Round(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.round(), a.y.round(), a.z.round());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 trunc(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.RoundToZero(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.trunc(), a.y.trunc(), a.z.trunc());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 frac(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - Vector256.Floor(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.frac(), a.y.frac(), a.z.frac());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 modf(this double3 a, out double3 i)
    {
        #if NET8_0_OR_GREATER
        var r = simd.ModF(a.vector, out var iv);
        i = new(iv);
        return new(r);
        #else // NET8_0_OR_GREATER
        double3 r = new(a.x.modf(out var i0), a.y.modf(out var i1), a.z.modf(out var i2));
        i = new(i0, i1, i2);
        return r;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 rcp(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return double3.One / a;
        #else // NET8_0_OR_GREATER
        return new(a.x.rcp(), a.y.rcp(), a.z.rcp());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 saturate(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return a.clamp(default, double3.One);
        #else // NET8_0_OR_GREATER
        return new(a.x.saturate(), a.y.saturate(), a.z.saturate());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 smoothstep(this double3 a, double3 min, double3 max)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * (3.0 - (2.0 * t));
    }

    [MethodImpl(256 | 512)]
    public static double3 reflect(this double3 i, double3 n) => i - 2 * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static double3 project(this double3 a, double3 onto) =>
        (double)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static double3 projectOnPlane(this double3 a, double3 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double3 projectNormalized(this double3 a, double3 onto) =>
        (double)(dot(a, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static double3 projectOnPlaneNormalized(this double3 a, double3 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double3 radians(this double3 a) => a * double3.DegToRad;

    [MethodImpl(256 | 512)]
    public static double3 degrees(this double3 a) => a * double3.RadToDeg;
}

#endregion // double3

#region double4

public partial struct double4
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static double4 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static double4 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static double4 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static double4 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static double4 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static double4 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static double4 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144);
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double4 mod(this double4 a, double4 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Mod(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.mod(b.x), a.y.mod(b.y), a.z.mod(b.z), a.w.mod(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 ceil(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Ceiling(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.ceil(), a.y.ceil(), a.z.ceil(), a.w.ceil());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 floor(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Floor(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 round(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Round(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.round(), a.y.round(), a.z.round(), a.w.round());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 trunc(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.RoundToZero(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.trunc(), a.y.trunc(), a.z.trunc(), a.w.trunc());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 frac(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - Vector256.Floor(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.frac(), a.y.frac(), a.z.frac(), a.w.frac());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 modf(this double4 a, out double4 i)
    {
        #if NET8_0_OR_GREATER
        var r = simd.ModF(a.vector, out var iv);
        i = new(iv);
        return new(r);
        #else // NET8_0_OR_GREATER
        double4 r = new(a.x.modf(out var i0), a.y.modf(out var i1), a.z.modf(out var i2), a.w.modf(out var i3));
        i = new(i0, i1, i2, i3);
        return r;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 rcp(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return double4.One / a;
        #else // NET8_0_OR_GREATER
        return new(a.x.rcp(), a.y.rcp(), a.z.rcp(), a.w.rcp());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 saturate(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return a.clamp(default, double4.One);
        #else // NET8_0_OR_GREATER
        return new(a.x.saturate(), a.y.saturate(), a.z.saturate(), a.w.saturate());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 smoothstep(this double4 a, double4 min, double4 max)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * (3.0 - (2.0 * t));
    }

    [MethodImpl(256 | 512)]
    public static double4 reflect(this double4 i, double4 n) => i - 2 * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static double4 project(this double4 a, double4 onto) =>
        (double)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static double4 projectOnPlane(this double4 a, double4 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double4 projectNormalized(this double4 a, double4 onto) =>
        (double)(dot(a, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static double4 projectOnPlaneNormalized(this double4 a, double4 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double4 radians(this double4 a) => a * double4.DegToRad;

    [MethodImpl(256 | 512)]
    public static double4 degrees(this double4 a) => a * double4.RadToDeg;
}

#endregion // double4

#region decimal2

public partial struct decimal2
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static decimal2 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277m); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static decimal2 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094m); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static decimal2 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009m);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static decimal2 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923m);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static decimal2 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846m);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static decimal2 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861m);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static decimal2 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144m);
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static decimal2 mod(this decimal2 a, decimal2 b)
    {
        return new(a.x.mod(b.x), a.y.mod(b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 ceil(this decimal2 a)
    {
        return new(a.x.ceil(), a.y.ceil());
    }

    [MethodImpl(256 | 512)]
    public static decimal2 floor(this decimal2 a)
    {
        return new(a.x.floor(), a.y.floor());
    }

    [MethodImpl(256 | 512)]
    public static decimal2 round(this decimal2 a)
    {
        return new(a.x.round(), a.y.round());
    }

    [MethodImpl(256 | 512)]
    public static decimal2 trunc(this decimal2 a)
    {
        return new(a.x.trunc(), a.y.trunc());
    }

    [MethodImpl(256 | 512)]
    public static decimal2 frac(this decimal2 a)
    {
        return new(a.x.frac(), a.y.frac());
    }

    [MethodImpl(256 | 512)]
    public static decimal2 modf(this decimal2 a, out decimal2 i)
    {
        decimal2 r = new(a.x.modf(out var i0), a.y.modf(out var i1));
        i = new(i0, i1);
        return r;
    }

    [MethodImpl(256 | 512)]
    public static decimal2 rcp(this decimal2 a)
    {
        return new(a.x.rcp(), a.y.rcp());
    }

    [MethodImpl(256 | 512)]
    public static decimal2 saturate(this decimal2 a)
    {
        return new(a.x.saturate(), a.y.saturate());
    }

    [MethodImpl(256 | 512)]
    public static decimal2 smoothstep(this decimal2 a, decimal2 min, decimal2 max)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * (3.0m - (2.0m * t));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 reflect(this decimal2 i, decimal2 n) => i - 2m * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static decimal2 project(this decimal2 a, decimal2 onto) =>
        (decimal)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static decimal2 projectOnPlane(this decimal2 a, decimal2 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static decimal2 projectNormalized(this decimal2 a, decimal2 onto) =>
        (decimal)(dot(a, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static decimal2 projectOnPlaneNormalized(this decimal2 a, decimal2 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static decimal2 radians(this decimal2 a) => a * decimal2.DegToRad;

    [MethodImpl(256 | 512)]
    public static decimal2 degrees(this decimal2 a) => a * decimal2.RadToDeg;
}

#endregion // decimal2

#region decimal3

public partial struct decimal3
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static decimal3 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277m); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static decimal3 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094m); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static decimal3 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009m);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static decimal3 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923m);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static decimal3 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846m);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static decimal3 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861m);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static decimal3 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144m);
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static decimal3 mod(this decimal3 a, decimal3 b)
    {
        return new(a.x.mod(b.x), a.y.mod(b.y), a.z.mod(b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 ceil(this decimal3 a)
    {
        return new(a.x.ceil(), a.y.ceil(), a.z.ceil());
    }

    [MethodImpl(256 | 512)]
    public static decimal3 floor(this decimal3 a)
    {
        return new(a.x.floor(), a.y.floor(), a.z.floor());
    }

    [MethodImpl(256 | 512)]
    public static decimal3 round(this decimal3 a)
    {
        return new(a.x.round(), a.y.round(), a.z.round());
    }

    [MethodImpl(256 | 512)]
    public static decimal3 trunc(this decimal3 a)
    {
        return new(a.x.trunc(), a.y.trunc(), a.z.trunc());
    }

    [MethodImpl(256 | 512)]
    public static decimal3 frac(this decimal3 a)
    {
        return new(a.x.frac(), a.y.frac(), a.z.frac());
    }

    [MethodImpl(256 | 512)]
    public static decimal3 modf(this decimal3 a, out decimal3 i)
    {
        decimal3 r = new(a.x.modf(out var i0), a.y.modf(out var i1), a.z.modf(out var i2));
        i = new(i0, i1, i2);
        return r;
    }

    [MethodImpl(256 | 512)]
    public static decimal3 rcp(this decimal3 a)
    {
        return new(a.x.rcp(), a.y.rcp(), a.z.rcp());
    }

    [MethodImpl(256 | 512)]
    public static decimal3 saturate(this decimal3 a)
    {
        return new(a.x.saturate(), a.y.saturate(), a.z.saturate());
    }

    [MethodImpl(256 | 512)]
    public static decimal3 smoothstep(this decimal3 a, decimal3 min, decimal3 max)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * (3.0m - (2.0m * t));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 reflect(this decimal3 i, decimal3 n) => i - 2m * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static decimal3 project(this decimal3 a, decimal3 onto) =>
        (decimal)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static decimal3 projectOnPlane(this decimal3 a, decimal3 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static decimal3 projectNormalized(this decimal3 a, decimal3 onto) =>
        (decimal)(dot(a, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static decimal3 projectOnPlaneNormalized(this decimal3 a, decimal3 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static decimal3 radians(this decimal3 a) => a * decimal3.DegToRad;

    [MethodImpl(256 | 512)]
    public static decimal3 degrees(this decimal3 a) => a * decimal3.RadToDeg;
}

#endregion // decimal3

#region decimal4

public partial struct decimal4
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static decimal4 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277m); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static decimal4 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094m); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static decimal4 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009m);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static decimal4 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923m);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static decimal4 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846m);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static decimal4 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861m);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static decimal4 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144m);
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static decimal4 mod(this decimal4 a, decimal4 b)
    {
        return new(a.x.mod(b.x), a.y.mod(b.y), a.z.mod(b.z), a.w.mod(b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 ceil(this decimal4 a)
    {
        return new(a.x.ceil(), a.y.ceil(), a.z.ceil(), a.w.ceil());
    }

    [MethodImpl(256 | 512)]
    public static decimal4 floor(this decimal4 a)
    {
        return new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());
    }

    [MethodImpl(256 | 512)]
    public static decimal4 round(this decimal4 a)
    {
        return new(a.x.round(), a.y.round(), a.z.round(), a.w.round());
    }

    [MethodImpl(256 | 512)]
    public static decimal4 trunc(this decimal4 a)
    {
        return new(a.x.trunc(), a.y.trunc(), a.z.trunc(), a.w.trunc());
    }

    [MethodImpl(256 | 512)]
    public static decimal4 frac(this decimal4 a)
    {
        return new(a.x.frac(), a.y.frac(), a.z.frac(), a.w.frac());
    }

    [MethodImpl(256 | 512)]
    public static decimal4 modf(this decimal4 a, out decimal4 i)
    {
        decimal4 r = new(a.x.modf(out var i0), a.y.modf(out var i1), a.z.modf(out var i2), a.w.modf(out var i3));
        i = new(i0, i1, i2, i3);
        return r;
    }

    [MethodImpl(256 | 512)]
    public static decimal4 rcp(this decimal4 a)
    {
        return new(a.x.rcp(), a.y.rcp(), a.z.rcp(), a.w.rcp());
    }

    [MethodImpl(256 | 512)]
    public static decimal4 saturate(this decimal4 a)
    {
        return new(a.x.saturate(), a.y.saturate(), a.z.saturate(), a.w.saturate());
    }

    [MethodImpl(256 | 512)]
    public static decimal4 smoothstep(this decimal4 a, decimal4 min, decimal4 max)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * (3.0m - (2.0m * t));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 reflect(this decimal4 i, decimal4 n) => i - 2m * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static decimal4 project(this decimal4 a, decimal4 onto) =>
        (decimal)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static decimal4 projectOnPlane(this decimal4 a, decimal4 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static decimal4 projectNormalized(this decimal4 a, decimal4 onto) =>
        (decimal)(dot(a, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static decimal4 projectOnPlaneNormalized(this decimal4 a, decimal4 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static decimal4 radians(this decimal4 a) => a * decimal4.DegToRad;

    [MethodImpl(256 | 512)]
    public static decimal4 degrees(this decimal4 a) => a * decimal4.RadToDeg;
}

#endregion // decimal4

#region half2

public partial struct half2
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static half2 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f.half()); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static half2 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f.half()); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static half2 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f.half());
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static half2 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f.half());
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static half2 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f.half());
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static half2 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f.half());
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static half2 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f.half());
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half2 mod(this half2 a, half2 b)
    {
        return new(a.x.mod(b.x), a.y.mod(b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 ceil(this half2 a)
    {
        return new(a.x.ceil(), a.y.ceil());
    }

    [MethodImpl(256 | 512)]
    public static half2 floor(this half2 a)
    {
        return new(a.x.floor(), a.y.floor());
    }

    [MethodImpl(256 | 512)]
    public static half2 round(this half2 a)
    {
        return new(a.x.round(), a.y.round());
    }

    [MethodImpl(256 | 512)]
    public static half2 trunc(this half2 a)
    {
        return new(a.x.trunc(), a.y.trunc());
    }

    [MethodImpl(256 | 512)]
    public static half2 frac(this half2 a)
    {
        return new(a.x.frac(), a.y.frac());
    }

    [MethodImpl(256 | 512)]
    public static half2 modf(this half2 a, out half2 i)
    {
        half2 r = new(a.x.modf(out var i0), a.y.modf(out var i1));
        i = new(i0, i1);
        return r;
    }

    [MethodImpl(256 | 512)]
    public static half2 rcp(this half2 a)
    {
        return new(a.x.rcp(), a.y.rcp());
    }

    [MethodImpl(256 | 512)]
    public static half2 saturate(this half2 a)
    {
        return new(a.x.saturate(), a.y.saturate());
    }

    [MethodImpl(256 | 512)]
    public static half2 smoothstep(this half2 a, half2 min, half2 max)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * (3.0f.half() - (2.0f.half() * t));
    }

    [MethodImpl(256 | 512)]
    public static half2 reflect(this half2 i, half2 n) => i - 2f.half() * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static half2 project(this half2 a, half2 onto) =>
        (half)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static half2 projectOnPlane(this half2 a, half2 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static half2 projectNormalized(this half2 a, half2 onto) =>
        (half)(dot(a, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static half2 projectOnPlaneNormalized(this half2 a, half2 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static half2 radians(this half2 a) => a * half2.DegToRad;

    [MethodImpl(256 | 512)]
    public static half2 degrees(this half2 a) => a * half2.RadToDeg;
}

#endregion // half2

#region half3

public partial struct half3
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static half3 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f.half()); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static half3 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f.half()); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static half3 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f.half());
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static half3 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f.half());
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static half3 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f.half());
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static half3 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f.half());
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static half3 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f.half());
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half3 mod(this half3 a, half3 b)
    {
        return new(a.x.mod(b.x), a.y.mod(b.y), a.z.mod(b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 ceil(this half3 a)
    {
        return new(a.x.ceil(), a.y.ceil(), a.z.ceil());
    }

    [MethodImpl(256 | 512)]
    public static half3 floor(this half3 a)
    {
        return new(a.x.floor(), a.y.floor(), a.z.floor());
    }

    [MethodImpl(256 | 512)]
    public static half3 round(this half3 a)
    {
        return new(a.x.round(), a.y.round(), a.z.round());
    }

    [MethodImpl(256 | 512)]
    public static half3 trunc(this half3 a)
    {
        return new(a.x.trunc(), a.y.trunc(), a.z.trunc());
    }

    [MethodImpl(256 | 512)]
    public static half3 frac(this half3 a)
    {
        return new(a.x.frac(), a.y.frac(), a.z.frac());
    }

    [MethodImpl(256 | 512)]
    public static half3 modf(this half3 a, out half3 i)
    {
        half3 r = new(a.x.modf(out var i0), a.y.modf(out var i1), a.z.modf(out var i2));
        i = new(i0, i1, i2);
        return r;
    }

    [MethodImpl(256 | 512)]
    public static half3 rcp(this half3 a)
    {
        return new(a.x.rcp(), a.y.rcp(), a.z.rcp());
    }

    [MethodImpl(256 | 512)]
    public static half3 saturate(this half3 a)
    {
        return new(a.x.saturate(), a.y.saturate(), a.z.saturate());
    }

    [MethodImpl(256 | 512)]
    public static half3 smoothstep(this half3 a, half3 min, half3 max)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * (3.0f.half() - (2.0f.half() * t));
    }

    [MethodImpl(256 | 512)]
    public static half3 reflect(this half3 i, half3 n) => i - 2f.half() * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static half3 project(this half3 a, half3 onto) =>
        (half)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static half3 projectOnPlane(this half3 a, half3 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static half3 projectNormalized(this half3 a, half3 onto) =>
        (half)(dot(a, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static half3 projectOnPlaneNormalized(this half3 a, half3 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static half3 radians(this half3 a) => a * half3.DegToRad;

    [MethodImpl(256 | 512)]
    public static half3 degrees(this half3 a) => a * half3.RadToDeg;
}

#endregion // half3

#region half4

public partial struct half4
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static half4 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f.half()); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static half4 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f.half()); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static half4 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f.half());
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static half4 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f.half());
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static half4 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f.half());
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static half4 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f.half());
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static half4 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f.half());
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half4 mod(this half4 a, half4 b)
    {
        return new(a.x.mod(b.x), a.y.mod(b.y), a.z.mod(b.z), a.w.mod(b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 ceil(this half4 a)
    {
        return new(a.x.ceil(), a.y.ceil(), a.z.ceil(), a.w.ceil());
    }

    [MethodImpl(256 | 512)]
    public static half4 floor(this half4 a)
    {
        return new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());
    }

    [MethodImpl(256 | 512)]
    public static half4 round(this half4 a)
    {
        return new(a.x.round(), a.y.round(), a.z.round(), a.w.round());
    }

    [MethodImpl(256 | 512)]
    public static half4 trunc(this half4 a)
    {
        return new(a.x.trunc(), a.y.trunc(), a.z.trunc(), a.w.trunc());
    }

    [MethodImpl(256 | 512)]
    public static half4 frac(this half4 a)
    {
        return new(a.x.frac(), a.y.frac(), a.z.frac(), a.w.frac());
    }

    [MethodImpl(256 | 512)]
    public static half4 modf(this half4 a, out half4 i)
    {
        half4 r = new(a.x.modf(out var i0), a.y.modf(out var i1), a.z.modf(out var i2), a.w.modf(out var i3));
        i = new(i0, i1, i2, i3);
        return r;
    }

    [MethodImpl(256 | 512)]
    public static half4 rcp(this half4 a)
    {
        return new(a.x.rcp(), a.y.rcp(), a.z.rcp(), a.w.rcp());
    }

    [MethodImpl(256 | 512)]
    public static half4 saturate(this half4 a)
    {
        return new(a.x.saturate(), a.y.saturate(), a.z.saturate(), a.w.saturate());
    }

    [MethodImpl(256 | 512)]
    public static half4 smoothstep(this half4 a, half4 min, half4 max)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * (3.0f.half() - (2.0f.half() * t));
    }

    [MethodImpl(256 | 512)]
    public static half4 reflect(this half4 i, half4 n) => i - 2f.half() * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static half4 project(this half4 a, half4 onto) =>
        (half)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static half4 projectOnPlane(this half4 a, half4 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static half4 projectNormalized(this half4 a, half4 onto) =>
        (half)(dot(a, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static half4 projectOnPlaneNormalized(this half4 a, half4 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static half4 radians(this half4 a) => a * half4.DegToRad;

    [MethodImpl(256 | 512)]
    public static half4 degrees(this half4 a) => a * half4.RadToDeg;
}

#endregion // half4
