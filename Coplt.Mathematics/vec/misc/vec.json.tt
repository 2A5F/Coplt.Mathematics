<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="../../types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics.Json;
<#
    foreach (var typ in Typ.Typs)
    {
        for (var i = 2; i <= 4; i++)
        {
            var typeName = $"{typ.name}{i}";

            var byteSize = typ.size * (i is 3 ? 4 : i);
            var bitSize = 8 * byteSize;
#>

#region <#= typeName #>

[CpuOnly]
public class <#= typeName #>JsonConverter : JsonConverter<<#= typeName #>>
{
    public override <#= typeName #> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType is not JsonTokenType.StartArray) 
            throw new JsonException($"Expected {JsonTokenType.StartArray} but found {reader.TokenType}");
<#
            for (var n = 0; n < i; n++)
            {
#>
        reader.Read();
        var <#= Typ.xyzw[n] #> = <#= typ.jsonCastBack #>reader.Get<#= typ.jsonType #>();
<#
            }
#>
        if (reader.TokenType is not JsonTokenType.EndArray) 
            throw new JsonException($"Expected {JsonTokenType.EndArray} but found {reader.TokenType}");
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => Typ.xyzw[n])) #>);
    }
    public override void Write(Utf8JsonWriter writer, <#= typeName #> value, JsonSerializerOptions options)
    {
        writer.WriteStartArray();
<#
            for (var n = 0; n < i; n++)
            {
                if (typ.bol)
                {
#>
        writer.WriteBooleanValue(value.<#= Typ.xyzw[n] #>);
<#
                }
                else
                {
#>
        writer.WriteNumberValue(<#= typ.jsonCast #>value.<#= Typ.xyzw[n] #>);
<#
                }
            }
#>
        writer.WriteEndArray();
    }
}

#endregion // <#= typeName #>
<#
        }
    }
#>
