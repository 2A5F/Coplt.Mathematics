// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region float2

public partial struct float2 
{
    public readonly float2 xx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector64.IsHardwareAccelerated)
                return new(Vector64.Shuffle(vector, Vector64.Create(0, 0)));
            else 
                return new(x, x);
        }
    }
    public readonly float2 rr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector64.IsHardwareAccelerated)
                return new(Vector64.Shuffle(vector, Vector64.Create(0, 0)));
            else 
                return new(x, x);
        }
    }
    public float2 xy
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public float2 rg
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public float2 yx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector64.IsHardwareAccelerated)
                return new(Vector64.Shuffle(vector, Vector64.Create(1, 0)));
            else 
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yx;
    }
    public float2 gr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector64.IsHardwareAccelerated)
                return new(Vector64.Shuffle(vector, Vector64.Create(1, 0)));
            else 
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yx;
    }
    public readonly float2 yy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector64.IsHardwareAccelerated)
                return new(Vector64.Shuffle(vector, Vector64.Create(1, 1)));
            else 
                return new(y, y);
        }
    }
    public readonly float2 gg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector64.IsHardwareAccelerated)
                return new(Vector64.Shuffle(vector, Vector64.Create(1, 1)));
            else 
                return new(y, y);
        }
    }
}

#endregion // float2

#region double2

public partial struct double2 
{
    public readonly double2 xx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 0)));
            else 
                return new(x, x);
        }
    }
    public readonly double2 rr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 0)));
            else 
                return new(x, x);
        }
    }
    public double2 xy
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public double2 rg
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public double2 yx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 0)));
            else 
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yx;
    }
    public double2 gr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 0)));
            else 
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yx;
    }
    public readonly double2 yy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 1)));
            else 
                return new(y, y);
        }
    }
    public readonly double2 gg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 1)));
            else 
                return new(y, y);
        }
    }
}

#endregion // double2

#region short2

public partial struct short2 
{
    public readonly short2 xx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x);
    }
    public readonly short2 rr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x);
    }
    public short2 xy
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public short2 rg
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public short2 yx
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, x);
        [MethodImpl(256 | 512)]
        set => this = value.yx;
    }
    public short2 gr
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, x);
        [MethodImpl(256 | 512)]
        set => this = value.yx;
    }
    public readonly short2 yy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y);
    }
    public readonly short2 gg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y);
    }
}

#endregion // short2

#region ushort2

public partial struct ushort2 
{
    public readonly ushort2 xx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x);
    }
    public readonly ushort2 rr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x);
    }
    public ushort2 xy
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public ushort2 rg
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public ushort2 yx
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, x);
        [MethodImpl(256 | 512)]
        set => this = value.yx;
    }
    public ushort2 gr
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, x);
        [MethodImpl(256 | 512)]
        set => this = value.yx;
    }
    public readonly ushort2 yy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y);
    }
    public readonly ushort2 gg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y);
    }
}

#endregion // ushort2

#region int2

public partial struct int2 
{
    public readonly int2 xx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector64.IsHardwareAccelerated)
                return new(Vector64.Shuffle(vector, Vector64.Create(0, 0)));
            else 
                return new(x, x);
        }
    }
    public readonly int2 rr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector64.IsHardwareAccelerated)
                return new(Vector64.Shuffle(vector, Vector64.Create(0, 0)));
            else 
                return new(x, x);
        }
    }
    public int2 xy
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public int2 rg
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public int2 yx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector64.IsHardwareAccelerated)
                return new(Vector64.Shuffle(vector, Vector64.Create(1, 0)));
            else 
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yx;
    }
    public int2 gr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector64.IsHardwareAccelerated)
                return new(Vector64.Shuffle(vector, Vector64.Create(1, 0)));
            else 
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yx;
    }
    public readonly int2 yy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector64.IsHardwareAccelerated)
                return new(Vector64.Shuffle(vector, Vector64.Create(1, 1)));
            else 
                return new(y, y);
        }
    }
    public readonly int2 gg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector64.IsHardwareAccelerated)
                return new(Vector64.Shuffle(vector, Vector64.Create(1, 1)));
            else 
                return new(y, y);
        }
    }
}

#endregion // int2

#region uint2

public partial struct uint2 
{
    public readonly uint2 xx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector64.IsHardwareAccelerated)
                return new(Vector64.Shuffle(vector, Vector64.Create((uint)0, 0)));
            else 
                return new(x, x);
        }
    }
    public readonly uint2 rr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector64.IsHardwareAccelerated)
                return new(Vector64.Shuffle(vector, Vector64.Create((uint)0, 0)));
            else 
                return new(x, x);
        }
    }
    public uint2 xy
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public uint2 rg
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public uint2 yx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector64.IsHardwareAccelerated)
                return new(Vector64.Shuffle(vector, Vector64.Create((uint)1, 0)));
            else 
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yx;
    }
    public uint2 gr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector64.IsHardwareAccelerated)
                return new(Vector64.Shuffle(vector, Vector64.Create((uint)1, 0)));
            else 
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yx;
    }
    public readonly uint2 yy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector64.IsHardwareAccelerated)
                return new(Vector64.Shuffle(vector, Vector64.Create((uint)1, 1)));
            else 
                return new(y, y);
        }
    }
    public readonly uint2 gg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector64.IsHardwareAccelerated)
                return new(Vector64.Shuffle(vector, Vector64.Create((uint)1, 1)));
            else 
                return new(y, y);
        }
    }
}

#endregion // uint2

#region long2

public partial struct long2 
{
    public readonly long2 xx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 0)));
            else 
                return new(x, x);
        }
    }
    public readonly long2 rr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 0)));
            else 
                return new(x, x);
        }
    }
    public long2 xy
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public long2 rg
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public long2 yx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 0)));
            else 
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yx;
    }
    public long2 gr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 0)));
            else 
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yx;
    }
    public readonly long2 yy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 1)));
            else 
                return new(y, y);
        }
    }
    public readonly long2 gg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 1)));
            else 
                return new(y, y);
        }
    }
}

#endregion // long2

#region ulong2

public partial struct ulong2 
{
    public readonly ulong2 xx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((ulong)0, 0)));
            else 
                return new(x, x);
        }
    }
    public readonly ulong2 rr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((ulong)0, 0)));
            else 
                return new(x, x);
        }
    }
    public ulong2 xy
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public ulong2 rg
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public ulong2 yx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((ulong)1, 0)));
            else 
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yx;
    }
    public ulong2 gr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((ulong)1, 0)));
            else 
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yx;
    }
    public readonly ulong2 yy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((ulong)1, 1)));
            else 
                return new(y, y);
        }
    }
    public readonly ulong2 gg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((ulong)1, 1)));
            else 
                return new(y, y);
        }
    }
}

#endregion // ulong2

#region decimal2

public partial struct decimal2 
{
    public readonly decimal2 xx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x);
    }
    public readonly decimal2 rr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x);
    }
    public decimal2 xy
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public decimal2 rg
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public decimal2 yx
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, x);
        [MethodImpl(256 | 512)]
        set => this = value.yx;
    }
    public decimal2 gr
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, x);
        [MethodImpl(256 | 512)]
        set => this = value.yx;
    }
    public readonly decimal2 yy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y);
    }
    public readonly decimal2 gg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y);
    }
}

#endregion // decimal2

#region half2

public partial struct half2 
{
    public readonly half2 xx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x);
    }
    public readonly half2 rr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x);
    }
    public half2 xy
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public half2 rg
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public half2 yx
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, x);
        [MethodImpl(256 | 512)]
        set => this = value.yx;
    }
    public half2 gr
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, x);
        [MethodImpl(256 | 512)]
        set => this = value.yx;
    }
    public readonly half2 yy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y);
    }
    public readonly half2 gg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y);
    }
}

#endregion // half2

#region b16v2

public partial struct b16v2 
{
    public readonly b16v2 xx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x);
    }
    public readonly b16v2 rr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x);
    }
    public b16v2 xy
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public b16v2 rg
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public b16v2 yx
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, x);
        [MethodImpl(256 | 512)]
        set => this = value.yx;
    }
    public b16v2 gr
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, x);
        [MethodImpl(256 | 512)]
        set => this = value.yx;
    }
    public readonly b16v2 yy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y);
    }
    public readonly b16v2 gg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y);
    }
}

#endregion // b16v2

#region b32v2

public partial struct b32v2 
{
    public readonly b32v2 xx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector64.IsHardwareAccelerated)
                return new(Vector64.Shuffle(vector, Vector64.Create((uint)0, 0)));
            else 
                return new(x, x);
        }
    }
    public readonly b32v2 rr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector64.IsHardwareAccelerated)
                return new(Vector64.Shuffle(vector, Vector64.Create((uint)0, 0)));
            else 
                return new(x, x);
        }
    }
    public b32v2 xy
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public b32v2 rg
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public b32v2 yx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector64.IsHardwareAccelerated)
                return new(Vector64.Shuffle(vector, Vector64.Create((uint)1, 0)));
            else 
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yx;
    }
    public b32v2 gr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector64.IsHardwareAccelerated)
                return new(Vector64.Shuffle(vector, Vector64.Create((uint)1, 0)));
            else 
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yx;
    }
    public readonly b32v2 yy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector64.IsHardwareAccelerated)
                return new(Vector64.Shuffle(vector, Vector64.Create((uint)1, 1)));
            else 
                return new(y, y);
        }
    }
    public readonly b32v2 gg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector64.IsHardwareAccelerated)
                return new(Vector64.Shuffle(vector, Vector64.Create((uint)1, 1)));
            else 
                return new(y, y);
        }
    }
}

#endregion // b32v2

#region b64v2

public partial struct b64v2 
{
    public readonly b64v2 xx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((ulong)0, 0)));
            else 
                return new(x, x);
        }
    }
    public readonly b64v2 rr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((ulong)0, 0)));
            else 
                return new(x, x);
        }
    }
    public b64v2 xy
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public b64v2 rg
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public b64v2 yx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((ulong)1, 0)));
            else 
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yx;
    }
    public b64v2 gr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((ulong)1, 0)));
            else 
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yx;
    }
    public readonly b64v2 yy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((ulong)1, 1)));
            else 
                return new(y, y);
        }
    }
    public readonly b64v2 gg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((ulong)1, 1)));
            else 
                return new(y, y);
        }
    }
}

#endregion // b64v2
