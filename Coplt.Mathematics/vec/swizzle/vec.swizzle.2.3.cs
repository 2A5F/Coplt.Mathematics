// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region float2

public partial struct float2 
{
    public readonly float3 xxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly float3 rrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly float3 xxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly float3 rrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly float3 xyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly float3 rgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly float3 xyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public readonly float3 rgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public readonly float3 yxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly float3 grr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly float3 yxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public readonly float3 grg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public readonly float3 yyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly float3 ggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly float3 yyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
    public readonly float3 ggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
}

#endregion // float2

#region double2

public partial struct double2 
{
    public readonly double3 xxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly double3 rrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly double3 xxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly double3 rrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly double3 xyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly double3 rgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly double3 xyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public readonly double3 rgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public readonly double3 yxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly double3 grr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly double3 yxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public readonly double3 grg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public readonly double3 yyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly double3 ggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly double3 yyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
    public readonly double3 ggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
}

#endregion // double2

#region short2

public partial struct short2 
{
    public readonly short3 xxx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
    }
    public readonly short3 rrr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
    }
    public readonly short3 xxy
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
    }
    public readonly short3 rrg
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
    }
    public readonly short3 xyx
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
    }
    public readonly short3 rgr
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
    }
    public readonly short3 xyy
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
    }
    public readonly short3 rgg
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
    }
    public readonly short3 yxx
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
    }
    public readonly short3 grr
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
    }
    public readonly short3 yxy
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
    }
    public readonly short3 grg
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
    }
    public readonly short3 yyx
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
    }
    public readonly short3 ggr
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
    }
    public readonly short3 yyy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
    }
    public readonly short3 ggg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
    }
}

#endregion // short2

#region ushort2

public partial struct ushort2 
{
    public readonly ushort3 xxx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
    }
    public readonly ushort3 rrr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
    }
    public readonly ushort3 xxy
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
    }
    public readonly ushort3 rrg
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
    }
    public readonly ushort3 xyx
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
    }
    public readonly ushort3 rgr
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
    }
    public readonly ushort3 xyy
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
    }
    public readonly ushort3 rgg
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
    }
    public readonly ushort3 yxx
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
    }
    public readonly ushort3 grr
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
    }
    public readonly ushort3 yxy
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
    }
    public readonly ushort3 grg
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
    }
    public readonly ushort3 yyx
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
    }
    public readonly ushort3 ggr
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
    }
    public readonly ushort3 yyy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
    }
    public readonly ushort3 ggg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
    }
}

#endregion // ushort2

#region int2

public partial struct int2 
{
    public readonly int3 xxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly int3 rrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly int3 xxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly int3 rrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly int3 xyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly int3 rgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly int3 xyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public readonly int3 rgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public readonly int3 yxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly int3 grr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly int3 yxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public readonly int3 grg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public readonly int3 yyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly int3 ggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly int3 yyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
    public readonly int3 ggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
}

#endregion // int2

#region uint2

public partial struct uint2 
{
    public readonly uint3 xxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly uint3 rrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly uint3 xxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly uint3 rrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly uint3 xyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly uint3 rgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly uint3 xyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public readonly uint3 rgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public readonly uint3 yxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly uint3 grr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly uint3 yxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public readonly uint3 grg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public readonly uint3 yyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly uint3 ggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly uint3 yyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
    public readonly uint3 ggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
}

#endregion // uint2

#region long2

public partial struct long2 
{
    public readonly long3 xxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly long3 rrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly long3 xxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly long3 rrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly long3 xyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly long3 rgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly long3 xyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public readonly long3 rgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public readonly long3 yxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly long3 grr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly long3 yxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public readonly long3 grg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public readonly long3 yyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly long3 ggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly long3 yyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
    public readonly long3 ggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
}

#endregion // long2

#region ulong2

public partial struct ulong2 
{
    public readonly ulong3 xxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly ulong3 rrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly ulong3 xxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly ulong3 rrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly ulong3 xyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly ulong3 rgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly ulong3 xyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public readonly ulong3 rgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public readonly ulong3 yxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly ulong3 grr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly ulong3 yxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public readonly ulong3 grg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public readonly ulong3 yyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly ulong3 ggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly ulong3 yyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
    public readonly ulong3 ggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
}

#endregion // ulong2

#region decimal2

public partial struct decimal2 
{
    public readonly decimal3 xxx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
    }
    public readonly decimal3 rrr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
    }
    public readonly decimal3 xxy
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
    }
    public readonly decimal3 rrg
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
    }
    public readonly decimal3 xyx
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
    }
    public readonly decimal3 rgr
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
    }
    public readonly decimal3 xyy
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
    }
    public readonly decimal3 rgg
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
    }
    public readonly decimal3 yxx
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
    }
    public readonly decimal3 grr
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
    }
    public readonly decimal3 yxy
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
    }
    public readonly decimal3 grg
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
    }
    public readonly decimal3 yyx
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
    }
    public readonly decimal3 ggr
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
    }
    public readonly decimal3 yyy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
    }
    public readonly decimal3 ggg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
    }
}

#endregion // decimal2

#region half2

public partial struct half2 
{
    public readonly half3 xxx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
    }
    public readonly half3 rrr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
    }
    public readonly half3 xxy
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
    }
    public readonly half3 rrg
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
    }
    public readonly half3 xyx
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
    }
    public readonly half3 rgr
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
    }
    public readonly half3 xyy
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
    }
    public readonly half3 rgg
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
    }
    public readonly half3 yxx
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
    }
    public readonly half3 grr
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
    }
    public readonly half3 yxy
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
    }
    public readonly half3 grg
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
    }
    public readonly half3 yyx
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
    }
    public readonly half3 ggr
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
    }
    public readonly half3 yyy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
    }
    public readonly half3 ggg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
    }
}

#endregion // half2

#region b16v2

public partial struct b16v2 
{
    public readonly b16v3 xxx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
    }
    public readonly b16v3 rrr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
    }
    public readonly b16v3 xxy
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
    }
    public readonly b16v3 rrg
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
    }
    public readonly b16v3 xyx
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
    }
    public readonly b16v3 rgr
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
    }
    public readonly b16v3 xyy
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
    }
    public readonly b16v3 rgg
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
    }
    public readonly b16v3 yxx
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
    }
    public readonly b16v3 grr
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
    }
    public readonly b16v3 yxy
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
    }
    public readonly b16v3 grg
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
    }
    public readonly b16v3 yyx
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
    }
    public readonly b16v3 ggr
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
    }
    public readonly b16v3 yyy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
    }
    public readonly b16v3 ggg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
    }
}

#endregion // b16v2

#region b32v2

public partial struct b32v2 
{
    public readonly b32v3 xxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly b32v3 rrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly b32v3 xxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly b32v3 rrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly b32v3 xyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly b32v3 rgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly b32v3 xyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public readonly b32v3 rgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public readonly b32v3 yxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly b32v3 grr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly b32v3 yxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public readonly b32v3 grg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public readonly b32v3 yyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly b32v3 ggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly b32v3 yyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
    public readonly b32v3 ggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
}

#endregion // b32v2

#region b64v2

public partial struct b64v2 
{
    public readonly b64v3 xxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly b64v3 rrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly b64v3 xxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly b64v3 rrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly b64v3 xyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly b64v3 rgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly b64v3 xyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public readonly b64v3 rgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public readonly b64v3 yxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly b64v3 grr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly b64v3 yxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public readonly b64v3 grg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public readonly b64v3 yyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly b64v3 ggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly b64v3 yyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
    public readonly b64v3 ggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
}

#endregion // b64v2
