// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region float2

public partial struct float2 
{
    public readonly float4 xxxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 0, 0, 0)));
            else
                return new(x, x, x, x);
        }
    }
    public readonly float4 rrrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 0, 0, 0)));
            else
                return new(x, x, x, x);
        }
    }
    public readonly float4 xxxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 0, 0, 1)));
            else
                return new(x, x, x, y);
        }
    }
    public readonly float4 rrrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 0, 0, 1)));
            else
                return new(x, x, x, y);
        }
    }
    public readonly float4 xxyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 0, 1, 0)));
            else
                return new(x, x, y, x);
        }
    }
    public readonly float4 rrgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 0, 1, 0)));
            else
                return new(x, x, y, x);
        }
    }
    public readonly float4 xxyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 0, 1, 1)));
            else
                return new(x, x, y, y);
        }
    }
    public readonly float4 rrgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 0, 1, 1)));
            else
                return new(x, x, y, y);
        }
    }
    public readonly float4 xyxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 1, 0, 0)));
            else
                return new(x, y, x, x);
        }
    }
    public readonly float4 rgrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 1, 0, 0)));
            else
                return new(x, y, x, x);
        }
    }
    public readonly float4 xyxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 1, 0, 1)));
            else
                return new(x, y, x, y);
        }
    }
    public readonly float4 rgrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 1, 0, 1)));
            else
                return new(x, y, x, y);
        }
    }
    public readonly float4 xyyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 1, 1, 0)));
            else
                return new(x, y, y, x);
        }
    }
    public readonly float4 rggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 1, 1, 0)));
            else
                return new(x, y, y, x);
        }
    }
    public readonly float4 xyyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 1, 1, 1)));
            else
                return new(x, y, y, y);
        }
    }
    public readonly float4 rggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 1, 1, 1)));
            else
                return new(x, y, y, y);
        }
    }
    public readonly float4 yxxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 0, 0, 0)));
            else
                return new(y, x, x, x);
        }
    }
    public readonly float4 grrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 0, 0, 0)));
            else
                return new(y, x, x, x);
        }
    }
    public readonly float4 yxxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 0, 0, 1)));
            else
                return new(y, x, x, y);
        }
    }
    public readonly float4 grrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 0, 0, 1)));
            else
                return new(y, x, x, y);
        }
    }
    public readonly float4 yxyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 0, 1, 0)));
            else
                return new(y, x, y, x);
        }
    }
    public readonly float4 grgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 0, 1, 0)));
            else
                return new(y, x, y, x);
        }
    }
    public readonly float4 yxyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 0, 1, 1)));
            else
                return new(y, x, y, y);
        }
    }
    public readonly float4 grgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 0, 1, 1)));
            else
                return new(y, x, y, y);
        }
    }
    public readonly float4 yyxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 1, 0, 0)));
            else
                return new(y, y, x, x);
        }
    }
    public readonly float4 ggrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 1, 0, 0)));
            else
                return new(y, y, x, x);
        }
    }
    public readonly float4 yyxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 1, 0, 1)));
            else
                return new(y, y, x, y);
        }
    }
    public readonly float4 ggrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 1, 0, 1)));
            else
                return new(y, y, x, y);
        }
    }
    public readonly float4 yyyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 1, 1, 0)));
            else
                return new(y, y, y, x);
        }
    }
    public readonly float4 gggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 1, 1, 0)));
            else
                return new(y, y, y, x);
        }
    }
    public readonly float4 yyyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 1, 1, 1)));
            else
                return new(y, y, y, y);
        }
    }
    public readonly float4 gggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 1, 1, 1)));
            else
                return new(y, y, y, y);
        }
    }
}

#endregion // float2

#region double2

public partial struct double2 
{
    public readonly double4 xxxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 0, 0, 0)));
            else
                return new(x, x, x, x);
        }
    }
    public readonly double4 rrrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 0, 0, 0)));
            else
                return new(x, x, x, x);
        }
    }
    public readonly double4 xxxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 0, 0, 1)));
            else
                return new(x, x, x, y);
        }
    }
    public readonly double4 rrrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 0, 0, 1)));
            else
                return new(x, x, x, y);
        }
    }
    public readonly double4 xxyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 0, 1, 0)));
            else
                return new(x, x, y, x);
        }
    }
    public readonly double4 rrgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 0, 1, 0)));
            else
                return new(x, x, y, x);
        }
    }
    public readonly double4 xxyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 0, 1, 1)));
            else
                return new(x, x, y, y);
        }
    }
    public readonly double4 rrgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 0, 1, 1)));
            else
                return new(x, x, y, y);
        }
    }
    public readonly double4 xyxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 1, 0, 0)));
            else
                return new(x, y, x, x);
        }
    }
    public readonly double4 rgrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 1, 0, 0)));
            else
                return new(x, y, x, x);
        }
    }
    public readonly double4 xyxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 1, 0, 1)));
            else
                return new(x, y, x, y);
        }
    }
    public readonly double4 rgrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 1, 0, 1)));
            else
                return new(x, y, x, y);
        }
    }
    public readonly double4 xyyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 1, 1, 0)));
            else
                return new(x, y, y, x);
        }
    }
    public readonly double4 rggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 1, 1, 0)));
            else
                return new(x, y, y, x);
        }
    }
    public readonly double4 xyyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 1, 1, 1)));
            else
                return new(x, y, y, y);
        }
    }
    public readonly double4 rggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 1, 1, 1)));
            else
                return new(x, y, y, y);
        }
    }
    public readonly double4 yxxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 0, 0, 0)));
            else
                return new(y, x, x, x);
        }
    }
    public readonly double4 grrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 0, 0, 0)));
            else
                return new(y, x, x, x);
        }
    }
    public readonly double4 yxxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 0, 0, 1)));
            else
                return new(y, x, x, y);
        }
    }
    public readonly double4 grrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 0, 0, 1)));
            else
                return new(y, x, x, y);
        }
    }
    public readonly double4 yxyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 0, 1, 0)));
            else
                return new(y, x, y, x);
        }
    }
    public readonly double4 grgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 0, 1, 0)));
            else
                return new(y, x, y, x);
        }
    }
    public readonly double4 yxyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 0, 1, 1)));
            else
                return new(y, x, y, y);
        }
    }
    public readonly double4 grgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 0, 1, 1)));
            else
                return new(y, x, y, y);
        }
    }
    public readonly double4 yyxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 1, 0, 0)));
            else
                return new(y, y, x, x);
        }
    }
    public readonly double4 ggrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 1, 0, 0)));
            else
                return new(y, y, x, x);
        }
    }
    public readonly double4 yyxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 1, 0, 1)));
            else
                return new(y, y, x, y);
        }
    }
    public readonly double4 ggrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 1, 0, 1)));
            else
                return new(y, y, x, y);
        }
    }
    public readonly double4 yyyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 1, 1, 0)));
            else
                return new(y, y, y, x);
        }
    }
    public readonly double4 gggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 1, 1, 0)));
            else
                return new(y, y, y, x);
        }
    }
    public readonly double4 yyyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 1, 1, 1)));
            else
                return new(y, y, y, y);
        }
    }
    public readonly double4 gggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 1, 1, 1)));
            else
                return new(y, y, y, y);
        }
    }
}

#endregion // double2

#region short2

public partial struct short2 
{
    public readonly short4 xxxx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x, x);
    }
    public readonly short4 rrrr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x, x);
    }
    public readonly short4 xxxy
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x, y);
    }
    public readonly short4 rrrg
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x, y);
    }
    public readonly short4 xxyx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y, x);
    }
    public readonly short4 rrgr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y, x);
    }
    public readonly short4 xxyy
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y, y);
    }
    public readonly short4 rrgg
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y, y);
    }
    public readonly short4 xyxx
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x, x);
    }
    public readonly short4 rgrr
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x, x);
    }
    public readonly short4 xyxy
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x, y);
    }
    public readonly short4 rgrg
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x, y);
    }
    public readonly short4 xyyx
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y, x);
    }
    public readonly short4 rggr
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y, x);
    }
    public readonly short4 xyyy
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y, y);
    }
    public readonly short4 rggg
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y, y);
    }
    public readonly short4 yxxx
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x, x);
    }
    public readonly short4 grrr
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x, x);
    }
    public readonly short4 yxxy
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x, y);
    }
    public readonly short4 grrg
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x, y);
    }
    public readonly short4 yxyx
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y, x);
    }
    public readonly short4 grgr
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y, x);
    }
    public readonly short4 yxyy
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y, y);
    }
    public readonly short4 grgg
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y, y);
    }
    public readonly short4 yyxx
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x, x);
    }
    public readonly short4 ggrr
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x, x);
    }
    public readonly short4 yyxy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x, y);
    }
    public readonly short4 ggrg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x, y);
    }
    public readonly short4 yyyx
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y, x);
    }
    public readonly short4 gggr
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y, x);
    }
    public readonly short4 yyyy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y, y);
    }
    public readonly short4 gggg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y, y);
    }
}

#endregion // short2

#region ushort2

public partial struct ushort2 
{
    public readonly ushort4 xxxx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x, x);
    }
    public readonly ushort4 rrrr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x, x);
    }
    public readonly ushort4 xxxy
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x, y);
    }
    public readonly ushort4 rrrg
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x, y);
    }
    public readonly ushort4 xxyx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y, x);
    }
    public readonly ushort4 rrgr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y, x);
    }
    public readonly ushort4 xxyy
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y, y);
    }
    public readonly ushort4 rrgg
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y, y);
    }
    public readonly ushort4 xyxx
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x, x);
    }
    public readonly ushort4 rgrr
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x, x);
    }
    public readonly ushort4 xyxy
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x, y);
    }
    public readonly ushort4 rgrg
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x, y);
    }
    public readonly ushort4 xyyx
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y, x);
    }
    public readonly ushort4 rggr
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y, x);
    }
    public readonly ushort4 xyyy
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y, y);
    }
    public readonly ushort4 rggg
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y, y);
    }
    public readonly ushort4 yxxx
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x, x);
    }
    public readonly ushort4 grrr
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x, x);
    }
    public readonly ushort4 yxxy
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x, y);
    }
    public readonly ushort4 grrg
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x, y);
    }
    public readonly ushort4 yxyx
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y, x);
    }
    public readonly ushort4 grgr
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y, x);
    }
    public readonly ushort4 yxyy
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y, y);
    }
    public readonly ushort4 grgg
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y, y);
    }
    public readonly ushort4 yyxx
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x, x);
    }
    public readonly ushort4 ggrr
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x, x);
    }
    public readonly ushort4 yyxy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x, y);
    }
    public readonly ushort4 ggrg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x, y);
    }
    public readonly ushort4 yyyx
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y, x);
    }
    public readonly ushort4 gggr
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y, x);
    }
    public readonly ushort4 yyyy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y, y);
    }
    public readonly ushort4 gggg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y, y);
    }
}

#endregion // ushort2

#region int2

public partial struct int2 
{
    public readonly int4 xxxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 0, 0, 0)));
            else
                return new(x, x, x, x);
        }
    }
    public readonly int4 rrrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 0, 0, 0)));
            else
                return new(x, x, x, x);
        }
    }
    public readonly int4 xxxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 0, 0, 1)));
            else
                return new(x, x, x, y);
        }
    }
    public readonly int4 rrrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 0, 0, 1)));
            else
                return new(x, x, x, y);
        }
    }
    public readonly int4 xxyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 0, 1, 0)));
            else
                return new(x, x, y, x);
        }
    }
    public readonly int4 rrgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 0, 1, 0)));
            else
                return new(x, x, y, x);
        }
    }
    public readonly int4 xxyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 0, 1, 1)));
            else
                return new(x, x, y, y);
        }
    }
    public readonly int4 rrgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 0, 1, 1)));
            else
                return new(x, x, y, y);
        }
    }
    public readonly int4 xyxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 1, 0, 0)));
            else
                return new(x, y, x, x);
        }
    }
    public readonly int4 rgrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 1, 0, 0)));
            else
                return new(x, y, x, x);
        }
    }
    public readonly int4 xyxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 1, 0, 1)));
            else
                return new(x, y, x, y);
        }
    }
    public readonly int4 rgrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 1, 0, 1)));
            else
                return new(x, y, x, y);
        }
    }
    public readonly int4 xyyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 1, 1, 0)));
            else
                return new(x, y, y, x);
        }
    }
    public readonly int4 rggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 1, 1, 0)));
            else
                return new(x, y, y, x);
        }
    }
    public readonly int4 xyyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 1, 1, 1)));
            else
                return new(x, y, y, y);
        }
    }
    public readonly int4 rggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(0, 1, 1, 1)));
            else
                return new(x, y, y, y);
        }
    }
    public readonly int4 yxxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 0, 0, 0)));
            else
                return new(y, x, x, x);
        }
    }
    public readonly int4 grrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 0, 0, 0)));
            else
                return new(y, x, x, x);
        }
    }
    public readonly int4 yxxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 0, 0, 1)));
            else
                return new(y, x, x, y);
        }
    }
    public readonly int4 grrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 0, 0, 1)));
            else
                return new(y, x, x, y);
        }
    }
    public readonly int4 yxyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 0, 1, 0)));
            else
                return new(y, x, y, x);
        }
    }
    public readonly int4 grgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 0, 1, 0)));
            else
                return new(y, x, y, x);
        }
    }
    public readonly int4 yxyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 0, 1, 1)));
            else
                return new(y, x, y, y);
        }
    }
    public readonly int4 grgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 0, 1, 1)));
            else
                return new(y, x, y, y);
        }
    }
    public readonly int4 yyxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 1, 0, 0)));
            else
                return new(y, y, x, x);
        }
    }
    public readonly int4 ggrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 1, 0, 0)));
            else
                return new(y, y, x, x);
        }
    }
    public readonly int4 yyxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 1, 0, 1)));
            else
                return new(y, y, x, y);
        }
    }
    public readonly int4 ggrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 1, 0, 1)));
            else
                return new(y, y, x, y);
        }
    }
    public readonly int4 yyyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 1, 1, 0)));
            else
                return new(y, y, y, x);
        }
    }
    public readonly int4 gggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 1, 1, 0)));
            else
                return new(y, y, y, x);
        }
    }
    public readonly int4 yyyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 1, 1, 1)));
            else
                return new(y, y, y, y);
        }
    }
    public readonly int4 gggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create(1, 1, 1, 1)));
            else
                return new(y, y, y, y);
        }
    }
}

#endregion // int2

#region uint2

public partial struct uint2 
{
    public readonly uint4 xxxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 0, 0, 0)));
            else
                return new(x, x, x, x);
        }
    }
    public readonly uint4 rrrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 0, 0, 0)));
            else
                return new(x, x, x, x);
        }
    }
    public readonly uint4 xxxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 0, 0, 1)));
            else
                return new(x, x, x, y);
        }
    }
    public readonly uint4 rrrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 0, 0, 1)));
            else
                return new(x, x, x, y);
        }
    }
    public readonly uint4 xxyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 0, 1, 0)));
            else
                return new(x, x, y, x);
        }
    }
    public readonly uint4 rrgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 0, 1, 0)));
            else
                return new(x, x, y, x);
        }
    }
    public readonly uint4 xxyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 0, 1, 1)));
            else
                return new(x, x, y, y);
        }
    }
    public readonly uint4 rrgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 0, 1, 1)));
            else
                return new(x, x, y, y);
        }
    }
    public readonly uint4 xyxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 1, 0, 0)));
            else
                return new(x, y, x, x);
        }
    }
    public readonly uint4 rgrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 1, 0, 0)));
            else
                return new(x, y, x, x);
        }
    }
    public readonly uint4 xyxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 1, 0, 1)));
            else
                return new(x, y, x, y);
        }
    }
    public readonly uint4 rgrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 1, 0, 1)));
            else
                return new(x, y, x, y);
        }
    }
    public readonly uint4 xyyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 1, 1, 0)));
            else
                return new(x, y, y, x);
        }
    }
    public readonly uint4 rggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 1, 1, 0)));
            else
                return new(x, y, y, x);
        }
    }
    public readonly uint4 xyyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 1, 1, 1)));
            else
                return new(x, y, y, y);
        }
    }
    public readonly uint4 rggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 1, 1, 1)));
            else
                return new(x, y, y, y);
        }
    }
    public readonly uint4 yxxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 0, 0, 0)));
            else
                return new(y, x, x, x);
        }
    }
    public readonly uint4 grrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 0, 0, 0)));
            else
                return new(y, x, x, x);
        }
    }
    public readonly uint4 yxxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 0, 0, 1)));
            else
                return new(y, x, x, y);
        }
    }
    public readonly uint4 grrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 0, 0, 1)));
            else
                return new(y, x, x, y);
        }
    }
    public readonly uint4 yxyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 0, 1, 0)));
            else
                return new(y, x, y, x);
        }
    }
    public readonly uint4 grgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 0, 1, 0)));
            else
                return new(y, x, y, x);
        }
    }
    public readonly uint4 yxyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 0, 1, 1)));
            else
                return new(y, x, y, y);
        }
    }
    public readonly uint4 grgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 0, 1, 1)));
            else
                return new(y, x, y, y);
        }
    }
    public readonly uint4 yyxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 1, 0, 0)));
            else
                return new(y, y, x, x);
        }
    }
    public readonly uint4 ggrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 1, 0, 0)));
            else
                return new(y, y, x, x);
        }
    }
    public readonly uint4 yyxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 1, 0, 1)));
            else
                return new(y, y, x, y);
        }
    }
    public readonly uint4 ggrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 1, 0, 1)));
            else
                return new(y, y, x, y);
        }
    }
    public readonly uint4 yyyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 1, 1, 0)));
            else
                return new(y, y, y, x);
        }
    }
    public readonly uint4 gggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 1, 1, 0)));
            else
                return new(y, y, y, x);
        }
    }
    public readonly uint4 yyyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 1, 1, 1)));
            else
                return new(y, y, y, y);
        }
    }
    public readonly uint4 gggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 1, 1, 1)));
            else
                return new(y, y, y, y);
        }
    }
}

#endregion // uint2

#region long2

public partial struct long2 
{
    public readonly long4 xxxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 0, 0, 0)));
            else
                return new(x, x, x, x);
        }
    }
    public readonly long4 rrrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 0, 0, 0)));
            else
                return new(x, x, x, x);
        }
    }
    public readonly long4 xxxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 0, 0, 1)));
            else
                return new(x, x, x, y);
        }
    }
    public readonly long4 rrrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 0, 0, 1)));
            else
                return new(x, x, x, y);
        }
    }
    public readonly long4 xxyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 0, 1, 0)));
            else
                return new(x, x, y, x);
        }
    }
    public readonly long4 rrgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 0, 1, 0)));
            else
                return new(x, x, y, x);
        }
    }
    public readonly long4 xxyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 0, 1, 1)));
            else
                return new(x, x, y, y);
        }
    }
    public readonly long4 rrgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 0, 1, 1)));
            else
                return new(x, x, y, y);
        }
    }
    public readonly long4 xyxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 1, 0, 0)));
            else
                return new(x, y, x, x);
        }
    }
    public readonly long4 rgrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 1, 0, 0)));
            else
                return new(x, y, x, x);
        }
    }
    public readonly long4 xyxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 1, 0, 1)));
            else
                return new(x, y, x, y);
        }
    }
    public readonly long4 rgrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 1, 0, 1)));
            else
                return new(x, y, x, y);
        }
    }
    public readonly long4 xyyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 1, 1, 0)));
            else
                return new(x, y, y, x);
        }
    }
    public readonly long4 rggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 1, 1, 0)));
            else
                return new(x, y, y, x);
        }
    }
    public readonly long4 xyyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 1, 1, 1)));
            else
                return new(x, y, y, y);
        }
    }
    public readonly long4 rggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(0, 1, 1, 1)));
            else
                return new(x, y, y, y);
        }
    }
    public readonly long4 yxxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 0, 0, 0)));
            else
                return new(y, x, x, x);
        }
    }
    public readonly long4 grrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 0, 0, 0)));
            else
                return new(y, x, x, x);
        }
    }
    public readonly long4 yxxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 0, 0, 1)));
            else
                return new(y, x, x, y);
        }
    }
    public readonly long4 grrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 0, 0, 1)));
            else
                return new(y, x, x, y);
        }
    }
    public readonly long4 yxyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 0, 1, 0)));
            else
                return new(y, x, y, x);
        }
    }
    public readonly long4 grgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 0, 1, 0)));
            else
                return new(y, x, y, x);
        }
    }
    public readonly long4 yxyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 0, 1, 1)));
            else
                return new(y, x, y, y);
        }
    }
    public readonly long4 grgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 0, 1, 1)));
            else
                return new(y, x, y, y);
        }
    }
    public readonly long4 yyxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 1, 0, 0)));
            else
                return new(y, y, x, x);
        }
    }
    public readonly long4 ggrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 1, 0, 0)));
            else
                return new(y, y, x, x);
        }
    }
    public readonly long4 yyxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 1, 0, 1)));
            else
                return new(y, y, x, y);
        }
    }
    public readonly long4 ggrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 1, 0, 1)));
            else
                return new(y, y, x, y);
        }
    }
    public readonly long4 yyyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 1, 1, 0)));
            else
                return new(y, y, y, x);
        }
    }
    public readonly long4 gggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 1, 1, 0)));
            else
                return new(y, y, y, x);
        }
    }
    public readonly long4 yyyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 1, 1, 1)));
            else
                return new(y, y, y, y);
        }
    }
    public readonly long4 gggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create(1, 1, 1, 1)));
            else
                return new(y, y, y, y);
        }
    }
}

#endregion // long2

#region ulong2

public partial struct ulong2 
{
    public readonly ulong4 xxxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 0, 0, 0)));
            else
                return new(x, x, x, x);
        }
    }
    public readonly ulong4 rrrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 0, 0, 0)));
            else
                return new(x, x, x, x);
        }
    }
    public readonly ulong4 xxxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 0, 0, 1)));
            else
                return new(x, x, x, y);
        }
    }
    public readonly ulong4 rrrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 0, 0, 1)));
            else
                return new(x, x, x, y);
        }
    }
    public readonly ulong4 xxyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 0, 1, 0)));
            else
                return new(x, x, y, x);
        }
    }
    public readonly ulong4 rrgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 0, 1, 0)));
            else
                return new(x, x, y, x);
        }
    }
    public readonly ulong4 xxyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 0, 1, 1)));
            else
                return new(x, x, y, y);
        }
    }
    public readonly ulong4 rrgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 0, 1, 1)));
            else
                return new(x, x, y, y);
        }
    }
    public readonly ulong4 xyxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 1, 0, 0)));
            else
                return new(x, y, x, x);
        }
    }
    public readonly ulong4 rgrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 1, 0, 0)));
            else
                return new(x, y, x, x);
        }
    }
    public readonly ulong4 xyxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 1, 0, 1)));
            else
                return new(x, y, x, y);
        }
    }
    public readonly ulong4 rgrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 1, 0, 1)));
            else
                return new(x, y, x, y);
        }
    }
    public readonly ulong4 xyyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 1, 1, 0)));
            else
                return new(x, y, y, x);
        }
    }
    public readonly ulong4 rggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 1, 1, 0)));
            else
                return new(x, y, y, x);
        }
    }
    public readonly ulong4 xyyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 1, 1, 1)));
            else
                return new(x, y, y, y);
        }
    }
    public readonly ulong4 rggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 1, 1, 1)));
            else
                return new(x, y, y, y);
        }
    }
    public readonly ulong4 yxxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 0, 0, 0)));
            else
                return new(y, x, x, x);
        }
    }
    public readonly ulong4 grrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 0, 0, 0)));
            else
                return new(y, x, x, x);
        }
    }
    public readonly ulong4 yxxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 0, 0, 1)));
            else
                return new(y, x, x, y);
        }
    }
    public readonly ulong4 grrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 0, 0, 1)));
            else
                return new(y, x, x, y);
        }
    }
    public readonly ulong4 yxyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 0, 1, 0)));
            else
                return new(y, x, y, x);
        }
    }
    public readonly ulong4 grgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 0, 1, 0)));
            else
                return new(y, x, y, x);
        }
    }
    public readonly ulong4 yxyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 0, 1, 1)));
            else
                return new(y, x, y, y);
        }
    }
    public readonly ulong4 grgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 0, 1, 1)));
            else
                return new(y, x, y, y);
        }
    }
    public readonly ulong4 yyxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 1, 0, 0)));
            else
                return new(y, y, x, x);
        }
    }
    public readonly ulong4 ggrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 1, 0, 0)));
            else
                return new(y, y, x, x);
        }
    }
    public readonly ulong4 yyxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 1, 0, 1)));
            else
                return new(y, y, x, y);
        }
    }
    public readonly ulong4 ggrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 1, 0, 1)));
            else
                return new(y, y, x, y);
        }
    }
    public readonly ulong4 yyyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 1, 1, 0)));
            else
                return new(y, y, y, x);
        }
    }
    public readonly ulong4 gggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 1, 1, 0)));
            else
                return new(y, y, y, x);
        }
    }
    public readonly ulong4 yyyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 1, 1, 1)));
            else
                return new(y, y, y, y);
        }
    }
    public readonly ulong4 gggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 1, 1, 1)));
            else
                return new(y, y, y, y);
        }
    }
}

#endregion // ulong2

#region decimal2

public partial struct decimal2 
{
    public readonly decimal4 xxxx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x, x);
    }
    public readonly decimal4 rrrr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x, x);
    }
    public readonly decimal4 xxxy
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x, y);
    }
    public readonly decimal4 rrrg
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x, y);
    }
    public readonly decimal4 xxyx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y, x);
    }
    public readonly decimal4 rrgr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y, x);
    }
    public readonly decimal4 xxyy
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y, y);
    }
    public readonly decimal4 rrgg
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y, y);
    }
    public readonly decimal4 xyxx
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x, x);
    }
    public readonly decimal4 rgrr
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x, x);
    }
    public readonly decimal4 xyxy
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x, y);
    }
    public readonly decimal4 rgrg
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x, y);
    }
    public readonly decimal4 xyyx
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y, x);
    }
    public readonly decimal4 rggr
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y, x);
    }
    public readonly decimal4 xyyy
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y, y);
    }
    public readonly decimal4 rggg
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y, y);
    }
    public readonly decimal4 yxxx
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x, x);
    }
    public readonly decimal4 grrr
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x, x);
    }
    public readonly decimal4 yxxy
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x, y);
    }
    public readonly decimal4 grrg
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x, y);
    }
    public readonly decimal4 yxyx
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y, x);
    }
    public readonly decimal4 grgr
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y, x);
    }
    public readonly decimal4 yxyy
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y, y);
    }
    public readonly decimal4 grgg
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y, y);
    }
    public readonly decimal4 yyxx
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x, x);
    }
    public readonly decimal4 ggrr
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x, x);
    }
    public readonly decimal4 yyxy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x, y);
    }
    public readonly decimal4 ggrg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x, y);
    }
    public readonly decimal4 yyyx
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y, x);
    }
    public readonly decimal4 gggr
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y, x);
    }
    public readonly decimal4 yyyy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y, y);
    }
    public readonly decimal4 gggg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y, y);
    }
}

#endregion // decimal2

#region half2

public partial struct half2 
{
    public readonly half4 xxxx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x, x);
    }
    public readonly half4 rrrr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x, x);
    }
    public readonly half4 xxxy
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x, y);
    }
    public readonly half4 rrrg
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x, y);
    }
    public readonly half4 xxyx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y, x);
    }
    public readonly half4 rrgr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y, x);
    }
    public readonly half4 xxyy
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y, y);
    }
    public readonly half4 rrgg
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y, y);
    }
    public readonly half4 xyxx
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x, x);
    }
    public readonly half4 rgrr
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x, x);
    }
    public readonly half4 xyxy
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x, y);
    }
    public readonly half4 rgrg
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x, y);
    }
    public readonly half4 xyyx
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y, x);
    }
    public readonly half4 rggr
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y, x);
    }
    public readonly half4 xyyy
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y, y);
    }
    public readonly half4 rggg
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y, y);
    }
    public readonly half4 yxxx
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x, x);
    }
    public readonly half4 grrr
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x, x);
    }
    public readonly half4 yxxy
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x, y);
    }
    public readonly half4 grrg
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x, y);
    }
    public readonly half4 yxyx
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y, x);
    }
    public readonly half4 grgr
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y, x);
    }
    public readonly half4 yxyy
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y, y);
    }
    public readonly half4 grgg
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y, y);
    }
    public readonly half4 yyxx
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x, x);
    }
    public readonly half4 ggrr
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x, x);
    }
    public readonly half4 yyxy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x, y);
    }
    public readonly half4 ggrg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x, y);
    }
    public readonly half4 yyyx
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y, x);
    }
    public readonly half4 gggr
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y, x);
    }
    public readonly half4 yyyy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y, y);
    }
    public readonly half4 gggg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y, y);
    }
}

#endregion // half2

#region b16v2

public partial struct b16v2 
{
    public readonly b16v4 xxxx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x, x);
    }
    public readonly b16v4 rrrr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x, x);
    }
    public readonly b16v4 xxxy
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x, y);
    }
    public readonly b16v4 rrrg
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x, y);
    }
    public readonly b16v4 xxyx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y, x);
    }
    public readonly b16v4 rrgr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y, x);
    }
    public readonly b16v4 xxyy
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y, y);
    }
    public readonly b16v4 rrgg
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y, y);
    }
    public readonly b16v4 xyxx
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x, x);
    }
    public readonly b16v4 rgrr
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x, x);
    }
    public readonly b16v4 xyxy
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x, y);
    }
    public readonly b16v4 rgrg
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x, y);
    }
    public readonly b16v4 xyyx
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y, x);
    }
    public readonly b16v4 rggr
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y, x);
    }
    public readonly b16v4 xyyy
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y, y);
    }
    public readonly b16v4 rggg
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y, y);
    }
    public readonly b16v4 yxxx
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x, x);
    }
    public readonly b16v4 grrr
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x, x);
    }
    public readonly b16v4 yxxy
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x, y);
    }
    public readonly b16v4 grrg
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x, y);
    }
    public readonly b16v4 yxyx
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y, x);
    }
    public readonly b16v4 grgr
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y, x);
    }
    public readonly b16v4 yxyy
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y, y);
    }
    public readonly b16v4 grgg
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y, y);
    }
    public readonly b16v4 yyxx
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x, x);
    }
    public readonly b16v4 ggrr
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x, x);
    }
    public readonly b16v4 yyxy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x, y);
    }
    public readonly b16v4 ggrg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x, y);
    }
    public readonly b16v4 yyyx
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y, x);
    }
    public readonly b16v4 gggr
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y, x);
    }
    public readonly b16v4 yyyy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y, y);
    }
    public readonly b16v4 gggg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y, y);
    }
}

#endregion // b16v2

#region b32v2

public partial struct b32v2 
{
    public readonly b32v4 xxxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 0, 0, 0)));
            else
                return new(x, x, x, x);
        }
    }
    public readonly b32v4 rrrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 0, 0, 0)));
            else
                return new(x, x, x, x);
        }
    }
    public readonly b32v4 xxxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 0, 0, 1)));
            else
                return new(x, x, x, y);
        }
    }
    public readonly b32v4 rrrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 0, 0, 1)));
            else
                return new(x, x, x, y);
        }
    }
    public readonly b32v4 xxyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 0, 1, 0)));
            else
                return new(x, x, y, x);
        }
    }
    public readonly b32v4 rrgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 0, 1, 0)));
            else
                return new(x, x, y, x);
        }
    }
    public readonly b32v4 xxyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 0, 1, 1)));
            else
                return new(x, x, y, y);
        }
    }
    public readonly b32v4 rrgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 0, 1, 1)));
            else
                return new(x, x, y, y);
        }
    }
    public readonly b32v4 xyxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 1, 0, 0)));
            else
                return new(x, y, x, x);
        }
    }
    public readonly b32v4 rgrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 1, 0, 0)));
            else
                return new(x, y, x, x);
        }
    }
    public readonly b32v4 xyxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 1, 0, 1)));
            else
                return new(x, y, x, y);
        }
    }
    public readonly b32v4 rgrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 1, 0, 1)));
            else
                return new(x, y, x, y);
        }
    }
    public readonly b32v4 xyyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 1, 1, 0)));
            else
                return new(x, y, y, x);
        }
    }
    public readonly b32v4 rggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 1, 1, 0)));
            else
                return new(x, y, y, x);
        }
    }
    public readonly b32v4 xyyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 1, 1, 1)));
            else
                return new(x, y, y, y);
        }
    }
    public readonly b32v4 rggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)0, 1, 1, 1)));
            else
                return new(x, y, y, y);
        }
    }
    public readonly b32v4 yxxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 0, 0, 0)));
            else
                return new(y, x, x, x);
        }
    }
    public readonly b32v4 grrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 0, 0, 0)));
            else
                return new(y, x, x, x);
        }
    }
    public readonly b32v4 yxxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 0, 0, 1)));
            else
                return new(y, x, x, y);
        }
    }
    public readonly b32v4 grrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 0, 0, 1)));
            else
                return new(y, x, x, y);
        }
    }
    public readonly b32v4 yxyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 0, 1, 0)));
            else
                return new(y, x, y, x);
        }
    }
    public readonly b32v4 grgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 0, 1, 0)));
            else
                return new(y, x, y, x);
        }
    }
    public readonly b32v4 yxyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 0, 1, 1)));
            else
                return new(y, x, y, y);
        }
    }
    public readonly b32v4 grgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 0, 1, 1)));
            else
                return new(y, x, y, y);
        }
    }
    public readonly b32v4 yyxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 1, 0, 0)));
            else
                return new(y, y, x, x);
        }
    }
    public readonly b32v4 ggrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 1, 0, 0)));
            else
                return new(y, y, x, x);
        }
    }
    public readonly b32v4 yyxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 1, 0, 1)));
            else
                return new(y, y, x, y);
        }
    }
    public readonly b32v4 ggrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 1, 0, 1)));
            else
                return new(y, y, x, y);
        }
    }
    public readonly b32v4 yyyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 1, 1, 0)));
            else
                return new(y, y, y, x);
        }
    }
    public readonly b32v4 gggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 1, 1, 0)));
            else
                return new(y, y, y, x);
        }
    }
    public readonly b32v4 yyyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 1, 1, 1)));
            else
                return new(y, y, y, y);
        }
    }
    public readonly b32v4 gggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector.ToVector128(), Vector128.Create((uint)1, 1, 1, 1)));
            else
                return new(y, y, y, y);
        }
    }
}

#endregion // b32v2

#region b64v2

public partial struct b64v2 
{
    public readonly b64v4 xxxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 0, 0, 0)));
            else
                return new(x, x, x, x);
        }
    }
    public readonly b64v4 rrrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 0, 0, 0)));
            else
                return new(x, x, x, x);
        }
    }
    public readonly b64v4 xxxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 0, 0, 1)));
            else
                return new(x, x, x, y);
        }
    }
    public readonly b64v4 rrrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 0, 0, 1)));
            else
                return new(x, x, x, y);
        }
    }
    public readonly b64v4 xxyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 0, 1, 0)));
            else
                return new(x, x, y, x);
        }
    }
    public readonly b64v4 rrgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 0, 1, 0)));
            else
                return new(x, x, y, x);
        }
    }
    public readonly b64v4 xxyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 0, 1, 1)));
            else
                return new(x, x, y, y);
        }
    }
    public readonly b64v4 rrgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 0, 1, 1)));
            else
                return new(x, x, y, y);
        }
    }
    public readonly b64v4 xyxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 1, 0, 0)));
            else
                return new(x, y, x, x);
        }
    }
    public readonly b64v4 rgrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 1, 0, 0)));
            else
                return new(x, y, x, x);
        }
    }
    public readonly b64v4 xyxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 1, 0, 1)));
            else
                return new(x, y, x, y);
        }
    }
    public readonly b64v4 rgrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 1, 0, 1)));
            else
                return new(x, y, x, y);
        }
    }
    public readonly b64v4 xyyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 1, 1, 0)));
            else
                return new(x, y, y, x);
        }
    }
    public readonly b64v4 rggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 1, 1, 0)));
            else
                return new(x, y, y, x);
        }
    }
    public readonly b64v4 xyyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 1, 1, 1)));
            else
                return new(x, y, y, y);
        }
    }
    public readonly b64v4 rggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)0, 1, 1, 1)));
            else
                return new(x, y, y, y);
        }
    }
    public readonly b64v4 yxxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 0, 0, 0)));
            else
                return new(y, x, x, x);
        }
    }
    public readonly b64v4 grrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 0, 0, 0)));
            else
                return new(y, x, x, x);
        }
    }
    public readonly b64v4 yxxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 0, 0, 1)));
            else
                return new(y, x, x, y);
        }
    }
    public readonly b64v4 grrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 0, 0, 1)));
            else
                return new(y, x, x, y);
        }
    }
    public readonly b64v4 yxyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 0, 1, 0)));
            else
                return new(y, x, y, x);
        }
    }
    public readonly b64v4 grgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 0, 1, 0)));
            else
                return new(y, x, y, x);
        }
    }
    public readonly b64v4 yxyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 0, 1, 1)));
            else
                return new(y, x, y, y);
        }
    }
    public readonly b64v4 grgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 0, 1, 1)));
            else
                return new(y, x, y, y);
        }
    }
    public readonly b64v4 yyxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 1, 0, 0)));
            else
                return new(y, y, x, x);
        }
    }
    public readonly b64v4 ggrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 1, 0, 0)));
            else
                return new(y, y, x, x);
        }
    }
    public readonly b64v4 yyxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 1, 0, 1)));
            else
                return new(y, y, x, y);
        }
    }
    public readonly b64v4 ggrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 1, 0, 1)));
            else
                return new(y, y, x, y);
        }
    }
    public readonly b64v4 yyyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 1, 1, 0)));
            else
                return new(y, y, y, x);
        }
    }
    public readonly b64v4 gggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 1, 1, 0)));
            else
                return new(y, y, y, x);
        }
    }
    public readonly b64v4 yyyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 1, 1, 1)));
            else
                return new(y, y, y, y);
        }
    }
    public readonly b64v4 gggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector.ToVector256(), Vector256.Create((ulong)1, 1, 1, 1)));
            else
                return new(y, y, y, y);
        }
    }
}

#endregion // b64v2
