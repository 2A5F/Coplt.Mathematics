// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region float3

public partial struct float3 
{
    public readonly float2 xx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 0, 0)).GetLower());
            else
                return new(x, x);
        }
    }
    public readonly float2 rr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 0, 0)).GetLower());
            else
                return new(x, x);
        }
    }
    public float2 xy
    {
        [MethodImpl(256 | 512)]
        readonly get => Vector128.IsHardwareAccelerated ? new(vector.GetLower()) : new(x, y);
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, 0, -1, -1).AsSingle(), 
                    vector,
                    value.vector.ToVector128()
                );
            else { x = value.x; y = value.y; }
        }
    }
    public float2 rg
    {
        [MethodImpl(256 | 512)]
        readonly get => Vector128.IsHardwareAccelerated ? new(vector.GetLower()) : new(x, y);
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, 0, -1, -1).AsSingle(), 
                    vector,
                    value.vector.ToVector128()
                );
            else { x = value.x; y = value.y; }
        }
    }
    public float2 xz
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 0, 0)).GetLower());
            else
                return new(x, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, -1, 0, -1).AsSingle(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create(0, 0, 1, 0))
                );
            else { x = value.x; z = value.y; }
        }
    }
    public float2 rb
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 0, 0)).GetLower());
            else
                return new(x, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, -1, 0, -1).AsSingle(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create(0, 0, 1, 0))
                );
            else { x = value.x; z = value.y; }
        }
    }
    public float2 yx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 0, 0)).GetLower());
            else
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, 0, -1, -1).AsSingle(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create(1, 0, 0, 0))
                );
            else { y = value.x; x = value.y; }
        }
    }
    public float2 gr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 0, 0)).GetLower());
            else
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, 0, -1, -1).AsSingle(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create(1, 0, 0, 0))
                );
            else { y = value.x; x = value.y; }
        }
    }
    public readonly float2 yy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 0, 0)).GetLower());
            else
                return new(y, y);
        }
    }
    public readonly float2 gg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 0, 0)).GetLower());
            else
                return new(y, y);
        }
    }
    public float2 yz
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 0, 0)).GetLower());
            else
                return new(y, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(-1, 0, 0, -1).AsSingle(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create(0, 0, 1, 0))
                );
            else { y = value.x; z = value.y; }
        }
    }
    public float2 gb
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 0, 0)).GetLower());
            else
                return new(y, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(-1, 0, 0, -1).AsSingle(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create(0, 0, 1, 0))
                );
            else { y = value.x; z = value.y; }
        }
    }
    public float2 zx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 0, 0)).GetLower());
            else
                return new(z, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, -1, 0, -1).AsSingle(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create(1, 0, 0, 0))
                );
            else { z = value.x; x = value.y; }
        }
    }
    public float2 br
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 0, 0)).GetLower());
            else
                return new(z, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, -1, 0, -1).AsSingle(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create(1, 0, 0, 0))
                );
            else { z = value.x; x = value.y; }
        }
    }
    public float2 zy
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 0, 0)).GetLower());
            else
                return new(z, y);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(-1, 0, 0, -1).AsSingle(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create(0, 1, 0, 0))
                );
            else { z = value.x; y = value.y; }
        }
    }
    public float2 bg
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 0, 0)).GetLower());
            else
                return new(z, y);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(-1, 0, 0, -1).AsSingle(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create(0, 1, 0, 0))
                );
            else { z = value.x; y = value.y; }
        }
    }
    public readonly float2 zz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 0, 0)).GetLower());
            else
                return new(z, z);
        }
    }
    public readonly float2 bb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 0, 0)).GetLower());
            else
                return new(z, z);
        }
    }
}

#endregion // float3

#region double3

public partial struct double3 
{
    public readonly double2 xx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 0, 0)).GetLower());
            else
                return new(x, x);
        }
    }
    public readonly double2 rr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 0, 0)).GetLower());
            else
                return new(x, x);
        }
    }
    public double2 xy
    {
        [MethodImpl(256 | 512)]
        readonly get => Vector256.IsHardwareAccelerated ? new(vector.GetLower()) : new(x, y);
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, 0, -1, -1).AsDouble(), 
                    vector,
                    value.vector.ToVector256()
                );
            else { x = value.x; y = value.y; }
        }
    }
    public double2 rg
    {
        [MethodImpl(256 | 512)]
        readonly get => Vector256.IsHardwareAccelerated ? new(vector.GetLower()) : new(x, y);
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, 0, -1, -1).AsDouble(), 
                    vector,
                    value.vector.ToVector256()
                );
            else { x = value.x; y = value.y; }
        }
    }
    public double2 xz
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 0, 0)).GetLower());
            else
                return new(x, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, -1, 0, -1).AsDouble(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create(0, 0, 1, 0))
                );
            else { x = value.x; z = value.y; }
        }
    }
    public double2 rb
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 0, 0)).GetLower());
            else
                return new(x, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, -1, 0, -1).AsDouble(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create(0, 0, 1, 0))
                );
            else { x = value.x; z = value.y; }
        }
    }
    public double2 yx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 0, 0)).GetLower());
            else
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, 0, -1, -1).AsDouble(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create(1, 0, 0, 0))
                );
            else { y = value.x; x = value.y; }
        }
    }
    public double2 gr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 0, 0)).GetLower());
            else
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, 0, -1, -1).AsDouble(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create(1, 0, 0, 0))
                );
            else { y = value.x; x = value.y; }
        }
    }
    public readonly double2 yy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 0, 0)).GetLower());
            else
                return new(y, y);
        }
    }
    public readonly double2 gg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 0, 0)).GetLower());
            else
                return new(y, y);
        }
    }
    public double2 yz
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 0, 0)).GetLower());
            else
                return new(y, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(-1, 0, 0, -1).AsDouble(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create(0, 0, 1, 0))
                );
            else { y = value.x; z = value.y; }
        }
    }
    public double2 gb
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 0, 0)).GetLower());
            else
                return new(y, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(-1, 0, 0, -1).AsDouble(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create(0, 0, 1, 0))
                );
            else { y = value.x; z = value.y; }
        }
    }
    public double2 zx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 0, 0)).GetLower());
            else
                return new(z, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, -1, 0, -1).AsDouble(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create(1, 0, 0, 0))
                );
            else { z = value.x; x = value.y; }
        }
    }
    public double2 br
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 0, 0)).GetLower());
            else
                return new(z, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, -1, 0, -1).AsDouble(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create(1, 0, 0, 0))
                );
            else { z = value.x; x = value.y; }
        }
    }
    public double2 zy
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 0, 0)).GetLower());
            else
                return new(z, y);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(-1, 0, 0, -1).AsDouble(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create(0, 1, 0, 0))
                );
            else { z = value.x; y = value.y; }
        }
    }
    public double2 bg
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 0, 0)).GetLower());
            else
                return new(z, y);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(-1, 0, 0, -1).AsDouble(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create(0, 1, 0, 0))
                );
            else { z = value.x; y = value.y; }
        }
    }
    public readonly double2 zz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 0, 0)).GetLower());
            else
                return new(z, z);
        }
    }
    public readonly double2 bb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 0, 0)).GetLower());
            else
                return new(z, z);
        }
    }
}

#endregion // double3

#region short3

public partial struct short3 
{
    public readonly short2 xx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x);
    }
    public readonly short2 rr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x);
    }
    public short2 xy
    {
        [MethodImpl(256 | 512)]
        readonly get => new(x, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; }
    }
    public short2 rg
    {
        [MethodImpl(256 | 512)]
        readonly get => new(x, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; }
    }
    public short2 xz
    {
        [MethodImpl(256 | 512)]
        readonly get => new(x, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; }
    }
    public short2 rb
    {
        [MethodImpl(256 | 512)]
        readonly get => new(x, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; }
    }
    public short2 yx
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; }
    }
    public short2 gr
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; }
    }
    public readonly short2 yy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y);
    }
    public readonly short2 gg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y);
    }
    public short2 yz
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; }
    }
    public short2 gb
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; }
    }
    public short2 zx
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; }
    }
    public short2 br
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; }
    }
    public short2 zy
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; }
    }
    public short2 bg
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; }
    }
    public readonly short2 zz
    {
        [MethodImpl(256 | 512)]
        get => new(z, z);
    }
    public readonly short2 bb
    {
        [MethodImpl(256 | 512)]
        get => new(z, z);
    }
}

#endregion // short3

#region ushort3

public partial struct ushort3 
{
    public readonly ushort2 xx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x);
    }
    public readonly ushort2 rr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x);
    }
    public ushort2 xy
    {
        [MethodImpl(256 | 512)]
        readonly get => new(x, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; }
    }
    public ushort2 rg
    {
        [MethodImpl(256 | 512)]
        readonly get => new(x, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; }
    }
    public ushort2 xz
    {
        [MethodImpl(256 | 512)]
        readonly get => new(x, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; }
    }
    public ushort2 rb
    {
        [MethodImpl(256 | 512)]
        readonly get => new(x, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; }
    }
    public ushort2 yx
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; }
    }
    public ushort2 gr
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; }
    }
    public readonly ushort2 yy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y);
    }
    public readonly ushort2 gg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y);
    }
    public ushort2 yz
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; }
    }
    public ushort2 gb
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; }
    }
    public ushort2 zx
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; }
    }
    public ushort2 br
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; }
    }
    public ushort2 zy
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; }
    }
    public ushort2 bg
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; }
    }
    public readonly ushort2 zz
    {
        [MethodImpl(256 | 512)]
        get => new(z, z);
    }
    public readonly ushort2 bb
    {
        [MethodImpl(256 | 512)]
        get => new(z, z);
    }
}

#endregion // ushort3

#region int3

public partial struct int3 
{
    public readonly int2 xx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 0, 0)).GetLower());
            else
                return new(x, x);
        }
    }
    public readonly int2 rr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 0, 0)).GetLower());
            else
                return new(x, x);
        }
    }
    public int2 xy
    {
        [MethodImpl(256 | 512)]
        readonly get => Vector128.IsHardwareAccelerated ? new(vector.GetLower()) : new(x, y);
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, 0, -1, -1).AsInt32(), 
                    vector,
                    value.vector.ToVector128()
                );
            else { x = value.x; y = value.y; }
        }
    }
    public int2 rg
    {
        [MethodImpl(256 | 512)]
        readonly get => Vector128.IsHardwareAccelerated ? new(vector.GetLower()) : new(x, y);
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, 0, -1, -1).AsInt32(), 
                    vector,
                    value.vector.ToVector128()
                );
            else { x = value.x; y = value.y; }
        }
    }
    public int2 xz
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 0, 0)).GetLower());
            else
                return new(x, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, -1, 0, -1).AsInt32(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create(0, 0, 1, 0))
                );
            else { x = value.x; z = value.y; }
        }
    }
    public int2 rb
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 0, 0)).GetLower());
            else
                return new(x, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, -1, 0, -1).AsInt32(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create(0, 0, 1, 0))
                );
            else { x = value.x; z = value.y; }
        }
    }
    public int2 yx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 0, 0)).GetLower());
            else
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, 0, -1, -1).AsInt32(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create(1, 0, 0, 0))
                );
            else { y = value.x; x = value.y; }
        }
    }
    public int2 gr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 0, 0)).GetLower());
            else
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, 0, -1, -1).AsInt32(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create(1, 0, 0, 0))
                );
            else { y = value.x; x = value.y; }
        }
    }
    public readonly int2 yy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 0, 0)).GetLower());
            else
                return new(y, y);
        }
    }
    public readonly int2 gg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 0, 0)).GetLower());
            else
                return new(y, y);
        }
    }
    public int2 yz
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 0, 0)).GetLower());
            else
                return new(y, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(-1, 0, 0, -1).AsInt32(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create(0, 0, 1, 0))
                );
            else { y = value.x; z = value.y; }
        }
    }
    public int2 gb
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 0, 0)).GetLower());
            else
                return new(y, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(-1, 0, 0, -1).AsInt32(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create(0, 0, 1, 0))
                );
            else { y = value.x; z = value.y; }
        }
    }
    public int2 zx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 0, 0)).GetLower());
            else
                return new(z, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, -1, 0, -1).AsInt32(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create(1, 0, 0, 0))
                );
            else { z = value.x; x = value.y; }
        }
    }
    public int2 br
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 0, 0)).GetLower());
            else
                return new(z, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, -1, 0, -1).AsInt32(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create(1, 0, 0, 0))
                );
            else { z = value.x; x = value.y; }
        }
    }
    public int2 zy
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 0, 0)).GetLower());
            else
                return new(z, y);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(-1, 0, 0, -1).AsInt32(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create(0, 1, 0, 0))
                );
            else { z = value.x; y = value.y; }
        }
    }
    public int2 bg
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 0, 0)).GetLower());
            else
                return new(z, y);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(-1, 0, 0, -1).AsInt32(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create(0, 1, 0, 0))
                );
            else { z = value.x; y = value.y; }
        }
    }
    public readonly int2 zz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 0, 0)).GetLower());
            else
                return new(z, z);
        }
    }
    public readonly int2 bb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 0, 0)).GetLower());
            else
                return new(z, z);
        }
    }
}

#endregion // int3

#region uint3

public partial struct uint3 
{
    public readonly uint2 xx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 0, 0)).GetLower());
            else
                return new(x, x);
        }
    }
    public readonly uint2 rr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 0, 0)).GetLower());
            else
                return new(x, x);
        }
    }
    public uint2 xy
    {
        [MethodImpl(256 | 512)]
        readonly get => Vector128.IsHardwareAccelerated ? new(vector.GetLower()) : new(x, y);
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, 0, -1, -1).AsUInt32(), 
                    vector,
                    value.vector.ToVector128()
                );
            else { x = value.x; y = value.y; }
        }
    }
    public uint2 rg
    {
        [MethodImpl(256 | 512)]
        readonly get => Vector128.IsHardwareAccelerated ? new(vector.GetLower()) : new(x, y);
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, 0, -1, -1).AsUInt32(), 
                    vector,
                    value.vector.ToVector128()
                );
            else { x = value.x; y = value.y; }
        }
    }
    public uint2 xz
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 0, 0)).GetLower());
            else
                return new(x, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, -1, 0, -1).AsUInt32(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create((uint)0, 0, 1, 0))
                );
            else { x = value.x; z = value.y; }
        }
    }
    public uint2 rb
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 0, 0)).GetLower());
            else
                return new(x, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, -1, 0, -1).AsUInt32(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create((uint)0, 0, 1, 0))
                );
            else { x = value.x; z = value.y; }
        }
    }
    public uint2 yx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 0, 0)).GetLower());
            else
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, 0, -1, -1).AsUInt32(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create((uint)1, 0, 0, 0))
                );
            else { y = value.x; x = value.y; }
        }
    }
    public uint2 gr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 0, 0)).GetLower());
            else
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, 0, -1, -1).AsUInt32(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create((uint)1, 0, 0, 0))
                );
            else { y = value.x; x = value.y; }
        }
    }
    public readonly uint2 yy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 0, 0)).GetLower());
            else
                return new(y, y);
        }
    }
    public readonly uint2 gg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 0, 0)).GetLower());
            else
                return new(y, y);
        }
    }
    public uint2 yz
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 0, 0)).GetLower());
            else
                return new(y, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(-1, 0, 0, -1).AsUInt32(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create((uint)0, 0, 1, 0))
                );
            else { y = value.x; z = value.y; }
        }
    }
    public uint2 gb
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 0, 0)).GetLower());
            else
                return new(y, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(-1, 0, 0, -1).AsUInt32(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create((uint)0, 0, 1, 0))
                );
            else { y = value.x; z = value.y; }
        }
    }
    public uint2 zx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 0, 0)).GetLower());
            else
                return new(z, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, -1, 0, -1).AsUInt32(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create((uint)1, 0, 0, 0))
                );
            else { z = value.x; x = value.y; }
        }
    }
    public uint2 br
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 0, 0)).GetLower());
            else
                return new(z, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, -1, 0, -1).AsUInt32(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create((uint)1, 0, 0, 0))
                );
            else { z = value.x; x = value.y; }
        }
    }
    public uint2 zy
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 0, 0)).GetLower());
            else
                return new(z, y);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(-1, 0, 0, -1).AsUInt32(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create((uint)0, 1, 0, 0))
                );
            else { z = value.x; y = value.y; }
        }
    }
    public uint2 bg
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 0, 0)).GetLower());
            else
                return new(z, y);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(-1, 0, 0, -1).AsUInt32(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create((uint)0, 1, 0, 0))
                );
            else { z = value.x; y = value.y; }
        }
    }
    public readonly uint2 zz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 0, 0)).GetLower());
            else
                return new(z, z);
        }
    }
    public readonly uint2 bb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 0, 0)).GetLower());
            else
                return new(z, z);
        }
    }
}

#endregion // uint3

#region long3

public partial struct long3 
{
    public readonly long2 xx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 0, 0)).GetLower());
            else
                return new(x, x);
        }
    }
    public readonly long2 rr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 0, 0)).GetLower());
            else
                return new(x, x);
        }
    }
    public long2 xy
    {
        [MethodImpl(256 | 512)]
        readonly get => Vector256.IsHardwareAccelerated ? new(vector.GetLower()) : new(x, y);
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, 0, -1, -1).AsInt64(), 
                    vector,
                    value.vector.ToVector256()
                );
            else { x = value.x; y = value.y; }
        }
    }
    public long2 rg
    {
        [MethodImpl(256 | 512)]
        readonly get => Vector256.IsHardwareAccelerated ? new(vector.GetLower()) : new(x, y);
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, 0, -1, -1).AsInt64(), 
                    vector,
                    value.vector.ToVector256()
                );
            else { x = value.x; y = value.y; }
        }
    }
    public long2 xz
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 0, 0)).GetLower());
            else
                return new(x, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, -1, 0, -1).AsInt64(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create(0, 0, 1, 0))
                );
            else { x = value.x; z = value.y; }
        }
    }
    public long2 rb
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 0, 0)).GetLower());
            else
                return new(x, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, -1, 0, -1).AsInt64(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create(0, 0, 1, 0))
                );
            else { x = value.x; z = value.y; }
        }
    }
    public long2 yx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 0, 0)).GetLower());
            else
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, 0, -1, -1).AsInt64(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create(1, 0, 0, 0))
                );
            else { y = value.x; x = value.y; }
        }
    }
    public long2 gr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 0, 0)).GetLower());
            else
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, 0, -1, -1).AsInt64(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create(1, 0, 0, 0))
                );
            else { y = value.x; x = value.y; }
        }
    }
    public readonly long2 yy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 0, 0)).GetLower());
            else
                return new(y, y);
        }
    }
    public readonly long2 gg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 0, 0)).GetLower());
            else
                return new(y, y);
        }
    }
    public long2 yz
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 0, 0)).GetLower());
            else
                return new(y, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(-1, 0, 0, -1).AsInt64(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create(0, 0, 1, 0))
                );
            else { y = value.x; z = value.y; }
        }
    }
    public long2 gb
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 0, 0)).GetLower());
            else
                return new(y, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(-1, 0, 0, -1).AsInt64(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create(0, 0, 1, 0))
                );
            else { y = value.x; z = value.y; }
        }
    }
    public long2 zx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 0, 0)).GetLower());
            else
                return new(z, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, -1, 0, -1).AsInt64(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create(1, 0, 0, 0))
                );
            else { z = value.x; x = value.y; }
        }
    }
    public long2 br
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 0, 0)).GetLower());
            else
                return new(z, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, -1, 0, -1).AsInt64(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create(1, 0, 0, 0))
                );
            else { z = value.x; x = value.y; }
        }
    }
    public long2 zy
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 0, 0)).GetLower());
            else
                return new(z, y);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(-1, 0, 0, -1).AsInt64(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create(0, 1, 0, 0))
                );
            else { z = value.x; y = value.y; }
        }
    }
    public long2 bg
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 0, 0)).GetLower());
            else
                return new(z, y);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(-1, 0, 0, -1).AsInt64(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create(0, 1, 0, 0))
                );
            else { z = value.x; y = value.y; }
        }
    }
    public readonly long2 zz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 0, 0)).GetLower());
            else
                return new(z, z);
        }
    }
    public readonly long2 bb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 0, 0)).GetLower());
            else
                return new(z, z);
        }
    }
}

#endregion // long3

#region ulong3

public partial struct ulong3 
{
    public readonly ulong2 xx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 0, 0)).GetLower());
            else
                return new(x, x);
        }
    }
    public readonly ulong2 rr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 0, 0)).GetLower());
            else
                return new(x, x);
        }
    }
    public ulong2 xy
    {
        [MethodImpl(256 | 512)]
        readonly get => Vector256.IsHardwareAccelerated ? new(vector.GetLower()) : new(x, y);
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, 0, -1, -1).AsUInt64(), 
                    vector,
                    value.vector.ToVector256()
                );
            else { x = value.x; y = value.y; }
        }
    }
    public ulong2 rg
    {
        [MethodImpl(256 | 512)]
        readonly get => Vector256.IsHardwareAccelerated ? new(vector.GetLower()) : new(x, y);
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, 0, -1, -1).AsUInt64(), 
                    vector,
                    value.vector.ToVector256()
                );
            else { x = value.x; y = value.y; }
        }
    }
    public ulong2 xz
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 0, 0)).GetLower());
            else
                return new(x, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, -1, 0, -1).AsUInt64(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create((ulong)0, 0, 1, 0))
                );
            else { x = value.x; z = value.y; }
        }
    }
    public ulong2 rb
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 0, 0)).GetLower());
            else
                return new(x, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, -1, 0, -1).AsUInt64(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create((ulong)0, 0, 1, 0))
                );
            else { x = value.x; z = value.y; }
        }
    }
    public ulong2 yx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 0, 0)).GetLower());
            else
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, 0, -1, -1).AsUInt64(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create((ulong)1, 0, 0, 0))
                );
            else { y = value.x; x = value.y; }
        }
    }
    public ulong2 gr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 0, 0)).GetLower());
            else
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, 0, -1, -1).AsUInt64(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create((ulong)1, 0, 0, 0))
                );
            else { y = value.x; x = value.y; }
        }
    }
    public readonly ulong2 yy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 0, 0)).GetLower());
            else
                return new(y, y);
        }
    }
    public readonly ulong2 gg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 0, 0)).GetLower());
            else
                return new(y, y);
        }
    }
    public ulong2 yz
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 0, 0)).GetLower());
            else
                return new(y, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(-1, 0, 0, -1).AsUInt64(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create((ulong)0, 0, 1, 0))
                );
            else { y = value.x; z = value.y; }
        }
    }
    public ulong2 gb
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 0, 0)).GetLower());
            else
                return new(y, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(-1, 0, 0, -1).AsUInt64(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create((ulong)0, 0, 1, 0))
                );
            else { y = value.x; z = value.y; }
        }
    }
    public ulong2 zx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 0, 0)).GetLower());
            else
                return new(z, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, -1, 0, -1).AsUInt64(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create((ulong)1, 0, 0, 0))
                );
            else { z = value.x; x = value.y; }
        }
    }
    public ulong2 br
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 0, 0)).GetLower());
            else
                return new(z, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, -1, 0, -1).AsUInt64(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create((ulong)1, 0, 0, 0))
                );
            else { z = value.x; x = value.y; }
        }
    }
    public ulong2 zy
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 0, 0)).GetLower());
            else
                return new(z, y);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(-1, 0, 0, -1).AsUInt64(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create((ulong)0, 1, 0, 0))
                );
            else { z = value.x; y = value.y; }
        }
    }
    public ulong2 bg
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 0, 0)).GetLower());
            else
                return new(z, y);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(-1, 0, 0, -1).AsUInt64(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create((ulong)0, 1, 0, 0))
                );
            else { z = value.x; y = value.y; }
        }
    }
    public readonly ulong2 zz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 0, 0)).GetLower());
            else
                return new(z, z);
        }
    }
    public readonly ulong2 bb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 0, 0)).GetLower());
            else
                return new(z, z);
        }
    }
}

#endregion // ulong3

#region decimal3

public partial struct decimal3 
{
    public readonly decimal2 xx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x);
    }
    public readonly decimal2 rr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x);
    }
    public decimal2 xy
    {
        [MethodImpl(256 | 512)]
        readonly get => new(x, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; }
    }
    public decimal2 rg
    {
        [MethodImpl(256 | 512)]
        readonly get => new(x, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; }
    }
    public decimal2 xz
    {
        [MethodImpl(256 | 512)]
        readonly get => new(x, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; }
    }
    public decimal2 rb
    {
        [MethodImpl(256 | 512)]
        readonly get => new(x, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; }
    }
    public decimal2 yx
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; }
    }
    public decimal2 gr
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; }
    }
    public readonly decimal2 yy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y);
    }
    public readonly decimal2 gg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y);
    }
    public decimal2 yz
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; }
    }
    public decimal2 gb
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; }
    }
    public decimal2 zx
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; }
    }
    public decimal2 br
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; }
    }
    public decimal2 zy
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; }
    }
    public decimal2 bg
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; }
    }
    public readonly decimal2 zz
    {
        [MethodImpl(256 | 512)]
        get => new(z, z);
    }
    public readonly decimal2 bb
    {
        [MethodImpl(256 | 512)]
        get => new(z, z);
    }
}

#endregion // decimal3

#region half3

public partial struct half3 
{
    public readonly half2 xx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x);
    }
    public readonly half2 rr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x);
    }
    public half2 xy
    {
        [MethodImpl(256 | 512)]
        readonly get => new(x, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; }
    }
    public half2 rg
    {
        [MethodImpl(256 | 512)]
        readonly get => new(x, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; }
    }
    public half2 xz
    {
        [MethodImpl(256 | 512)]
        readonly get => new(x, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; }
    }
    public half2 rb
    {
        [MethodImpl(256 | 512)]
        readonly get => new(x, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; }
    }
    public half2 yx
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; }
    }
    public half2 gr
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; }
    }
    public readonly half2 yy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y);
    }
    public readonly half2 gg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y);
    }
    public half2 yz
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; }
    }
    public half2 gb
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; }
    }
    public half2 zx
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; }
    }
    public half2 br
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; }
    }
    public half2 zy
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; }
    }
    public half2 bg
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; }
    }
    public readonly half2 zz
    {
        [MethodImpl(256 | 512)]
        get => new(z, z);
    }
    public readonly half2 bb
    {
        [MethodImpl(256 | 512)]
        get => new(z, z);
    }
}

#endregion // half3

#region b16v3

public partial struct b16v3 
{
    public readonly b16v2 xx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x);
    }
    public readonly b16v2 rr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x);
    }
    public b16v2 xy
    {
        [MethodImpl(256 | 512)]
        readonly get => new(x, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; }
    }
    public b16v2 rg
    {
        [MethodImpl(256 | 512)]
        readonly get => new(x, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; }
    }
    public b16v2 xz
    {
        [MethodImpl(256 | 512)]
        readonly get => new(x, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; }
    }
    public b16v2 rb
    {
        [MethodImpl(256 | 512)]
        readonly get => new(x, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; }
    }
    public b16v2 yx
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; }
    }
    public b16v2 gr
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; }
    }
    public readonly b16v2 yy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y);
    }
    public readonly b16v2 gg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y);
    }
    public b16v2 yz
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; }
    }
    public b16v2 gb
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; }
    }
    public b16v2 zx
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; }
    }
    public b16v2 br
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; }
    }
    public b16v2 zy
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; }
    }
    public b16v2 bg
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; }
    }
    public readonly b16v2 zz
    {
        [MethodImpl(256 | 512)]
        get => new(z, z);
    }
    public readonly b16v2 bb
    {
        [MethodImpl(256 | 512)]
        get => new(z, z);
    }
}

#endregion // b16v3

#region b32v3

public partial struct b32v3 
{
    public readonly b32v2 xx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 0, 0)).GetLower());
            else
                return new(x, x);
        }
    }
    public readonly b32v2 rr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 0, 0)).GetLower());
            else
                return new(x, x);
        }
    }
    public b32v2 xy
    {
        [MethodImpl(256 | 512)]
        readonly get => Vector128.IsHardwareAccelerated ? new(vector.GetLower()) : new(x, y);
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, 0, -1, -1).AsUInt32(), 
                    vector,
                    value.vector.ToVector128()
                );
            else { x = value.x; y = value.y; }
        }
    }
    public b32v2 rg
    {
        [MethodImpl(256 | 512)]
        readonly get => Vector128.IsHardwareAccelerated ? new(vector.GetLower()) : new(x, y);
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, 0, -1, -1).AsUInt32(), 
                    vector,
                    value.vector.ToVector128()
                );
            else { x = value.x; y = value.y; }
        }
    }
    public b32v2 xz
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 0, 0)).GetLower());
            else
                return new(x, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, -1, 0, -1).AsUInt32(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create((uint)0, 0, 1, 0))
                );
            else { x = value.x; z = value.y; }
        }
    }
    public b32v2 rb
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 0, 0)).GetLower());
            else
                return new(x, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, -1, 0, -1).AsUInt32(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create((uint)0, 0, 1, 0))
                );
            else { x = value.x; z = value.y; }
        }
    }
    public b32v2 yx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 0, 0)).GetLower());
            else
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, 0, -1, -1).AsUInt32(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create((uint)1, 0, 0, 0))
                );
            else { y = value.x; x = value.y; }
        }
    }
    public b32v2 gr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 0, 0)).GetLower());
            else
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, 0, -1, -1).AsUInt32(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create((uint)1, 0, 0, 0))
                );
            else { y = value.x; x = value.y; }
        }
    }
    public readonly b32v2 yy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 0, 0)).GetLower());
            else
                return new(y, y);
        }
    }
    public readonly b32v2 gg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 0, 0)).GetLower());
            else
                return new(y, y);
        }
    }
    public b32v2 yz
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 0, 0)).GetLower());
            else
                return new(y, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(-1, 0, 0, -1).AsUInt32(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create((uint)0, 0, 1, 0))
                );
            else { y = value.x; z = value.y; }
        }
    }
    public b32v2 gb
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 0, 0)).GetLower());
            else
                return new(y, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(-1, 0, 0, -1).AsUInt32(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create((uint)0, 0, 1, 0))
                );
            else { y = value.x; z = value.y; }
        }
    }
    public b32v2 zx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 0, 0)).GetLower());
            else
                return new(z, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, -1, 0, -1).AsUInt32(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create((uint)1, 0, 0, 0))
                );
            else { z = value.x; x = value.y; }
        }
    }
    public b32v2 br
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 0, 0)).GetLower());
            else
                return new(z, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(0, -1, 0, -1).AsUInt32(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create((uint)1, 0, 0, 0))
                );
            else { z = value.x; x = value.y; }
        }
    }
    public b32v2 zy
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 0, 0)).GetLower());
            else
                return new(z, y);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(-1, 0, 0, -1).AsUInt32(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create((uint)0, 1, 0, 0))
                );
            else { z = value.x; y = value.y; }
        }
    }
    public b32v2 bg
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 0, 0)).GetLower());
            else
                return new(z, y);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector128.IsHardwareAccelerated)
                vector = Vector128.ConditionalSelect(
                    Vector128.Create(-1, 0, 0, -1).AsUInt32(), 
                    vector, 
                    Vector128.Shuffle(value.vector.ToVector128(), Vector128.Create((uint)0, 1, 0, 0))
                );
            else { z = value.x; y = value.y; }
        }
    }
    public readonly b32v2 zz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 0, 0)).GetLower());
            else
                return new(z, z);
        }
    }
    public readonly b32v2 bb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 0, 0)).GetLower());
            else
                return new(z, z);
        }
    }
}

#endregion // b32v3

#region b64v3

public partial struct b64v3 
{
    public readonly b64v2 xx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 0, 0)).GetLower());
            else
                return new(x, x);
        }
    }
    public readonly b64v2 rr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 0, 0)).GetLower());
            else
                return new(x, x);
        }
    }
    public b64v2 xy
    {
        [MethodImpl(256 | 512)]
        readonly get => Vector256.IsHardwareAccelerated ? new(vector.GetLower()) : new(x, y);
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, 0, -1, -1).AsUInt64(), 
                    vector,
                    value.vector.ToVector256()
                );
            else { x = value.x; y = value.y; }
        }
    }
    public b64v2 rg
    {
        [MethodImpl(256 | 512)]
        readonly get => Vector256.IsHardwareAccelerated ? new(vector.GetLower()) : new(x, y);
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, 0, -1, -1).AsUInt64(), 
                    vector,
                    value.vector.ToVector256()
                );
            else { x = value.x; y = value.y; }
        }
    }
    public b64v2 xz
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 0, 0)).GetLower());
            else
                return new(x, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, -1, 0, -1).AsUInt64(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create((ulong)0, 0, 1, 0))
                );
            else { x = value.x; z = value.y; }
        }
    }
    public b64v2 rb
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 0, 0)).GetLower());
            else
                return new(x, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, -1, 0, -1).AsUInt64(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create((ulong)0, 0, 1, 0))
                );
            else { x = value.x; z = value.y; }
        }
    }
    public b64v2 yx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 0, 0)).GetLower());
            else
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, 0, -1, -1).AsUInt64(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create((ulong)1, 0, 0, 0))
                );
            else { y = value.x; x = value.y; }
        }
    }
    public b64v2 gr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 0, 0)).GetLower());
            else
                return new(y, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, 0, -1, -1).AsUInt64(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create((ulong)1, 0, 0, 0))
                );
            else { y = value.x; x = value.y; }
        }
    }
    public readonly b64v2 yy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 0, 0)).GetLower());
            else
                return new(y, y);
        }
    }
    public readonly b64v2 gg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 0, 0)).GetLower());
            else
                return new(y, y);
        }
    }
    public b64v2 yz
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 0, 0)).GetLower());
            else
                return new(y, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(-1, 0, 0, -1).AsUInt64(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create((ulong)0, 0, 1, 0))
                );
            else { y = value.x; z = value.y; }
        }
    }
    public b64v2 gb
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 0, 0)).GetLower());
            else
                return new(y, z);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(-1, 0, 0, -1).AsUInt64(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create((ulong)0, 0, 1, 0))
                );
            else { y = value.x; z = value.y; }
        }
    }
    public b64v2 zx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 0, 0)).GetLower());
            else
                return new(z, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, -1, 0, -1).AsUInt64(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create((ulong)1, 0, 0, 0))
                );
            else { z = value.x; x = value.y; }
        }
    }
    public b64v2 br
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 0, 0)).GetLower());
            else
                return new(z, x);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(0, -1, 0, -1).AsUInt64(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create((ulong)1, 0, 0, 0))
                );
            else { z = value.x; x = value.y; }
        }
    }
    public b64v2 zy
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 0, 0)).GetLower());
            else
                return new(z, y);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(-1, 0, 0, -1).AsUInt64(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create((ulong)0, 1, 0, 0))
                );
            else { z = value.x; y = value.y; }
        }
    }
    public b64v2 bg
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 0, 0)).GetLower());
            else
                return new(z, y);
        }
        [MethodImpl(256 | 512)]
        set
        {
            if (Vector256.IsHardwareAccelerated)
                vector = Vector256.ConditionalSelect(
                    Vector256.Create(-1, 0, 0, -1).AsUInt64(), 
                    vector, 
                    Vector256.Shuffle(value.vector.ToVector256(), Vector256.Create((ulong)0, 1, 0, 0))
                );
            else { z = value.x; y = value.y; }
        }
    }
    public readonly b64v2 zz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 0, 0)).GetLower());
            else
                return new(z, z);
        }
    }
    public readonly b64v2 bb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 0, 0)).GetLower());
            else
                return new(z, z);
        }
    }
}

#endregion // b64v3
