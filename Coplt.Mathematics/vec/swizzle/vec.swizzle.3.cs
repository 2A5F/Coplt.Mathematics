// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region float3

public partial struct float3 
{
    public readonly float3 xxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly float3 rrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly float3 xxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly float3 rrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly float3 xxz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 2, 3)));
            else
                return new(x, x, z);
        }
    }
    public readonly float3 rrb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 2, 3)));
            else
                return new(x, x, z);
        }
    }
    public readonly float3 xyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly float3 rgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly float3 xyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public readonly float3 rgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public float3 xyz
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public float3 rgb
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public readonly float3 xzx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 0, 3)));
            else
                return new(x, z, x);
        }
    }
    public readonly float3 rbr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 0, 3)));
            else
                return new(x, z, x);
        }
    }
    public float3 xzy
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 1, 3)));
            else
                return new(x, z, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.xzy;
    }
    public float3 rbg
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 1, 3)));
            else
                return new(x, z, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.xzy;
    }
    public readonly float3 xzz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 2, 3)));
            else
                return new(x, z, z);
        }
    }
    public readonly float3 rbb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 2, 3)));
            else
                return new(x, z, z);
        }
    }
    public readonly float3 yxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly float3 grr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly float3 yxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public readonly float3 grg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public float3 yxz
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 2, 3)));
            else
                return new(y, x, z);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yxz;
    }
    public float3 grb
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 2, 3)));
            else
                return new(y, x, z);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yxz;
    }
    public readonly float3 yyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly float3 ggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly float3 yyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
    public readonly float3 ggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
    public readonly float3 yyz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 2, 3)));
            else
                return new(y, y, z);
        }
    }
    public readonly float3 ggb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 2, 3)));
            else
                return new(y, y, z);
        }
    }
    public float3 yzx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 0, 3)));
            else
                return new(y, z, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zxy;
    }
    public float3 gbr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 0, 3)));
            else
                return new(y, z, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zxy;
    }
    public readonly float3 yzy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 1, 3)));
            else
                return new(y, z, y);
        }
    }
    public readonly float3 gbg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 1, 3)));
            else
                return new(y, z, y);
        }
    }
    public readonly float3 yzz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 2, 3)));
            else
                return new(y, z, z);
        }
    }
    public readonly float3 gbb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 2, 3)));
            else
                return new(y, z, z);
        }
    }
    public readonly float3 zxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 0, 3)));
            else
                return new(z, x, x);
        }
    }
    public readonly float3 brr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 0, 3)));
            else
                return new(z, x, x);
        }
    }
    public float3 zxy
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 1, 3)));
            else
                return new(z, x, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yzx;
    }
    public float3 brg
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 1, 3)));
            else
                return new(z, x, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yzx;
    }
    public readonly float3 zxz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 2, 3)));
            else
                return new(z, x, z);
        }
    }
    public readonly float3 brb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 2, 3)));
            else
                return new(z, x, z);
        }
    }
    public float3 zyx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 0, 3)));
            else
                return new(z, y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zyx;
    }
    public float3 bgr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 0, 3)));
            else
                return new(z, y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zyx;
    }
    public readonly float3 zyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 1, 3)));
            else
                return new(z, y, y);
        }
    }
    public readonly float3 bgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 1, 3)));
            else
                return new(z, y, y);
        }
    }
    public readonly float3 zyz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 2, 3)));
            else
                return new(z, y, z);
        }
    }
    public readonly float3 bgb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 2, 3)));
            else
                return new(z, y, z);
        }
    }
    public readonly float3 zzx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 0, 3)));
            else
                return new(z, z, x);
        }
    }
    public readonly float3 bbr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 0, 3)));
            else
                return new(z, z, x);
        }
    }
    public readonly float3 zzy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 1, 3)));
            else
                return new(z, z, y);
        }
    }
    public readonly float3 bbg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 1, 3)));
            else
                return new(z, z, y);
        }
    }
    public readonly float3 zzz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 2, 3)));
            else
                return new(z, z, z);
        }
    }
    public readonly float3 bbb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 2, 3)));
            else
                return new(z, z, z);
        }
    }
}

#endregion // float3

#region double3

public partial struct double3 
{
    public readonly double3 xxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly double3 rrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly double3 xxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly double3 rrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly double3 xxz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 2, 3)));
            else
                return new(x, x, z);
        }
    }
    public readonly double3 rrb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 2, 3)));
            else
                return new(x, x, z);
        }
    }
    public readonly double3 xyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly double3 rgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly double3 xyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public readonly double3 rgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public double3 xyz
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public double3 rgb
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public readonly double3 xzx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 0, 3)));
            else
                return new(x, z, x);
        }
    }
    public readonly double3 rbr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 0, 3)));
            else
                return new(x, z, x);
        }
    }
    public double3 xzy
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 1, 3)));
            else
                return new(x, z, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.xzy;
    }
    public double3 rbg
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 1, 3)));
            else
                return new(x, z, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.xzy;
    }
    public readonly double3 xzz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 2, 3)));
            else
                return new(x, z, z);
        }
    }
    public readonly double3 rbb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 2, 3)));
            else
                return new(x, z, z);
        }
    }
    public readonly double3 yxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly double3 grr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly double3 yxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public readonly double3 grg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public double3 yxz
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 2, 3)));
            else
                return new(y, x, z);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yxz;
    }
    public double3 grb
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 2, 3)));
            else
                return new(y, x, z);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yxz;
    }
    public readonly double3 yyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly double3 ggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly double3 yyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
    public readonly double3 ggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
    public readonly double3 yyz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 2, 3)));
            else
                return new(y, y, z);
        }
    }
    public readonly double3 ggb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 2, 3)));
            else
                return new(y, y, z);
        }
    }
    public double3 yzx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 0, 3)));
            else
                return new(y, z, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zxy;
    }
    public double3 gbr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 0, 3)));
            else
                return new(y, z, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zxy;
    }
    public readonly double3 yzy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 1, 3)));
            else
                return new(y, z, y);
        }
    }
    public readonly double3 gbg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 1, 3)));
            else
                return new(y, z, y);
        }
    }
    public readonly double3 yzz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 2, 3)));
            else
                return new(y, z, z);
        }
    }
    public readonly double3 gbb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 2, 3)));
            else
                return new(y, z, z);
        }
    }
    public readonly double3 zxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 0, 3)));
            else
                return new(z, x, x);
        }
    }
    public readonly double3 brr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 0, 3)));
            else
                return new(z, x, x);
        }
    }
    public double3 zxy
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 1, 3)));
            else
                return new(z, x, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yzx;
    }
    public double3 brg
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 1, 3)));
            else
                return new(z, x, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yzx;
    }
    public readonly double3 zxz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 2, 3)));
            else
                return new(z, x, z);
        }
    }
    public readonly double3 brb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 2, 3)));
            else
                return new(z, x, z);
        }
    }
    public double3 zyx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 0, 3)));
            else
                return new(z, y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zyx;
    }
    public double3 bgr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 0, 3)));
            else
                return new(z, y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zyx;
    }
    public readonly double3 zyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 1, 3)));
            else
                return new(z, y, y);
        }
    }
    public readonly double3 bgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 1, 3)));
            else
                return new(z, y, y);
        }
    }
    public readonly double3 zyz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 2, 3)));
            else
                return new(z, y, z);
        }
    }
    public readonly double3 bgb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 2, 3)));
            else
                return new(z, y, z);
        }
    }
    public readonly double3 zzx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 0, 3)));
            else
                return new(z, z, x);
        }
    }
    public readonly double3 bbr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 0, 3)));
            else
                return new(z, z, x);
        }
    }
    public readonly double3 zzy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 1, 3)));
            else
                return new(z, z, y);
        }
    }
    public readonly double3 bbg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 1, 3)));
            else
                return new(z, z, y);
        }
    }
    public readonly double3 zzz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 2, 3)));
            else
                return new(z, z, z);
        }
    }
    public readonly double3 bbb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 2, 3)));
            else
                return new(z, z, z);
        }
    }
}

#endregion // double3

#region short3

public partial struct short3 
{
    public readonly short3 xxx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
    }
    public readonly short3 rrr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
    }
    public readonly short3 xxy
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
    }
    public readonly short3 rrg
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
    }
    public readonly short3 xxz
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
    }
    public readonly short3 rrb
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
    }
    public readonly short3 xyx
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
    }
    public readonly short3 rgr
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
    }
    public readonly short3 xyy
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
    }
    public readonly short3 rgg
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
    }
    public short3 xyz
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public short3 rgb
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public readonly short3 xzx
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
    }
    public readonly short3 rbr
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
    }
    public short3 xzy
    {
        [MethodImpl(256 | 512)]
        readonly get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set => this = value.xzy;
    }
    public short3 rbg
    {
        [MethodImpl(256 | 512)]
        readonly get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set => this = value.xzy;
    }
    public readonly short3 xzz
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
    }
    public readonly short3 rbb
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
    }
    public readonly short3 yxx
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
    }
    public readonly short3 grr
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
    }
    public readonly short3 yxy
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
    }
    public readonly short3 grg
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
    }
    public short3 yxz
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set => this = value.yxz;
    }
    public short3 grb
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set => this = value.yxz;
    }
    public readonly short3 yyx
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
    }
    public readonly short3 ggr
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
    }
    public readonly short3 yyy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
    }
    public readonly short3 ggg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
    }
    public readonly short3 yyz
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
    }
    public readonly short3 ggb
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
    }
    public short3 yzx
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set => this = value.zxy;
    }
    public short3 gbr
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set => this = value.zxy;
    }
    public readonly short3 yzy
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
    }
    public readonly short3 gbg
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
    }
    public readonly short3 yzz
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
    }
    public readonly short3 gbb
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
    }
    public readonly short3 zxx
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
    }
    public readonly short3 brr
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
    }
    public short3 zxy
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set => this = value.yzx;
    }
    public short3 brg
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set => this = value.yzx;
    }
    public readonly short3 zxz
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
    }
    public readonly short3 brb
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
    }
    public short3 zyx
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set => this = value.zyx;
    }
    public short3 bgr
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set => this = value.zyx;
    }
    public readonly short3 zyy
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
    }
    public readonly short3 bgg
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
    }
    public readonly short3 zyz
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
    }
    public readonly short3 bgb
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
    }
    public readonly short3 zzx
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
    }
    public readonly short3 bbr
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
    }
    public readonly short3 zzy
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
    }
    public readonly short3 bbg
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
    }
    public readonly short3 zzz
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
    }
    public readonly short3 bbb
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
    }
}

#endregion // short3

#region ushort3

public partial struct ushort3 
{
    public readonly ushort3 xxx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
    }
    public readonly ushort3 rrr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
    }
    public readonly ushort3 xxy
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
    }
    public readonly ushort3 rrg
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
    }
    public readonly ushort3 xxz
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
    }
    public readonly ushort3 rrb
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
    }
    public readonly ushort3 xyx
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
    }
    public readonly ushort3 rgr
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
    }
    public readonly ushort3 xyy
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
    }
    public readonly ushort3 rgg
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
    }
    public ushort3 xyz
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public ushort3 rgb
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public readonly ushort3 xzx
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
    }
    public readonly ushort3 rbr
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
    }
    public ushort3 xzy
    {
        [MethodImpl(256 | 512)]
        readonly get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set => this = value.xzy;
    }
    public ushort3 rbg
    {
        [MethodImpl(256 | 512)]
        readonly get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set => this = value.xzy;
    }
    public readonly ushort3 xzz
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
    }
    public readonly ushort3 rbb
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
    }
    public readonly ushort3 yxx
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
    }
    public readonly ushort3 grr
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
    }
    public readonly ushort3 yxy
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
    }
    public readonly ushort3 grg
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
    }
    public ushort3 yxz
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set => this = value.yxz;
    }
    public ushort3 grb
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set => this = value.yxz;
    }
    public readonly ushort3 yyx
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
    }
    public readonly ushort3 ggr
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
    }
    public readonly ushort3 yyy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
    }
    public readonly ushort3 ggg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
    }
    public readonly ushort3 yyz
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
    }
    public readonly ushort3 ggb
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
    }
    public ushort3 yzx
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set => this = value.zxy;
    }
    public ushort3 gbr
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set => this = value.zxy;
    }
    public readonly ushort3 yzy
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
    }
    public readonly ushort3 gbg
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
    }
    public readonly ushort3 yzz
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
    }
    public readonly ushort3 gbb
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
    }
    public readonly ushort3 zxx
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
    }
    public readonly ushort3 brr
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
    }
    public ushort3 zxy
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set => this = value.yzx;
    }
    public ushort3 brg
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set => this = value.yzx;
    }
    public readonly ushort3 zxz
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
    }
    public readonly ushort3 brb
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
    }
    public ushort3 zyx
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set => this = value.zyx;
    }
    public ushort3 bgr
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set => this = value.zyx;
    }
    public readonly ushort3 zyy
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
    }
    public readonly ushort3 bgg
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
    }
    public readonly ushort3 zyz
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
    }
    public readonly ushort3 bgb
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
    }
    public readonly ushort3 zzx
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
    }
    public readonly ushort3 bbr
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
    }
    public readonly ushort3 zzy
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
    }
    public readonly ushort3 bbg
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
    }
    public readonly ushort3 zzz
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
    }
    public readonly ushort3 bbb
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
    }
}

#endregion // ushort3

#region int3

public partial struct int3 
{
    public readonly int3 xxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly int3 rrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly int3 xxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly int3 rrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly int3 xxz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 2, 3)));
            else
                return new(x, x, z);
        }
    }
    public readonly int3 rrb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 2, 3)));
            else
                return new(x, x, z);
        }
    }
    public readonly int3 xyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly int3 rgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly int3 xyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public readonly int3 rgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public int3 xyz
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public int3 rgb
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public readonly int3 xzx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 0, 3)));
            else
                return new(x, z, x);
        }
    }
    public readonly int3 rbr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 0, 3)));
            else
                return new(x, z, x);
        }
    }
    public int3 xzy
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 1, 3)));
            else
                return new(x, z, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.xzy;
    }
    public int3 rbg
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 1, 3)));
            else
                return new(x, z, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.xzy;
    }
    public readonly int3 xzz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 2, 3)));
            else
                return new(x, z, z);
        }
    }
    public readonly int3 rbb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 2, 3)));
            else
                return new(x, z, z);
        }
    }
    public readonly int3 yxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly int3 grr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly int3 yxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public readonly int3 grg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public int3 yxz
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 2, 3)));
            else
                return new(y, x, z);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yxz;
    }
    public int3 grb
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 2, 3)));
            else
                return new(y, x, z);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yxz;
    }
    public readonly int3 yyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly int3 ggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly int3 yyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
    public readonly int3 ggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
    public readonly int3 yyz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 2, 3)));
            else
                return new(y, y, z);
        }
    }
    public readonly int3 ggb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 2, 3)));
            else
                return new(y, y, z);
        }
    }
    public int3 yzx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 0, 3)));
            else
                return new(y, z, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zxy;
    }
    public int3 gbr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 0, 3)));
            else
                return new(y, z, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zxy;
    }
    public readonly int3 yzy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 1, 3)));
            else
                return new(y, z, y);
        }
    }
    public readonly int3 gbg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 1, 3)));
            else
                return new(y, z, y);
        }
    }
    public readonly int3 yzz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 2, 3)));
            else
                return new(y, z, z);
        }
    }
    public readonly int3 gbb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 2, 3)));
            else
                return new(y, z, z);
        }
    }
    public readonly int3 zxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 0, 3)));
            else
                return new(z, x, x);
        }
    }
    public readonly int3 brr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 0, 3)));
            else
                return new(z, x, x);
        }
    }
    public int3 zxy
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 1, 3)));
            else
                return new(z, x, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yzx;
    }
    public int3 brg
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 1, 3)));
            else
                return new(z, x, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yzx;
    }
    public readonly int3 zxz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 2, 3)));
            else
                return new(z, x, z);
        }
    }
    public readonly int3 brb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 2, 3)));
            else
                return new(z, x, z);
        }
    }
    public int3 zyx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 0, 3)));
            else
                return new(z, y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zyx;
    }
    public int3 bgr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 0, 3)));
            else
                return new(z, y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zyx;
    }
    public readonly int3 zyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 1, 3)));
            else
                return new(z, y, y);
        }
    }
    public readonly int3 bgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 1, 3)));
            else
                return new(z, y, y);
        }
    }
    public readonly int3 zyz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 2, 3)));
            else
                return new(z, y, z);
        }
    }
    public readonly int3 bgb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 2, 3)));
            else
                return new(z, y, z);
        }
    }
    public readonly int3 zzx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 0, 3)));
            else
                return new(z, z, x);
        }
    }
    public readonly int3 bbr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 0, 3)));
            else
                return new(z, z, x);
        }
    }
    public readonly int3 zzy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 1, 3)));
            else
                return new(z, z, y);
        }
    }
    public readonly int3 bbg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 1, 3)));
            else
                return new(z, z, y);
        }
    }
    public readonly int3 zzz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 2, 3)));
            else
                return new(z, z, z);
        }
    }
    public readonly int3 bbb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 2, 3)));
            else
                return new(z, z, z);
        }
    }
}

#endregion // int3

#region uint3

public partial struct uint3 
{
    public readonly uint3 xxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly uint3 rrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly uint3 xxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly uint3 rrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly uint3 xxz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 2, 3)));
            else
                return new(x, x, z);
        }
    }
    public readonly uint3 rrb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 2, 3)));
            else
                return new(x, x, z);
        }
    }
    public readonly uint3 xyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly uint3 rgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly uint3 xyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public readonly uint3 rgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public uint3 xyz
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public uint3 rgb
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public readonly uint3 xzx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 0, 3)));
            else
                return new(x, z, x);
        }
    }
    public readonly uint3 rbr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 0, 3)));
            else
                return new(x, z, x);
        }
    }
    public uint3 xzy
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 1, 3)));
            else
                return new(x, z, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.xzy;
    }
    public uint3 rbg
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 1, 3)));
            else
                return new(x, z, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.xzy;
    }
    public readonly uint3 xzz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 2, 3)));
            else
                return new(x, z, z);
        }
    }
    public readonly uint3 rbb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 2, 3)));
            else
                return new(x, z, z);
        }
    }
    public readonly uint3 yxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly uint3 grr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly uint3 yxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public readonly uint3 grg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public uint3 yxz
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 2, 3)));
            else
                return new(y, x, z);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yxz;
    }
    public uint3 grb
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 2, 3)));
            else
                return new(y, x, z);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yxz;
    }
    public readonly uint3 yyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly uint3 ggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly uint3 yyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
    public readonly uint3 ggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
    public readonly uint3 yyz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 2, 3)));
            else
                return new(y, y, z);
        }
    }
    public readonly uint3 ggb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 2, 3)));
            else
                return new(y, y, z);
        }
    }
    public uint3 yzx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 0, 3)));
            else
                return new(y, z, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zxy;
    }
    public uint3 gbr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 0, 3)));
            else
                return new(y, z, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zxy;
    }
    public readonly uint3 yzy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 1, 3)));
            else
                return new(y, z, y);
        }
    }
    public readonly uint3 gbg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 1, 3)));
            else
                return new(y, z, y);
        }
    }
    public readonly uint3 yzz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 2, 3)));
            else
                return new(y, z, z);
        }
    }
    public readonly uint3 gbb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 2, 3)));
            else
                return new(y, z, z);
        }
    }
    public readonly uint3 zxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 0, 3)));
            else
                return new(z, x, x);
        }
    }
    public readonly uint3 brr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 0, 3)));
            else
                return new(z, x, x);
        }
    }
    public uint3 zxy
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 1, 3)));
            else
                return new(z, x, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yzx;
    }
    public uint3 brg
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 1, 3)));
            else
                return new(z, x, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yzx;
    }
    public readonly uint3 zxz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 2, 3)));
            else
                return new(z, x, z);
        }
    }
    public readonly uint3 brb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 2, 3)));
            else
                return new(z, x, z);
        }
    }
    public uint3 zyx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 0, 3)));
            else
                return new(z, y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zyx;
    }
    public uint3 bgr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 0, 3)));
            else
                return new(z, y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zyx;
    }
    public readonly uint3 zyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 1, 3)));
            else
                return new(z, y, y);
        }
    }
    public readonly uint3 bgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 1, 3)));
            else
                return new(z, y, y);
        }
    }
    public readonly uint3 zyz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 2, 3)));
            else
                return new(z, y, z);
        }
    }
    public readonly uint3 bgb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 2, 3)));
            else
                return new(z, y, z);
        }
    }
    public readonly uint3 zzx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 0, 3)));
            else
                return new(z, z, x);
        }
    }
    public readonly uint3 bbr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 0, 3)));
            else
                return new(z, z, x);
        }
    }
    public readonly uint3 zzy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 1, 3)));
            else
                return new(z, z, y);
        }
    }
    public readonly uint3 bbg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 1, 3)));
            else
                return new(z, z, y);
        }
    }
    public readonly uint3 zzz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 2, 3)));
            else
                return new(z, z, z);
        }
    }
    public readonly uint3 bbb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 2, 3)));
            else
                return new(z, z, z);
        }
    }
}

#endregion // uint3

#region long3

public partial struct long3 
{
    public readonly long3 xxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly long3 rrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly long3 xxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly long3 rrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly long3 xxz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 2, 3)));
            else
                return new(x, x, z);
        }
    }
    public readonly long3 rrb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 2, 3)));
            else
                return new(x, x, z);
        }
    }
    public readonly long3 xyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly long3 rgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly long3 xyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public readonly long3 rgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public long3 xyz
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public long3 rgb
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public readonly long3 xzx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 0, 3)));
            else
                return new(x, z, x);
        }
    }
    public readonly long3 rbr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 0, 3)));
            else
                return new(x, z, x);
        }
    }
    public long3 xzy
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 1, 3)));
            else
                return new(x, z, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.xzy;
    }
    public long3 rbg
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 1, 3)));
            else
                return new(x, z, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.xzy;
    }
    public readonly long3 xzz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 2, 3)));
            else
                return new(x, z, z);
        }
    }
    public readonly long3 rbb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 2, 3)));
            else
                return new(x, z, z);
        }
    }
    public readonly long3 yxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly long3 grr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly long3 yxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public readonly long3 grg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public long3 yxz
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 2, 3)));
            else
                return new(y, x, z);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yxz;
    }
    public long3 grb
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 2, 3)));
            else
                return new(y, x, z);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yxz;
    }
    public readonly long3 yyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly long3 ggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly long3 yyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
    public readonly long3 ggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
    public readonly long3 yyz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 2, 3)));
            else
                return new(y, y, z);
        }
    }
    public readonly long3 ggb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 2, 3)));
            else
                return new(y, y, z);
        }
    }
    public long3 yzx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 0, 3)));
            else
                return new(y, z, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zxy;
    }
    public long3 gbr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 0, 3)));
            else
                return new(y, z, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zxy;
    }
    public readonly long3 yzy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 1, 3)));
            else
                return new(y, z, y);
        }
    }
    public readonly long3 gbg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 1, 3)));
            else
                return new(y, z, y);
        }
    }
    public readonly long3 yzz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 2, 3)));
            else
                return new(y, z, z);
        }
    }
    public readonly long3 gbb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 2, 3)));
            else
                return new(y, z, z);
        }
    }
    public readonly long3 zxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 0, 3)));
            else
                return new(z, x, x);
        }
    }
    public readonly long3 brr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 0, 3)));
            else
                return new(z, x, x);
        }
    }
    public long3 zxy
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 1, 3)));
            else
                return new(z, x, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yzx;
    }
    public long3 brg
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 1, 3)));
            else
                return new(z, x, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yzx;
    }
    public readonly long3 zxz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 2, 3)));
            else
                return new(z, x, z);
        }
    }
    public readonly long3 brb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 2, 3)));
            else
                return new(z, x, z);
        }
    }
    public long3 zyx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 0, 3)));
            else
                return new(z, y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zyx;
    }
    public long3 bgr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 0, 3)));
            else
                return new(z, y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zyx;
    }
    public readonly long3 zyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 1, 3)));
            else
                return new(z, y, y);
        }
    }
    public readonly long3 bgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 1, 3)));
            else
                return new(z, y, y);
        }
    }
    public readonly long3 zyz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 2, 3)));
            else
                return new(z, y, z);
        }
    }
    public readonly long3 bgb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 2, 3)));
            else
                return new(z, y, z);
        }
    }
    public readonly long3 zzx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 0, 3)));
            else
                return new(z, z, x);
        }
    }
    public readonly long3 bbr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 0, 3)));
            else
                return new(z, z, x);
        }
    }
    public readonly long3 zzy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 1, 3)));
            else
                return new(z, z, y);
        }
    }
    public readonly long3 bbg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 1, 3)));
            else
                return new(z, z, y);
        }
    }
    public readonly long3 zzz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 2, 3)));
            else
                return new(z, z, z);
        }
    }
    public readonly long3 bbb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 2, 3)));
            else
                return new(z, z, z);
        }
    }
}

#endregion // long3

#region ulong3

public partial struct ulong3 
{
    public readonly ulong3 xxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly ulong3 rrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly ulong3 xxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly ulong3 rrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly ulong3 xxz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 2, 3)));
            else
                return new(x, x, z);
        }
    }
    public readonly ulong3 rrb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 2, 3)));
            else
                return new(x, x, z);
        }
    }
    public readonly ulong3 xyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly ulong3 rgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly ulong3 xyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public readonly ulong3 rgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public ulong3 xyz
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public ulong3 rgb
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public readonly ulong3 xzx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 0, 3)));
            else
                return new(x, z, x);
        }
    }
    public readonly ulong3 rbr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 0, 3)));
            else
                return new(x, z, x);
        }
    }
    public ulong3 xzy
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 1, 3)));
            else
                return new(x, z, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.xzy;
    }
    public ulong3 rbg
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 1, 3)));
            else
                return new(x, z, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.xzy;
    }
    public readonly ulong3 xzz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 2, 3)));
            else
                return new(x, z, z);
        }
    }
    public readonly ulong3 rbb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 2, 3)));
            else
                return new(x, z, z);
        }
    }
    public readonly ulong3 yxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly ulong3 grr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly ulong3 yxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public readonly ulong3 grg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public ulong3 yxz
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 2, 3)));
            else
                return new(y, x, z);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yxz;
    }
    public ulong3 grb
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 2, 3)));
            else
                return new(y, x, z);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yxz;
    }
    public readonly ulong3 yyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly ulong3 ggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly ulong3 yyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
    public readonly ulong3 ggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
    public readonly ulong3 yyz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 2, 3)));
            else
                return new(y, y, z);
        }
    }
    public readonly ulong3 ggb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 2, 3)));
            else
                return new(y, y, z);
        }
    }
    public ulong3 yzx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 0, 3)));
            else
                return new(y, z, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zxy;
    }
    public ulong3 gbr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 0, 3)));
            else
                return new(y, z, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zxy;
    }
    public readonly ulong3 yzy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 1, 3)));
            else
                return new(y, z, y);
        }
    }
    public readonly ulong3 gbg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 1, 3)));
            else
                return new(y, z, y);
        }
    }
    public readonly ulong3 yzz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 2, 3)));
            else
                return new(y, z, z);
        }
    }
    public readonly ulong3 gbb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 2, 3)));
            else
                return new(y, z, z);
        }
    }
    public readonly ulong3 zxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 0, 3)));
            else
                return new(z, x, x);
        }
    }
    public readonly ulong3 brr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 0, 3)));
            else
                return new(z, x, x);
        }
    }
    public ulong3 zxy
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 1, 3)));
            else
                return new(z, x, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yzx;
    }
    public ulong3 brg
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 1, 3)));
            else
                return new(z, x, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yzx;
    }
    public readonly ulong3 zxz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 2, 3)));
            else
                return new(z, x, z);
        }
    }
    public readonly ulong3 brb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 2, 3)));
            else
                return new(z, x, z);
        }
    }
    public ulong3 zyx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 0, 3)));
            else
                return new(z, y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zyx;
    }
    public ulong3 bgr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 0, 3)));
            else
                return new(z, y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zyx;
    }
    public readonly ulong3 zyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 1, 3)));
            else
                return new(z, y, y);
        }
    }
    public readonly ulong3 bgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 1, 3)));
            else
                return new(z, y, y);
        }
    }
    public readonly ulong3 zyz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 2, 3)));
            else
                return new(z, y, z);
        }
    }
    public readonly ulong3 bgb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 2, 3)));
            else
                return new(z, y, z);
        }
    }
    public readonly ulong3 zzx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 0, 3)));
            else
                return new(z, z, x);
        }
    }
    public readonly ulong3 bbr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 0, 3)));
            else
                return new(z, z, x);
        }
    }
    public readonly ulong3 zzy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 1, 3)));
            else
                return new(z, z, y);
        }
    }
    public readonly ulong3 bbg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 1, 3)));
            else
                return new(z, z, y);
        }
    }
    public readonly ulong3 zzz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 2, 3)));
            else
                return new(z, z, z);
        }
    }
    public readonly ulong3 bbb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 2, 3)));
            else
                return new(z, z, z);
        }
    }
}

#endregion // ulong3

#region decimal3

public partial struct decimal3 
{
    public readonly decimal3 xxx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
    }
    public readonly decimal3 rrr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
    }
    public readonly decimal3 xxy
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
    }
    public readonly decimal3 rrg
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
    }
    public readonly decimal3 xxz
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
    }
    public readonly decimal3 rrb
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
    }
    public readonly decimal3 xyx
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
    }
    public readonly decimal3 rgr
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
    }
    public readonly decimal3 xyy
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
    }
    public readonly decimal3 rgg
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
    }
    public decimal3 xyz
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public decimal3 rgb
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public readonly decimal3 xzx
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
    }
    public readonly decimal3 rbr
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
    }
    public decimal3 xzy
    {
        [MethodImpl(256 | 512)]
        readonly get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set => this = value.xzy;
    }
    public decimal3 rbg
    {
        [MethodImpl(256 | 512)]
        readonly get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set => this = value.xzy;
    }
    public readonly decimal3 xzz
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
    }
    public readonly decimal3 rbb
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
    }
    public readonly decimal3 yxx
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
    }
    public readonly decimal3 grr
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
    }
    public readonly decimal3 yxy
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
    }
    public readonly decimal3 grg
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
    }
    public decimal3 yxz
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set => this = value.yxz;
    }
    public decimal3 grb
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set => this = value.yxz;
    }
    public readonly decimal3 yyx
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
    }
    public readonly decimal3 ggr
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
    }
    public readonly decimal3 yyy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
    }
    public readonly decimal3 ggg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
    }
    public readonly decimal3 yyz
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
    }
    public readonly decimal3 ggb
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
    }
    public decimal3 yzx
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set => this = value.zxy;
    }
    public decimal3 gbr
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set => this = value.zxy;
    }
    public readonly decimal3 yzy
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
    }
    public readonly decimal3 gbg
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
    }
    public readonly decimal3 yzz
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
    }
    public readonly decimal3 gbb
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
    }
    public readonly decimal3 zxx
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
    }
    public readonly decimal3 brr
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
    }
    public decimal3 zxy
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set => this = value.yzx;
    }
    public decimal3 brg
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set => this = value.yzx;
    }
    public readonly decimal3 zxz
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
    }
    public readonly decimal3 brb
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
    }
    public decimal3 zyx
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set => this = value.zyx;
    }
    public decimal3 bgr
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set => this = value.zyx;
    }
    public readonly decimal3 zyy
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
    }
    public readonly decimal3 bgg
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
    }
    public readonly decimal3 zyz
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
    }
    public readonly decimal3 bgb
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
    }
    public readonly decimal3 zzx
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
    }
    public readonly decimal3 bbr
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
    }
    public readonly decimal3 zzy
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
    }
    public readonly decimal3 bbg
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
    }
    public readonly decimal3 zzz
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
    }
    public readonly decimal3 bbb
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
    }
}

#endregion // decimal3

#region half3

public partial struct half3 
{
    public readonly half3 xxx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
    }
    public readonly half3 rrr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
    }
    public readonly half3 xxy
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
    }
    public readonly half3 rrg
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
    }
    public readonly half3 xxz
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
    }
    public readonly half3 rrb
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
    }
    public readonly half3 xyx
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
    }
    public readonly half3 rgr
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
    }
    public readonly half3 xyy
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
    }
    public readonly half3 rgg
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
    }
    public half3 xyz
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public half3 rgb
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public readonly half3 xzx
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
    }
    public readonly half3 rbr
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
    }
    public half3 xzy
    {
        [MethodImpl(256 | 512)]
        readonly get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set => this = value.xzy;
    }
    public half3 rbg
    {
        [MethodImpl(256 | 512)]
        readonly get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set => this = value.xzy;
    }
    public readonly half3 xzz
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
    }
    public readonly half3 rbb
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
    }
    public readonly half3 yxx
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
    }
    public readonly half3 grr
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
    }
    public readonly half3 yxy
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
    }
    public readonly half3 grg
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
    }
    public half3 yxz
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set => this = value.yxz;
    }
    public half3 grb
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set => this = value.yxz;
    }
    public readonly half3 yyx
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
    }
    public readonly half3 ggr
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
    }
    public readonly half3 yyy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
    }
    public readonly half3 ggg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
    }
    public readonly half3 yyz
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
    }
    public readonly half3 ggb
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
    }
    public half3 yzx
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set => this = value.zxy;
    }
    public half3 gbr
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set => this = value.zxy;
    }
    public readonly half3 yzy
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
    }
    public readonly half3 gbg
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
    }
    public readonly half3 yzz
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
    }
    public readonly half3 gbb
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
    }
    public readonly half3 zxx
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
    }
    public readonly half3 brr
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
    }
    public half3 zxy
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set => this = value.yzx;
    }
    public half3 brg
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set => this = value.yzx;
    }
    public readonly half3 zxz
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
    }
    public readonly half3 brb
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
    }
    public half3 zyx
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set => this = value.zyx;
    }
    public half3 bgr
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set => this = value.zyx;
    }
    public readonly half3 zyy
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
    }
    public readonly half3 bgg
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
    }
    public readonly half3 zyz
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
    }
    public readonly half3 bgb
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
    }
    public readonly half3 zzx
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
    }
    public readonly half3 bbr
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
    }
    public readonly half3 zzy
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
    }
    public readonly half3 bbg
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
    }
    public readonly half3 zzz
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
    }
    public readonly half3 bbb
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
    }
}

#endregion // half3

#region b16v3

public partial struct b16v3 
{
    public readonly b16v3 xxx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
    }
    public readonly b16v3 rrr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
    }
    public readonly b16v3 xxy
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
    }
    public readonly b16v3 rrg
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
    }
    public readonly b16v3 xxz
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
    }
    public readonly b16v3 rrb
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
    }
    public readonly b16v3 xyx
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
    }
    public readonly b16v3 rgr
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
    }
    public readonly b16v3 xyy
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
    }
    public readonly b16v3 rgg
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
    }
    public b16v3 xyz
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public b16v3 rgb
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public readonly b16v3 xzx
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
    }
    public readonly b16v3 rbr
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
    }
    public b16v3 xzy
    {
        [MethodImpl(256 | 512)]
        readonly get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set => this = value.xzy;
    }
    public b16v3 rbg
    {
        [MethodImpl(256 | 512)]
        readonly get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set => this = value.xzy;
    }
    public readonly b16v3 xzz
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
    }
    public readonly b16v3 rbb
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
    }
    public readonly b16v3 yxx
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
    }
    public readonly b16v3 grr
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
    }
    public readonly b16v3 yxy
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
    }
    public readonly b16v3 grg
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
    }
    public b16v3 yxz
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set => this = value.yxz;
    }
    public b16v3 grb
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set => this = value.yxz;
    }
    public readonly b16v3 yyx
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
    }
    public readonly b16v3 ggr
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
    }
    public readonly b16v3 yyy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
    }
    public readonly b16v3 ggg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
    }
    public readonly b16v3 yyz
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
    }
    public readonly b16v3 ggb
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
    }
    public b16v3 yzx
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set => this = value.zxy;
    }
    public b16v3 gbr
    {
        [MethodImpl(256 | 512)]
        readonly get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set => this = value.zxy;
    }
    public readonly b16v3 yzy
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
    }
    public readonly b16v3 gbg
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
    }
    public readonly b16v3 yzz
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
    }
    public readonly b16v3 gbb
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
    }
    public readonly b16v3 zxx
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
    }
    public readonly b16v3 brr
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
    }
    public b16v3 zxy
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set => this = value.yzx;
    }
    public b16v3 brg
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set => this = value.yzx;
    }
    public readonly b16v3 zxz
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
    }
    public readonly b16v3 brb
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
    }
    public b16v3 zyx
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set => this = value.zyx;
    }
    public b16v3 bgr
    {
        [MethodImpl(256 | 512)]
        readonly get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set => this = value.zyx;
    }
    public readonly b16v3 zyy
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
    }
    public readonly b16v3 bgg
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
    }
    public readonly b16v3 zyz
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
    }
    public readonly b16v3 bgb
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
    }
    public readonly b16v3 zzx
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
    }
    public readonly b16v3 bbr
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
    }
    public readonly b16v3 zzy
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
    }
    public readonly b16v3 bbg
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
    }
    public readonly b16v3 zzz
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
    }
    public readonly b16v3 bbb
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
    }
}

#endregion // b16v3

#region b32v3

public partial struct b32v3 
{
    public readonly b32v3 xxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly b32v3 rrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly b32v3 xxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly b32v3 rrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly b32v3 xxz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 2, 3)));
            else
                return new(x, x, z);
        }
    }
    public readonly b32v3 rrb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 2, 3)));
            else
                return new(x, x, z);
        }
    }
    public readonly b32v3 xyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly b32v3 rgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly b32v3 xyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public readonly b32v3 rgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public b32v3 xyz
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public b32v3 rgb
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public readonly b32v3 xzx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 0, 3)));
            else
                return new(x, z, x);
        }
    }
    public readonly b32v3 rbr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 0, 3)));
            else
                return new(x, z, x);
        }
    }
    public b32v3 xzy
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 1, 3)));
            else
                return new(x, z, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.xzy;
    }
    public b32v3 rbg
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 1, 3)));
            else
                return new(x, z, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.xzy;
    }
    public readonly b32v3 xzz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 2, 3)));
            else
                return new(x, z, z);
        }
    }
    public readonly b32v3 rbb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 2, 3)));
            else
                return new(x, z, z);
        }
    }
    public readonly b32v3 yxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly b32v3 grr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly b32v3 yxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public readonly b32v3 grg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public b32v3 yxz
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 2, 3)));
            else
                return new(y, x, z);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yxz;
    }
    public b32v3 grb
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 2, 3)));
            else
                return new(y, x, z);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yxz;
    }
    public readonly b32v3 yyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly b32v3 ggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly b32v3 yyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
    public readonly b32v3 ggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
    public readonly b32v3 yyz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 2, 3)));
            else
                return new(y, y, z);
        }
    }
    public readonly b32v3 ggb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 2, 3)));
            else
                return new(y, y, z);
        }
    }
    public b32v3 yzx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 0, 3)));
            else
                return new(y, z, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zxy;
    }
    public b32v3 gbr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 0, 3)));
            else
                return new(y, z, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zxy;
    }
    public readonly b32v3 yzy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 1, 3)));
            else
                return new(y, z, y);
        }
    }
    public readonly b32v3 gbg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 1, 3)));
            else
                return new(y, z, y);
        }
    }
    public readonly b32v3 yzz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 2, 3)));
            else
                return new(y, z, z);
        }
    }
    public readonly b32v3 gbb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 2, 3)));
            else
                return new(y, z, z);
        }
    }
    public readonly b32v3 zxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 0, 3)));
            else
                return new(z, x, x);
        }
    }
    public readonly b32v3 brr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 0, 3)));
            else
                return new(z, x, x);
        }
    }
    public b32v3 zxy
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 1, 3)));
            else
                return new(z, x, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yzx;
    }
    public b32v3 brg
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 1, 3)));
            else
                return new(z, x, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yzx;
    }
    public readonly b32v3 zxz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 2, 3)));
            else
                return new(z, x, z);
        }
    }
    public readonly b32v3 brb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 2, 3)));
            else
                return new(z, x, z);
        }
    }
    public b32v3 zyx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 0, 3)));
            else
                return new(z, y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zyx;
    }
    public b32v3 bgr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 0, 3)));
            else
                return new(z, y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zyx;
    }
    public readonly b32v3 zyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 1, 3)));
            else
                return new(z, y, y);
        }
    }
    public readonly b32v3 bgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 1, 3)));
            else
                return new(z, y, y);
        }
    }
    public readonly b32v3 zyz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 2, 3)));
            else
                return new(z, y, z);
        }
    }
    public readonly b32v3 bgb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 2, 3)));
            else
                return new(z, y, z);
        }
    }
    public readonly b32v3 zzx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 0, 3)));
            else
                return new(z, z, x);
        }
    }
    public readonly b32v3 bbr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 0, 3)));
            else
                return new(z, z, x);
        }
    }
    public readonly b32v3 zzy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 1, 3)));
            else
                return new(z, z, y);
        }
    }
    public readonly b32v3 bbg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 1, 3)));
            else
                return new(z, z, y);
        }
    }
    public readonly b32v3 zzz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 2, 3)));
            else
                return new(z, z, z);
        }
    }
    public readonly b32v3 bbb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector128.IsHardwareAccelerated)
                return new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 2, 3)));
            else
                return new(z, z, z);
        }
    }
}

#endregion // b32v3

#region b64v3

public partial struct b64v3 
{
    public readonly b64v3 xxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly b64v3 rrr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 0, 3)));
            else
                return new(x, x, x);
        }
    }
    public readonly b64v3 xxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly b64v3 rrg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 1, 3)));
            else
                return new(x, x, y);
        }
    }
    public readonly b64v3 xxz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 2, 3)));
            else
                return new(x, x, z);
        }
    }
    public readonly b64v3 rrb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 2, 3)));
            else
                return new(x, x, z);
        }
    }
    public readonly b64v3 xyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly b64v3 rgr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 1, 0, 3)));
            else
                return new(x, y, x);
        }
    }
    public readonly b64v3 xyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public readonly b64v3 rgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 1, 1, 3)));
            else
                return new(x, y, y);
        }
    }
    public b64v3 xyz
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public b64v3 rgb
    {
        [MethodImpl(256 | 512)]
        readonly get => this;
        [MethodImpl(256 | 512)]
        set => this = value;
    }
    public readonly b64v3 xzx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 0, 3)));
            else
                return new(x, z, x);
        }
    }
    public readonly b64v3 rbr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 0, 3)));
            else
                return new(x, z, x);
        }
    }
    public b64v3 xzy
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 1, 3)));
            else
                return new(x, z, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.xzy;
    }
    public b64v3 rbg
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 1, 3)));
            else
                return new(x, z, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.xzy;
    }
    public readonly b64v3 xzz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 2, 3)));
            else
                return new(x, z, z);
        }
    }
    public readonly b64v3 rbb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 2, 3)));
            else
                return new(x, z, z);
        }
    }
    public readonly b64v3 yxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly b64v3 grr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 0, 3)));
            else
                return new(y, x, x);
        }
    }
    public readonly b64v3 yxy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public readonly b64v3 grg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 1, 3)));
            else
                return new(y, x, y);
        }
    }
    public b64v3 yxz
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 2, 3)));
            else
                return new(y, x, z);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yxz;
    }
    public b64v3 grb
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 2, 3)));
            else
                return new(y, x, z);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yxz;
    }
    public readonly b64v3 yyx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly b64v3 ggr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 0, 3)));
            else
                return new(y, y, x);
        }
    }
    public readonly b64v3 yyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
    public readonly b64v3 ggg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 1, 3)));
            else
                return new(y, y, y);
        }
    }
    public readonly b64v3 yyz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 2, 3)));
            else
                return new(y, y, z);
        }
    }
    public readonly b64v3 ggb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 2, 3)));
            else
                return new(y, y, z);
        }
    }
    public b64v3 yzx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 0, 3)));
            else
                return new(y, z, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zxy;
    }
    public b64v3 gbr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 0, 3)));
            else
                return new(y, z, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zxy;
    }
    public readonly b64v3 yzy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 1, 3)));
            else
                return new(y, z, y);
        }
    }
    public readonly b64v3 gbg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 1, 3)));
            else
                return new(y, z, y);
        }
    }
    public readonly b64v3 yzz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 2, 3)));
            else
                return new(y, z, z);
        }
    }
    public readonly b64v3 gbb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 2, 3)));
            else
                return new(y, z, z);
        }
    }
    public readonly b64v3 zxx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 0, 3)));
            else
                return new(z, x, x);
        }
    }
    public readonly b64v3 brr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 0, 3)));
            else
                return new(z, x, x);
        }
    }
    public b64v3 zxy
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 1, 3)));
            else
                return new(z, x, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yzx;
    }
    public b64v3 brg
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 1, 3)));
            else
                return new(z, x, y);
        }
        [MethodImpl(256 | 512)]
        set => this = value.yzx;
    }
    public readonly b64v3 zxz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 2, 3)));
            else
                return new(z, x, z);
        }
    }
    public readonly b64v3 brb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 2, 3)));
            else
                return new(z, x, z);
        }
    }
    public b64v3 zyx
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 0, 3)));
            else
                return new(z, y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zyx;
    }
    public b64v3 bgr
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 0, 3)));
            else
                return new(z, y, x);
        }
        [MethodImpl(256 | 512)]
        set => this = value.zyx;
    }
    public readonly b64v3 zyy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 1, 3)));
            else
                return new(z, y, y);
        }
    }
    public readonly b64v3 bgg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 1, 3)));
            else
                return new(z, y, y);
        }
    }
    public readonly b64v3 zyz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 2, 3)));
            else
                return new(z, y, z);
        }
    }
    public readonly b64v3 bgb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 2, 3)));
            else
                return new(z, y, z);
        }
    }
    public readonly b64v3 zzx
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 0, 3)));
            else
                return new(z, z, x);
        }
    }
    public readonly b64v3 bbr
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 0, 3)));
            else
                return new(z, z, x);
        }
    }
    public readonly b64v3 zzy
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 1, 3)));
            else
                return new(z, z, y);
        }
    }
    public readonly b64v3 bbg
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 1, 3)));
            else
                return new(z, z, y);
        }
    }
    public readonly b64v3 zzz
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 2, 3)));
            else
                return new(z, z, z);
        }
    }
    public readonly b64v3 bbb
    {
        [MethodImpl(256 | 512)]
        get
        {
            if (Vector256.IsHardwareAccelerated)
                return new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 2, 3)));
            else
                return new(z, z, z);
        }
    }
}

#endregion // b64v3
