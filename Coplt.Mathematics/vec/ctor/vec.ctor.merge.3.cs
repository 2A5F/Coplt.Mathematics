// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region float3

public partial struct float3 
{
    [MethodImpl(256 | 512)]
    public float3(float2 xy, float z)
    {
        vector = Vector128.Create(xy.vector, Vector64.Create(z, default));
    }

    [MethodImpl(256 | 512)]
    public float3(float x, float2 yz)
    {
        if (Vector128.IsHardwareAccelerated)
            vector = Vector128.Shuffle(
                Vector128.Create(Vector64.Create(x, default), yz.vector),
                Vector128.Create(0, 2, 3, 1)
            );
        else
            this = new(x, yz.x, yz.y);
    }

    [MethodImpl(256 | 512)]
    internal float3(float2 xz, float y, insert_y _)
    {
        if (Vector128.IsHardwareAccelerated)
            vector = Vector128.Shuffle(
                Vector128.Create(xz.vector, Vector64.Create(y, default)),
                Vector128.Create(0, 2, 1, 3)
            );
        else
            this = new(xz.x, y, xz.y);
    }
}

public static partial class ctor
{
    [MethodImpl(256 | 512)]
    public static float3 float3(float2 xy, float z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static float3 float3(float x, float2 yz) => new(x, yz);
}

public static partial class math_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3 Ix(this float2 yz, float x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3 Iy(this float2 xz, float y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3 Iz(this float2 xy, float z) => new(xy, z);
}

#endregion // float3

#region double3

public partial struct double3 
{
    [MethodImpl(256 | 512)]
    public double3(double2 xy, double z)
    {
        vector = Vector256.Create(xy.vector, Vector128.Create(z, default));
    }

    [MethodImpl(256 | 512)]
    public double3(double x, double2 yz)
    {
        if (Vector256.IsHardwareAccelerated)
            vector = Vector256.Shuffle(
                Vector256.Create(Vector128.Create(x, default), yz.vector),
                Vector256.Create(0, 2, 3, 1)
            );
        else
            this = new(x, yz.x, yz.y);
    }

    [MethodImpl(256 | 512)]
    internal double3(double2 xz, double y, insert_y _)
    {
        if (Vector256.IsHardwareAccelerated)
            vector = Vector256.Shuffle(
                Vector256.Create(xz.vector, Vector128.Create(y, default)),
                Vector256.Create(0, 2, 1, 3)
            );
        else
            this = new(xz.x, y, xz.y);
    }
}

public static partial class ctor
{
    [MethodImpl(256 | 512)]
    public static double3 double3(double2 xy, double z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static double3 double3(double x, double2 yz) => new(x, yz);
}

public static partial class math_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3 Ix(this double2 yz, double x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3 Iy(this double2 xz, double y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3 Iz(this double2 xy, double z) => new(xy, z);
}

#endregion // double3

#region short3

public partial struct short3 
{
    [MethodImpl(256 | 512)]
    public short3(short2 xy, short z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public short3(short x, short2 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal short3(short2 xz, short y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor
{
    [MethodImpl(256 | 512)]
    public static short3 short3(short2 xy, short z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static short3 short3(short x, short2 yz) => new(x, yz);
}

public static partial class math_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static short3 Ix(this short2 yz, short x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static short3 Iy(this short2 xz, short y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static short3 Iz(this short2 xy, short z) => new(xy, z);
}

#endregion // short3

#region ushort3

public partial struct ushort3 
{
    [MethodImpl(256 | 512)]
    public ushort3(ushort2 xy, ushort z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public ushort3(ushort x, ushort2 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal ushort3(ushort2 xz, ushort y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor
{
    [MethodImpl(256 | 512)]
    public static ushort3 ushort3(ushort2 xy, ushort z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static ushort3 ushort3(ushort x, ushort2 yz) => new(x, yz);
}

public static partial class math_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ushort3 Ix(this ushort2 yz, ushort x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ushort3 Iy(this ushort2 xz, ushort y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ushort3 Iz(this ushort2 xy, ushort z) => new(xy, z);
}

#endregion // ushort3

#region int3

public partial struct int3 
{
    [MethodImpl(256 | 512)]
    public int3(int2 xy, int z)
    {
        vector = Vector128.Create(xy.vector, Vector64.Create(z, default));
    }

    [MethodImpl(256 | 512)]
    public int3(int x, int2 yz)
    {
        if (Vector128.IsHardwareAccelerated)
            vector = Vector128.Shuffle(
                Vector128.Create(Vector64.Create(x, default), yz.vector),
                Vector128.Create(0, 2, 3, 1)
            );
        else
            this = new(x, yz.x, yz.y);
    }

    [MethodImpl(256 | 512)]
    internal int3(int2 xz, int y, insert_y _)
    {
        if (Vector128.IsHardwareAccelerated)
            vector = Vector128.Shuffle(
                Vector128.Create(xz.vector, Vector64.Create(y, default)),
                Vector128.Create(0, 2, 1, 3)
            );
        else
            this = new(xz.x, y, xz.y);
    }
}

public static partial class ctor
{
    [MethodImpl(256 | 512)]
    public static int3 int3(int2 xy, int z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static int3 int3(int x, int2 yz) => new(x, yz);
}

public static partial class math_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3 Ix(this int2 yz, int x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3 Iy(this int2 xz, int y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3 Iz(this int2 xy, int z) => new(xy, z);
}

#endregion // int3

#region uint3

public partial struct uint3 
{
    [MethodImpl(256 | 512)]
    public uint3(uint2 xy, uint z)
    {
        vector = Vector128.Create(xy.vector, Vector64.Create(z, default));
    }

    [MethodImpl(256 | 512)]
    public uint3(uint x, uint2 yz)
    {
        if (Vector128.IsHardwareAccelerated)
            vector = Vector128.Shuffle(
                Vector128.Create(Vector64.Create(x, default), yz.vector),
                Vector128.Create((uint)0, 2, 3, 1)
            );
        else
            this = new(x, yz.x, yz.y);
    }

    [MethodImpl(256 | 512)]
    internal uint3(uint2 xz, uint y, insert_y _)
    {
        if (Vector128.IsHardwareAccelerated)
            vector = Vector128.Shuffle(
                Vector128.Create(xz.vector, Vector64.Create(y, default)),
                Vector128.Create((uint)0, 2, 1, 3)
            );
        else
            this = new(xz.x, y, xz.y);
    }
}

public static partial class ctor
{
    [MethodImpl(256 | 512)]
    public static uint3 uint3(uint2 xy, uint z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static uint3 uint3(uint x, uint2 yz) => new(x, yz);
}

public static partial class math_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3 Ix(this uint2 yz, uint x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3 Iy(this uint2 xz, uint y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3 Iz(this uint2 xy, uint z) => new(xy, z);
}

#endregion // uint3

#region long3

public partial struct long3 
{
    [MethodImpl(256 | 512)]
    public long3(long2 xy, long z)
    {
        vector = Vector256.Create(xy.vector, Vector128.Create(z, default));
    }

    [MethodImpl(256 | 512)]
    public long3(long x, long2 yz)
    {
        if (Vector256.IsHardwareAccelerated)
            vector = Vector256.Shuffle(
                Vector256.Create(Vector128.Create(x, default), yz.vector),
                Vector256.Create(0, 2, 3, 1)
            );
        else
            this = new(x, yz.x, yz.y);
    }

    [MethodImpl(256 | 512)]
    internal long3(long2 xz, long y, insert_y _)
    {
        if (Vector256.IsHardwareAccelerated)
            vector = Vector256.Shuffle(
                Vector256.Create(xz.vector, Vector128.Create(y, default)),
                Vector256.Create(0, 2, 1, 3)
            );
        else
            this = new(xz.x, y, xz.y);
    }
}

public static partial class ctor
{
    [MethodImpl(256 | 512)]
    public static long3 long3(long2 xy, long z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static long3 long3(long x, long2 yz) => new(x, yz);
}

public static partial class math_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3 Ix(this long2 yz, long x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3 Iy(this long2 xz, long y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3 Iz(this long2 xy, long z) => new(xy, z);
}

#endregion // long3

#region ulong3

public partial struct ulong3 
{
    [MethodImpl(256 | 512)]
    public ulong3(ulong2 xy, ulong z)
    {
        vector = Vector256.Create(xy.vector, Vector128.Create(z, default));
    }

    [MethodImpl(256 | 512)]
    public ulong3(ulong x, ulong2 yz)
    {
        if (Vector256.IsHardwareAccelerated)
            vector = Vector256.Shuffle(
                Vector256.Create(Vector128.Create(x, default), yz.vector),
                Vector256.Create((ulong)0, 2, 3, 1)
            );
        else
            this = new(x, yz.x, yz.y);
    }

    [MethodImpl(256 | 512)]
    internal ulong3(ulong2 xz, ulong y, insert_y _)
    {
        if (Vector256.IsHardwareAccelerated)
            vector = Vector256.Shuffle(
                Vector256.Create(xz.vector, Vector128.Create(y, default)),
                Vector256.Create((ulong)0, 2, 1, 3)
            );
        else
            this = new(xz.x, y, xz.y);
    }
}

public static partial class ctor
{
    [MethodImpl(256 | 512)]
    public static ulong3 ulong3(ulong2 xy, ulong z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static ulong3 ulong3(ulong x, ulong2 yz) => new(x, yz);
}

public static partial class math_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3 Ix(this ulong2 yz, ulong x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3 Iy(this ulong2 xz, ulong y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3 Iz(this ulong2 xy, ulong z) => new(xy, z);
}

#endregion // ulong3

#region decimal3

public partial struct decimal3 
{
    [MethodImpl(256 | 512)]
    public decimal3(decimal2 xy, decimal z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public decimal3(decimal x, decimal2 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal decimal3(decimal2 xz, decimal y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor
{
    [MethodImpl(256 | 512)]
    public static decimal3 decimal3(decimal2 xy, decimal z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static decimal3 decimal3(decimal x, decimal2 yz) => new(x, yz);
}

public static partial class math_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static decimal3 Ix(this decimal2 yz, decimal x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static decimal3 Iy(this decimal2 xz, decimal y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static decimal3 Iz(this decimal2 xy, decimal z) => new(xy, z);
}

#endregion // decimal3

#region half3

public partial struct half3 
{
    [MethodImpl(256 | 512)]
    public half3(half2 xy, half z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public half3(half x, half2 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal half3(half2 xz, half y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor
{
    [MethodImpl(256 | 512)]
    public static half3 half3(half2 xy, half z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static half3 half3(half x, half2 yz) => new(x, yz);
}

public static partial class math_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static half3 Ix(this half2 yz, half x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static half3 Iy(this half2 xz, half y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static half3 Iz(this half2 xy, half z) => new(xy, z);
}

#endregion // half3

#region b16v3

public partial struct b16v3 
{
    [MethodImpl(256 | 512)]
    public b16v3(b16v2 xy, b16 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public b16v3(b16 x, b16v2 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal b16v3(b16v2 xz, b16 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor
{
    [MethodImpl(256 | 512)]
    public static b16v3 b16v3(b16v2 xy, b16 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static b16v3 b16v3(b16 x, b16v2 yz) => new(x, yz);
}

public static partial class math_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b16v3 Ix(this b16v2 yz, b16 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b16v3 Iy(this b16v2 xz, b16 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b16v3 Iz(this b16v2 xy, b16 z) => new(xy, z);
}

#endregion // b16v3

#region b32v3

public partial struct b32v3 
{
    [MethodImpl(256 | 512)]
    public b32v3(b32v2 xy, b32 z)
    {
        vector = Vector128.Create(xy.vector, Vector64.Create(z, default));
    }

    [MethodImpl(256 | 512)]
    public b32v3(b32 x, b32v2 yz)
    {
        if (Vector128.IsHardwareAccelerated)
            vector = Vector128.Shuffle(
                Vector128.Create(Vector64.Create(x, default), yz.vector),
                Vector128.Create((uint)0, 2, 3, 1)
            );
        else
            this = new(x, yz.x, yz.y);
    }

    [MethodImpl(256 | 512)]
    internal b32v3(b32v2 xz, b32 y, insert_y _)
    {
        if (Vector128.IsHardwareAccelerated)
            vector = Vector128.Shuffle(
                Vector128.Create(xz.vector, Vector64.Create(y, default)),
                Vector128.Create((uint)0, 2, 1, 3)
            );
        else
            this = new(xz.x, y, xz.y);
    }
}

public static partial class ctor
{
    [MethodImpl(256 | 512)]
    public static b32v3 b32v3(b32v2 xy, b32 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static b32v3 b32v3(b32 x, b32v2 yz) => new(x, yz);
}

public static partial class math_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3 Ix(this b32v2 yz, b32 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3 Iy(this b32v2 xz, b32 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3 Iz(this b32v2 xy, b32 z) => new(xy, z);
}

#endregion // b32v3

#region b64v3

public partial struct b64v3 
{
    [MethodImpl(256 | 512)]
    public b64v3(b64v2 xy, b64 z)
    {
        vector = Vector256.Create(xy.vector, Vector128.Create(z, default));
    }

    [MethodImpl(256 | 512)]
    public b64v3(b64 x, b64v2 yz)
    {
        if (Vector256.IsHardwareAccelerated)
            vector = Vector256.Shuffle(
                Vector256.Create(Vector128.Create(x, default), yz.vector),
                Vector256.Create((ulong)0, 2, 3, 1)
            );
        else
            this = new(x, yz.x, yz.y);
    }

    [MethodImpl(256 | 512)]
    internal b64v3(b64v2 xz, b64 y, insert_y _)
    {
        if (Vector256.IsHardwareAccelerated)
            vector = Vector256.Shuffle(
                Vector256.Create(xz.vector, Vector128.Create(y, default)),
                Vector256.Create((ulong)0, 2, 1, 3)
            );
        else
            this = new(xz.x, y, xz.y);
    }
}

public static partial class ctor
{
    [MethodImpl(256 | 512)]
    public static b64v3 b64v3(b64v2 xy, b64 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static b64v3 b64v3(b64 x, b64v2 yz) => new(x, yz);
}

public static partial class math_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3 Ix(this b64v2 yz, b64 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3 Iy(this b64v2 xz, b64 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3 Iz(this b64v2 xy, b64 z) => new(xy, z);
}

#endregion // b64v3
