// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region b16v2

public partial struct b16v2
{
    public static b16v2 True
    {
        [MethodImpl(256 | 512)]
        get => new(b16v.True);
    }
    public static b16v2 False
    {
        [MethodImpl(256 | 512)]
        get => new(b16v.False);
    }

    [MethodImpl(256 | 512)]
    public static b16v2 operator !(b16v2 self)
    {
        return new(!self.x, !self.y);
    }
}

[Ex]
public static partial class math
{

    [MethodImpl(256 | 512)]
    public static bool all([This] b16v2 v)
    {
        return v.x && v.y;
    }

    [MethodImpl(256 | 512)]
    public static bool any([This] b16v2 v)
    {
        return v.x || v.y;
    }

    [MethodImpl(256 | 512)]
    public static bool allFalse([This] b16v2 v)
    {
        return !v.x && !v.y;
    }
}

#endregion // b16v2

#region b16v3

public partial struct b16v3
{
    public static b16v3 True
    {
        [MethodImpl(256 | 512)]
        get => new(b16v.True);
    }
    public static b16v3 False
    {
        [MethodImpl(256 | 512)]
        get => new(b16v.False);
    }

    [MethodImpl(256 | 512)]
    public static b16v3 operator !(b16v3 self)
    {
        return new(!self.x, !self.y, !self.z);
    }
}

[Ex]
public static partial class math
{

    [MethodImpl(256 | 512)]
    public static bool all([This] b16v3 v)
    {
        return v.x && v.y && v.z;
    }

    [MethodImpl(256 | 512)]
    public static bool any([This] b16v3 v)
    {
        return v.x || v.y || v.z;
    }

    [MethodImpl(256 | 512)]
    public static bool allFalse([This] b16v3 v)
    {
        return !v.x && !v.y && !v.z;
    }
}

#endregion // b16v3

#region b16v4

public partial struct b16v4
{
    public static b16v4 True
    {
        [MethodImpl(256 | 512)]
        get => new(b16v.True);
    }
    public static b16v4 False
    {
        [MethodImpl(256 | 512)]
        get => new(b16v.False);
    }

    [MethodImpl(256 | 512)]
    public static b16v4 operator !(b16v4 self)
    {
        return new(!self.x, !self.y, !self.z, !self.w);
    }
}

[Ex]
public static partial class math
{

    [MethodImpl(256 | 512)]
    public static bool all([This] b16v4 v)
    {
        return v.x && v.y && v.z && v.w;
    }

    [MethodImpl(256 | 512)]
    public static bool any([This] b16v4 v)
    {
        return v.x || v.y || v.z || v.w;
    }

    [MethodImpl(256 | 512)]
    public static bool allFalse([This] b16v4 v)
    {
        return !v.x && !v.y && !v.z && !v.w;
    }
}

#endregion // b16v4

#region b32v2

public partial struct b32v2
{
    public static b32v2 True
    {
        [MethodImpl(256 | 512)]
        get => new(b32v.True);
    }
    public static b32v2 False
    {
        [MethodImpl(256 | 512)]
        get => new(b32v.False);
    }

    [MethodImpl(256 | 512)]
    public static b32v2 operator !(b32v2 self)
    {
        if (Vector64.IsHardwareAccelerated)
            return new((~self.vector));
        return new(!self.x, !self.y);
    }
}

[Ex]
public static partial class math
{

    [MethodImpl(256 | 512)]
    public static bool all([This] b32v2 v)
    {
        if (Vector64.IsHardwareAccelerated)
            return v.vector.ExtractMostSignificantBits() >= 0xF;
        return v.x && v.y;
    }

    [MethodImpl(256 | 512)]
    public static bool any([This] b32v2 v)
    {
        if (Vector64.IsHardwareAccelerated)
            return v.vector.ExtractMostSignificantBits() != 0;
        return v.x || v.y;
    }

    [MethodImpl(256 | 512)]
    public static bool allFalse([This] b32v2 v)
    {
        if (Vector64.IsHardwareAccelerated)
            return v.vector.ExtractMostSignificantBits() == 0;
        return !v.x && !v.y;
    }
}

#endregion // b32v2

#region b32v3

public partial struct b32v3
{
    public static b32v3 True
    {
        [MethodImpl(256 | 512)]
        get => new(b32v.True);
    }
    public static b32v3 False
    {
        [MethodImpl(256 | 512)]
        get => new(b32v.False);
    }

    [MethodImpl(256 | 512)]
    public static b32v3 operator !(b32v3 self)
    {
        if (Vector128.IsHardwareAccelerated)
            return new((~self.vector) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        return new(!self.x, !self.y, !self.z);
    }
}

[Ex]
public static partial class math
{

    [MethodImpl(256 | 512)]
    public static bool all([This] b32v3 v)
    {
        if (Vector128.IsHardwareAccelerated)
            return v.vector.ExtractMostSignificantBits() >= 0x7;
        return v.x && v.y && v.z;
    }

    [MethodImpl(256 | 512)]
    public static bool any([This] b32v3 v)
    {
        if (Vector128.IsHardwareAccelerated)
            return v.vector.ExtractMostSignificantBits() != 0;
        return v.x || v.y || v.z;
    }

    [MethodImpl(256 | 512)]
    public static bool allFalse([This] b32v3 v)
    {
        if (Vector128.IsHardwareAccelerated)
            return v.vector.ExtractMostSignificantBits() == 0;
        return !v.x && !v.y && !v.z;
    }
}

#endregion // b32v3

#region b32v4

public partial struct b32v4
{
    public static b32v4 True
    {
        [MethodImpl(256 | 512)]
        get => new(b32v.True);
    }
    public static b32v4 False
    {
        [MethodImpl(256 | 512)]
        get => new(b32v.False);
    }

    [MethodImpl(256 | 512)]
    public static b32v4 operator !(b32v4 self)
    {
        if (Vector128.IsHardwareAccelerated)
            return new((~self.vector));
        return new(!self.x, !self.y, !self.z, !self.w);
    }
}

[Ex]
public static partial class math
{

    [MethodImpl(256 | 512)]
    public static bool all([This] b32v4 v)
    {
        if (Vector128.IsHardwareAccelerated)
            return v.vector.ExtractMostSignificantBits() >= 0xF;
        return v.x && v.y && v.z && v.w;
    }

    [MethodImpl(256 | 512)]
    public static bool any([This] b32v4 v)
    {
        if (Vector128.IsHardwareAccelerated)
            return v.vector.ExtractMostSignificantBits() != 0;
        return v.x || v.y || v.z || v.w;
    }

    [MethodImpl(256 | 512)]
    public static bool allFalse([This] b32v4 v)
    {
        if (Vector128.IsHardwareAccelerated)
            return v.vector.ExtractMostSignificantBits() == 0;
        return !v.x && !v.y && !v.z && !v.w;
    }
}

#endregion // b32v4

#region b64v2

public partial struct b64v2
{
    public static b64v2 True
    {
        [MethodImpl(256 | 512)]
        get => new(b64v.True);
    }
    public static b64v2 False
    {
        [MethodImpl(256 | 512)]
        get => new(b64v.False);
    }

    [MethodImpl(256 | 512)]
    public static b64v2 operator !(b64v2 self)
    {
        if (Vector128.IsHardwareAccelerated)
            return new((~self.vector));
        return new(!self.x, !self.y);
    }
}

[Ex]
public static partial class math
{

    [MethodImpl(256 | 512)]
    public static bool all([This] b64v2 v)
    {
        if (Vector128.IsHardwareAccelerated)
            return v.vector.ExtractMostSignificantBits() >= 0xF;
        return v.x && v.y;
    }

    [MethodImpl(256 | 512)]
    public static bool any([This] b64v2 v)
    {
        if (Vector128.IsHardwareAccelerated)
            return v.vector.ExtractMostSignificantBits() != 0;
        return v.x || v.y;
    }

    [MethodImpl(256 | 512)]
    public static bool allFalse([This] b64v2 v)
    {
        if (Vector128.IsHardwareAccelerated)
            return v.vector.ExtractMostSignificantBits() == 0;
        return !v.x && !v.y;
    }
}

#endregion // b64v2

#region b64v3

public partial struct b64v3
{
    public static b64v3 True
    {
        [MethodImpl(256 | 512)]
        get => new(b64v.True);
    }
    public static b64v3 False
    {
        [MethodImpl(256 | 512)]
        get => new(b64v.False);
    }

    [MethodImpl(256 | 512)]
    public static b64v3 operator !(b64v3 self)
    {
        if (Vector256.IsHardwareAccelerated)
            return new((~self.vector) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        return new(!self.x, !self.y, !self.z);
    }
}

[Ex]
public static partial class math
{

    [MethodImpl(256 | 512)]
    public static bool all([This] b64v3 v)
    {
        if (Vector256.IsHardwareAccelerated)
            return v.vector.ExtractMostSignificantBits() >= 0x7;
        return v.x && v.y && v.z;
    }

    [MethodImpl(256 | 512)]
    public static bool any([This] b64v3 v)
    {
        if (Vector256.IsHardwareAccelerated)
            return v.vector.ExtractMostSignificantBits() != 0;
        return v.x || v.y || v.z;
    }

    [MethodImpl(256 | 512)]
    public static bool allFalse([This] b64v3 v)
    {
        if (Vector256.IsHardwareAccelerated)
            return v.vector.ExtractMostSignificantBits() == 0;
        return !v.x && !v.y && !v.z;
    }
}

#endregion // b64v3

#region b64v4

public partial struct b64v4
{
    public static b64v4 True
    {
        [MethodImpl(256 | 512)]
        get => new(b64v.True);
    }
    public static b64v4 False
    {
        [MethodImpl(256 | 512)]
        get => new(b64v.False);
    }

    [MethodImpl(256 | 512)]
    public static b64v4 operator !(b64v4 self)
    {
        if (Vector256.IsHardwareAccelerated)
            return new((~self.vector));
        return new(!self.x, !self.y, !self.z, !self.w);
    }
}

[Ex]
public static partial class math
{

    [MethodImpl(256 | 512)]
    public static bool all([This] b64v4 v)
    {
        if (Vector256.IsHardwareAccelerated)
            return v.vector.ExtractMostSignificantBits() >= 0xF;
        return v.x && v.y && v.z && v.w;
    }

    [MethodImpl(256 | 512)]
    public static bool any([This] b64v4 v)
    {
        if (Vector256.IsHardwareAccelerated)
            return v.vector.ExtractMostSignificantBits() != 0;
        return v.x || v.y || v.z || v.w;
    }

    [MethodImpl(256 | 512)]
    public static bool allFalse([This] b64v4 v)
    {
        if (Vector256.IsHardwareAccelerated)
            return v.vector.ExtractMostSignificantBits() == 0;
        return !v.x && !v.y && !v.z && !v.w;
    }
}

#endregion // b64v4
