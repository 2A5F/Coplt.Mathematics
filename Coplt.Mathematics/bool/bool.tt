<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics;
<#
    for (int s = 2; s <= 8; s *= 2)
    {
        var size = s * 8;
        var typeName = $"b{size}";
        var type = s switch { 2 => "ushort", 4 => "uint", 8 => "ulong", _ => "" };

        string ei(string t) => t == type ? "implicit" : "explicit"; 
#>

#region <#= typeName #>

public readonly partial record struct <#= typeName #> : IEquatable<bool>, IFormattable
#if NET8_0_OR_GREATER
    , ISpanFormattable, IUtf8SpanFormattable
    , IEqualityOperators<<#= typeName #>, <#= typeName #>, bool>
#endif
{
    [MethodImpl(256 | 512)]
    internal <#= typeName #>(<#= type #> value) => this.value = value;
    internal readonly <#= type #> value;

    public static readonly <#= typeName #> True = new(<#= type #>.MaxValue);
    public static readonly <#= typeName #> False = new(0);

    public bool Equals(bool other) => other == (bool)this;

    #region ToString

    public override string ToString() => ((bool)this).ToString();

    public string ToString(string? format, IFormatProvider? formatProvider) => ToString();

    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
        => ((bool)this).TryFormat(destination, out charsWritten);

    #if NET8_0_OR_GREATER
    public bool TryFormat(Span<byte> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        charsWritten = 0;
        if (this)
        {
            if (destination.Length < 4) return false;
            var lit = "True"u8;
            lit.CopyTo(destination);
            charsWritten = 4;
        }
        else 
        {
            if (destination.Length < 5) return false;
            var lit = "False"u8;
            lit.CopyTo(destination);
            charsWritten = 5;
        }
        return true;
    }
    #endif

    #endregion

    #region operators

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator !(<#= typeName #> v) => new((<#= type #>)~v.value);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator ~(<#= typeName #> v) => new((<#= type #>)~v.value);
    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator |(<#= typeName #> a, <#= typeName #> b) => new((<#= type #>)(a.value | b.value));
    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator &(<#= typeName #> a, <#= typeName #> b) => new((<#= type #>)(a.value & b.value));
    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator ^(<#= typeName #> a, <#= typeName #> b) => new((<#= type #>)(a.value ^ b.value));

    [MethodImpl(256 | 512)]
    public static implicit operator bool(<#= typeName #> v) => v.value != 0;
    [MethodImpl(256 | 512)]
    public static implicit operator <#= typeName #>(bool v) => v ? True : False;

    [MethodImpl(256 | 512)]
    public static bool operator true(<#= typeName #> v) => v.value != 0;
    [MethodImpl(256 | 512)]
    public static bool operator false(<#= typeName #> v) => v.value == 0;

    [MethodImpl(256 | 512)]
    public static explicit operator byte(<#= typeName #> v) => (byte)v.value;
    [MethodImpl(256 | 512)]
    public static explicit operator sbyte(<#= typeName #> v) => (sbyte)v.value;
    [MethodImpl(256 | 512)]
    public static <#= ei("ushort") #> operator ushort(<#= typeName #> v) => (ushort)v.value;
    [MethodImpl(256 | 512)]
    public static explicit operator short(<#= typeName #> v) => (short)v.value;
    [MethodImpl(256 | 512)]
    public static <#= ei("uint") #> operator uint(<#= typeName #> v) => (uint)v.value;
    [MethodImpl(256 | 512)]
    public static explicit operator int(<#= typeName #> v) => (int)v.value;
    [MethodImpl(256 | 512)]
    public static <#= ei("ulong") #> operator ulong(<#= typeName #> v) => (ulong)v.value;
    [MethodImpl(256 | 512)]
    public static explicit operator long(<#= typeName #> v) => (long)v.value;
    [MethodImpl(256 | 512)]
    public static explicit operator half(<#= typeName #> v) => (Half)v.value;
    [MethodImpl(256 | 512)]
    public static explicit operator float(<#= typeName #> v) => (float)v.value;
    [MethodImpl(256 | 512)]
    public static explicit operator double(<#= typeName #> v) => (double)v.value;
    [MethodImpl(256 | 512)]
    public static explicit operator decimal(<#= typeName #> v) => (decimal)v.value;

    [MethodImpl(256 | 512)]
    public static explicit operator <#= typeName #>(sbyte v) => v.Equals(default) ? False : True;
    [MethodImpl(256 | 512)]
    public static explicit operator <#= typeName #>(byte v) => v.Equals(default) ? False : True;
    [MethodImpl(256 | 512)]
    public static <#= ei("ushort") #> operator <#= typeName #>(ushort v) => v.Equals(default) ? False : True;
    [MethodImpl(256 | 512)]
    public static explicit operator <#= typeName #>(short v) => v.Equals(default) ? False : True;
    [MethodImpl(256 | 512)]
    public static <#= ei("uint") #> operator <#= typeName #>(uint v) => v.Equals(default) ? False : True;
    [MethodImpl(256 | 512)]
    public static explicit operator <#= typeName #>(int v) => v.Equals(default) ? False : True;
    [MethodImpl(256 | 512)]
    public static <#= ei("ulong") #> operator <#= typeName #>(ulong v) => v.Equals(default) ? False : True;
    [MethodImpl(256 | 512)]
    public static explicit operator <#= typeName #>(long v) => v.Equals(default) ? False : True;
    [MethodImpl(256 | 512)]
    public static explicit operator <#= typeName #>(half v) => v.Equals(default) ? False : True;
    [MethodImpl(256 | 512)]
    public static explicit operator <#= typeName #>(float v) => v.Equals(default) ? False : True;
    [MethodImpl(256 | 512)]
    public static explicit operator <#= typeName #>(double v) => v.Equals(default) ? False : True;
    [MethodImpl(256 | 512)]
    public static explicit operator <#= typeName #>(decimal v) => v.Equals(default) ? False : True;

    #endregion
}

#endregion // <#= typeName #>
<#
    }
#>
