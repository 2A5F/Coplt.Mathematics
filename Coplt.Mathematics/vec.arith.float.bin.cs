// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region float2

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b32v2 isInf(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.IsInfinity(a.vector).AsUInt32());
        #else // NET8_0_OR_GREATER
        return new(a.x.isInf(), a.y.isInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b32v2 isPosInf(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Equals(a.vector, Vector64.Create(float.PositiveInfinity)).AsUInt32());
        #else // NET8_0_OR_GREATER
        return new(a.x.isPosInf(), a.y.isPosInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b32v2 isNegInf(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Equals(a.vector, Vector64.Create(float.NegativeInfinity)).AsUInt32());
        #else // NET8_0_OR_GREATER
        return new(a.x.isNegInf(), a.y.isNegInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 log(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log(), a.y.log());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 log2(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log2(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log2(), a.y.log2());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 log(this float2 a, float2 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log(a.vector) / simd.Log(b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log(b.x), a.y.log(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 log10(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log10(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log10(), a.y.log10());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 exp(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Exp(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.exp(), a.y.exp());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 pow(this float2 a, float2 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Pow(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.pow(b.x), a.y.pow(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 pow(this float2 a, float b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Pow(a.vector, b));
        #else // NET8_0_OR_GREATER
        return new(a.x.pow(b), a.y.pow(b));
        #endif // NET8_0_OR_GREATER
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float2 fma(this float2 a, float2 b, float2 c)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Fma(a.vector, b.vector, c.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y));
        #endif // NET8_0_OR_GREATER
    }
}

#endregion // float2

#region float3

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b32v3 isInf(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.IsInfinity(a.vector).AsUInt32());
        #else // NET8_0_OR_GREATER
        return new(a.x.isInf(), a.y.isInf(), a.z.isInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b32v3 isPosInf(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Equals(a.vector, Vector128.Create(float.PositiveInfinity)).AsUInt32());
        #else // NET8_0_OR_GREATER
        return new(a.x.isPosInf(), a.y.isPosInf(), a.z.isPosInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b32v3 isNegInf(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Equals(a.vector, Vector128.Create(float.NegativeInfinity)).AsUInt32());
        #else // NET8_0_OR_GREATER
        return new(a.x.isNegInf(), a.y.isNegInf(), a.z.isNegInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 log(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log(), a.y.log(), a.z.log());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 log2(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log2(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log2(), a.y.log2(), a.z.log2());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 log(this float3 a, float3 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log(a.vector) / simd.Log(b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log(b.x), a.y.log(b.y), a.z.log(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 log10(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log10(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log10(), a.y.log10(), a.z.log10());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 exp(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Exp(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.exp(), a.y.exp(), a.z.exp());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 pow(this float3 a, float3 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Pow(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.pow(b.x), a.y.pow(b.y), a.z.pow(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 pow(this float3 a, float b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Pow(a.vector, b));
        #else // NET8_0_OR_GREATER
        return new(a.x.pow(b), a.y.pow(b), a.z.pow(b));
        #endif // NET8_0_OR_GREATER
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float3 fma(this float3 a, float3 b, float3 c)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Fma(a.vector, b.vector, c.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z));
        #endif // NET8_0_OR_GREATER
    }
}

#endregion // float3

#region float4

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b32v4 isInf(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.IsInfinity(a.vector).AsUInt32());
        #else // NET8_0_OR_GREATER
        return new(a.x.isInf(), a.y.isInf(), a.z.isInf(), a.w.isInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b32v4 isPosInf(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Equals(a.vector, Vector128.Create(float.PositiveInfinity)).AsUInt32());
        #else // NET8_0_OR_GREATER
        return new(a.x.isPosInf(), a.y.isPosInf(), a.z.isPosInf(), a.w.isPosInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b32v4 isNegInf(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Equals(a.vector, Vector128.Create(float.NegativeInfinity)).AsUInt32());
        #else // NET8_0_OR_GREATER
        return new(a.x.isNegInf(), a.y.isNegInf(), a.z.isNegInf(), a.w.isNegInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 log(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log(), a.y.log(), a.z.log(), a.w.log());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 log2(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log2(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log2(), a.y.log2(), a.z.log2(), a.w.log2());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 log(this float4 a, float4 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log(a.vector) / simd.Log(b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log(b.x), a.y.log(b.y), a.z.log(b.z), a.w.log(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 log10(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log10(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log10(), a.y.log10(), a.z.log10(), a.w.log10());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 exp(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Exp(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.exp(), a.y.exp(), a.z.exp(), a.w.exp());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 pow(this float4 a, float4 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Pow(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.pow(b.x), a.y.pow(b.y), a.z.pow(b.z), a.w.pow(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 pow(this float4 a, float b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Pow(a.vector, b));
        #else // NET8_0_OR_GREATER
        return new(a.x.pow(b), a.y.pow(b), a.z.pow(b), a.w.pow(b));
        #endif // NET8_0_OR_GREATER
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float4 fma(this float4 a, float4 b, float4 c)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Fma(a.vector, b.vector, c.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z), a.w.fma(b.w, c.w));
        #endif // NET8_0_OR_GREATER
    }
}

#endregion // float4

#region double2

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b64v2 isInf(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.IsInfinity(a.vector).AsUInt64());
        #else // NET8_0_OR_GREATER
        return new(a.x.isInf(), a.y.isInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b64v2 isPosInf(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Equals(a.vector, Vector128.Create(double.PositiveInfinity)).AsUInt64());
        #else // NET8_0_OR_GREATER
        return new(a.x.isPosInf(), a.y.isPosInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b64v2 isNegInf(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Equals(a.vector, Vector128.Create(double.NegativeInfinity)).AsUInt64());
        #else // NET8_0_OR_GREATER
        return new(a.x.isNegInf(), a.y.isNegInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 log(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log(), a.y.log());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 log2(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log2(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log2(), a.y.log2());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 log(this double2 a, double2 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log(a.vector) / simd.Log(b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log(b.x), a.y.log(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 log10(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log10(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log10(), a.y.log10());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 exp(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Exp(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.exp(), a.y.exp());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 pow(this double2 a, double2 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Pow(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.pow(b.x), a.y.pow(b.y));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 pow(this double2 a, double b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Pow(a.vector, b));
        #else // NET8_0_OR_GREATER
        return new(a.x.pow(b), a.y.pow(b));
        #endif // NET8_0_OR_GREATER
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double2 fma(this double2 a, double2 b, double2 c)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Fma(a.vector, b.vector, c.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y));
        #endif // NET8_0_OR_GREATER
    }
}

#endregion // double2

#region double3

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b64v3 isInf(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.IsInfinity(a.vector).AsUInt64());
        #else // NET8_0_OR_GREATER
        return new(a.x.isInf(), a.y.isInf(), a.z.isInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b64v3 isPosInf(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Equals(a.vector, Vector256.Create(double.PositiveInfinity)).AsUInt64());
        #else // NET8_0_OR_GREATER
        return new(a.x.isPosInf(), a.y.isPosInf(), a.z.isPosInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b64v3 isNegInf(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Equals(a.vector, Vector256.Create(double.NegativeInfinity)).AsUInt64());
        #else // NET8_0_OR_GREATER
        return new(a.x.isNegInf(), a.y.isNegInf(), a.z.isNegInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 log(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log(), a.y.log(), a.z.log());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 log2(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log2(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log2(), a.y.log2(), a.z.log2());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 log(this double3 a, double3 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log(a.vector) / simd.Log(b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log(b.x), a.y.log(b.y), a.z.log(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 log10(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log10(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log10(), a.y.log10(), a.z.log10());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 exp(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Exp(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.exp(), a.y.exp(), a.z.exp());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 pow(this double3 a, double3 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Pow(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.pow(b.x), a.y.pow(b.y), a.z.pow(b.z));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 pow(this double3 a, double b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Pow(a.vector, b));
        #else // NET8_0_OR_GREATER
        return new(a.x.pow(b), a.y.pow(b), a.z.pow(b));
        #endif // NET8_0_OR_GREATER
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double3 fma(this double3 a, double3 b, double3 c)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Fma(a.vector, b.vector, c.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z));
        #endif // NET8_0_OR_GREATER
    }
}

#endregion // double3

#region double4

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b64v4 isInf(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.IsInfinity(a.vector).AsUInt64());
        #else // NET8_0_OR_GREATER
        return new(a.x.isInf(), a.y.isInf(), a.z.isInf(), a.w.isInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b64v4 isPosInf(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Equals(a.vector, Vector256.Create(double.PositiveInfinity)).AsUInt64());
        #else // NET8_0_OR_GREATER
        return new(a.x.isPosInf(), a.y.isPosInf(), a.z.isPosInf(), a.w.isPosInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b64v4 isNegInf(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Equals(a.vector, Vector256.Create(double.NegativeInfinity)).AsUInt64());
        #else // NET8_0_OR_GREATER
        return new(a.x.isNegInf(), a.y.isNegInf(), a.z.isNegInf(), a.w.isNegInf());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 log(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log(), a.y.log(), a.z.log(), a.w.log());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 log2(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log2(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log2(), a.y.log2(), a.z.log2(), a.w.log2());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 log(this double4 a, double4 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log(a.vector) / simd.Log(b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log(b.x), a.y.log(b.y), a.z.log(b.z), a.w.log(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 log10(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Log10(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.log10(), a.y.log10(), a.z.log10(), a.w.log10());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 exp(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Exp(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.exp(), a.y.exp(), a.z.exp(), a.w.exp());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 pow(this double4 a, double4 b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Pow(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.pow(b.x), a.y.pow(b.y), a.z.pow(b.z), a.w.pow(b.w));
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 pow(this double4 a, double b)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Pow(a.vector, b));
        #else // NET8_0_OR_GREATER
        return new(a.x.pow(b), a.y.pow(b), a.z.pow(b), a.w.pow(b));
        #endif // NET8_0_OR_GREATER
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double4 fma(this double4 a, double4 b, double4 c)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Fma(a.vector, b.vector, c.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z), a.w.fma(b.w, c.w));
        #endif // NET8_0_OR_GREATER
    }
}

#endregion // double4

#region half2

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b16v2 isInf(this half2 a)
    {
        return new(a.x.isInf(), a.y.isInf());
    }

    [MethodImpl(256 | 512)]
    public static b16v2 isPosInf(this half2 a)
    {
        return new(a.x.isPosInf(), a.y.isPosInf());
    }

    [MethodImpl(256 | 512)]
    public static b16v2 isNegInf(this half2 a)
    {
        return new(a.x.isNegInf(), a.y.isNegInf());
    }

    [MethodImpl(256 | 512)]
    public static half2 log(this half2 a)
    {
        return new(a.x.log(), a.y.log());
    }

    [MethodImpl(256 | 512)]
    public static half2 log2(this half2 a)
    {
        return new(a.x.log2(), a.y.log2());
    }

    [MethodImpl(256 | 512)]
    public static half2 log(this half2 a, half2 b)
    {
        return new(a.x.log(b.x), a.y.log(b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 log10(this half2 a)
    {
        return new(a.x.log10(), a.y.log10());
    }

    [MethodImpl(256 | 512)]
    public static half2 exp(this half2 a)
    {
        return new(a.x.exp(), a.y.exp());
    }

    [MethodImpl(256 | 512)]
    public static half2 pow(this half2 a, half2 b)
    {
        return new(a.x.pow(b.x), a.y.pow(b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 pow(this half2 a, half b)
    {
        return new(a.x.pow(b), a.y.pow(b));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static half2 fma(this half2 a, half2 b, half2 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y));
    }
}

#endregion // half2

#region half3

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b16v3 isInf(this half3 a)
    {
        return new(a.x.isInf(), a.y.isInf(), a.z.isInf());
    }

    [MethodImpl(256 | 512)]
    public static b16v3 isPosInf(this half3 a)
    {
        return new(a.x.isPosInf(), a.y.isPosInf(), a.z.isPosInf());
    }

    [MethodImpl(256 | 512)]
    public static b16v3 isNegInf(this half3 a)
    {
        return new(a.x.isNegInf(), a.y.isNegInf(), a.z.isNegInf());
    }

    [MethodImpl(256 | 512)]
    public static half3 log(this half3 a)
    {
        return new(a.x.log(), a.y.log(), a.z.log());
    }

    [MethodImpl(256 | 512)]
    public static half3 log2(this half3 a)
    {
        return new(a.x.log2(), a.y.log2(), a.z.log2());
    }

    [MethodImpl(256 | 512)]
    public static half3 log(this half3 a, half3 b)
    {
        return new(a.x.log(b.x), a.y.log(b.y), a.z.log(b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 log10(this half3 a)
    {
        return new(a.x.log10(), a.y.log10(), a.z.log10());
    }

    [MethodImpl(256 | 512)]
    public static half3 exp(this half3 a)
    {
        return new(a.x.exp(), a.y.exp(), a.z.exp());
    }

    [MethodImpl(256 | 512)]
    public static half3 pow(this half3 a, half3 b)
    {
        return new(a.x.pow(b.x), a.y.pow(b.y), a.z.pow(b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 pow(this half3 a, half b)
    {
        return new(a.x.pow(b), a.y.pow(b), a.z.pow(b));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static half3 fma(this half3 a, half3 b, half3 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z));
    }
}

#endregion // half3

#region half4

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b16v4 isInf(this half4 a)
    {
        return new(a.x.isInf(), a.y.isInf(), a.z.isInf(), a.w.isInf());
    }

    [MethodImpl(256 | 512)]
    public static b16v4 isPosInf(this half4 a)
    {
        return new(a.x.isPosInf(), a.y.isPosInf(), a.z.isPosInf(), a.w.isPosInf());
    }

    [MethodImpl(256 | 512)]
    public static b16v4 isNegInf(this half4 a)
    {
        return new(a.x.isNegInf(), a.y.isNegInf(), a.z.isNegInf(), a.w.isNegInf());
    }

    [MethodImpl(256 | 512)]
    public static half4 log(this half4 a)
    {
        return new(a.x.log(), a.y.log(), a.z.log(), a.w.log());
    }

    [MethodImpl(256 | 512)]
    public static half4 log2(this half4 a)
    {
        return new(a.x.log2(), a.y.log2(), a.z.log2(), a.w.log2());
    }

    [MethodImpl(256 | 512)]
    public static half4 log(this half4 a, half4 b)
    {
        return new(a.x.log(b.x), a.y.log(b.y), a.z.log(b.z), a.w.log(b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 log10(this half4 a)
    {
        return new(a.x.log10(), a.y.log10(), a.z.log10(), a.w.log10());
    }

    [MethodImpl(256 | 512)]
    public static half4 exp(this half4 a)
    {
        return new(a.x.exp(), a.y.exp(), a.z.exp(), a.w.exp());
    }

    [MethodImpl(256 | 512)]
    public static half4 pow(this half4 a, half4 b)
    {
        return new(a.x.pow(b.x), a.y.pow(b.y), a.z.pow(b.z), a.w.pow(b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 pow(this half4 a, half b)
    {
        return new(a.x.pow(b), a.y.pow(b), a.z.pow(b), a.w.pow(b));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static half4 fma(this half4 a, half4 b, half4 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z), a.w.fma(b.w, c.w));
    }
}

#endregion // half4
