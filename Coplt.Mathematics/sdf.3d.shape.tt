<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics.Sdf;

<#
    foreach (var typ in Typ.Typs)
    {
        if (!typ.f || !typ.bin) continue;
        if (typ.name == "half") continue;

        var typeBitSize = typ.size * 8;

        var byteSize = typ.size * 4;
        var bitSize = 8 * byteSize;

        var suffix = typ.suffix;

        var scalar = typ.compType;
        var vec4 = $"{typ.name}{4}";
        var vec3 = $"{typ.name}{3}";
        var vec2 = $"{typ.name}{2}";
        var vec = vec3;
#>
#region <#= typ.name #>

[method: MethodImpl(256 | 512)]
public readonly partial record struct revolution_2d_to_3d<#= typ.structSuffix #><S>(S shape, <#= scalar #> o) : ISdfShape3d<<#= scalar #>, <#= vec #>> 
    where S : ISdfShape2d<<#= scalar #>, <#= vec2 #>>
{
    public readonly S shape = shape;
    public readonly <#= scalar #> o = o;

    [MethodImpl(256 | 512)]
    public <#= scalar #> calc(<#= vec #> target) => shape.calc(new(target.xz.length() - o, target.y));
}

[method: MethodImpl(256 | 512)]
public readonly partial record struct extrusion_2d_to_3d<#= typ.structSuffix #><S>(S shape, <#= scalar #> h) : ISdfShape3d<<#= scalar #>, <#= vec #>> 
    where S : ISdfShape2d<<#= scalar #>, <#= vec2 #>>
{
    public readonly S shape = shape;
    public readonly <#= scalar #> h = h;

    [MethodImpl(256 | 512)]
    public <#= scalar #> calc(<#= vec #> target)
    {
        var d = shape.calc(target.xy);
        var w = new <#= vec2 #>(d, target.z.abs() - h);
        return w.cmax().min(0.0<#= suffix #>) + w.max(0.0<#= suffix #>).length();
    }
}

[method: MethodImpl(256 | 512)]
public readonly partial record struct round3d<#= typ.structSuffix #><S>(S shape, <#= scalar #> radius) : ISdfShape3d<<#= scalar #>, <#= vec #>> 
    where S : ISdfShape3d<<#= scalar #>, <#= vec #>>
{
    public readonly S shape = shape;
    public readonly <#= scalar #> radius = radius;

    [MethodImpl(256 | 512)]
    public <#= scalar #> calc(<#= vec #> target) => shape.calc(target) - radius;
}

[method: MethodImpl(256 | 512)]
public readonly partial record struct onion3d<#= typ.structSuffix #><S>(S shape, <#= scalar #> radius) : ISdfShape3d<<#= scalar #>, <#= vec #>> 
    where S : ISdfShape3d<<#= scalar #>, <#= vec #>>
{
    public readonly S shape = shape;
    public readonly <#= scalar #> radius = radius;

    [MethodImpl(256 | 512)]
    public <#= scalar #> calc(<#= vec #> target) => shape.calc(target).abs() - radius;
}

[method: MethodImpl(256 | 512)]
public readonly partial record struct point3d<#= typ.structSuffix #>(<#= vec #> center) : ISdfShape3d<<#= scalar #>, <#= vec #>>
{
    public readonly <#= vec #> center = center;

    [MethodImpl(256 | 512)]
    public <#= scalar #> calc(<#= vec #> target) => sdf.sphere(target, center, 0);
}

[method: MethodImpl(256 | 512)]
public readonly partial record struct sphere<#= typ.structSuffix #>(<#= vec #> center, <#= scalar #> radius) : ISdfShape3d<<#= scalar #>, <#= vec #>>
{
    public readonly <#= vec #> center = center;
    public readonly <#= scalar #> radius = radius;

    [MethodImpl(256 | 512)]
    public <#= scalar #> calc(<#= vec #> target) => sdf.sphere(target, center, radius);
}

[method: MethodImpl(256 | 512)]
public readonly partial record struct capsule<#= typ.structSuffix #>(<#= vec #> a, <#= vec #> b, <#= scalar #> radius) : ISdfShape3d<<#= scalar #>, <#= vec #>>
{
    public readonly <#= vec #> a = a;
    public readonly <#= vec #> b = b;
    public readonly <#= scalar #> radius = radius;

    [MethodImpl(256 | 512)]
    public <#= scalar #> calc(<#= vec #> target) => sdf.capsule(target, a, b, radius);
}

#endregion // <#= typ.name #>

<#
    }
#>
