<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics;
<#
    foreach (var typ in Typ.Typs)
    {
        for (var n = 2; n <= 4; n++)
        {
            for (var m = 2; m <= 4; m++)
            {
                var byteSize = typ.size * (n is 3 ? 4 : n);
                var bitSize = 8 * byteSize;

                var vecTypeName = $"{typ.name}{n}";
                var typeName = $"{typ.name.Replace('v', 'm')}{n}x{m}";
#>

#region <#= typeName #>

[Serializable]
[JsonConverter(typeof(<#= typeName #>JsonConverter))]
public partial struct <#= typeName #> :
    IMatrix<#= n #>x<#= m #><<#= typ.compType #>>, IMatrixSelf<<#= typeName #>>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => <#= typ.simd ? "true" : "false" #>;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => <#= n * m #>; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(<#= n #>, <#= m #>); 
    }

    public static <#= typeName #> Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static <#= typeName #> One
    { 
        [MethodImpl(256 | 512)]
        get => new(<#= typ.one #>); 
    }
<#
                if (true)
                {
#>

    public static <#= typeName #> Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            <#=
                        string.Join(",\n            ", Enumerable.Range(0, n).Select(j => string.Join(", ", Enumerable.Range(0, m).Select(i => j == i ? typ.one : "default")))) #>
        ); 
    }
<#
                }
#>

    #endregion

    #region fields
<#
                for (int i = 0; i < m; i++)
                {
#>
    public <#= vecTypeName #> c<#= i #>;
<#
                }
#>

    #endregion

    #region getter

<#
                for (int i = 0; i < n; i++)
                {
                    for (int j = 0; j < m; j++)
                    {
#>
    public <#= typ.compType #> m<#= i #><#= j #>
    {
        [MethodImpl(256 | 512)]
        get => c<#= j #>.<#= Typ.xyzw[i] #>;
        [MethodImpl(256 | 512)]
        set => c<#= j #>.<#= Typ.xyzw[i] #> = value;
    }
<#
                    }
                }
#>

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#= string.Join(", ", Enumerable.Range(0, m).Select(i => $"{vecTypeName} c{i}")) #>)
    {
<#
                for (int i = 0; i < m; i++)
                {
#>
        this.c<#= i #> = c<#= i #>;
<#
                }
#>
    }

    [MethodImpl(256 | 512)]
    public <#= typeName #>((<#= string.Join(", ", Enumerable.Range(0, m).Select(i => $"{vecTypeName} c{i}")) #>) tuple)
    {
<#
                for (int i = 0; i < m; i++)
                {
#>
        this.c<#= i #> = tuple.c<#= i #>;
<#
                }
#>
    }

    [MethodImpl(256 | 512)]
    public static implicit operator <#= typeName #>((<#= string.Join(", ", Enumerable.Range(0, m).Select(i => $"{vecTypeName} c{i}")) #>) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public <#= typeName #>(
        <#=
                    string.Join(",\n        ", Enumerable.Range(0, n).Select(j => string.Join(", ", Enumerable.Range(0, m).Select(i => $"{typ.compType} m{j}{i}")))) #>
    )
    {
<#
                for (int i = 0; i < m; i++)
                {
#>
        this.c<#= i #> = new(<#= string.Join(", ", Enumerable.Range(0, n).Select(j => $"m{j}{i}")) #>);
<#
                }
#>
    }

    [MethodImpl(256 | 512)]
    public static implicit operator <#= typeName #>((
        <#=
                    string.Join(",\n        ", Enumerable.Range(0, n).Select(j => string.Join(", ", Enumerable.Range(0, m).Select(i => $"{typ.compType} m{j}{i}")))) #>
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public <#= typeName #>((
        <#=
                    string.Join(",\n        ", Enumerable.Range(0, n).Select(j => string.Join(", ", Enumerable.Range(0, m).Select(i => $"{typ.compType} m{j}{i}")))) #>
    ) tuple)
    {
<#
                for (int i = 0; i < m; i++)
                {
#>
        this.c<#= i #> = new(<#= string.Join(", ", Enumerable.Range(0, n).Select(j => $"tuple.m{j}{i}")) #>);
<#
                }
#>
    }

    [MethodImpl(256 | 512)]
    public static implicit operator <#= typeName #>((
        <#=
                    string.Join(",\n        ", Enumerable.Range(0, n).Select(j => $"({string.Join(", ", Enumerable.Range(0, m).Select(i => $"{typ.compType} m{j}{i}"))}) r{j}")) #>
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public <#= typeName #>((
        <#=
                    string.Join(",\n        ", Enumerable.Range(0, n).Select(j => $"({string.Join(", ", Enumerable.Range(0, m).Select(i => $"{typ.compType} m{j}{i}"))}) r{j}")) #>
    ) tuple)
    {
<#
                for (int i = 0; i < m; i++)
                {
#>
        this.c<#= i #> = new(<#= string.Join(", ", Enumerable.Range(0, n).Select(j => $"tuple.r{j}.m{j}{i}")) #>);
<#
                }
#>
    }

    [MethodImpl(256 | 512)]
    public static implicit operator <#= typeName #>(<#= typ.compType #> value) => new(value);

    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#= typ.compType #> value)
    {
<#
                for (int i = 0; i < m; i++)
                {
#>
        this.c<#= i #> = value;
<#
                }
#>
    }

    [MethodImpl(256 | 512)]
    public static implicit operator <#= typeName #>(<#= vecTypeName #> value) => new(value);

    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#= vecTypeName #> value)
    {
<#
                for (int i = 0; i < m; i++)
                {
#>
        this.c<#= i #> = value;
<#
                }
#>
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(<#= string.Join(", ", Enumerable.Range(0, m).Select(i => $"out {vecTypeName} c{i}")) #>)
    {
<#
                for (int i = 0; i < m; i++)
                {
#>
        c<#= i #> = this.c<#= i #>;
<#
                }
#>
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        <#=
                    string.Join(",\n        ", Enumerable.Range(0, n).Select(j => string.Join(", ", Enumerable.Range(0, m).Select(i => $"out {typ.compType} m{j}{i}")))) #>
    )
    {
<#
                for (int i = 0; i < m; i++)
                {
#>
        this.c<#= i #>.Deconstruct(<#= string.Join(", ", Enumerable.Range(0, n).Select(j => $"out m{j}{i}")) #>);
<#
                }
#>
    }

    #endregion // deconstruct

    #region index

    public <#= vecTypeName #> this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
<#
                for (var j = 0; j < m; j++)
                {
#>
            <#= j #> => c<#= j #>,
<#
                }
#>
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
<#
                for (var j = 0; j < m; j++)
                {
#>
                case <#= j #>:
                    c<#= j #> = value;
                    break;
<#
                }
#>
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public <#= typ.compType #> this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
<#
                for (var j = 0; j < m; j++)
                {
#>
            <#= j #> => c<#= j #>[r],
<#
                }
#>
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
<#
                for (var j = 0; j < m; j++)
                {
#>
                case <#= j #>:
                    c<#= j #>[r] = value;
                    break;
<#
                }
#>
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // <#= typeName #>
<#
            }
        }
    }
#>
