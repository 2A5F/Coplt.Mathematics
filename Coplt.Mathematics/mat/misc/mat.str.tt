<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics;
<#
    foreach (var typ in Typ.Typs)
    {
        for (var n = 2; n <= 4; n++)
        {
            for (var m = 2; m <= 4; m++)
            {
                var byteSize = typ.size * (n is 3 ? 4 : n);
                var bitSize = 8 * byteSize;

                var vecTypeName = $"{typ.name}{n}";
                var typeName = $"{typ.name.Replace('v', 'm')}{n}x{m}";

                var format = string.Join(", ", Enumerable.Range(0, n).Select(j =>
                    $"{{{{{string.Join(", ", Enumerable.Range(0, m).Select(i => $"{{m{j}{i}}}"))}}}}}"
                    ));

                var format2 = !typ.formattable
                    ? format
                    : string.Join(", ", Enumerable.Range(0, n).Select(j =>
                        $"{{{{{string.Join(", ", Enumerable.Range(0, m).Select(i => $"{{m{j}{i}.ToString(format, formatProvider)}}"))}}}}}"
                        ));
#>

#region <#= typeName #>

public partial struct <#= typeName #> : IFormattable
    #if NET8_0_OR_GREATER
    , ISpanFormattable
    , IUtf8SpanFormattable
    #endif
{
    [CpuOnly]
    public override string ToString() => $"<#= typeName #>(<#= format #>)";

    [CpuOnly]
    public string ToString(string? format, IFormatProvider? formatProvider) => $"<#= typeName #>(<#= format2 #>)";

    [CpuOnly]
    public bool TryFormat(Span<char> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        if (!TryFormatPart(ref dst, ref nc, "<#= typeName #>({")) return false;
<#
                for (var j = 0; j < n; j++)
                {
                    if (j != 0)
                    {
#>
        if (!TryFormatPart(ref dst, ref nc, "}, {")) return false;
<#
                    }
                    for (var i = 0; i < m; i++)
                    {
                        var comp = $"m{j}{i}";
                        if (i != 0)
                        {
#>
        if (!TryFormatPart(ref dst, ref nc, ", ")) return false;
<#
                        }
#>
        if (!TryFormatPart(ref dst, ref nc, <#= comp #>, format, provider)) return false;
<#
                    }
                }
#>
        if (!TryFormatPart(ref dst, ref nc, "})")) return false;
        return true;
    }
<#
                if (typ.formattable)
                {
#>

    #if NET8_0_OR_GREATER
    [CpuOnly]
    public bool TryFormat(Span<byte> dst, out int nc, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        nc = 0;
        if (!TryFormatPart(ref dst, ref nc, "<#= typeName #>({"u8)) return false;
<#
                    for (var j = 0; j < n; j++)
                    {
                        if (j != 0)
                        {
#>
        if (!TryFormatPart(ref dst, ref nc, "}, {"u8)) return false;
<#
                        }
                        for (var i = 0; i < m; i++)
                        {
                            var comp = $"m{j}{i}";
                            if (i != 0)
                            {
#>
        if (!TryFormatPart(ref dst, ref nc, ", "u8)) return false;
<#
                            }
#>
        if (!TryFormatPart(ref dst, ref nc, <#= comp #>, format, provider)) return false;
<#
                        }
                    }
#>
        if (!TryFormatPart(ref dst, ref nc, "})"u8)) return false;
        return true;
    }
    #endif
<#
                }
#>
}

#endregion // <#= typeName #>
<#
            }
        }
    }
#>
