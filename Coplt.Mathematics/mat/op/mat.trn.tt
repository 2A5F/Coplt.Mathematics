<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="../../types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics;
<#
    foreach (var typ in Typ.Typs)
    {
        for (var n = 2; n <= 4; n++)
        {
            for (var m = 2; m <= 4; m++)
            {
                var byteSize = typ.size * (n is 3 ? 4 : n);
                var bitSize = 8 * byteSize;

                var vecTypeName = $"{typ.name}{n}";
                var typeName = $"{typ.name.Replace('v', 'm')}{n}x{m}";

                var t_byteSize = typ.size * (m is 3 ? 4 : m);
                var t_bitSize = 8 * t_byteSize;

                var t_vecTypeName = $"{typ.name}{m}";
                var t_typeName = $"{typ.name.Replace('v', 'm')}{m}x{n}";

                var simd_method_suffix = n == m ? $"{n}x{m}" : $"{n}x{m}To{m}x{n}";

                var has_simd = typ.simd && !(n == m && n == 2);
#>

#region <#= typeName #>

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static <#= t_typeName #> transpose([This] <#= typeName #> mat)
    {
<#
                if (has_simd)
                {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
        {
<#
                    if ((n == m && (n == 3 || n == 4)) || (n == 2 && m == 4) || (n == 4 && m == 2))
                    {
#>
            var r = simd_matrix.Transpose<#= simd_method_suffix #>(<#= string.Join(", ", Enumerable.Range(0, m).Select(j => $"mat.c{j}.vector")) #>);
            return new(<#= string.Join(", ", Enumerable.Range(0, n).Select(j => $"new(r.c{j})")) #>);
<#
                    }
                    else if (n == 3 && m == 4)
                    {
#>
            var r = simd_matrix.Transpose4x4(<#= string.Join(", ", Enumerable.Range(0, m).Select(j => $"mat.c{j}.vector")) #>);
            return new(<#= string.Join(", ", Enumerable.Range(0, n).Select(j => $"new(r.c{j})")) #>);
<#
                    }
                    else if (n == 4 && m == 3)
                    {
#>
            var r = simd_matrix.Transpose4x4(<#= string.Join(", ", Enumerable.Range(0, m).Select(j => $"mat.c{j}.vector")) #>, default);
            return new(<#= string.Join(", ", Enumerable.Range(0, n).Select(j => $"new(r.c{j})")) #>);
<#
                    }
                    else if (n == 2 && m == 3)
                    {
#>
            var r = simd_matrix.Transpose2x4To4x2(<#= string.Join(", ", Enumerable.Range(0, m).Select(j => $"mat.c{j}.vector")) #>, default);
            return new(<#= string.Join(", ", Enumerable.Range(0, n).Select(j => $"new(r.c{j})")) #>);
<#
                    }
                    else if (n == 3 && m == 2)
                    {
#>
            var r = simd_matrix.Transpose4x2To2x4(<#= string.Join(", ", Enumerable.Range(0, m).Select(j => $"mat.c{j}.vector")) #>);
            return new(<#= string.Join(", ", Enumerable.Range(0, n).Select(j => $"new(r.c{j})")) #>);
<#
                    }
                    else
                    {
#>
            throw new NotSupportedException("Source Generator Error");
<#
                    }
#>
        }
<#
                }
#>
        return new(
<#
                for (var i = 0; i < n; i++)
                {
#>
            new(<#= string.Join(", ", Enumerable.Range(0, m).Select(j => $"mat.c{j}.{Typ.xyzw[i]}")) #>)<#= i == n - 1 ? "" : "," #>
<#
                }
#>
        );
    }
}

#endregion // <#= typeName #>
<#
            }
        }
    }
#>
