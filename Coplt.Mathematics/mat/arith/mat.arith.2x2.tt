<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="../../types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics;
<#
    foreach (var typ in Typ.Typs)
    {
        if (!typ.arith) continue;

        var byteSize = typ.size * 2;
        var bitSize = 8 * byteSize;

        var vecTypeName = $"{typ.name}{2}";
        var typeName = $"{typ.name.Replace('v', 'm')}{2}x{2}";
#>

#region <#= typeName #>

public partial struct <#= typeName #>
{
<#
        if (typ.f && typ.bin)
        {
#>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> Rotate(<#= typ.compType #> angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            c, -s,
            s,  c
        );
    }

<#
        }
#>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> Scale(<#= typ.compType #> s) => new(
        s,   default,
        default, s
    );

    [MethodImpl(256 | 512)]
    public static <#= typeName #> Scale(<#= typ.compType #> x, <#= typ.compType #> y) => new(
        x,   default,
        default, y
    );

    [MethodImpl(256 | 512)]
    public static <#= typeName #> Scale(<#= vecTypeName #> v) => new(
        v.x,   default,
        default, v.y
    );
}

[Ex]
public static partial class math
{
<#
        if (typ.f)
        {
#>
    /// <summary>Returns the determinant of a <#= typeName #> matrix</summary>
    /// <param name="m">Matrix to use when computing determinant</param>
    /// <returns>The determinant of the matrix</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> inverse([This] <#= typeName #> m)
    {
        var a = m.c0.x;
        var b = m.c1.x;
        var c = m.c0.y;
        var d = m.c1.y;

        // var det = <#= typ.arithCast #>(a * d - b * c);
        var det = <#= typ.arithCast #>(fsm(a * d, b, c));

        return new <#= typeName #>(d, -b, -c, a) * <#= typ.arithCast #>(<#= typ.one #> / det);
    }

    [MethodImpl(256 | 512)]
    public static <#= typ.compType #> determinant([This] <#= typeName #> m)
    {
        var a = m.c0.x;
        var b = m.c1.x;
        var c = m.c0.y;
        var d = m.c1.y;

        // return <#= typ.arithCast #>(a * d - b * c);
        return <#= typ.arithCast #>(fsm(a * d, b, c));
    }
<#
        }
#>
}

#endregion // <#= typeName #>
<#
    }
#>
