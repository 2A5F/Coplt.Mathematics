// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region float3x3

public partial struct float3x3
{
    /// <summary>
    /// Constructs a float3x3 from the upper left 3x3 of a float4x4
    /// </summary>
    /// <param name="m4x4"><see cref="float4x4"/> to extract a float3x3 from</param>
    [MethodImpl(256 | 512)]
    public float3x3(float4x4 m4x4)
    {
        c0 = m4x4.c0.xyz;
        c1 = m4x4.c1.xyz;
        c2 = m4x4.c2.xyz;
    }

    /// <summary>Constructs a float3x3 matrix from a unit quaternion</summary>
    /// <param name="q">The quaternion rotation</param>
    [MethodImpl(256 | 512)]
    public float3x3(quaternion q)
    {
        var v = q.value;
        var v2 = v + v;

        var npn = new uint3(0x80000000, default, 0x80000000).asf();
        var nnp = new uint3(0x80000000, 0x80000000, default).asf();
        var pnn = new uint3(default, 0x80000000, 0x80000000).asf();

        c0 = v2.yyy.fms(v.yxw ^ npn, v2.zzz * (v.zwx ^ pnn)) + new float3(1.0f, default, default);
        c1 = v2.zzz.fms(v.wzy ^ nnp, v2.xxx * (v.yxw ^ npn)) + new float3(default, 1.0f, default);
        c2 = v2.xxx.fms(v.zwx ^ pnn, v2.yyy * (v.wzy ^ nnp)) + new float3(default, default, 1.0f);
    }

    /// <summary>
    /// Returns a float3x3 view rotation matrix given a unit length forward vector and a unit length up vector.
    /// The two input vectors are assumed to be unit length and not collinear.
    /// If these assumptions are not met use <see cref="float3x3.LookRotationSafe" /> instead.
    /// </summary>
    /// <param name="forward">The forward vector to align the center of view with</param>
    /// <param name="up">The up vector to point top of view toward</param>
    /// <returns>The float3x3 view rotation matrix</returns>
    [MethodImpl(256 | 512)]
    public static float3x3 LookRotation(float3 forward, float3 up)
    {
        var t = up.cross(forward).normalize();
        return new(t, forward.cross(t), forward);
    }

    /// <summary>
    /// Returns a float3x3 view rotation matrix given a forward vector and an up vector.
    /// The two input vectors are not assumed to be unit length.
    /// If the magnitude of either of the vectors is so extreme that the calculation cannot be carried out reliably or the vectors are collinear,
    /// the identity will be returned instead.
    /// </summary>
    /// <param name="forward">The forward vector to align the center of view with</param>
    /// <param name="up">The up vector to point top of view toward</param>
    /// <returns>The float3x3 view rotation matrix or the identity matrix.</returns>
    [MethodImpl(256 | 512)]
    public static float3x3 LookRotationSafe(float3 forward, float3 up)
    {
        var forwardLengthSq = forward.dot(forward);
        var upLengthSq = up.dot(up);

        forward *= forwardLengthSq.rsqrt();
        up *= upLengthSq.rsqrt();

        var t = up.cross(forward);
        var tLengthSq = t.dot(t);
        t *= tLengthSq.rsqrt();

        var mn = forwardLengthSq.min(upLengthSq).min(tLengthSq);
        var mx = forwardLengthSq.max(upLengthSq).max(tLengthSq);

        var accept = mn > math.MinRotateSafe<float>() && mx < math.MaxRotateSafe<float>()
            && forwardLengthSq.isFinite() && upLengthSq.isFinite() && tLengthSq.isFinite();
        if (!accept) return Identity;
        return new(t, forward.cross(t), forward);
    }
    
    /// <summary>
    /// Returns a float3x3 matrix representing a rotation around a unit axis by an angle in radians.
    /// The rotation direction is clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="axis">The rotation axis</param>
    /// <param name="angle">The angle of rotation in radians</param>
    /// <returns>The float3x3 matrix representing the rotation around an axis.</returns>
    [MethodImpl(256 | 512)]
    public static float3x3 AxisAngle(float3 axis, float angle)
    {
        angle.sincos(out var sina, out var cosa);
        var u = axis;
        var u_inv_cosa = u - u * cosa; // u * (1 - cosa);
        var t = new float4(u * sina, cosa);

        var ppn = new uint3(default, default, 0x80000000).asfloat();
        var npp = new uint3(0x80000000, default, default).asfloat();
        var pnp = new uint3(default, 0x80000000, default).asfloat();

        return new(
            u.xxx.fma(u_inv_cosa, t.wzy ^ ppn),
            u.yyy.fma(u_inv_cosa, t.zwx ^ npp),
            u.zzz.fma(u_inv_cosa, t.yxw ^ pnp)
        );
    }

    /// <summary>
    /// Returns a float3x3 rotation matrix constructed by first performing a rotation around the x-axis, then the y-axis and finally the z-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The float3x3 rotation matrix of the Euler angle rotation in x-y-z order</returns>
    [MethodImpl(256 | 512)]
    public static float3x3 EulerXYZ(float3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (c.y * c.z),  (c.z * s.x * s.y - c.x * s.z),    (c.x * c.z * s.y + s.x * s.z),
            (c.y * s.z),  (c.x * c.z + s.x * s.y * s.z),    (c.x * s.y * s.z - c.z * s.x),
            (-s.y),       (c.y * s.x),                      (c.x * c.y)
        );
    }

    /// <summary>
    /// Returns a float3x3 rotation matrix constructed by first performing a rotation around the x-axis, then the z-axis and finally the y-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The float3x3 rotation matrix of the Euler angle rotation in x-z-y order</returns>
    [MethodImpl(256 | 512)]
    public static float3x3 EulerXZY(float3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (c.y * c.z),  (s.x * s.y - c.x * c.y * s.z),    (c.x * s.y + c.y * s.x * s.z),
            (s.z),        (c.x * c.z),                      (-c.z * s.x),                 
            (-c.z * s.y), (c.y * s.x + c.x * s.y * s.z),    (c.x * c.y - s.x * s.y * s.z)
        );
    }

    /// <summary>
    /// Returns a float3x3 rotation matrix constructed by first performing a rotation around the y-axis, then the x-axis and finally the z-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The float3x3 rotation matrix of the Euler angle rotation in y-x-z order</returns>
    [MethodImpl(256 | 512)]
    public static float3x3 EulerYXZ(float3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (c.y * c.z - s.x * s.y * s.z),    (-c.x * s.z), (c.z * s.y + c.y * s.x * s.z),
            (c.z * s.x * s.y + c.y * s.z),    (c.x * c.z),  (s.y * s.z - c.y * c.z * s.x),
            (-c.x * s.y),                     (s.x),        (c.x * c.y)
        );
    }

    /// <summary>
    /// Returns a float3x3 rotation matrix constructed by first performing a rotation around the y-axis, then the z-axis and finally the x-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The float3x3 rotation matrix of the Euler angle rotation in y-z-x order</returns>
    [MethodImpl(256 | 512)]
    public static float3x3 EulerYZX(float3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (c.y * c.z),                      (-s.z),       (c.z * s.y),                  
            (s.x * s.y + c.x * c.y * s.z),    (c.x * c.z),  (c.x * s.y * s.z - c.y * s.x),
            (c.y * s.x * s.z - c.x * s.y),    (c.z * s.x),  (c.x * c.y + s.x * s.y * s.z)
        );
    }

    /// <summary>
    /// Returns a float3x3 rotation matrix constructed by first performing a rotation around the z-axis, then the x-axis and finally the y-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The float3x3 rotation matrix of the Euler angle rotation in z-x-y order</returns>
    [MethodImpl(256 | 512)]
    public static float3x3 EulerZXY(float3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (c.y * c.z + s.x * s.y * s.z),    (c.z * s.x * s.y - c.y * s.z),    (c.x * s.y),
            (c.x * s.z),                      (c.x * c.z),                      (-s.x),     
            (c.y * s.x * s.z - c.z * s.y),    (c.y * c.z * s.x + s.y * s.z),    (c.x * c.y)
        );
    }

    /// <summary>
    /// Returns a float3x3 rotation matrix constructed by first performing a rotation around the z-axis, then the y-axis and finally the x-axis
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The float3x3 rotation matrix of the Euler angle rotation in z-y-x order</returns>
    [MethodImpl(256 | 512)]
    public static float3x3 EulerZYX(float3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (c.y * c.z),                      (-c.y * s.z),                     (s.y),       
            (c.z * s.x * s.y + c.x * s.z),    (c.x * c.z - s.x * s.y * s.z),    (-c.y * s.x),
            (s.x * s.z - c.x * c.z * s.y),    (c.z * s.x + c.x * s.y * s.z),    (c.x * c.y)
        );
    }

    /// <summary>Returns a float3x3 matrix that rotates around the x-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the x-axis towards the origin in radians</param>
    /// <returns>The float3x3 rotation matrix that rotates around the x-axis</returns>
    [MethodImpl(256 | 512)]
    public static float3x3 RotateX(float angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            1.0f, default, default,
            default, c,     -s,
            default, s,     c
        );
    }

    /// <summary>Returns a float3x3 matrix that rotates around the y-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the y-axis towards the origin in radians</param>
    /// <returns>The float3x3 rotation matrix that rotates around the y-axis</returns>
    [MethodImpl(256 | 512)]
    public static float3x3 RotateY(float angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            c,     default, s,
            default, 1.0f, default,
            -s,    default, c
        );
    }

    /// <summary>Returns a float3x3 matrix that rotates around the z-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the z-axis towards the origin in radians</param>
    /// <returns>The float3x3 rotation matrix that rotates around the z-axis</returns>
    [MethodImpl(256 | 512)]
    public static float3x3 RotateZ(float angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            c,     -s,    default,
            s,     c,     default,
            default, default, 1.0f
        );
    }
    
    /// <summary>Returns a float3x3 matrix representing a uniform scaling of all axes by s</summary>
    /// <param name="s">The uniform scaling factor</param>
    /// <returns>The float3x3 matrix representing a uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static float3x3 Scale(float s) => new(
        s,    default, default,
        default, s,    default,
        default, default, s
    );
    
    /// <summary>Returns a float3x3 matrix representing a non-uniform axis scaling by x, y and z</summary>
    /// <param name="x">The x-axis scaling factor</param>
    /// <param name="y">The y-axis scaling factor</param>
    /// <param name="z">The z-axis scaling factor</param>
    /// <returns>The float3x3 rotation matrix representing a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static float3x3 Scale(float x, float y, float z) => new(
        x,    default, default,
        default, y,    default,
        default, default, z
    );

    /// <summary>Returns a float3x3 matrix representing a non-uniform axis scaling by the components of the float3 vector v</summary>
    /// <param name="v">The vector containing non-uniform scaling factors</param>
    /// <returns>The float3x3 rotation matrix representing a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static float3x3 Scale(float3 v) => new(
        v.x,    default, default,
        default, v.y,    default,
        default, default, v.z
    );

    /// <summary>
    /// Converts a float4x4 to a float3x3
    /// </summary>
    /// <param name="m4x4">The float4x4 to convert to a float3x3</param>
    /// <returns>The float3x3 constructed from the upper left 3x3 of the input float4x4 matrix</returns>
    [MethodImpl(256 | 512)]
    public static explicit operator float3x3(float4x4 m4x4) => new(m4x4);
}

public static partial class math
{

    /// <summary>Returns the float3x3 full inverse of a float3x3 matrix</summary>
    /// <param name="m">Matrix to invert</param>
    /// <returns>The inverted matrix</returns>
    [MethodImpl(256 | 512)]
    public static float3x3 inverse(this float3x3 m)
    {
        var (c0, c1, c2) = m;
        // var t0 = new float3(c1.x, c2.x, c0.x);
        // var t1 = new float3(c1.y, c2.y, c0.y);
        // var t2 = new float3(c1.z, c2.z, c0.z);
        var (t0, t1, t2) = transpose(new float3x3(c1, c2, c0));
    
        var m0 = t1 * t2.yzx - t1.yzx * t2;
        var m1 = t0.yzx * t2 - t0 * t2.yzx;
        var m2 = t0 * t1.yzx - t0.yzx * t1;
    
        var rcpDet = (1.0f / csum(t0.zxy * m0));
        return new float3x3(m0, m1, m2) * rcpDet;
    }

    // <summary>Returns the determinant of a float3x3 matrix</summary>
    /// <param name="m">Matrix to use when computing determinant</param>
    /// <returns>The determinant of the matrix</returns>
    [MethodImpl(256 | 512)]
    public static float determinant(this float3x3 m)
    {
        var (c0, c1, c2) = m;

        var m00 = c1.y * c2.z - c1.z * c2.y;
        var m01 = c0.y * c2.z - c0.z * c2.y;
        var m02 = c0.y * c1.z - c0.z * c1.y;

        var r = c0.x * m00 - c1.x * m01 + c2.x * m02;

        return r;
    }
}

#endregion // float3x3

#region double3x3

public partial struct double3x3
{
    /// <summary>
    /// Constructs a double3x3 from the upper left 3x3 of a double4x4
    /// </summary>
    /// <param name="m4x4"><see cref="double4x4"/> to extract a double3x3 from</param>
    [MethodImpl(256 | 512)]
    public double3x3(double4x4 m4x4)
    {
        c0 = m4x4.c0.xyz;
        c1 = m4x4.c1.xyz;
        c2 = m4x4.c2.xyz;
    }

    /// <summary>Constructs a double3x3 matrix from a unit quaternion</summary>
    /// <param name="q">The quaternion rotation</param>
    [MethodImpl(256 | 512)]
    public double3x3(quaternion_d q)
    {
        var v = q.value;
        var v2 = v + v;

        var npn = new ulong3(0x8000000000000000, default, 0x8000000000000000).asf();
        var nnp = new ulong3(0x8000000000000000, 0x8000000000000000, default).asf();
        var pnn = new ulong3(default, 0x8000000000000000, 0x8000000000000000).asf();

        c0 = v2.yyy.fms(v.yxw ^ npn, v2.zzz * (v.zwx ^ pnn)) + new double3(1.0, default, default);
        c1 = v2.zzz.fms(v.wzy ^ nnp, v2.xxx * (v.yxw ^ npn)) + new double3(default, 1.0, default);
        c2 = v2.xxx.fms(v.zwx ^ pnn, v2.yyy * (v.wzy ^ nnp)) + new double3(default, default, 1.0);
    }

    /// <summary>
    /// Returns a double3x3 view rotation matrix given a unit length forward vector and a unit length up vector.
    /// The two input vectors are assumed to be unit length and not collinear.
    /// If these assumptions are not met use <see cref="double3x3.LookRotationSafe" /> instead.
    /// </summary>
    /// <param name="forward">The forward vector to align the center of view with</param>
    /// <param name="up">The up vector to point top of view toward</param>
    /// <returns>The double3x3 view rotation matrix</returns>
    [MethodImpl(256 | 512)]
    public static double3x3 LookRotation(double3 forward, double3 up)
    {
        var t = up.cross(forward).normalize();
        return new(t, forward.cross(t), forward);
    }

    /// <summary>
    /// Returns a double3x3 view rotation matrix given a forward vector and an up vector.
    /// The two input vectors are not assumed to be unit length.
    /// If the magnitude of either of the vectors is so extreme that the calculation cannot be carried out reliably or the vectors are collinear,
    /// the identity will be returned instead.
    /// </summary>
    /// <param name="forward">The forward vector to align the center of view with</param>
    /// <param name="up">The up vector to point top of view toward</param>
    /// <returns>The double3x3 view rotation matrix or the identity matrix.</returns>
    [MethodImpl(256 | 512)]
    public static double3x3 LookRotationSafe(double3 forward, double3 up)
    {
        var forwardLengthSq = forward.dot(forward);
        var upLengthSq = up.dot(up);

        forward *= forwardLengthSq.rsqrt();
        up *= upLengthSq.rsqrt();

        var t = up.cross(forward);
        var tLengthSq = t.dot(t);
        t *= tLengthSq.rsqrt();

        var mn = forwardLengthSq.min(upLengthSq).min(tLengthSq);
        var mx = forwardLengthSq.max(upLengthSq).max(tLengthSq);

        var accept = mn > math.MinRotateSafe<double>() && mx < math.MaxRotateSafe<double>()
            && forwardLengthSq.isFinite() && upLengthSq.isFinite() && tLengthSq.isFinite();
        if (!accept) return Identity;
        return new(t, forward.cross(t), forward);
    }
    
    /// <summary>
    /// Returns a double3x3 matrix representing a rotation around a unit axis by an angle in radians.
    /// The rotation direction is clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="axis">The rotation axis</param>
    /// <param name="angle">The angle of rotation in radians</param>
    /// <returns>The double3x3 matrix representing the rotation around an axis.</returns>
    [MethodImpl(256 | 512)]
    public static double3x3 AxisAngle(double3 axis, double angle)
    {
        angle.sincos(out var sina, out var cosa);
        var u = axis;
        var u_inv_cosa = u - u * cosa; // u * (1 - cosa);
        var t = new double4(u * sina, cosa);

        var ppn = new ulong3(default, default, 0x8000000000000000).asdouble();
        var npp = new ulong3(0x8000000000000000, default, default).asdouble();
        var pnp = new ulong3(default, 0x8000000000000000, default).asdouble();

        return new(
            u.xxx.fma(u_inv_cosa, t.wzy ^ ppn),
            u.yyy.fma(u_inv_cosa, t.zwx ^ npp),
            u.zzz.fma(u_inv_cosa, t.yxw ^ pnp)
        );
    }

    /// <summary>
    /// Returns a double3x3 rotation matrix constructed by first performing a rotation around the x-axis, then the y-axis and finally the z-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A double3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The double3x3 rotation matrix of the Euler angle rotation in x-y-z order</returns>
    [MethodImpl(256 | 512)]
    public static double3x3 EulerXYZ(double3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (c.y * c.z),  (c.z * s.x * s.y - c.x * s.z),    (c.x * c.z * s.y + s.x * s.z),
            (c.y * s.z),  (c.x * c.z + s.x * s.y * s.z),    (c.x * s.y * s.z - c.z * s.x),
            (-s.y),       (c.y * s.x),                      (c.x * c.y)
        );
    }

    /// <summary>
    /// Returns a double3x3 rotation matrix constructed by first performing a rotation around the x-axis, then the z-axis and finally the y-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A double3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The double3x3 rotation matrix of the Euler angle rotation in x-z-y order</returns>
    [MethodImpl(256 | 512)]
    public static double3x3 EulerXZY(double3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (c.y * c.z),  (s.x * s.y - c.x * c.y * s.z),    (c.x * s.y + c.y * s.x * s.z),
            (s.z),        (c.x * c.z),                      (-c.z * s.x),                 
            (-c.z * s.y), (c.y * s.x + c.x * s.y * s.z),    (c.x * c.y - s.x * s.y * s.z)
        );
    }

    /// <summary>
    /// Returns a double3x3 rotation matrix constructed by first performing a rotation around the y-axis, then the x-axis and finally the z-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A double3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The double3x3 rotation matrix of the Euler angle rotation in y-x-z order</returns>
    [MethodImpl(256 | 512)]
    public static double3x3 EulerYXZ(double3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (c.y * c.z - s.x * s.y * s.z),    (-c.x * s.z), (c.z * s.y + c.y * s.x * s.z),
            (c.z * s.x * s.y + c.y * s.z),    (c.x * c.z),  (s.y * s.z - c.y * c.z * s.x),
            (-c.x * s.y),                     (s.x),        (c.x * c.y)
        );
    }

    /// <summary>
    /// Returns a double3x3 rotation matrix constructed by first performing a rotation around the y-axis, then the z-axis and finally the x-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A double3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The double3x3 rotation matrix of the Euler angle rotation in y-z-x order</returns>
    [MethodImpl(256 | 512)]
    public static double3x3 EulerYZX(double3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (c.y * c.z),                      (-s.z),       (c.z * s.y),                  
            (s.x * s.y + c.x * c.y * s.z),    (c.x * c.z),  (c.x * s.y * s.z - c.y * s.x),
            (c.y * s.x * s.z - c.x * s.y),    (c.z * s.x),  (c.x * c.y + s.x * s.y * s.z)
        );
    }

    /// <summary>
    /// Returns a double3x3 rotation matrix constructed by first performing a rotation around the z-axis, then the x-axis and finally the y-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A double3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The double3x3 rotation matrix of the Euler angle rotation in z-x-y order</returns>
    [MethodImpl(256 | 512)]
    public static double3x3 EulerZXY(double3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (c.y * c.z + s.x * s.y * s.z),    (c.z * s.x * s.y - c.y * s.z),    (c.x * s.y),
            (c.x * s.z),                      (c.x * c.z),                      (-s.x),     
            (c.y * s.x * s.z - c.z * s.y),    (c.y * c.z * s.x + s.y * s.z),    (c.x * c.y)
        );
    }

    /// <summary>
    /// Returns a double3x3 rotation matrix constructed by first performing a rotation around the z-axis, then the y-axis and finally the x-axis
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="xyz">A double3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The double3x3 rotation matrix of the Euler angle rotation in z-y-x order</returns>
    [MethodImpl(256 | 512)]
    public static double3x3 EulerZYX(double3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (c.y * c.z),                      (-c.y * s.z),                     (s.y),       
            (c.z * s.x * s.y + c.x * s.z),    (c.x * c.z - s.x * s.y * s.z),    (-c.y * s.x),
            (s.x * s.z - c.x * c.z * s.y),    (c.z * s.x + c.x * s.y * s.z),    (c.x * c.y)
        );
    }

    /// <summary>Returns a double3x3 matrix that rotates around the x-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the x-axis towards the origin in radians</param>
    /// <returns>The double3x3 rotation matrix that rotates around the x-axis</returns>
    [MethodImpl(256 | 512)]
    public static double3x3 RotateX(double angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            1.0, default, default,
            default, c,     -s,
            default, s,     c
        );
    }

    /// <summary>Returns a double3x3 matrix that rotates around the y-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the y-axis towards the origin in radians</param>
    /// <returns>The double3x3 rotation matrix that rotates around the y-axis</returns>
    [MethodImpl(256 | 512)]
    public static double3x3 RotateY(double angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            c,     default, s,
            default, 1.0, default,
            -s,    default, c
        );
    }

    /// <summary>Returns a double3x3 matrix that rotates around the z-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the z-axis towards the origin in radians</param>
    /// <returns>The double3x3 rotation matrix that rotates around the z-axis</returns>
    [MethodImpl(256 | 512)]
    public static double3x3 RotateZ(double angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            c,     -s,    default,
            s,     c,     default,
            default, default, 1.0
        );
    }
    
    /// <summary>Returns a double3x3 matrix representing a uniform scaling of all axes by s</summary>
    /// <param name="s">The uniform scaling factor</param>
    /// <returns>The double3x3 matrix representing a uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static double3x3 Scale(double s) => new(
        s,    default, default,
        default, s,    default,
        default, default, s
    );
    
    /// <summary>Returns a double3x3 matrix representing a non-uniform axis scaling by x, y and z</summary>
    /// <param name="x">The x-axis scaling factor</param>
    /// <param name="y">The y-axis scaling factor</param>
    /// <param name="z">The z-axis scaling factor</param>
    /// <returns>The double3x3 rotation matrix representing a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static double3x3 Scale(double x, double y, double z) => new(
        x,    default, default,
        default, y,    default,
        default, default, z
    );

    /// <summary>Returns a double3x3 matrix representing a non-uniform axis scaling by the components of the double3 vector v</summary>
    /// <param name="v">The vector containing non-uniform scaling factors</param>
    /// <returns>The double3x3 rotation matrix representing a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static double3x3 Scale(double3 v) => new(
        v.x,    default, default,
        default, v.y,    default,
        default, default, v.z
    );

    /// <summary>
    /// Converts a double4x4 to a double3x3
    /// </summary>
    /// <param name="m4x4">The double4x4 to convert to a double3x3</param>
    /// <returns>The double3x3 constructed from the upper left 3x3 of the input double4x4 matrix</returns>
    [MethodImpl(256 | 512)]
    public static explicit operator double3x3(double4x4 m4x4) => new(m4x4);
}

public static partial class math
{

    /// <summary>Returns the double3x3 full inverse of a double3x3 matrix</summary>
    /// <param name="m">Matrix to invert</param>
    /// <returns>The inverted matrix</returns>
    [MethodImpl(256 | 512)]
    public static double3x3 inverse(this double3x3 m)
    {
        var (c0, c1, c2) = m;
        // var t0 = new double3(c1.x, c2.x, c0.x);
        // var t1 = new double3(c1.y, c2.y, c0.y);
        // var t2 = new double3(c1.z, c2.z, c0.z);
        var (t0, t1, t2) = transpose(new double3x3(c1, c2, c0));
    
        var m0 = t1 * t2.yzx - t1.yzx * t2;
        var m1 = t0.yzx * t2 - t0 * t2.yzx;
        var m2 = t0 * t1.yzx - t0.yzx * t1;
    
        var rcpDet = (1.0 / csum(t0.zxy * m0));
        return new double3x3(m0, m1, m2) * rcpDet;
    }

    // <summary>Returns the determinant of a double3x3 matrix</summary>
    /// <param name="m">Matrix to use when computing determinant</param>
    /// <returns>The determinant of the matrix</returns>
    [MethodImpl(256 | 512)]
    public static double determinant(this double3x3 m)
    {
        var (c0, c1, c2) = m;

        var m00 = c1.y * c2.z - c1.z * c2.y;
        var m01 = c0.y * c2.z - c0.z * c2.y;
        var m02 = c0.y * c1.z - c0.z * c1.y;

        var r = c0.x * m00 - c1.x * m01 + c2.x * m02;

        return r;
    }
}

#endregion // double3x3

#region short3x3

public partial struct short3x3
{
    /// <summary>
    /// Constructs a short3x3 from the upper left 3x3 of a short4x4
    /// </summary>
    /// <param name="m4x4"><see cref="short4x4"/> to extract a short3x3 from</param>
    [MethodImpl(256 | 512)]
    public short3x3(short4x4 m4x4)
    {
        c0 = m4x4.c0.xyz;
        c1 = m4x4.c1.xyz;
        c2 = m4x4.c2.xyz;
    }
    
    /// <summary>Returns a short3x3 matrix representing a uniform scaling of all axes by s</summary>
    /// <param name="s">The uniform scaling factor</param>
    /// <returns>The short3x3 matrix representing a uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static short3x3 Scale(short s) => new(
        s,    default, default,
        default, s,    default,
        default, default, s
    );
    
    /// <summary>Returns a short3x3 matrix representing a non-uniform axis scaling by x, y and z</summary>
    /// <param name="x">The x-axis scaling factor</param>
    /// <param name="y">The y-axis scaling factor</param>
    /// <param name="z">The z-axis scaling factor</param>
    /// <returns>The short3x3 rotation matrix representing a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static short3x3 Scale(short x, short y, short z) => new(
        x,    default, default,
        default, y,    default,
        default, default, z
    );

    /// <summary>Returns a short3x3 matrix representing a non-uniform axis scaling by the components of the short3 vector v</summary>
    /// <param name="v">The vector containing non-uniform scaling factors</param>
    /// <returns>The short3x3 rotation matrix representing a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static short3x3 Scale(short3 v) => new(
        v.x,    default, default,
        default, v.y,    default,
        default, default, v.z
    );

    /// <summary>
    /// Converts a short4x4 to a short3x3
    /// </summary>
    /// <param name="m4x4">The short4x4 to convert to a short3x3</param>
    /// <returns>The short3x3 constructed from the upper left 3x3 of the input short4x4 matrix</returns>
    [MethodImpl(256 | 512)]
    public static explicit operator short3x3(short4x4 m4x4) => new(m4x4);
}

public static partial class math
{
}

#endregion // short3x3

#region ushort3x3

public partial struct ushort3x3
{
    /// <summary>
    /// Constructs a ushort3x3 from the upper left 3x3 of a ushort4x4
    /// </summary>
    /// <param name="m4x4"><see cref="ushort4x4"/> to extract a ushort3x3 from</param>
    [MethodImpl(256 | 512)]
    public ushort3x3(ushort4x4 m4x4)
    {
        c0 = m4x4.c0.xyz;
        c1 = m4x4.c1.xyz;
        c2 = m4x4.c2.xyz;
    }
    
    /// <summary>Returns a ushort3x3 matrix representing a uniform scaling of all axes by s</summary>
    /// <param name="s">The uniform scaling factor</param>
    /// <returns>The ushort3x3 matrix representing a uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static ushort3x3 Scale(ushort s) => new(
        s,    default, default,
        default, s,    default,
        default, default, s
    );
    
    /// <summary>Returns a ushort3x3 matrix representing a non-uniform axis scaling by x, y and z</summary>
    /// <param name="x">The x-axis scaling factor</param>
    /// <param name="y">The y-axis scaling factor</param>
    /// <param name="z">The z-axis scaling factor</param>
    /// <returns>The ushort3x3 rotation matrix representing a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static ushort3x3 Scale(ushort x, ushort y, ushort z) => new(
        x,    default, default,
        default, y,    default,
        default, default, z
    );

    /// <summary>Returns a ushort3x3 matrix representing a non-uniform axis scaling by the components of the ushort3 vector v</summary>
    /// <param name="v">The vector containing non-uniform scaling factors</param>
    /// <returns>The ushort3x3 rotation matrix representing a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static ushort3x3 Scale(ushort3 v) => new(
        v.x,    default, default,
        default, v.y,    default,
        default, default, v.z
    );

    /// <summary>
    /// Converts a ushort4x4 to a ushort3x3
    /// </summary>
    /// <param name="m4x4">The ushort4x4 to convert to a ushort3x3</param>
    /// <returns>The ushort3x3 constructed from the upper left 3x3 of the input ushort4x4 matrix</returns>
    [MethodImpl(256 | 512)]
    public static explicit operator ushort3x3(ushort4x4 m4x4) => new(m4x4);
}

public static partial class math
{
}

#endregion // ushort3x3

#region int3x3

public partial struct int3x3
{
    /// <summary>
    /// Constructs a int3x3 from the upper left 3x3 of a int4x4
    /// </summary>
    /// <param name="m4x4"><see cref="int4x4"/> to extract a int3x3 from</param>
    [MethodImpl(256 | 512)]
    public int3x3(int4x4 m4x4)
    {
        c0 = m4x4.c0.xyz;
        c1 = m4x4.c1.xyz;
        c2 = m4x4.c2.xyz;
    }
    
    /// <summary>Returns a int3x3 matrix representing a uniform scaling of all axes by s</summary>
    /// <param name="s">The uniform scaling factor</param>
    /// <returns>The int3x3 matrix representing a uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static int3x3 Scale(int s) => new(
        s,    default, default,
        default, s,    default,
        default, default, s
    );
    
    /// <summary>Returns a int3x3 matrix representing a non-uniform axis scaling by x, y and z</summary>
    /// <param name="x">The x-axis scaling factor</param>
    /// <param name="y">The y-axis scaling factor</param>
    /// <param name="z">The z-axis scaling factor</param>
    /// <returns>The int3x3 rotation matrix representing a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static int3x3 Scale(int x, int y, int z) => new(
        x,    default, default,
        default, y,    default,
        default, default, z
    );

    /// <summary>Returns a int3x3 matrix representing a non-uniform axis scaling by the components of the int3 vector v</summary>
    /// <param name="v">The vector containing non-uniform scaling factors</param>
    /// <returns>The int3x3 rotation matrix representing a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static int3x3 Scale(int3 v) => new(
        v.x,    default, default,
        default, v.y,    default,
        default, default, v.z
    );

    /// <summary>
    /// Converts a int4x4 to a int3x3
    /// </summary>
    /// <param name="m4x4">The int4x4 to convert to a int3x3</param>
    /// <returns>The int3x3 constructed from the upper left 3x3 of the input int4x4 matrix</returns>
    [MethodImpl(256 | 512)]
    public static explicit operator int3x3(int4x4 m4x4) => new(m4x4);
}

public static partial class math
{
}

#endregion // int3x3

#region uint3x3

public partial struct uint3x3
{
    /// <summary>
    /// Constructs a uint3x3 from the upper left 3x3 of a uint4x4
    /// </summary>
    /// <param name="m4x4"><see cref="uint4x4"/> to extract a uint3x3 from</param>
    [MethodImpl(256 | 512)]
    public uint3x3(uint4x4 m4x4)
    {
        c0 = m4x4.c0.xyz;
        c1 = m4x4.c1.xyz;
        c2 = m4x4.c2.xyz;
    }
    
    /// <summary>Returns a uint3x3 matrix representing a uniform scaling of all axes by s</summary>
    /// <param name="s">The uniform scaling factor</param>
    /// <returns>The uint3x3 matrix representing a uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static uint3x3 Scale(uint s) => new(
        s,    default, default,
        default, s,    default,
        default, default, s
    );
    
    /// <summary>Returns a uint3x3 matrix representing a non-uniform axis scaling by x, y and z</summary>
    /// <param name="x">The x-axis scaling factor</param>
    /// <param name="y">The y-axis scaling factor</param>
    /// <param name="z">The z-axis scaling factor</param>
    /// <returns>The uint3x3 rotation matrix representing a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static uint3x3 Scale(uint x, uint y, uint z) => new(
        x,    default, default,
        default, y,    default,
        default, default, z
    );

    /// <summary>Returns a uint3x3 matrix representing a non-uniform axis scaling by the components of the uint3 vector v</summary>
    /// <param name="v">The vector containing non-uniform scaling factors</param>
    /// <returns>The uint3x3 rotation matrix representing a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static uint3x3 Scale(uint3 v) => new(
        v.x,    default, default,
        default, v.y,    default,
        default, default, v.z
    );

    /// <summary>
    /// Converts a uint4x4 to a uint3x3
    /// </summary>
    /// <param name="m4x4">The uint4x4 to convert to a uint3x3</param>
    /// <returns>The uint3x3 constructed from the upper left 3x3 of the input uint4x4 matrix</returns>
    [MethodImpl(256 | 512)]
    public static explicit operator uint3x3(uint4x4 m4x4) => new(m4x4);
}

public static partial class math
{
}

#endregion // uint3x3

#region long3x3

public partial struct long3x3
{
    /// <summary>
    /// Constructs a long3x3 from the upper left 3x3 of a long4x4
    /// </summary>
    /// <param name="m4x4"><see cref="long4x4"/> to extract a long3x3 from</param>
    [MethodImpl(256 | 512)]
    public long3x3(long4x4 m4x4)
    {
        c0 = m4x4.c0.xyz;
        c1 = m4x4.c1.xyz;
        c2 = m4x4.c2.xyz;
    }
    
    /// <summary>Returns a long3x3 matrix representing a uniform scaling of all axes by s</summary>
    /// <param name="s">The uniform scaling factor</param>
    /// <returns>The long3x3 matrix representing a uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static long3x3 Scale(long s) => new(
        s,    default, default,
        default, s,    default,
        default, default, s
    );
    
    /// <summary>Returns a long3x3 matrix representing a non-uniform axis scaling by x, y and z</summary>
    /// <param name="x">The x-axis scaling factor</param>
    /// <param name="y">The y-axis scaling factor</param>
    /// <param name="z">The z-axis scaling factor</param>
    /// <returns>The long3x3 rotation matrix representing a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static long3x3 Scale(long x, long y, long z) => new(
        x,    default, default,
        default, y,    default,
        default, default, z
    );

    /// <summary>Returns a long3x3 matrix representing a non-uniform axis scaling by the components of the long3 vector v</summary>
    /// <param name="v">The vector containing non-uniform scaling factors</param>
    /// <returns>The long3x3 rotation matrix representing a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static long3x3 Scale(long3 v) => new(
        v.x,    default, default,
        default, v.y,    default,
        default, default, v.z
    );

    /// <summary>
    /// Converts a long4x4 to a long3x3
    /// </summary>
    /// <param name="m4x4">The long4x4 to convert to a long3x3</param>
    /// <returns>The long3x3 constructed from the upper left 3x3 of the input long4x4 matrix</returns>
    [MethodImpl(256 | 512)]
    public static explicit operator long3x3(long4x4 m4x4) => new(m4x4);
}

public static partial class math
{
}

#endregion // long3x3

#region ulong3x3

public partial struct ulong3x3
{
    /// <summary>
    /// Constructs a ulong3x3 from the upper left 3x3 of a ulong4x4
    /// </summary>
    /// <param name="m4x4"><see cref="ulong4x4"/> to extract a ulong3x3 from</param>
    [MethodImpl(256 | 512)]
    public ulong3x3(ulong4x4 m4x4)
    {
        c0 = m4x4.c0.xyz;
        c1 = m4x4.c1.xyz;
        c2 = m4x4.c2.xyz;
    }
    
    /// <summary>Returns a ulong3x3 matrix representing a uniform scaling of all axes by s</summary>
    /// <param name="s">The uniform scaling factor</param>
    /// <returns>The ulong3x3 matrix representing a uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static ulong3x3 Scale(ulong s) => new(
        s,    default, default,
        default, s,    default,
        default, default, s
    );
    
    /// <summary>Returns a ulong3x3 matrix representing a non-uniform axis scaling by x, y and z</summary>
    /// <param name="x">The x-axis scaling factor</param>
    /// <param name="y">The y-axis scaling factor</param>
    /// <param name="z">The z-axis scaling factor</param>
    /// <returns>The ulong3x3 rotation matrix representing a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static ulong3x3 Scale(ulong x, ulong y, ulong z) => new(
        x,    default, default,
        default, y,    default,
        default, default, z
    );

    /// <summary>Returns a ulong3x3 matrix representing a non-uniform axis scaling by the components of the ulong3 vector v</summary>
    /// <param name="v">The vector containing non-uniform scaling factors</param>
    /// <returns>The ulong3x3 rotation matrix representing a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static ulong3x3 Scale(ulong3 v) => new(
        v.x,    default, default,
        default, v.y,    default,
        default, default, v.z
    );

    /// <summary>
    /// Converts a ulong4x4 to a ulong3x3
    /// </summary>
    /// <param name="m4x4">The ulong4x4 to convert to a ulong3x3</param>
    /// <returns>The ulong3x3 constructed from the upper left 3x3 of the input ulong4x4 matrix</returns>
    [MethodImpl(256 | 512)]
    public static explicit operator ulong3x3(ulong4x4 m4x4) => new(m4x4);
}

public static partial class math
{
}

#endregion // ulong3x3

#region decimal3x3

public partial struct decimal3x3
{
    /// <summary>
    /// Constructs a decimal3x3 from the upper left 3x3 of a decimal4x4
    /// </summary>
    /// <param name="m4x4"><see cref="decimal4x4"/> to extract a decimal3x3 from</param>
    [MethodImpl(256 | 512)]
    public decimal3x3(decimal4x4 m4x4)
    {
        c0 = m4x4.c0.xyz;
        c1 = m4x4.c1.xyz;
        c2 = m4x4.c2.xyz;
    }
    
    /// <summary>Returns a decimal3x3 matrix representing a uniform scaling of all axes by s</summary>
    /// <param name="s">The uniform scaling factor</param>
    /// <returns>The decimal3x3 matrix representing a uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static decimal3x3 Scale(decimal s) => new(
        s,    default, default,
        default, s,    default,
        default, default, s
    );
    
    /// <summary>Returns a decimal3x3 matrix representing a non-uniform axis scaling by x, y and z</summary>
    /// <param name="x">The x-axis scaling factor</param>
    /// <param name="y">The y-axis scaling factor</param>
    /// <param name="z">The z-axis scaling factor</param>
    /// <returns>The decimal3x3 rotation matrix representing a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static decimal3x3 Scale(decimal x, decimal y, decimal z) => new(
        x,    default, default,
        default, y,    default,
        default, default, z
    );

    /// <summary>Returns a decimal3x3 matrix representing a non-uniform axis scaling by the components of the decimal3 vector v</summary>
    /// <param name="v">The vector containing non-uniform scaling factors</param>
    /// <returns>The decimal3x3 rotation matrix representing a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static decimal3x3 Scale(decimal3 v) => new(
        v.x,    default, default,
        default, v.y,    default,
        default, default, v.z
    );

    /// <summary>
    /// Converts a decimal4x4 to a decimal3x3
    /// </summary>
    /// <param name="m4x4">The decimal4x4 to convert to a decimal3x3</param>
    /// <returns>The decimal3x3 constructed from the upper left 3x3 of the input decimal4x4 matrix</returns>
    [MethodImpl(256 | 512)]
    public static explicit operator decimal3x3(decimal4x4 m4x4) => new(m4x4);
}

public static partial class math
{

    /// <summary>Returns the decimal3x3 full inverse of a decimal3x3 matrix</summary>
    /// <param name="m">Matrix to invert</param>
    /// <returns>The inverted matrix</returns>
    [MethodImpl(256 | 512)]
    public static decimal3x3 inverse(this decimal3x3 m)
    {
        var (c0, c1, c2) = m;
        // var t0 = new decimal3(c1.x, c2.x, c0.x);
        // var t1 = new decimal3(c1.y, c2.y, c0.y);
        // var t2 = new decimal3(c1.z, c2.z, c0.z);
        var (t0, t1, t2) = transpose(new decimal3x3(c1, c2, c0));
    
        var m0 = t1 * t2.yzx - t1.yzx * t2;
        var m1 = t0.yzx * t2 - t0 * t2.yzx;
        var m2 = t0 * t1.yzx - t0.yzx * t1;
    
        var rcpDet = (1m / csum(t0.zxy * m0));
        return new decimal3x3(m0, m1, m2) * rcpDet;
    }

    // <summary>Returns the determinant of a decimal3x3 matrix</summary>
    /// <param name="m">Matrix to use when computing determinant</param>
    /// <returns>The determinant of the matrix</returns>
    [MethodImpl(256 | 512)]
    public static decimal determinant(this decimal3x3 m)
    {
        var (c0, c1, c2) = m;

        var m00 = c1.y * c2.z - c1.z * c2.y;
        var m01 = c0.y * c2.z - c0.z * c2.y;
        var m02 = c0.y * c1.z - c0.z * c1.y;

        var r = c0.x * m00 - c1.x * m01 + c2.x * m02;

        return r;
    }
}

#endregion // decimal3x3

#region half3x3

public partial struct half3x3
{
    /// <summary>
    /// Constructs a half3x3 from the upper left 3x3 of a half4x4
    /// </summary>
    /// <param name="m4x4"><see cref="half4x4"/> to extract a half3x3 from</param>
    [MethodImpl(256 | 512)]
    public half3x3(half4x4 m4x4)
    {
        c0 = m4x4.c0.xyz;
        c1 = m4x4.c1.xyz;
        c2 = m4x4.c2.xyz;
    }

    /// <summary>Constructs a half3x3 matrix from a unit quaternion</summary>
    /// <param name="q">The quaternion rotation</param>
    [MethodImpl(256 | 512)]
    public half3x3(quaternion_h q)
    {
        var v = q.value;
        var v2 = v + v;

        var npn = new ushort3(0x8000, default, 0x8000).asf();
        var nnp = new ushort3(0x8000, 0x8000, default).asf();
        var pnn = new ushort3(default, 0x8000, 0x8000).asf();

        c0 = v2.yyy.fms(v.yxw ^ npn, v2.zzz * (v.zwx ^ pnn)) + new half3((half)1.0, default, default);
        c1 = v2.zzz.fms(v.wzy ^ nnp, v2.xxx * (v.yxw ^ npn)) + new half3(default, (half)1.0, default);
        c2 = v2.xxx.fms(v.zwx ^ pnn, v2.yyy * (v.wzy ^ nnp)) + new half3(default, default, (half)1.0);
    }

    /// <summary>
    /// Returns a half3x3 view rotation matrix given a unit length forward vector and a unit length up vector.
    /// The two input vectors are assumed to be unit length and not collinear.
    /// If these assumptions are not met use <see cref="half3x3.LookRotationSafe" /> instead.
    /// </summary>
    /// <param name="forward">The forward vector to align the center of view with</param>
    /// <param name="up">The up vector to point top of view toward</param>
    /// <returns>The half3x3 view rotation matrix</returns>
    [MethodImpl(256 | 512)]
    public static half3x3 LookRotation(half3 forward, half3 up)
    {
        var t = up.cross(forward).normalize();
        return new(t, forward.cross(t), forward);
    }

    /// <summary>
    /// Returns a half3x3 view rotation matrix given a forward vector and an up vector.
    /// The two input vectors are not assumed to be unit length.
    /// If the magnitude of either of the vectors is so extreme that the calculation cannot be carried out reliably or the vectors are collinear,
    /// the identity will be returned instead.
    /// </summary>
    /// <param name="forward">The forward vector to align the center of view with</param>
    /// <param name="up">The up vector to point top of view toward</param>
    /// <returns>The half3x3 view rotation matrix or the identity matrix.</returns>
    [MethodImpl(256 | 512)]
    public static half3x3 LookRotationSafe(half3 forward, half3 up)
    {
        var forwardLengthSq = forward.dot(forward);
        var upLengthSq = up.dot(up);

        forward *= forwardLengthSq.rsqrt();
        up *= upLengthSq.rsqrt();

        var t = up.cross(forward);
        var tLengthSq = t.dot(t);
        t *= tLengthSq.rsqrt();

        var mn = forwardLengthSq.min(upLengthSq).min(tLengthSq);
        var mx = forwardLengthSq.max(upLengthSq).max(tLengthSq);

        var accept = mn > math.MinRotateSafe<half>() && mx < math.MaxRotateSafe<half>()
            && forwardLengthSq.isFinite() && upLengthSq.isFinite() && tLengthSq.isFinite();
        if (!accept) return Identity;
        return new(t, forward.cross(t), forward);
    }
    
    /// <summary>
    /// Returns a half3x3 matrix representing a rotation around a unit axis by an angle in radians.
    /// The rotation direction is clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="axis">The rotation axis</param>
    /// <param name="angle">The angle of rotation in radians</param>
    /// <returns>The half3x3 matrix representing the rotation around an axis.</returns>
    [MethodImpl(256 | 512)]
    public static half3x3 AxisAngle(half3 axis, half angle)
    {
        angle.sincos(out var sina, out var cosa);
        var u = axis;
        var u_inv_cosa = u - u * cosa; // u * (1 - cosa);
        var t = new half4(u * sina, cosa);

        var ppn = new ushort3(default, default, 0x8000).ashalf();
        var npp = new ushort3(0x8000, default, default).ashalf();
        var pnp = new ushort3(default, 0x8000, default).ashalf();

        return new(
            u.xxx.fma(u_inv_cosa, t.wzy ^ ppn),
            u.yyy.fma(u_inv_cosa, t.zwx ^ npp),
            u.zzz.fma(u_inv_cosa, t.yxw ^ pnp)
        );
    }

    /// <summary>
    /// Returns a half3x3 rotation matrix constructed by first performing a rotation around the x-axis, then the y-axis and finally the z-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A half3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The half3x3 rotation matrix of the Euler angle rotation in x-y-z order</returns>
    [MethodImpl(256 | 512)]
    public static half3x3 EulerXYZ(half3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (half)(c.y * c.z),  (half)(c.z * s.x * s.y - c.x * s.z),    (half)(c.x * c.z * s.y + s.x * s.z),
            (half)(c.y * s.z),  (half)(c.x * c.z + s.x * s.y * s.z),    (half)(c.x * s.y * s.z - c.z * s.x),
            (half)(-s.y),       (half)(c.y * s.x),                      (half)(c.x * c.y)
        );
    }

    /// <summary>
    /// Returns a half3x3 rotation matrix constructed by first performing a rotation around the x-axis, then the z-axis and finally the y-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A half3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The half3x3 rotation matrix of the Euler angle rotation in x-z-y order</returns>
    [MethodImpl(256 | 512)]
    public static half3x3 EulerXZY(half3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (half)(c.y * c.z),  (half)(s.x * s.y - c.x * c.y * s.z),    (half)(c.x * s.y + c.y * s.x * s.z),
            (half)(s.z),        (half)(c.x * c.z),                      (half)(-c.z * s.x),                 
            (half)(-c.z * s.y), (half)(c.y * s.x + c.x * s.y * s.z),    (half)(c.x * c.y - s.x * s.y * s.z)
        );
    }

    /// <summary>
    /// Returns a half3x3 rotation matrix constructed by first performing a rotation around the y-axis, then the x-axis and finally the z-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A half3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The half3x3 rotation matrix of the Euler angle rotation in y-x-z order</returns>
    [MethodImpl(256 | 512)]
    public static half3x3 EulerYXZ(half3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (half)(c.y * c.z - s.x * s.y * s.z),    (half)(-c.x * s.z), (half)(c.z * s.y + c.y * s.x * s.z),
            (half)(c.z * s.x * s.y + c.y * s.z),    (half)(c.x * c.z),  (half)(s.y * s.z - c.y * c.z * s.x),
            (half)(-c.x * s.y),                     (half)(s.x),        (half)(c.x * c.y)
        );
    }

    /// <summary>
    /// Returns a half3x3 rotation matrix constructed by first performing a rotation around the y-axis, then the z-axis and finally the x-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A half3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The half3x3 rotation matrix of the Euler angle rotation in y-z-x order</returns>
    [MethodImpl(256 | 512)]
    public static half3x3 EulerYZX(half3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (half)(c.y * c.z),                      (half)(-s.z),       (half)(c.z * s.y),                  
            (half)(s.x * s.y + c.x * c.y * s.z),    (half)(c.x * c.z),  (half)(c.x * s.y * s.z - c.y * s.x),
            (half)(c.y * s.x * s.z - c.x * s.y),    (half)(c.z * s.x),  (half)(c.x * c.y + s.x * s.y * s.z)
        );
    }

    /// <summary>
    /// Returns a half3x3 rotation matrix constructed by first performing a rotation around the z-axis, then the x-axis and finally the y-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A half3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The half3x3 rotation matrix of the Euler angle rotation in z-x-y order</returns>
    [MethodImpl(256 | 512)]
    public static half3x3 EulerZXY(half3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (half)(c.y * c.z + s.x * s.y * s.z),    (half)(c.z * s.x * s.y - c.y * s.z),    (half)(c.x * s.y),
            (half)(c.x * s.z),                      (half)(c.x * c.z),                      (half)(-s.x),     
            (half)(c.y * s.x * s.z - c.z * s.y),    (half)(c.y * c.z * s.x + s.y * s.z),    (half)(c.x * c.y)
        );
    }

    /// <summary>
    /// Returns a half3x3 rotation matrix constructed by first performing a rotation around the z-axis, then the y-axis and finally the x-axis
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="xyz">A half3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The half3x3 rotation matrix of the Euler angle rotation in z-y-x order</returns>
    [MethodImpl(256 | 512)]
    public static half3x3 EulerZYX(half3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (half)(c.y * c.z),                      (half)(-c.y * s.z),                     (half)(s.y),       
            (half)(c.z * s.x * s.y + c.x * s.z),    (half)(c.x * c.z - s.x * s.y * s.z),    (half)(-c.y * s.x),
            (half)(s.x * s.z - c.x * c.z * s.y),    (half)(c.z * s.x + c.x * s.y * s.z),    (half)(c.x * c.y)
        );
    }

    /// <summary>Returns a half3x3 matrix that rotates around the x-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the x-axis towards the origin in radians</param>
    /// <returns>The half3x3 rotation matrix that rotates around the x-axis</returns>
    [MethodImpl(256 | 512)]
    public static half3x3 RotateX(half angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            (half)1.0, default, default,
            default, c,     -s,
            default, s,     c
        );
    }

    /// <summary>Returns a half3x3 matrix that rotates around the y-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the y-axis towards the origin in radians</param>
    /// <returns>The half3x3 rotation matrix that rotates around the y-axis</returns>
    [MethodImpl(256 | 512)]
    public static half3x3 RotateY(half angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            c,     default, s,
            default, (half)1.0, default,
            -s,    default, c
        );
    }

    /// <summary>Returns a half3x3 matrix that rotates around the z-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the z-axis towards the origin in radians</param>
    /// <returns>The half3x3 rotation matrix that rotates around the z-axis</returns>
    [MethodImpl(256 | 512)]
    public static half3x3 RotateZ(half angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            c,     -s,    default,
            s,     c,     default,
            default, default, (half)1.0
        );
    }
    
    /// <summary>Returns a half3x3 matrix representing a uniform scaling of all axes by s</summary>
    /// <param name="s">The uniform scaling factor</param>
    /// <returns>The half3x3 matrix representing a uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static half3x3 Scale(half s) => new(
        s,    default, default,
        default, s,    default,
        default, default, s
    );
    
    /// <summary>Returns a half3x3 matrix representing a non-uniform axis scaling by x, y and z</summary>
    /// <param name="x">The x-axis scaling factor</param>
    /// <param name="y">The y-axis scaling factor</param>
    /// <param name="z">The z-axis scaling factor</param>
    /// <returns>The half3x3 rotation matrix representing a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static half3x3 Scale(half x, half y, half z) => new(
        x,    default, default,
        default, y,    default,
        default, default, z
    );

    /// <summary>Returns a half3x3 matrix representing a non-uniform axis scaling by the components of the half3 vector v</summary>
    /// <param name="v">The vector containing non-uniform scaling factors</param>
    /// <returns>The half3x3 rotation matrix representing a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static half3x3 Scale(half3 v) => new(
        v.x,    default, default,
        default, v.y,    default,
        default, default, v.z
    );

    /// <summary>
    /// Converts a half4x4 to a half3x3
    /// </summary>
    /// <param name="m4x4">The half4x4 to convert to a half3x3</param>
    /// <returns>The half3x3 constructed from the upper left 3x3 of the input half4x4 matrix</returns>
    [MethodImpl(256 | 512)]
    public static explicit operator half3x3(half4x4 m4x4) => new(m4x4);
}

public static partial class math
{

    /// <summary>Returns the half3x3 full inverse of a half3x3 matrix</summary>
    /// <param name="m">Matrix to invert</param>
    /// <returns>The inverted matrix</returns>
    [MethodImpl(256 | 512)]
    public static half3x3 inverse(this half3x3 m)
    {
        var (c0, c1, c2) = m;
        // var t0 = new half3(c1.x, c2.x, c0.x);
        // var t1 = new half3(c1.y, c2.y, c0.y);
        // var t2 = new half3(c1.z, c2.z, c0.z);
        var (t0, t1, t2) = transpose(new half3x3(c1, c2, c0));
    
        var m0 = t1 * t2.yzx - t1.yzx * t2;
        var m1 = t0.yzx * t2 - t0 * t2.yzx;
        var m2 = t0 * t1.yzx - t0.yzx * t1;
    
        var rcpDet = (half)((half)1.0 / csum(t0.zxy * m0));
        return new half3x3(m0, m1, m2) * rcpDet;
    }

    // <summary>Returns the determinant of a half3x3 matrix</summary>
    /// <param name="m">Matrix to use when computing determinant</param>
    /// <returns>The determinant of the matrix</returns>
    [MethodImpl(256 | 512)]
    public static half determinant(this half3x3 m)
    {
        var (c0, c1, c2) = m;

        var m00 = c1.y * c2.z - c1.z * c2.y;
        var m01 = c0.y * c2.z - c0.z * c2.y;
        var m02 = c0.y * c1.z - c0.z * c1.y;

        var r = c0.x * m00 - c1.x * m01 + c2.x * m02;

        return (half)r;
    }
}

#endregion // half3x3
