// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region float2x2

public partial struct float2x2
{
    [MethodImpl(256 | 512)]
    public static float2x2 Rotate(float angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            c, -s,
            s,  c
        );
    }

    [MethodImpl(256 | 512)]
    public static float2x2 Scale(float s) => new(
        s,   default,
        default, s
    );

    [MethodImpl(256 | 512)]
    public static float2x2 Scale(float x, float y) => new(
        x,   default,
        default, y
    );

    [MethodImpl(256 | 512)]
    public static float2x2 Scale(float2 v) => new(
        v.x,   default,
        default, v.y
    );
}

public static partial class math
{
    /// <summary>Returns the determinant of a float2x2 matrix</summary>
    /// <param name="m">Matrix to use when computing determinant</param>
    /// <returns>The determinant of the matrix</returns>
    [MethodImpl(256 | 512)]
    public static float2x2 inverse(this float2x2 m)
    {
        var a = m.c0.x;
        var b = m.c1.x;
        var c = m.c0.y;
        var d = m.c1.y;

        // var det = (a * d - b * c);
        var det = (fsm(a * d, b, c));

        return new float2x2(d, -b, -c, a) * (1.0f / det);
    }

    [MethodImpl(256 | 512)]
    public static float determinant(this float2x2 m)
    {
        var a = m.c0.x;
        var b = m.c1.x;
        var c = m.c0.y;
        var d = m.c1.y;

        // return (a * d - b * c);
        return (fsm(a * d, b, c));
    }
}

#endregion // float2x2

#region double2x2

public partial struct double2x2
{
    [MethodImpl(256 | 512)]
    public static double2x2 Rotate(double angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            c, -s,
            s,  c
        );
    }

    [MethodImpl(256 | 512)]
    public static double2x2 Scale(double s) => new(
        s,   default,
        default, s
    );

    [MethodImpl(256 | 512)]
    public static double2x2 Scale(double x, double y) => new(
        x,   default,
        default, y
    );

    [MethodImpl(256 | 512)]
    public static double2x2 Scale(double2 v) => new(
        v.x,   default,
        default, v.y
    );
}

public static partial class math
{
    /// <summary>Returns the determinant of a double2x2 matrix</summary>
    /// <param name="m">Matrix to use when computing determinant</param>
    /// <returns>The determinant of the matrix</returns>
    [MethodImpl(256 | 512)]
    public static double2x2 inverse(this double2x2 m)
    {
        var a = m.c0.x;
        var b = m.c1.x;
        var c = m.c0.y;
        var d = m.c1.y;

        // var det = (a * d - b * c);
        var det = (fsm(a * d, b, c));

        return new double2x2(d, -b, -c, a) * (1.0 / det);
    }

    [MethodImpl(256 | 512)]
    public static double determinant(this double2x2 m)
    {
        var a = m.c0.x;
        var b = m.c1.x;
        var c = m.c0.y;
        var d = m.c1.y;

        // return (a * d - b * c);
        return (fsm(a * d, b, c));
    }
}

#endregion // double2x2

#region short2x2

public partial struct short2x2
{
    [MethodImpl(256 | 512)]
    public static short2x2 Scale(short s) => new(
        s,   default,
        default, s
    );

    [MethodImpl(256 | 512)]
    public static short2x2 Scale(short x, short y) => new(
        x,   default,
        default, y
    );

    [MethodImpl(256 | 512)]
    public static short2x2 Scale(short2 v) => new(
        v.x,   default,
        default, v.y
    );
}

public static partial class math
{
}

#endregion // short2x2

#region ushort2x2

public partial struct ushort2x2
{
    [MethodImpl(256 | 512)]
    public static ushort2x2 Scale(ushort s) => new(
        s,   default,
        default, s
    );

    [MethodImpl(256 | 512)]
    public static ushort2x2 Scale(ushort x, ushort y) => new(
        x,   default,
        default, y
    );

    [MethodImpl(256 | 512)]
    public static ushort2x2 Scale(ushort2 v) => new(
        v.x,   default,
        default, v.y
    );
}

public static partial class math
{
}

#endregion // ushort2x2

#region int2x2

public partial struct int2x2
{
    [MethodImpl(256 | 512)]
    public static int2x2 Scale(int s) => new(
        s,   default,
        default, s
    );

    [MethodImpl(256 | 512)]
    public static int2x2 Scale(int x, int y) => new(
        x,   default,
        default, y
    );

    [MethodImpl(256 | 512)]
    public static int2x2 Scale(int2 v) => new(
        v.x,   default,
        default, v.y
    );
}

public static partial class math
{
}

#endregion // int2x2

#region uint2x2

public partial struct uint2x2
{
    [MethodImpl(256 | 512)]
    public static uint2x2 Scale(uint s) => new(
        s,   default,
        default, s
    );

    [MethodImpl(256 | 512)]
    public static uint2x2 Scale(uint x, uint y) => new(
        x,   default,
        default, y
    );

    [MethodImpl(256 | 512)]
    public static uint2x2 Scale(uint2 v) => new(
        v.x,   default,
        default, v.y
    );
}

public static partial class math
{
}

#endregion // uint2x2

#region long2x2

public partial struct long2x2
{
    [MethodImpl(256 | 512)]
    public static long2x2 Scale(long s) => new(
        s,   default,
        default, s
    );

    [MethodImpl(256 | 512)]
    public static long2x2 Scale(long x, long y) => new(
        x,   default,
        default, y
    );

    [MethodImpl(256 | 512)]
    public static long2x2 Scale(long2 v) => new(
        v.x,   default,
        default, v.y
    );
}

public static partial class math
{
}

#endregion // long2x2

#region ulong2x2

public partial struct ulong2x2
{
    [MethodImpl(256 | 512)]
    public static ulong2x2 Scale(ulong s) => new(
        s,   default,
        default, s
    );

    [MethodImpl(256 | 512)]
    public static ulong2x2 Scale(ulong x, ulong y) => new(
        x,   default,
        default, y
    );

    [MethodImpl(256 | 512)]
    public static ulong2x2 Scale(ulong2 v) => new(
        v.x,   default,
        default, v.y
    );
}

public static partial class math
{
}

#endregion // ulong2x2

#region decimal2x2

public partial struct decimal2x2
{
    [MethodImpl(256 | 512)]
    public static decimal2x2 Scale(decimal s) => new(
        s,   default,
        default, s
    );

    [MethodImpl(256 | 512)]
    public static decimal2x2 Scale(decimal x, decimal y) => new(
        x,   default,
        default, y
    );

    [MethodImpl(256 | 512)]
    public static decimal2x2 Scale(decimal2 v) => new(
        v.x,   default,
        default, v.y
    );
}

public static partial class math
{
    /// <summary>Returns the determinant of a decimal2x2 matrix</summary>
    /// <param name="m">Matrix to use when computing determinant</param>
    /// <returns>The determinant of the matrix</returns>
    [MethodImpl(256 | 512)]
    public static decimal2x2 inverse(this decimal2x2 m)
    {
        var a = m.c0.x;
        var b = m.c1.x;
        var c = m.c0.y;
        var d = m.c1.y;

        // var det = (a * d - b * c);
        var det = (fsm(a * d, b, c));

        return new decimal2x2(d, -b, -c, a) * (1m / det);
    }

    [MethodImpl(256 | 512)]
    public static decimal determinant(this decimal2x2 m)
    {
        var a = m.c0.x;
        var b = m.c1.x;
        var c = m.c0.y;
        var d = m.c1.y;

        // return (a * d - b * c);
        return (fsm(a * d, b, c));
    }
}

#endregion // decimal2x2

#region half2x2

public partial struct half2x2
{
    [MethodImpl(256 | 512)]
    public static half2x2 Rotate(half angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            c, -s,
            s,  c
        );
    }

    [MethodImpl(256 | 512)]
    public static half2x2 Scale(half s) => new(
        s,   default,
        default, s
    );

    [MethodImpl(256 | 512)]
    public static half2x2 Scale(half x, half y) => new(
        x,   default,
        default, y
    );

    [MethodImpl(256 | 512)]
    public static half2x2 Scale(half2 v) => new(
        v.x,   default,
        default, v.y
    );
}

public static partial class math
{
    /// <summary>Returns the determinant of a half2x2 matrix</summary>
    /// <param name="m">Matrix to use when computing determinant</param>
    /// <returns>The determinant of the matrix</returns>
    [MethodImpl(256 | 512)]
    public static half2x2 inverse(this half2x2 m)
    {
        var a = m.c0.x;
        var b = m.c1.x;
        var c = m.c0.y;
        var d = m.c1.y;

        // var det = (half)(a * d - b * c);
        var det = (half)(fsm(a * d, b, c));

        return new half2x2(d, -b, -c, a) * (half)((half)1.0 / det);
    }

    [MethodImpl(256 | 512)]
    public static half determinant(this half2x2 m)
    {
        var a = m.c0.x;
        var b = m.c1.x;
        var c = m.c0.y;
        var d = m.c1.y;

        // return (half)(a * d - b * c);
        return (half)(fsm(a * d, b, c));
    }
}

#endregion // half2x2
