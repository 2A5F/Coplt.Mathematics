// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region float4x4

public partial struct float4x4
{
    /// <summary>Constructs a float4x4 from a float3x3 rotation matrix and a float3 translation vector</summary>
    /// <param name="rotation">The float3x3 rotation matrix</param>
    /// <param name="translation">The translation vector</param>
    [MethodImpl(256 | 512)]
    public float4x4(float3x3 rotation, float3 translation)
    {
        #if NET8_0_OR_GREATER
        c0 = new(rotation.c0.vector);
        c1 = new(rotation.c1.vector);
        c2 = new(rotation.c2.vector);
        #else // NET8_0_OR_GREATER
        c0 = new(rotation.c0, default);
        c1 = new(rotation.c1, default);
        c2 = new(rotation.c2, default);
        #endif // NET8_0_OR_GREATER
        c3 = new(translation, 1.0f);
    }

    /// <summary>
    /// Returns a float4x4 matrix representing a rotation around a unit axis by an angle in radians
    /// The rotation direction is clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="axis">The axis of rotation</param>
    /// <param name="angle">The angle of rotation in radians</param>
    /// <returns>The float4x4 matrix representing the rotation about an axis</returns>
    [MethodImpl(256 | 512)]
    public static float4x4 AxisAngle(float3 axis, float angle)
    {
        angle.sincos(out var sina, out var cosa);
        var u = new float4(axis, default);
        var u_inv_cosa = u - u * cosa; // u * (1 - cosa);
        var t = new float4(u.xyz * sina, cosa);

        var ppnp = new uint4(default, default, 0x80000000, default).asfloat();
        var nppp = new uint4(0x80000000, default, default, default).asfloat();
        var pnpp = new uint4(default, 0x80000000, default, default).asfloat();
        var mask = new int4(-1, -1, -1, default).asfloat();

        return new(
            u.xxxx.fma(u_inv_cosa, (t.wzyx ^ ppnp) & mask),
            u.yyyy.fma(u_inv_cosa, (t.zwxx ^ nppp) & mask),
            u.zzzz.fma(u_inv_cosa, (t.yxwx ^ pnpp) & mask),
            new(default, default, default, 1.0f)
        );
    }

    /// <summary>
    /// Returns a float4x4 rotation matrix constructed by first performing a rotation around the x-axis, then the y-axis and finally the z-axis
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The float4x4 rotation matrix of the Euler angle rotation in x-y-z order</returns>
    [MethodImpl(256 | 512)]
    public static float4x4 EulerXYZ(float3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (c.y * c.z),  (c.z * s.x * s.y - c.x * s.z),    (c.x * c.z * s.y + s.x * s.z),    default,
            (c.y * s.z),  (c.x * c.z + s.x * s.y * s.z),    (c.x * s.y * s.z - c.z * s.x),    default,
            (-s.y),       (c.y * s.x),                      (c.x * c.y),                      default,
            default,                        default,                        default,       1.0f
        );
    }

    /// <summary>
    /// Returns a float4x4 rotation matrix constructed by first performing a rotation around the x-axis, then the z-axis and finally the y-axis
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The float4x4 rotation matrix of the Euler angle rotation in x-z-y order</returns>
    [MethodImpl(256 | 512)]
    public static float4x4 EulerXZY(float3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (c.y * c.z),  (s.x * s.y - c.x * c.y * s.z),    (c.x * s.y + c.y * s.x * s.z),    default,
            (s.z),        (c.x * c.z),                      (-c.z * s.x),                     default,
            (-c.z * s.y), (c.y * s.x + c.x * s.y * s.z),    (c.x * c.y - s.x * s.y * s.z),    default,
            default,                        default,                        default,       1.0f
        );
    }

    /// <summary>
    /// Returns a float4x4 rotation matrix constructed by first performing a rotation around the y-axis, then the x-axis and finally the z-axis
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The float4x4 rotation matrix of the Euler angle rotation in y-x-z order</returns>
    [MethodImpl(256 | 512)]
    public static float4x4 EulerYXZ(float3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (c.y * c.z - s.x * s.y * s.z),    (-c.x * s.z), (c.z * s.y + c.y * s.x * s.z),    default,
            (c.z * s.x * s.y + c.y * s.z),    (c.x * c.z),  (s.y * s.z - c.y * c.z * s.x),    default,
            (-c.x * s.y),                     (s.x),        (c.x * c.y),                      default,
            default,                        default,                        default,       1.0f
        );
    }

    /// <summary>
    /// Returns a float4x4 rotation matrix constructed by first performing a rotation around the y-axis, then the z-axis and finally the x-axis
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The float4x4 rotation matrix of the Euler angle rotation in y-z-x order</returns>
    [MethodImpl(256 | 512)]
    public static float4x4 EulerYZX(float3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (c.y * c.z),                      (-s.z),       (c.z * s.y),                      default,
            (s.x * s.y + c.x * c.y * s.z),    (c.x * c.z),  (c.x * s.y * s.z - c.y * s.x),    default,
            (c.y * s.x * s.z - c.x * s.y),    (c.z * s.x),  (c.x * c.y + s.x * s.y * s.z),    default,
            default,                        default,                        default,       1.0f
        );
    }

    /// <summary>
    /// Returns a float4x4 rotation matrix constructed by first performing a rotation around the z-axis, then the x-axis and finally the y-axis
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin
    /// This is the default order rotation order in Unity
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The float4x4 rotation matrix of the Euler angle rotation in z-x-y order</returns>
    [MethodImpl(256 | 512)]
    public static float4x4 EulerZXY(float3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (c.y * c.z + s.x * s.y * s.z),    (c.z * s.x * s.y - c.y * s.z),    (c.x * s.y),  default,
            (c.x * s.z),                      (c.x * c.z),                      (-s.x),       default,
            (c.y * s.x * s.z - c.z * s.y),    (c.y * c.z * s.x + s.y * s.z),    (c.x * c.y),  default,
            default,                        default,                        default,       1.0f
        );
    }

    /// <summary>
    /// Returns a float4x4 rotation matrix constructed by first performing a rotation around the z-axis, then the y-axis and finally the x-axis
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The float4x4 rotation matrix of the Euler angle rotation in z-y-x order</returns>
    [MethodImpl(256 | 512)]
    public static float4x4 EulerZYX(float3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (c.y * c.z),                      (-c.y * s.z),                     (s.y),        default,
            (c.z * s.x * s.y + c.x * s.z),    (c.x * c.z - s.x * s.y * s.z),    (-c.y * s.x), default,
            (s.x * s.z - c.x * c.z * s.y),    (c.z * s.x + c.x * s.y * s.z),    (c.x * c.y),  default,
            default,                        default,                        default,       1.0f
        );
    }

    /// <summary>Returns a float4x4 matrix that rotates around the x-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the x-axis towards the origin in radians</param>
    /// <returns>The float4x4 rotation matrix that rotates around the x-axis</returns>
    [MethodImpl(256 | 512)]
    public static float4x4 RotateX(float angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            1.0f, default, default, default,
            default, c,     -s,    default,
            default, s,     c,     default,
            default, default, default, 1.0f
        );
    }

    /// <summary>Returns a float4x4 matrix that rotates around the y-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the y-axis towards the origin in radians</param>
    /// <returns>The float4x4 rotation matrix that rotates around the y-axis</returns>
    [MethodImpl(256 | 512)]
    public static float4x4 RotateY(float angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            c,     default, s,     default,
            default, 1.0f, default, default,
            -s,    default, c,     default,
            default, default, default, 1.0f
        );
    }

    /// <summary>Returns a float4x4 matrix that rotates around the z-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the z-axis towards the origin in radians</param>
    /// <returns>The float4x4 rotation matrix that rotates around the z-axis</returns>
    [MethodImpl(256 | 512)]
    public static float4x4 RotateZ(float angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            c,     -s,    default, default,
            s,     c,     default, default,
            default, default, 1.0f, default,
            default, default, default, 1.0f
        );
    }

    /// <summary>Returns a float4x4 scale matrix given 3 axis scales</summary>
    /// <param name="s">The uniform scaling factor</param>
    /// <returns>The float4x4 matrix that represents a uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static float4x4 Scale(float s) => new(
        s,    default, default, default,
        default, s,    default, default,
        default, default, s,    default,
        default, default, default, 1.0f
    );

    /// <summary>Returns a float4x4 scale matrix given a float3 vector containing the 3 axis scales</summary>
    /// <param name="x">The x-axis scaling factor</param>
    /// <param name="y">The y-axis scaling factor</param>
    /// <param name="z">The z-axis scaling factor</param>
    /// <returns>The float4x4 matrix that represents a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static float4x4 Scale(float x, float y, float z) => new(
        x,    default, default, default,
        default, y,    default, default,
        default, default, z,    default,
        default, default, default, 1.0f
    );

    /// <summary>Returns a float4x4 scale matrix given a float3 vector containing the 3 axis scales</summary>
    /// <param name="scales">The vector containing scale factors for each axis</param>
    /// <returns>The float4x4 matrix that represents a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static float4x4 Scale(float3 scales) => Scale(scales.x, scales.y, scales.z);

    /// <summary>Returns a float4x4 translation matrix given a float3 translation vector</summary>
    /// <param name="vector">The translation vector</param>
    /// <returns>The float4x4 translation matrix</returns>
    [MethodImpl(256 | 512)]
    public static float4x4 Translate(float3 vector) => new(
        new(1.0f, default, default, default),
        new(default, 1.0f, default, default),
        new(default, default, 1.0f, default),
        new(vector, 1.0f)
    );
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float3 rotate(this float4x4 a, float3 b) 
        => b.xxxx.fma(a.c0, b.yyyy.fma(a.c1, b.zzzz * a.c2)).xyz;
        // (a.c0 * b.x + a.c1 * b.y + a.c2 * b.z).xyz;

    [MethodImpl(256 | 512)]
    public static float3 transform(this float4x4 a, float3 b) 
        => b.xxxx.fma(a.c0, b.yyyy.fma(a.c1, b.zzzz.fma(a.c2, a.c3))).xyz;
        // (a.c0 * b.x + a.c1 * b.y + a.c2 * b.z + a.c3).xyz;
}

#endregion // float4x4

#region double4x4

public partial struct double4x4
{
    /// <summary>Constructs a float4x4 from a float3x3 rotation matrix and a float3 translation vector</summary>
    /// <param name="rotation">The float3x3 rotation matrix</param>
    /// <param name="translation">The translation vector</param>
    [MethodImpl(256 | 512)]
    public double4x4(double3x3 rotation, double3 translation)
    {
        #if NET8_0_OR_GREATER
        c0 = new(rotation.c0.vector);
        c1 = new(rotation.c1.vector);
        c2 = new(rotation.c2.vector);
        #else // NET8_0_OR_GREATER
        c0 = new(rotation.c0, default);
        c1 = new(rotation.c1, default);
        c2 = new(rotation.c2, default);
        #endif // NET8_0_OR_GREATER
        c3 = new(translation, 1.0);
    }

    /// <summary>
    /// Returns a float4x4 matrix representing a rotation around a unit axis by an angle in radians
    /// The rotation direction is clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="axis">The axis of rotation</param>
    /// <param name="angle">The angle of rotation in radians</param>
    /// <returns>The float4x4 matrix representing the rotation about an axis</returns>
    [MethodImpl(256 | 512)]
    public static double4x4 AxisAngle(double3 axis, double angle)
    {
        angle.sincos(out var sina, out var cosa);
        var u = new double4(axis, default);
        var u_inv_cosa = u - u * cosa; // u * (1 - cosa);
        var t = new double4(u.xyz * sina, cosa);

        var ppnp = new ulong4(default, default, 0x8000000000000000, default).asdouble();
        var nppp = new ulong4(0x8000000000000000, default, default, default).asdouble();
        var pnpp = new ulong4(default, 0x8000000000000000, default, default).asdouble();
        var mask = new long4(-1, -1, -1, default).asdouble();

        return new(
            u.xxxx.fma(u_inv_cosa, (t.wzyx ^ ppnp) & mask),
            u.yyyy.fma(u_inv_cosa, (t.zwxx ^ nppp) & mask),
            u.zzzz.fma(u_inv_cosa, (t.yxwx ^ pnpp) & mask),
            new(default, default, default, 1.0)
        );
    }

    /// <summary>
    /// Returns a float4x4 rotation matrix constructed by first performing a rotation around the x-axis, then the y-axis and finally the z-axis
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The float4x4 rotation matrix of the Euler angle rotation in x-y-z order</returns>
    [MethodImpl(256 | 512)]
    public static double4x4 EulerXYZ(double3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (c.y * c.z),  (c.z * s.x * s.y - c.x * s.z),    (c.x * c.z * s.y + s.x * s.z),    default,
            (c.y * s.z),  (c.x * c.z + s.x * s.y * s.z),    (c.x * s.y * s.z - c.z * s.x),    default,
            (-s.y),       (c.y * s.x),                      (c.x * c.y),                      default,
            default,                        default,                        default,       1.0
        );
    }

    /// <summary>
    /// Returns a float4x4 rotation matrix constructed by first performing a rotation around the x-axis, then the z-axis and finally the y-axis
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The float4x4 rotation matrix of the Euler angle rotation in x-z-y order</returns>
    [MethodImpl(256 | 512)]
    public static double4x4 EulerXZY(double3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (c.y * c.z),  (s.x * s.y - c.x * c.y * s.z),    (c.x * s.y + c.y * s.x * s.z),    default,
            (s.z),        (c.x * c.z),                      (-c.z * s.x),                     default,
            (-c.z * s.y), (c.y * s.x + c.x * s.y * s.z),    (c.x * c.y - s.x * s.y * s.z),    default,
            default,                        default,                        default,       1.0
        );
    }

    /// <summary>
    /// Returns a float4x4 rotation matrix constructed by first performing a rotation around the y-axis, then the x-axis and finally the z-axis
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The float4x4 rotation matrix of the Euler angle rotation in y-x-z order</returns>
    [MethodImpl(256 | 512)]
    public static double4x4 EulerYXZ(double3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (c.y * c.z - s.x * s.y * s.z),    (-c.x * s.z), (c.z * s.y + c.y * s.x * s.z),    default,
            (c.z * s.x * s.y + c.y * s.z),    (c.x * c.z),  (s.y * s.z - c.y * c.z * s.x),    default,
            (-c.x * s.y),                     (s.x),        (c.x * c.y),                      default,
            default,                        default,                        default,       1.0
        );
    }

    /// <summary>
    /// Returns a float4x4 rotation matrix constructed by first performing a rotation around the y-axis, then the z-axis and finally the x-axis
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The float4x4 rotation matrix of the Euler angle rotation in y-z-x order</returns>
    [MethodImpl(256 | 512)]
    public static double4x4 EulerYZX(double3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (c.y * c.z),                      (-s.z),       (c.z * s.y),                      default,
            (s.x * s.y + c.x * c.y * s.z),    (c.x * c.z),  (c.x * s.y * s.z - c.y * s.x),    default,
            (c.y * s.x * s.z - c.x * s.y),    (c.z * s.x),  (c.x * c.y + s.x * s.y * s.z),    default,
            default,                        default,                        default,       1.0
        );
    }

    /// <summary>
    /// Returns a float4x4 rotation matrix constructed by first performing a rotation around the z-axis, then the x-axis and finally the y-axis
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin
    /// This is the default order rotation order in Unity
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The float4x4 rotation matrix of the Euler angle rotation in z-x-y order</returns>
    [MethodImpl(256 | 512)]
    public static double4x4 EulerZXY(double3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (c.y * c.z + s.x * s.y * s.z),    (c.z * s.x * s.y - c.y * s.z),    (c.x * s.y),  default,
            (c.x * s.z),                      (c.x * c.z),                      (-s.x),       default,
            (c.y * s.x * s.z - c.z * s.y),    (c.y * c.z * s.x + s.y * s.z),    (c.x * c.y),  default,
            default,                        default,                        default,       1.0
        );
    }

    /// <summary>
    /// Returns a float4x4 rotation matrix constructed by first performing a rotation around the z-axis, then the y-axis and finally the x-axis
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The float4x4 rotation matrix of the Euler angle rotation in z-y-x order</returns>
    [MethodImpl(256 | 512)]
    public static double4x4 EulerZYX(double3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (c.y * c.z),                      (-c.y * s.z),                     (s.y),        default,
            (c.z * s.x * s.y + c.x * s.z),    (c.x * c.z - s.x * s.y * s.z),    (-c.y * s.x), default,
            (s.x * s.z - c.x * c.z * s.y),    (c.z * s.x + c.x * s.y * s.z),    (c.x * c.y),  default,
            default,                        default,                        default,       1.0
        );
    }

    /// <summary>Returns a float4x4 matrix that rotates around the x-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the x-axis towards the origin in radians</param>
    /// <returns>The float4x4 rotation matrix that rotates around the x-axis</returns>
    [MethodImpl(256 | 512)]
    public static double4x4 RotateX(double angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            1.0, default, default, default,
            default, c,     -s,    default,
            default, s,     c,     default,
            default, default, default, 1.0
        );
    }

    /// <summary>Returns a float4x4 matrix that rotates around the y-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the y-axis towards the origin in radians</param>
    /// <returns>The float4x4 rotation matrix that rotates around the y-axis</returns>
    [MethodImpl(256 | 512)]
    public static double4x4 RotateY(double angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            c,     default, s,     default,
            default, 1.0, default, default,
            -s,    default, c,     default,
            default, default, default, 1.0
        );
    }

    /// <summary>Returns a float4x4 matrix that rotates around the z-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the z-axis towards the origin in radians</param>
    /// <returns>The float4x4 rotation matrix that rotates around the z-axis</returns>
    [MethodImpl(256 | 512)]
    public static double4x4 RotateZ(double angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            c,     -s,    default, default,
            s,     c,     default, default,
            default, default, 1.0, default,
            default, default, default, 1.0
        );
    }

    /// <summary>Returns a float4x4 scale matrix given 3 axis scales</summary>
    /// <param name="s">The uniform scaling factor</param>
    /// <returns>The float4x4 matrix that represents a uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static double4x4 Scale(double s) => new(
        s,    default, default, default,
        default, s,    default, default,
        default, default, s,    default,
        default, default, default, 1.0
    );

    /// <summary>Returns a float4x4 scale matrix given a float3 vector containing the 3 axis scales</summary>
    /// <param name="x">The x-axis scaling factor</param>
    /// <param name="y">The y-axis scaling factor</param>
    /// <param name="z">The z-axis scaling factor</param>
    /// <returns>The float4x4 matrix that represents a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static double4x4 Scale(double x, double y, double z) => new(
        x,    default, default, default,
        default, y,    default, default,
        default, default, z,    default,
        default, default, default, 1.0
    );

    /// <summary>Returns a float4x4 scale matrix given a float3 vector containing the 3 axis scales</summary>
    /// <param name="scales">The vector containing scale factors for each axis</param>
    /// <returns>The float4x4 matrix that represents a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static double4x4 Scale(double3 scales) => Scale(scales.x, scales.y, scales.z);

    /// <summary>Returns a float4x4 translation matrix given a float3 translation vector</summary>
    /// <param name="vector">The translation vector</param>
    /// <returns>The float4x4 translation matrix</returns>
    [MethodImpl(256 | 512)]
    public static double4x4 Translate(double3 vector) => new(
        new(1.0, default, default, default),
        new(default, 1.0, default, default),
        new(default, default, 1.0, default),
        new(vector, 1.0)
    );
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double3 rotate(this double4x4 a, double3 b) 
        => b.xxxx.fma(a.c0, b.yyyy.fma(a.c1, b.zzzz * a.c2)).xyz;
        // (a.c0 * b.x + a.c1 * b.y + a.c2 * b.z).xyz;

    [MethodImpl(256 | 512)]
    public static double3 transform(this double4x4 a, double3 b) 
        => b.xxxx.fma(a.c0, b.yyyy.fma(a.c1, b.zzzz.fma(a.c2, a.c3))).xyz;
        // (a.c0 * b.x + a.c1 * b.y + a.c2 * b.z + a.c3).xyz;
}

#endregion // double4x4

#region short4x4

public partial struct short4x4
{
    /// <summary>Constructs a float4x4 from a float3x3 rotation matrix and a float3 translation vector</summary>
    /// <param name="rotation">The float3x3 rotation matrix</param>
    /// <param name="translation">The translation vector</param>
    [MethodImpl(256 | 512)]
    public short4x4(short3x3 rotation, short3 translation)
    {
        c0 = new(rotation.c0, default);
        c1 = new(rotation.c1, default);
        c2 = new(rotation.c2, default);
        c3 = new(translation, (short)1);
    }

    /// <summary>Returns a float4x4 scale matrix given 3 axis scales</summary>
    /// <param name="s">The uniform scaling factor</param>
    /// <returns>The float4x4 matrix that represents a uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static short4x4 Scale(short s) => new(
        s,    default, default, default,
        default, s,    default, default,
        default, default, s,    default,
        default, default, default, (short)1
    );

    /// <summary>Returns a float4x4 scale matrix given a float3 vector containing the 3 axis scales</summary>
    /// <param name="x">The x-axis scaling factor</param>
    /// <param name="y">The y-axis scaling factor</param>
    /// <param name="z">The z-axis scaling factor</param>
    /// <returns>The float4x4 matrix that represents a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static short4x4 Scale(short x, short y, short z) => new(
        x,    default, default, default,
        default, y,    default, default,
        default, default, z,    default,
        default, default, default, (short)1
    );

    /// <summary>Returns a float4x4 scale matrix given a float3 vector containing the 3 axis scales</summary>
    /// <param name="scales">The vector containing scale factors for each axis</param>
    /// <returns>The float4x4 matrix that represents a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static short4x4 Scale(short3 scales) => Scale(scales.x, scales.y, scales.z);

    /// <summary>Returns a float4x4 translation matrix given a float3 translation vector</summary>
    /// <param name="vector">The translation vector</param>
    /// <returns>The float4x4 translation matrix</returns>
    [MethodImpl(256 | 512)]
    public static short4x4 Translate(short3 vector) => new(
        new((short)1, default, default, default),
        new(default, (short)1, default, default),
        new(default, default, (short)1, default),
        new(vector, (short)1)
    );
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static short3 rotate(this short4x4 a, short3 b) 
        => b.xxxx.fma(a.c0, b.yyyy.fma(a.c1, b.zzzz * a.c2)).xyz;
        // (a.c0 * b.x + a.c1 * b.y + a.c2 * b.z).xyz;

    [MethodImpl(256 | 512)]
    public static short3 transform(this short4x4 a, short3 b) 
        => b.xxxx.fma(a.c0, b.yyyy.fma(a.c1, b.zzzz.fma(a.c2, a.c3))).xyz;
        // (a.c0 * b.x + a.c1 * b.y + a.c2 * b.z + a.c3).xyz;
}

#endregion // short4x4

#region ushort4x4

public partial struct ushort4x4
{
    /// <summary>Constructs a float4x4 from a float3x3 rotation matrix and a float3 translation vector</summary>
    /// <param name="rotation">The float3x3 rotation matrix</param>
    /// <param name="translation">The translation vector</param>
    [MethodImpl(256 | 512)]
    public ushort4x4(ushort3x3 rotation, ushort3 translation)
    {
        c0 = new(rotation.c0, default);
        c1 = new(rotation.c1, default);
        c2 = new(rotation.c2, default);
        c3 = new(translation, (ushort)1);
    }

    /// <summary>Returns a float4x4 scale matrix given 3 axis scales</summary>
    /// <param name="s">The uniform scaling factor</param>
    /// <returns>The float4x4 matrix that represents a uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static ushort4x4 Scale(ushort s) => new(
        s,    default, default, default,
        default, s,    default, default,
        default, default, s,    default,
        default, default, default, (ushort)1
    );

    /// <summary>Returns a float4x4 scale matrix given a float3 vector containing the 3 axis scales</summary>
    /// <param name="x">The x-axis scaling factor</param>
    /// <param name="y">The y-axis scaling factor</param>
    /// <param name="z">The z-axis scaling factor</param>
    /// <returns>The float4x4 matrix that represents a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static ushort4x4 Scale(ushort x, ushort y, ushort z) => new(
        x,    default, default, default,
        default, y,    default, default,
        default, default, z,    default,
        default, default, default, (ushort)1
    );

    /// <summary>Returns a float4x4 scale matrix given a float3 vector containing the 3 axis scales</summary>
    /// <param name="scales">The vector containing scale factors for each axis</param>
    /// <returns>The float4x4 matrix that represents a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static ushort4x4 Scale(ushort3 scales) => Scale(scales.x, scales.y, scales.z);

    /// <summary>Returns a float4x4 translation matrix given a float3 translation vector</summary>
    /// <param name="vector">The translation vector</param>
    /// <returns>The float4x4 translation matrix</returns>
    [MethodImpl(256 | 512)]
    public static ushort4x4 Translate(ushort3 vector) => new(
        new((ushort)1, default, default, default),
        new(default, (ushort)1, default, default),
        new(default, default, (ushort)1, default),
        new(vector, (ushort)1)
    );
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ushort3 rotate(this ushort4x4 a, ushort3 b) 
        => b.xxxx.fma(a.c0, b.yyyy.fma(a.c1, b.zzzz * a.c2)).xyz;
        // (a.c0 * b.x + a.c1 * b.y + a.c2 * b.z).xyz;

    [MethodImpl(256 | 512)]
    public static ushort3 transform(this ushort4x4 a, ushort3 b) 
        => b.xxxx.fma(a.c0, b.yyyy.fma(a.c1, b.zzzz.fma(a.c2, a.c3))).xyz;
        // (a.c0 * b.x + a.c1 * b.y + a.c2 * b.z + a.c3).xyz;
}

#endregion // ushort4x4

#region int4x4

public partial struct int4x4
{
    /// <summary>Constructs a float4x4 from a float3x3 rotation matrix and a float3 translation vector</summary>
    /// <param name="rotation">The float3x3 rotation matrix</param>
    /// <param name="translation">The translation vector</param>
    [MethodImpl(256 | 512)]
    public int4x4(int3x3 rotation, int3 translation)
    {
        #if NET8_0_OR_GREATER
        c0 = new(rotation.c0.vector);
        c1 = new(rotation.c1.vector);
        c2 = new(rotation.c2.vector);
        #else // NET8_0_OR_GREATER
        c0 = new(rotation.c0, default);
        c1 = new(rotation.c1, default);
        c2 = new(rotation.c2, default);
        #endif // NET8_0_OR_GREATER
        c3 = new(translation, 1);
    }

    /// <summary>Returns a float4x4 scale matrix given 3 axis scales</summary>
    /// <param name="s">The uniform scaling factor</param>
    /// <returns>The float4x4 matrix that represents a uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static int4x4 Scale(int s) => new(
        s,    default, default, default,
        default, s,    default, default,
        default, default, s,    default,
        default, default, default, 1
    );

    /// <summary>Returns a float4x4 scale matrix given a float3 vector containing the 3 axis scales</summary>
    /// <param name="x">The x-axis scaling factor</param>
    /// <param name="y">The y-axis scaling factor</param>
    /// <param name="z">The z-axis scaling factor</param>
    /// <returns>The float4x4 matrix that represents a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static int4x4 Scale(int x, int y, int z) => new(
        x,    default, default, default,
        default, y,    default, default,
        default, default, z,    default,
        default, default, default, 1
    );

    /// <summary>Returns a float4x4 scale matrix given a float3 vector containing the 3 axis scales</summary>
    /// <param name="scales">The vector containing scale factors for each axis</param>
    /// <returns>The float4x4 matrix that represents a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static int4x4 Scale(int3 scales) => Scale(scales.x, scales.y, scales.z);

    /// <summary>Returns a float4x4 translation matrix given a float3 translation vector</summary>
    /// <param name="vector">The translation vector</param>
    /// <returns>The float4x4 translation matrix</returns>
    [MethodImpl(256 | 512)]
    public static int4x4 Translate(int3 vector) => new(
        new(1, default, default, default),
        new(default, 1, default, default),
        new(default, default, 1, default),
        new(vector, 1)
    );
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int3 rotate(this int4x4 a, int3 b) 
        => b.xxxx.fma(a.c0, b.yyyy.fma(a.c1, b.zzzz * a.c2)).xyz;
        // (a.c0 * b.x + a.c1 * b.y + a.c2 * b.z).xyz;

    [MethodImpl(256 | 512)]
    public static int3 transform(this int4x4 a, int3 b) 
        => b.xxxx.fma(a.c0, b.yyyy.fma(a.c1, b.zzzz.fma(a.c2, a.c3))).xyz;
        // (a.c0 * b.x + a.c1 * b.y + a.c2 * b.z + a.c3).xyz;
}

#endregion // int4x4

#region uint4x4

public partial struct uint4x4
{
    /// <summary>Constructs a float4x4 from a float3x3 rotation matrix and a float3 translation vector</summary>
    /// <param name="rotation">The float3x3 rotation matrix</param>
    /// <param name="translation">The translation vector</param>
    [MethodImpl(256 | 512)]
    public uint4x4(uint3x3 rotation, uint3 translation)
    {
        #if NET8_0_OR_GREATER
        c0 = new(rotation.c0.vector);
        c1 = new(rotation.c1.vector);
        c2 = new(rotation.c2.vector);
        #else // NET8_0_OR_GREATER
        c0 = new(rotation.c0, default);
        c1 = new(rotation.c1, default);
        c2 = new(rotation.c2, default);
        #endif // NET8_0_OR_GREATER
        c3 = new(translation, 1u);
    }

    /// <summary>Returns a float4x4 scale matrix given 3 axis scales</summary>
    /// <param name="s">The uniform scaling factor</param>
    /// <returns>The float4x4 matrix that represents a uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static uint4x4 Scale(uint s) => new(
        s,    default, default, default,
        default, s,    default, default,
        default, default, s,    default,
        default, default, default, 1u
    );

    /// <summary>Returns a float4x4 scale matrix given a float3 vector containing the 3 axis scales</summary>
    /// <param name="x">The x-axis scaling factor</param>
    /// <param name="y">The y-axis scaling factor</param>
    /// <param name="z">The z-axis scaling factor</param>
    /// <returns>The float4x4 matrix that represents a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static uint4x4 Scale(uint x, uint y, uint z) => new(
        x,    default, default, default,
        default, y,    default, default,
        default, default, z,    default,
        default, default, default, 1u
    );

    /// <summary>Returns a float4x4 scale matrix given a float3 vector containing the 3 axis scales</summary>
    /// <param name="scales">The vector containing scale factors for each axis</param>
    /// <returns>The float4x4 matrix that represents a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static uint4x4 Scale(uint3 scales) => Scale(scales.x, scales.y, scales.z);

    /// <summary>Returns a float4x4 translation matrix given a float3 translation vector</summary>
    /// <param name="vector">The translation vector</param>
    /// <returns>The float4x4 translation matrix</returns>
    [MethodImpl(256 | 512)]
    public static uint4x4 Translate(uint3 vector) => new(
        new(1u, default, default, default),
        new(default, 1u, default, default),
        new(default, default, 1u, default),
        new(vector, 1u)
    );
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint3 rotate(this uint4x4 a, uint3 b) 
        => b.xxxx.fma(a.c0, b.yyyy.fma(a.c1, b.zzzz * a.c2)).xyz;
        // (a.c0 * b.x + a.c1 * b.y + a.c2 * b.z).xyz;

    [MethodImpl(256 | 512)]
    public static uint3 transform(this uint4x4 a, uint3 b) 
        => b.xxxx.fma(a.c0, b.yyyy.fma(a.c1, b.zzzz.fma(a.c2, a.c3))).xyz;
        // (a.c0 * b.x + a.c1 * b.y + a.c2 * b.z + a.c3).xyz;
}

#endregion // uint4x4

#region long4x4

public partial struct long4x4
{
    /// <summary>Constructs a float4x4 from a float3x3 rotation matrix and a float3 translation vector</summary>
    /// <param name="rotation">The float3x3 rotation matrix</param>
    /// <param name="translation">The translation vector</param>
    [MethodImpl(256 | 512)]
    public long4x4(long3x3 rotation, long3 translation)
    {
        #if NET8_0_OR_GREATER
        c0 = new(rotation.c0.vector);
        c1 = new(rotation.c1.vector);
        c2 = new(rotation.c2.vector);
        #else // NET8_0_OR_GREATER
        c0 = new(rotation.c0, default);
        c1 = new(rotation.c1, default);
        c2 = new(rotation.c2, default);
        #endif // NET8_0_OR_GREATER
        c3 = new(translation, 1L);
    }

    /// <summary>Returns a float4x4 scale matrix given 3 axis scales</summary>
    /// <param name="s">The uniform scaling factor</param>
    /// <returns>The float4x4 matrix that represents a uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static long4x4 Scale(long s) => new(
        s,    default, default, default,
        default, s,    default, default,
        default, default, s,    default,
        default, default, default, 1L
    );

    /// <summary>Returns a float4x4 scale matrix given a float3 vector containing the 3 axis scales</summary>
    /// <param name="x">The x-axis scaling factor</param>
    /// <param name="y">The y-axis scaling factor</param>
    /// <param name="z">The z-axis scaling factor</param>
    /// <returns>The float4x4 matrix that represents a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static long4x4 Scale(long x, long y, long z) => new(
        x,    default, default, default,
        default, y,    default, default,
        default, default, z,    default,
        default, default, default, 1L
    );

    /// <summary>Returns a float4x4 scale matrix given a float3 vector containing the 3 axis scales</summary>
    /// <param name="scales">The vector containing scale factors for each axis</param>
    /// <returns>The float4x4 matrix that represents a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static long4x4 Scale(long3 scales) => Scale(scales.x, scales.y, scales.z);

    /// <summary>Returns a float4x4 translation matrix given a float3 translation vector</summary>
    /// <param name="vector">The translation vector</param>
    /// <returns>The float4x4 translation matrix</returns>
    [MethodImpl(256 | 512)]
    public static long4x4 Translate(long3 vector) => new(
        new(1L, default, default, default),
        new(default, 1L, default, default),
        new(default, default, 1L, default),
        new(vector, 1L)
    );
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long3 rotate(this long4x4 a, long3 b) 
        => b.xxxx.fma(a.c0, b.yyyy.fma(a.c1, b.zzzz * a.c2)).xyz;
        // (a.c0 * b.x + a.c1 * b.y + a.c2 * b.z).xyz;

    [MethodImpl(256 | 512)]
    public static long3 transform(this long4x4 a, long3 b) 
        => b.xxxx.fma(a.c0, b.yyyy.fma(a.c1, b.zzzz.fma(a.c2, a.c3))).xyz;
        // (a.c0 * b.x + a.c1 * b.y + a.c2 * b.z + a.c3).xyz;
}

#endregion // long4x4

#region ulong4x4

public partial struct ulong4x4
{
    /// <summary>Constructs a float4x4 from a float3x3 rotation matrix and a float3 translation vector</summary>
    /// <param name="rotation">The float3x3 rotation matrix</param>
    /// <param name="translation">The translation vector</param>
    [MethodImpl(256 | 512)]
    public ulong4x4(ulong3x3 rotation, ulong3 translation)
    {
        #if NET8_0_OR_GREATER
        c0 = new(rotation.c0.vector);
        c1 = new(rotation.c1.vector);
        c2 = new(rotation.c2.vector);
        #else // NET8_0_OR_GREATER
        c0 = new(rotation.c0, default);
        c1 = new(rotation.c1, default);
        c2 = new(rotation.c2, default);
        #endif // NET8_0_OR_GREATER
        c3 = new(translation, 1UL);
    }

    /// <summary>Returns a float4x4 scale matrix given 3 axis scales</summary>
    /// <param name="s">The uniform scaling factor</param>
    /// <returns>The float4x4 matrix that represents a uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static ulong4x4 Scale(ulong s) => new(
        s,    default, default, default,
        default, s,    default, default,
        default, default, s,    default,
        default, default, default, 1UL
    );

    /// <summary>Returns a float4x4 scale matrix given a float3 vector containing the 3 axis scales</summary>
    /// <param name="x">The x-axis scaling factor</param>
    /// <param name="y">The y-axis scaling factor</param>
    /// <param name="z">The z-axis scaling factor</param>
    /// <returns>The float4x4 matrix that represents a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static ulong4x4 Scale(ulong x, ulong y, ulong z) => new(
        x,    default, default, default,
        default, y,    default, default,
        default, default, z,    default,
        default, default, default, 1UL
    );

    /// <summary>Returns a float4x4 scale matrix given a float3 vector containing the 3 axis scales</summary>
    /// <param name="scales">The vector containing scale factors for each axis</param>
    /// <returns>The float4x4 matrix that represents a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static ulong4x4 Scale(ulong3 scales) => Scale(scales.x, scales.y, scales.z);

    /// <summary>Returns a float4x4 translation matrix given a float3 translation vector</summary>
    /// <param name="vector">The translation vector</param>
    /// <returns>The float4x4 translation matrix</returns>
    [MethodImpl(256 | 512)]
    public static ulong4x4 Translate(ulong3 vector) => new(
        new(1UL, default, default, default),
        new(default, 1UL, default, default),
        new(default, default, 1UL, default),
        new(vector, 1UL)
    );
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong3 rotate(this ulong4x4 a, ulong3 b) 
        => b.xxxx.fma(a.c0, b.yyyy.fma(a.c1, b.zzzz * a.c2)).xyz;
        // (a.c0 * b.x + a.c1 * b.y + a.c2 * b.z).xyz;

    [MethodImpl(256 | 512)]
    public static ulong3 transform(this ulong4x4 a, ulong3 b) 
        => b.xxxx.fma(a.c0, b.yyyy.fma(a.c1, b.zzzz.fma(a.c2, a.c3))).xyz;
        // (a.c0 * b.x + a.c1 * b.y + a.c2 * b.z + a.c3).xyz;
}

#endregion // ulong4x4

#region decimal4x4

public partial struct decimal4x4
{
    /// <summary>Constructs a float4x4 from a float3x3 rotation matrix and a float3 translation vector</summary>
    /// <param name="rotation">The float3x3 rotation matrix</param>
    /// <param name="translation">The translation vector</param>
    [MethodImpl(256 | 512)]
    public decimal4x4(decimal3x3 rotation, decimal3 translation)
    {
        c0 = new(rotation.c0, default);
        c1 = new(rotation.c1, default);
        c2 = new(rotation.c2, default);
        c3 = new(translation, 1m);
    }

    /// <summary>Returns a float4x4 scale matrix given 3 axis scales</summary>
    /// <param name="s">The uniform scaling factor</param>
    /// <returns>The float4x4 matrix that represents a uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static decimal4x4 Scale(decimal s) => new(
        s,    default, default, default,
        default, s,    default, default,
        default, default, s,    default,
        default, default, default, 1m
    );

    /// <summary>Returns a float4x4 scale matrix given a float3 vector containing the 3 axis scales</summary>
    /// <param name="x">The x-axis scaling factor</param>
    /// <param name="y">The y-axis scaling factor</param>
    /// <param name="z">The z-axis scaling factor</param>
    /// <returns>The float4x4 matrix that represents a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static decimal4x4 Scale(decimal x, decimal y, decimal z) => new(
        x,    default, default, default,
        default, y,    default, default,
        default, default, z,    default,
        default, default, default, 1m
    );

    /// <summary>Returns a float4x4 scale matrix given a float3 vector containing the 3 axis scales</summary>
    /// <param name="scales">The vector containing scale factors for each axis</param>
    /// <returns>The float4x4 matrix that represents a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static decimal4x4 Scale(decimal3 scales) => Scale(scales.x, scales.y, scales.z);

    /// <summary>Returns a float4x4 translation matrix given a float3 translation vector</summary>
    /// <param name="vector">The translation vector</param>
    /// <returns>The float4x4 translation matrix</returns>
    [MethodImpl(256 | 512)]
    public static decimal4x4 Translate(decimal3 vector) => new(
        new(1m, default, default, default),
        new(default, 1m, default, default),
        new(default, default, 1m, default),
        new(vector, 1m)
    );
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static decimal3 rotate(this decimal4x4 a, decimal3 b) 
        => b.xxxx.fma(a.c0, b.yyyy.fma(a.c1, b.zzzz * a.c2)).xyz;
        // (a.c0 * b.x + a.c1 * b.y + a.c2 * b.z).xyz;

    [MethodImpl(256 | 512)]
    public static decimal3 transform(this decimal4x4 a, decimal3 b) 
        => b.xxxx.fma(a.c0, b.yyyy.fma(a.c1, b.zzzz.fma(a.c2, a.c3))).xyz;
        // (a.c0 * b.x + a.c1 * b.y + a.c2 * b.z + a.c3).xyz;
}

#endregion // decimal4x4

#region half4x4

public partial struct half4x4
{
    /// <summary>Constructs a float4x4 from a float3x3 rotation matrix and a float3 translation vector</summary>
    /// <param name="rotation">The float3x3 rotation matrix</param>
    /// <param name="translation">The translation vector</param>
    [MethodImpl(256 | 512)]
    public half4x4(half3x3 rotation, half3 translation)
    {
        c0 = new(rotation.c0, default);
        c1 = new(rotation.c1, default);
        c2 = new(rotation.c2, default);
        c3 = new(translation, (half)1.0);
    }

    /// <summary>
    /// Returns a float4x4 matrix representing a rotation around a unit axis by an angle in radians
    /// The rotation direction is clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="axis">The axis of rotation</param>
    /// <param name="angle">The angle of rotation in radians</param>
    /// <returns>The float4x4 matrix representing the rotation about an axis</returns>
    [MethodImpl(256 | 512)]
    public static half4x4 AxisAngle(half3 axis, half angle)
    {
        angle.sincos(out var sina, out var cosa);
        var u = new half4(axis, default);
        var u_inv_cosa = u - u * cosa; // u * (1 - cosa);
        var t = new half4(u.xyz * sina, cosa);

        var ppnp = new ushort4(default, default, 0x8000, default).ashalf();
        var nppp = new ushort4(0x8000, default, default, default).ashalf();
        var pnpp = new ushort4(default, 0x8000, default, default).ashalf();
        var mask = new short4(-1, -1, -1, default).ashalf();

        return new(
            u.xxxx.fma(u_inv_cosa, (t.wzyx ^ ppnp) & mask),
            u.yyyy.fma(u_inv_cosa, (t.zwxx ^ nppp) & mask),
            u.zzzz.fma(u_inv_cosa, (t.yxwx ^ pnpp) & mask),
            new(default, default, default, (half)1.0)
        );
    }

    /// <summary>
    /// Returns a float4x4 rotation matrix constructed by first performing a rotation around the x-axis, then the y-axis and finally the z-axis
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The float4x4 rotation matrix of the Euler angle rotation in x-y-z order</returns>
    [MethodImpl(256 | 512)]
    public static half4x4 EulerXYZ(half3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (half)(c.y * c.z),  (half)(c.z * s.x * s.y - c.x * s.z),    (half)(c.x * c.z * s.y + s.x * s.z),    default,
            (half)(c.y * s.z),  (half)(c.x * c.z + s.x * s.y * s.z),    (half)(c.x * s.y * s.z - c.z * s.x),    default,
            (half)(-s.y),       (half)(c.y * s.x),                      (half)(c.x * c.y),                      default,
            default,                        default,                        default,       (half)1.0
        );
    }

    /// <summary>
    /// Returns a float4x4 rotation matrix constructed by first performing a rotation around the x-axis, then the z-axis and finally the y-axis
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The float4x4 rotation matrix of the Euler angle rotation in x-z-y order</returns>
    [MethodImpl(256 | 512)]
    public static half4x4 EulerXZY(half3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (half)(c.y * c.z),  (half)(s.x * s.y - c.x * c.y * s.z),    (half)(c.x * s.y + c.y * s.x * s.z),    default,
            (half)(s.z),        (half)(c.x * c.z),                      (half)(-c.z * s.x),                     default,
            (half)(-c.z * s.y), (half)(c.y * s.x + c.x * s.y * s.z),    (half)(c.x * c.y - s.x * s.y * s.z),    default,
            default,                        default,                        default,       (half)1.0
        );
    }

    /// <summary>
    /// Returns a float4x4 rotation matrix constructed by first performing a rotation around the y-axis, then the x-axis and finally the z-axis
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The float4x4 rotation matrix of the Euler angle rotation in y-x-z order</returns>
    [MethodImpl(256 | 512)]
    public static half4x4 EulerYXZ(half3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (half)(c.y * c.z - s.x * s.y * s.z),    (half)(-c.x * s.z), (half)(c.z * s.y + c.y * s.x * s.z),    default,
            (half)(c.z * s.x * s.y + c.y * s.z),    (half)(c.x * c.z),  (half)(s.y * s.z - c.y * c.z * s.x),    default,
            (half)(-c.x * s.y),                     (half)(s.x),        (half)(c.x * c.y),                      default,
            default,                        default,                        default,       (half)1.0
        );
    }

    /// <summary>
    /// Returns a float4x4 rotation matrix constructed by first performing a rotation around the y-axis, then the z-axis and finally the x-axis
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The float4x4 rotation matrix of the Euler angle rotation in y-z-x order</returns>
    [MethodImpl(256 | 512)]
    public static half4x4 EulerYZX(half3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (half)(c.y * c.z),                      (half)(-s.z),       (half)(c.z * s.y),                      default,
            (half)(s.x * s.y + c.x * c.y * s.z),    (half)(c.x * c.z),  (half)(c.x * s.y * s.z - c.y * s.x),    default,
            (half)(c.y * s.x * s.z - c.x * s.y),    (half)(c.z * s.x),  (half)(c.x * c.y + s.x * s.y * s.z),    default,
            default,                        default,                        default,       (half)1.0
        );
    }

    /// <summary>
    /// Returns a float4x4 rotation matrix constructed by first performing a rotation around the z-axis, then the x-axis and finally the y-axis
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin
    /// This is the default order rotation order in Unity
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The float4x4 rotation matrix of the Euler angle rotation in z-x-y order</returns>
    [MethodImpl(256 | 512)]
    public static half4x4 EulerZXY(half3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (half)(c.y * c.z + s.x * s.y * s.z),    (half)(c.z * s.x * s.y - c.y * s.z),    (half)(c.x * s.y),  default,
            (half)(c.x * s.z),                      (half)(c.x * c.z),                      (half)(-s.x),       default,
            (half)(c.y * s.x * s.z - c.z * s.y),    (half)(c.y * c.z * s.x + s.y * s.z),    (half)(c.x * c.y),  default,
            default,                        default,                        default,       (half)1.0
        );
    }

    /// <summary>
    /// Returns a float4x4 rotation matrix constructed by first performing a rotation around the z-axis, then the y-axis and finally the x-axis
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The float4x4 rotation matrix of the Euler angle rotation in z-y-x order</returns>
    [MethodImpl(256 | 512)]
    public static half4x4 EulerZYX(half3 xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            (half)(c.y * c.z),                      (half)(-c.y * s.z),                     (half)(s.y),        default,
            (half)(c.z * s.x * s.y + c.x * s.z),    (half)(c.x * c.z - s.x * s.y * s.z),    (half)(-c.y * s.x), default,
            (half)(s.x * s.z - c.x * c.z * s.y),    (half)(c.z * s.x + c.x * s.y * s.z),    (half)(c.x * c.y),  default,
            default,                        default,                        default,       (half)1.0
        );
    }

    /// <summary>Returns a float4x4 matrix that rotates around the x-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the x-axis towards the origin in radians</param>
    /// <returns>The float4x4 rotation matrix that rotates around the x-axis</returns>
    [MethodImpl(256 | 512)]
    public static half4x4 RotateX(half angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            (half)1.0, default, default, default,
            default, c,     -s,    default,
            default, s,     c,     default,
            default, default, default, (half)1.0
        );
    }

    /// <summary>Returns a float4x4 matrix that rotates around the y-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the y-axis towards the origin in radians</param>
    /// <returns>The float4x4 rotation matrix that rotates around the y-axis</returns>
    [MethodImpl(256 | 512)]
    public static half4x4 RotateY(half angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            c,     default, s,     default,
            default, (half)1.0, default, default,
            -s,    default, c,     default,
            default, default, default, (half)1.0
        );
    }

    /// <summary>Returns a float4x4 matrix that rotates around the z-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the z-axis towards the origin in radians</param>
    /// <returns>The float4x4 rotation matrix that rotates around the z-axis</returns>
    [MethodImpl(256 | 512)]
    public static half4x4 RotateZ(half angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            c,     -s,    default, default,
            s,     c,     default, default,
            default, default, (half)1.0, default,
            default, default, default, (half)1.0
        );
    }

    /// <summary>Returns a float4x4 scale matrix given 3 axis scales</summary>
    /// <param name="s">The uniform scaling factor</param>
    /// <returns>The float4x4 matrix that represents a uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static half4x4 Scale(half s) => new(
        s,    default, default, default,
        default, s,    default, default,
        default, default, s,    default,
        default, default, default, (half)1.0
    );

    /// <summary>Returns a float4x4 scale matrix given a float3 vector containing the 3 axis scales</summary>
    /// <param name="x">The x-axis scaling factor</param>
    /// <param name="y">The y-axis scaling factor</param>
    /// <param name="z">The z-axis scaling factor</param>
    /// <returns>The float4x4 matrix that represents a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static half4x4 Scale(half x, half y, half z) => new(
        x,    default, default, default,
        default, y,    default, default,
        default, default, z,    default,
        default, default, default, (half)1.0
    );

    /// <summary>Returns a float4x4 scale matrix given a float3 vector containing the 3 axis scales</summary>
    /// <param name="scales">The vector containing scale factors for each axis</param>
    /// <returns>The float4x4 matrix that represents a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static half4x4 Scale(half3 scales) => Scale(scales.x, scales.y, scales.z);

    /// <summary>Returns a float4x4 translation matrix given a float3 translation vector</summary>
    /// <param name="vector">The translation vector</param>
    /// <returns>The float4x4 translation matrix</returns>
    [MethodImpl(256 | 512)]
    public static half4x4 Translate(half3 vector) => new(
        new((half)1.0, default, default, default),
        new(default, (half)1.0, default, default),
        new(default, default, (half)1.0, default),
        new(vector, (half)1.0)
    );
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half3 rotate(this half4x4 a, half3 b) 
        => b.xxxx.fma(a.c0, b.yyyy.fma(a.c1, b.zzzz * a.c2)).xyz;
        // (a.c0 * b.x + a.c1 * b.y + a.c2 * b.z).xyz;

    [MethodImpl(256 | 512)]
    public static half3 transform(this half4x4 a, half3 b) 
        => b.xxxx.fma(a.c0, b.yyyy.fma(a.c1, b.zzzz.fma(a.c2, a.c3))).xyz;
        // (a.c0 * b.x + a.c1 * b.y + a.c2 * b.z + a.c3).xyz;
}

#endregion // half4x4
