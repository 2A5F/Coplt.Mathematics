<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics;
<#
    foreach (var typ in Typ.Typs)
    {
        if (!typ.arith) continue;

        for (var i = 2; i <= 4; i++)
        {
            var typeName = $"{typ.name}{i}";

            var byteSize = typ.size * (i is 3 ? 4 : i);
            var bitSize = 8 * byteSize;
#>

#region <#= typeName #>

public partial struct <#= typeName #>
{
    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator +(<#= typeName #> a) => a;
<#
            if (typ.sig)
            {
#>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator -(<#= typeName #> a)
    {
<#
                if (typ.simd)
                {
#>
        #if NET8_0_OR_GREATER
        return new(-a.vector<#
                    if (i == 3)
                    {
#> & Vector<#= bitSize #>.Create(-1, -1, -1, 0).As<#= typ.Type #>()<#
                    }
#>);
        #else // NET8_0_OR_GREATER
<#
                }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"{typ.arithCast}(-a.{Typ.xyzw[n]})")) #>);
<#
                if (typ.simd)
                {
#>
        #endif // NET8_0_OR_GREATER
<#
                }
#>
    }
<#
            }
#>

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator +(<#= typeName #> a, <#= typeName #> b)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(a.vector + b.vector);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"({typ.compType})(a.{Typ.xyzw[n]} + b.{Typ.xyzw[n]})")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator -(<#= typeName #> a, <#= typeName #> b)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(a.vector - b.vector);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"({typ.compType})(a.{Typ.xyzw[n]} - b.{Typ.xyzw[n]})")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator *(<#= typeName #> a, <#= typeName #> b)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(a.vector * b.vector);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"({typ.compType})(a.{Typ.xyzw[n]} * b.{Typ.xyzw[n]})")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator *(<#= typ.compType #> a, <#= typeName #> b)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(a * b.vector);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"({typ.compType})(a * b.{Typ.xyzw[n]})")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator *(<#= typeName #> a, <#= typ.compType #> b)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(a.vector * b);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"({typ.compType})(a.{Typ.xyzw[n]} * b)")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator /(<#= typeName #> a, <#= typeName #> b)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new((a.vector / b.vector)<#
                if (i == 3 && typ.f)
                {
#> & Vector<#= bitSize #>.Create(-1, -1, -1, 0).As<#= typ.Type #>()<#
                }
#>);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"({typ.compType})(a.{Typ.xyzw[n]} / b.{Typ.xyzw[n]})")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator /(<#= typeName #> a, <#= typ.compType #> b)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new((a.vector / b)<#
                if (i == 3 && typ.f)
                {
#> & Vector<#= bitSize #>.Create(-1, -1, -1, 0).As<#= typ.Type #>()<#
                }
#>);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"({typ.compType})(a.{Typ.xyzw[n]} / b)")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator %(<#= typeName #> a, <#= typeName #> b)
    {
<#
            if (typ.simd && typ.f)
            {
#>
        #if NET8_0_OR_GREATER
        return new(simd.Mod(a.vector, b.vector)<#
                if (i == 3 && typ.f)
                {
#> & Vector<#= bitSize #>.Create(-1, -1, -1, 0).As<#= typ.Type #>()<#
                }
#>);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"({typ.compType})(a.{Typ.xyzw[n]} % b.{Typ.xyzw[n]})")) #>);
<#
            if (typ.simd && typ.f)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator %(<#= typeName #> a, <#= typ.compType #> b)
    {
<#
            if (typ.simd && typ.f)
            {
#>
        #if NET8_0_OR_GREATER
        return new(simd.Mod(a.vector, b)<#
                if (i == 3 && typ.f)
                {
#> & Vector<#= bitSize #>.Create(-1, -1, -1, 0).As<#= typ.Type #>()<#
                }
#>);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"({typ.compType})(a.{Typ.xyzw[n]} % b)")) #>);
<#
            if (typ.simd && typ.f)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator --(<#= typeName #> a) => a - One;

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator ++(<#= typeName #> a) => a + One;
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static <#= typeName #> abs(this <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(Vector<#= bitSize #>.Abs(a.vector));
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.abs()")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> sign(this <#= typeName #> a)
    {
<#
            if (typ.simd && (typ.f || typ.i))
            {
#>
        #if NET8_0_OR_GREATER
        return new(<#
                if (typ.f)
                {
#>simd.SignFloat(a.vector)<#
                }
                else if (typ.sig)
                {
#>simd.SignInt(a.vector)<#
                }
                else
                {
#>simd.SignUInt(a.vector)<#
                }
#><#
                if (i == 3)
                {
#> & Vector<#= bitSize #>.Create(-1, -1, -1, 0).As<#= typ.Type #>()<#
                }
#>);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.sign()")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> min(this <#= typeName #> a, <#= typeName #> b)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(Vector<#= bitSize #>.Min(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.min(b.{Typ.xyzw[n]})")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> max(this <#= typeName #> a, <#= typeName #> b)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(Vector<#= bitSize #>.Max(a.vector, b.vector));
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.max(b.{Typ.xyzw[n]})")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> clamp(this <#= typeName #> v, <#= typeName #> min, <#= typeName #> max)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(Vector<#= bitSize #>.Max(min.vector, Vector<#= bitSize #>.Min(max.vector, v.vector)));
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"v.{Typ.xyzw[n]}.clamp(min.{Typ.xyzw[n]}, max.{Typ.xyzw[n]})")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typ.simdComp #> dot(this <#= typeName #> a, <#= typeName #> b)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return Vector<#= bitSize #>.Dot(a.vector, b.vector);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return (<#= typ.simdComp #>)(<#= string.Join(" + ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]} * b.{Typ.xyzw[n]}")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }
<#
            if (i == 3)
            {
#>

    [MethodImpl(256 | 512)]
    public static <#= typeName #> cross(this <#= typeName #> a, <#= typeName #> b) => (a * b.yzx - a.yzx * b).yzx;
<#
            }
#>

    [MethodImpl(256 | 512)]
    public static <#= typ.simdComp #> lengthsq(this <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return Vector<#= bitSize #>.Dot(a.vector, a.vector);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return a.dot(a);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typ.simdComp #> distancesq(this <#= typeName #> a, <#= typeName #> b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> square(this <#= typeName #> a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> fma(this <#= typeName #> a, <#= typeName #> b, <#= typeName #> c)
    {
<#
            if (typ.simd && typ.f && typ.bin)
            {
#>
        #if NET8_0_OR_GREATER
        return new(simd.Fma(a.vector, b.vector, c.vector));
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.fma(b.{Typ.xyzw[n]}, c.{Typ.xyzw[n]})")) #>);
<#
            if (typ.simd && typ.f && typ.bin)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> fms(this <#= typeName #> a, <#= typeName #> b, <#= typeName #> c)
    {
<#
            if (typ.simd && typ.f && typ.bin)
            {
#>
        #if NET8_0_OR_GREATER
        return new(simd.Fms(a.vector, b.vector, c.vector));
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.fms(b.{Typ.xyzw[n]}, c.{Typ.xyzw[n]})")) #>);
<#
            if (typ.simd && typ.f && typ.bin)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }
}

#endregion // <#= typeName #>
<#
        }
    }
#>
