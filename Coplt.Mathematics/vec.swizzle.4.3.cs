// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region float4

public partial struct float4 
{
    public float3 xxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
#endif // NET8_0_OR_GREATER
    }
    public float3 rrr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
#endif // NET8_0_OR_GREATER
    }
    public float3 xxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
#endif // NET8_0_OR_GREATER
    }
    public float3 rrg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
#endif // NET8_0_OR_GREATER
    }
    public float3 xxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
#endif // NET8_0_OR_GREATER
    }
    public float3 rrb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
#endif // NET8_0_OR_GREATER
    }
    public float3 xxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, w);
#endif // NET8_0_OR_GREATER
    }
    public float3 rra
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, w);
#endif // NET8_0_OR_GREATER
    }
    public float3 xyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
#endif // NET8_0_OR_GREATER
    }
    public float3 rgr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
#endif // NET8_0_OR_GREATER
    }
    public float3 xyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
#endif // NET8_0_OR_GREATER
    }
    public float3 rgg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
#endif // NET8_0_OR_GREATER
    }
    public float3 xyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(vector & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsSingle(), 
            vector,
            value.vector
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 rgb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(vector & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsSingle(), 
            vector,
            value.vector
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 xyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 rga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 xzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
#endif // NET8_0_OR_GREATER
    }
    public float3 rbr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
#endif // NET8_0_OR_GREATER
    }
    public float3 xzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 rbg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 xzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
#endif // NET8_0_OR_GREATER
    }
    public float3 rbb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
#endif // NET8_0_OR_GREATER
    }
    public float3 xzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 rba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 xwx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, x);
#endif // NET8_0_OR_GREATER
    }
    public float3 rar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, x);
#endif // NET8_0_OR_GREATER
    }
    public float3 xwy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 rag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 xwz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 rab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 xww
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, w);
#endif // NET8_0_OR_GREATER
    }
    public float3 raa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, w);
#endif // NET8_0_OR_GREATER
    }
    public float3 yxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
#endif // NET8_0_OR_GREATER
    }
    public float3 grr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
#endif // NET8_0_OR_GREATER
    }
    public float3 yxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
#endif // NET8_0_OR_GREATER
    }
    public float3 grg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
#endif // NET8_0_OR_GREATER
    }
    public float3 yxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 grb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 yxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 gra
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 yyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
#endif // NET8_0_OR_GREATER
    }
    public float3 ggr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
#endif // NET8_0_OR_GREATER
    }
    public float3 yyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
#endif // NET8_0_OR_GREATER
    }
    public float3 ggg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
#endif // NET8_0_OR_GREATER
    }
    public float3 yyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
#endif // NET8_0_OR_GREATER
    }
    public float3 ggb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
#endif // NET8_0_OR_GREATER
    }
    public float3 yyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, w);
#endif // NET8_0_OR_GREATER
    }
    public float3 gga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, w);
#endif // NET8_0_OR_GREATER
    }
    public float3 yzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 gbr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 yzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
#endif // NET8_0_OR_GREATER
    }
    public float3 gbg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
#endif // NET8_0_OR_GREATER
    }
    public float3 yzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
#endif // NET8_0_OR_GREATER
    }
    public float3 gbb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
#endif // NET8_0_OR_GREATER
    }
    public float3 yzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 gba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 ywx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 gar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 ywy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, y);
#endif // NET8_0_OR_GREATER
    }
    public float3 gag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, y);
#endif // NET8_0_OR_GREATER
    }
    public float3 ywz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 gab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 yww
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, w);
#endif // NET8_0_OR_GREATER
    }
    public float3 gaa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, w);
#endif // NET8_0_OR_GREATER
    }
    public float3 zxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
#endif // NET8_0_OR_GREATER
    }
    public float3 brr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
#endif // NET8_0_OR_GREATER
    }
    public float3 zxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 brg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 zxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
#endif // NET8_0_OR_GREATER
    }
    public float3 brb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
#endif // NET8_0_OR_GREATER
    }
    public float3 zxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 bra
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 zyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 bgr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 zyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
#endif // NET8_0_OR_GREATER
    }
    public float3 bgg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
#endif // NET8_0_OR_GREATER
    }
    public float3 zyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
#endif // NET8_0_OR_GREATER
    }
    public float3 bgb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
#endif // NET8_0_OR_GREATER
    }
    public float3 zyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 bga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 zzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
#endif // NET8_0_OR_GREATER
    }
    public float3 bbr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
#endif // NET8_0_OR_GREATER
    }
    public float3 zzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
#endif // NET8_0_OR_GREATER
    }
    public float3 bbg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
#endif // NET8_0_OR_GREATER
    }
    public float3 zzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
#endif // NET8_0_OR_GREATER
    }
    public float3 bbb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
#endif // NET8_0_OR_GREATER
    }
    public float3 zzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, w);
#endif // NET8_0_OR_GREATER
    }
    public float3 bba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, w);
#endif // NET8_0_OR_GREATER
    }
    public float3 zwx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 bar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 zwy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 bag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 zwz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, z);
#endif // NET8_0_OR_GREATER
    }
    public float3 bab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, z);
#endif // NET8_0_OR_GREATER
    }
    public float3 zww
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, w);
#endif // NET8_0_OR_GREATER
    }
    public float3 baa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, w);
#endif // NET8_0_OR_GREATER
    }
    public float3 wxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, x);
#endif // NET8_0_OR_GREATER
    }
    public float3 arr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, x);
#endif // NET8_0_OR_GREATER
    }
    public float3 wxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 arg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 wxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 arb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 wxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, w);
#endif // NET8_0_OR_GREATER
    }
    public float3 ara
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, w);
#endif // NET8_0_OR_GREATER
    }
    public float3 wyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 agr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 wyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, y);
#endif // NET8_0_OR_GREATER
    }
    public float3 agg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, y);
#endif // NET8_0_OR_GREATER
    }
    public float3 wyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 1, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 1, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 agb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 1, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 1, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 wyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, w);
#endif // NET8_0_OR_GREATER
    }
    public float3 aga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, w);
#endif // NET8_0_OR_GREATER
    }
    public float3 wzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 abr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 wzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 abg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsSingle(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public float3 wzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, z);
#endif // NET8_0_OR_GREATER
    }
    public float3 abb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, z);
#endif // NET8_0_OR_GREATER
    }
    public float3 wzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, w);
#endif // NET8_0_OR_GREATER
    }
    public float3 aba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, w);
#endif // NET8_0_OR_GREATER
    }
    public float3 wwx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, x);
#endif // NET8_0_OR_GREATER
    }
    public float3 aar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, x);
#endif // NET8_0_OR_GREATER
    }
    public float3 wwy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, y);
#endif // NET8_0_OR_GREATER
    }
    public float3 aag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, y);
#endif // NET8_0_OR_GREATER
    }
    public float3 wwz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, z);
#endif // NET8_0_OR_GREATER
    }
    public float3 aab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, z);
#endif // NET8_0_OR_GREATER
    }
    public float3 www
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, w);
#endif // NET8_0_OR_GREATER
    }
    public float3 aaa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsSingle());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, w);
#endif // NET8_0_OR_GREATER
    }
}

#endregion // float4

#region double4

public partial struct double4 
{
    public double3 xxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
#endif // NET8_0_OR_GREATER
    }
    public double3 rrr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
#endif // NET8_0_OR_GREATER
    }
    public double3 xxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
#endif // NET8_0_OR_GREATER
    }
    public double3 rrg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
#endif // NET8_0_OR_GREATER
    }
    public double3 xxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
#endif // NET8_0_OR_GREATER
    }
    public double3 rrb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
#endif // NET8_0_OR_GREATER
    }
    public double3 xxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, w);
#endif // NET8_0_OR_GREATER
    }
    public double3 rra
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, w);
#endif // NET8_0_OR_GREATER
    }
    public double3 xyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
#endif // NET8_0_OR_GREATER
    }
    public double3 rgr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
#endif // NET8_0_OR_GREATER
    }
    public double3 xyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
#endif // NET8_0_OR_GREATER
    }
    public double3 rgg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
#endif // NET8_0_OR_GREATER
    }
    public double3 xyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(vector & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsDouble(), 
            vector,
            value.vector
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 rgb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(vector & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsDouble(), 
            vector,
            value.vector
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 xyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 rga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 xzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
#endif // NET8_0_OR_GREATER
    }
    public double3 rbr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
#endif // NET8_0_OR_GREATER
    }
    public double3 xzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 rbg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 xzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
#endif // NET8_0_OR_GREATER
    }
    public double3 rbb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
#endif // NET8_0_OR_GREATER
    }
    public double3 xzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 rba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 xwx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, x);
#endif // NET8_0_OR_GREATER
    }
    public double3 rar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, x);
#endif // NET8_0_OR_GREATER
    }
    public double3 xwy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 rag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 xwz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 rab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 xww
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, w);
#endif // NET8_0_OR_GREATER
    }
    public double3 raa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, w);
#endif // NET8_0_OR_GREATER
    }
    public double3 yxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
#endif // NET8_0_OR_GREATER
    }
    public double3 grr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
#endif // NET8_0_OR_GREATER
    }
    public double3 yxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
#endif // NET8_0_OR_GREATER
    }
    public double3 grg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
#endif // NET8_0_OR_GREATER
    }
    public double3 yxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 grb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 yxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 gra
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 yyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
#endif // NET8_0_OR_GREATER
    }
    public double3 ggr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
#endif // NET8_0_OR_GREATER
    }
    public double3 yyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
#endif // NET8_0_OR_GREATER
    }
    public double3 ggg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
#endif // NET8_0_OR_GREATER
    }
    public double3 yyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
#endif // NET8_0_OR_GREATER
    }
    public double3 ggb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
#endif // NET8_0_OR_GREATER
    }
    public double3 yyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, w);
#endif // NET8_0_OR_GREATER
    }
    public double3 gga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, w);
#endif // NET8_0_OR_GREATER
    }
    public double3 yzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 gbr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 yzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
#endif // NET8_0_OR_GREATER
    }
    public double3 gbg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
#endif // NET8_0_OR_GREATER
    }
    public double3 yzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
#endif // NET8_0_OR_GREATER
    }
    public double3 gbb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
#endif // NET8_0_OR_GREATER
    }
    public double3 yzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 gba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 ywx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 gar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 ywy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, y);
#endif // NET8_0_OR_GREATER
    }
    public double3 gag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, y);
#endif // NET8_0_OR_GREATER
    }
    public double3 ywz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 gab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 yww
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, w);
#endif // NET8_0_OR_GREATER
    }
    public double3 gaa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, w);
#endif // NET8_0_OR_GREATER
    }
    public double3 zxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
#endif // NET8_0_OR_GREATER
    }
    public double3 brr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
#endif // NET8_0_OR_GREATER
    }
    public double3 zxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 brg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 zxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
#endif // NET8_0_OR_GREATER
    }
    public double3 brb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
#endif // NET8_0_OR_GREATER
    }
    public double3 zxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 bra
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 zyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 bgr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 zyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
#endif // NET8_0_OR_GREATER
    }
    public double3 bgg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
#endif // NET8_0_OR_GREATER
    }
    public double3 zyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
#endif // NET8_0_OR_GREATER
    }
    public double3 bgb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
#endif // NET8_0_OR_GREATER
    }
    public double3 zyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 bga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 zzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
#endif // NET8_0_OR_GREATER
    }
    public double3 bbr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
#endif // NET8_0_OR_GREATER
    }
    public double3 zzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
#endif // NET8_0_OR_GREATER
    }
    public double3 bbg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
#endif // NET8_0_OR_GREATER
    }
    public double3 zzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
#endif // NET8_0_OR_GREATER
    }
    public double3 bbb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
#endif // NET8_0_OR_GREATER
    }
    public double3 zzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, w);
#endif // NET8_0_OR_GREATER
    }
    public double3 bba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, w);
#endif // NET8_0_OR_GREATER
    }
    public double3 zwx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 bar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 zwy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 bag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 zwz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, z);
#endif // NET8_0_OR_GREATER
    }
    public double3 bab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, z);
#endif // NET8_0_OR_GREATER
    }
    public double3 zww
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, w);
#endif // NET8_0_OR_GREATER
    }
    public double3 baa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, w);
#endif // NET8_0_OR_GREATER
    }
    public double3 wxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, x);
#endif // NET8_0_OR_GREATER
    }
    public double3 arr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, x);
#endif // NET8_0_OR_GREATER
    }
    public double3 wxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 arg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 wxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 arb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 wxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, w);
#endif // NET8_0_OR_GREATER
    }
    public double3 ara
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, w);
#endif // NET8_0_OR_GREATER
    }
    public double3 wyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 agr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 wyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, y);
#endif // NET8_0_OR_GREATER
    }
    public double3 agg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, y);
#endif // NET8_0_OR_GREATER
    }
    public double3 wyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 1, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 1, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 agb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 1, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 1, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 wyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, w);
#endif // NET8_0_OR_GREATER
    }
    public double3 aga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, w);
#endif // NET8_0_OR_GREATER
    }
    public double3 wzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 abr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 wzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 abg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsDouble(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public double3 wzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, z);
#endif // NET8_0_OR_GREATER
    }
    public double3 abb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, z);
#endif // NET8_0_OR_GREATER
    }
    public double3 wzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, w);
#endif // NET8_0_OR_GREATER
    }
    public double3 aba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, w);
#endif // NET8_0_OR_GREATER
    }
    public double3 wwx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, x);
#endif // NET8_0_OR_GREATER
    }
    public double3 aar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, x);
#endif // NET8_0_OR_GREATER
    }
    public double3 wwy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, y);
#endif // NET8_0_OR_GREATER
    }
    public double3 aag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, y);
#endif // NET8_0_OR_GREATER
    }
    public double3 wwz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, z);
#endif // NET8_0_OR_GREATER
    }
    public double3 aab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, z);
#endif // NET8_0_OR_GREATER
    }
    public double3 www
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, w);
#endif // NET8_0_OR_GREATER
    }
    public double3 aaa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsDouble());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, w);
#endif // NET8_0_OR_GREATER
    }
}

#endregion // double4

#region short4

public partial struct short4 
{
    public short3 xxx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
    }
    public short3 rrr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
    }
    public short3 xxy
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
    }
    public short3 rrg
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
    }
    public short3 xxz
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
    }
    public short3 rrb
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
    }
    public short3 xxw
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, w);
    }
    public short3 rra
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, w);
    }
    public short3 xyx
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
    }
    public short3 rgr
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
    }
    public short3 xyy
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
    }
    public short3 rgg
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
    }
    public short3 xyz
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; z = value.z; }
    }
    public short3 rgb
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; z = value.z; }
    }
    public short3 xyw
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; w = value.z; }
    }
    public short3 rga
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; w = value.z; }
    }
    public short3 xzx
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
    }
    public short3 rbr
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
    }
    public short3 xzy
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; y = value.z; }
    }
    public short3 rbg
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; y = value.z; }
    }
    public short3 xzz
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
    }
    public short3 rbb
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
    }
    public short3 xzw
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; w = value.z; }
    }
    public short3 rba
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; w = value.z; }
    }
    public short3 xwx
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, x);
    }
    public short3 rar
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, x);
    }
    public short3 xwy
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; y = value.z; }
    }
    public short3 rag
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; y = value.z; }
    }
    public short3 xwz
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; z = value.z; }
    }
    public short3 rab
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; z = value.z; }
    }
    public short3 xww
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, w);
    }
    public short3 raa
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, w);
    }
    public short3 yxx
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
    }
    public short3 grr
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
    }
    public short3 yxy
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
    }
    public short3 grg
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
    }
    public short3 yxz
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; z = value.z; }
    }
    public short3 grb
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; z = value.z; }
    }
    public short3 yxw
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; w = value.z; }
    }
    public short3 gra
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; w = value.z; }
    }
    public short3 yyx
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
    }
    public short3 ggr
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
    }
    public short3 yyy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
    }
    public short3 ggg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
    }
    public short3 yyz
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
    }
    public short3 ggb
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
    }
    public short3 yyw
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, w);
    }
    public short3 gga
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, w);
    }
    public short3 yzx
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; x = value.z; }
    }
    public short3 gbr
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; x = value.z; }
    }
    public short3 yzy
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
    }
    public short3 gbg
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
    }
    public short3 yzz
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
    }
    public short3 gbb
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
    }
    public short3 yzw
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; w = value.z; }
    }
    public short3 gba
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; w = value.z; }
    }
    public short3 ywx
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; x = value.z; }
    }
    public short3 gar
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; x = value.z; }
    }
    public short3 ywy
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, y);
    }
    public short3 gag
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, y);
    }
    public short3 ywz
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; z = value.z; }
    }
    public short3 gab
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; z = value.z; }
    }
    public short3 yww
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, w);
    }
    public short3 gaa
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, w);
    }
    public short3 zxx
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
    }
    public short3 brr
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
    }
    public short3 zxy
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; y = value.z; }
    }
    public short3 brg
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; y = value.z; }
    }
    public short3 zxz
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
    }
    public short3 brb
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
    }
    public short3 zxw
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; w = value.z; }
    }
    public short3 bra
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; w = value.z; }
    }
    public short3 zyx
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; x = value.z; }
    }
    public short3 bgr
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; x = value.z; }
    }
    public short3 zyy
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
    }
    public short3 bgg
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
    }
    public short3 zyz
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
    }
    public short3 bgb
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
    }
    public short3 zyw
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; w = value.z; }
    }
    public short3 bga
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; w = value.z; }
    }
    public short3 zzx
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
    }
    public short3 bbr
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
    }
    public short3 zzy
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
    }
    public short3 bbg
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
    }
    public short3 zzz
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
    }
    public short3 bbb
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
    }
    public short3 zzw
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, w);
    }
    public short3 bba
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, w);
    }
    public short3 zwx
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; x = value.z; }
    }
    public short3 bar
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; x = value.z; }
    }
    public short3 zwy
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; y = value.z; }
    }
    public short3 bag
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; y = value.z; }
    }
    public short3 zwz
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, z);
    }
    public short3 bab
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, z);
    }
    public short3 zww
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, w);
    }
    public short3 baa
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, w);
    }
    public short3 wxx
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, x);
    }
    public short3 arr
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, x);
    }
    public short3 wxy
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; y = value.z; }
    }
    public short3 arg
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; y = value.z; }
    }
    public short3 wxz
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; z = value.z; }
    }
    public short3 arb
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; z = value.z; }
    }
    public short3 wxw
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, w);
    }
    public short3 ara
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, w);
    }
    public short3 wyx
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; x = value.z; }
    }
    public short3 agr
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; x = value.z; }
    }
    public short3 wyy
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, y);
    }
    public short3 agg
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, y);
    }
    public short3 wyz
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; z = value.z; }
    }
    public short3 agb
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; z = value.z; }
    }
    public short3 wyw
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, w);
    }
    public short3 aga
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, w);
    }
    public short3 wzx
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; x = value.z; }
    }
    public short3 abr
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; x = value.z; }
    }
    public short3 wzy
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; y = value.z; }
    }
    public short3 abg
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; y = value.z; }
    }
    public short3 wzz
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, z);
    }
    public short3 abb
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, z);
    }
    public short3 wzw
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, w);
    }
    public short3 aba
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, w);
    }
    public short3 wwx
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, x);
    }
    public short3 aar
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, x);
    }
    public short3 wwy
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, y);
    }
    public short3 aag
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, y);
    }
    public short3 wwz
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, z);
    }
    public short3 aab
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, z);
    }
    public short3 www
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, w);
    }
    public short3 aaa
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, w);
    }
}

#endregion // short4

#region ushort4

public partial struct ushort4 
{
    public ushort3 xxx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
    }
    public ushort3 rrr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
    }
    public ushort3 xxy
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
    }
    public ushort3 rrg
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
    }
    public ushort3 xxz
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
    }
    public ushort3 rrb
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
    }
    public ushort3 xxw
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, w);
    }
    public ushort3 rra
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, w);
    }
    public ushort3 xyx
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
    }
    public ushort3 rgr
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
    }
    public ushort3 xyy
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
    }
    public ushort3 rgg
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
    }
    public ushort3 xyz
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; z = value.z; }
    }
    public ushort3 rgb
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; z = value.z; }
    }
    public ushort3 xyw
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; w = value.z; }
    }
    public ushort3 rga
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; w = value.z; }
    }
    public ushort3 xzx
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
    }
    public ushort3 rbr
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
    }
    public ushort3 xzy
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; y = value.z; }
    }
    public ushort3 rbg
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; y = value.z; }
    }
    public ushort3 xzz
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
    }
    public ushort3 rbb
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
    }
    public ushort3 xzw
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; w = value.z; }
    }
    public ushort3 rba
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; w = value.z; }
    }
    public ushort3 xwx
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, x);
    }
    public ushort3 rar
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, x);
    }
    public ushort3 xwy
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; y = value.z; }
    }
    public ushort3 rag
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; y = value.z; }
    }
    public ushort3 xwz
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; z = value.z; }
    }
    public ushort3 rab
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; z = value.z; }
    }
    public ushort3 xww
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, w);
    }
    public ushort3 raa
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, w);
    }
    public ushort3 yxx
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
    }
    public ushort3 grr
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
    }
    public ushort3 yxy
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
    }
    public ushort3 grg
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
    }
    public ushort3 yxz
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; z = value.z; }
    }
    public ushort3 grb
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; z = value.z; }
    }
    public ushort3 yxw
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; w = value.z; }
    }
    public ushort3 gra
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; w = value.z; }
    }
    public ushort3 yyx
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
    }
    public ushort3 ggr
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
    }
    public ushort3 yyy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
    }
    public ushort3 ggg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
    }
    public ushort3 yyz
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
    }
    public ushort3 ggb
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
    }
    public ushort3 yyw
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, w);
    }
    public ushort3 gga
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, w);
    }
    public ushort3 yzx
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; x = value.z; }
    }
    public ushort3 gbr
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; x = value.z; }
    }
    public ushort3 yzy
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
    }
    public ushort3 gbg
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
    }
    public ushort3 yzz
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
    }
    public ushort3 gbb
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
    }
    public ushort3 yzw
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; w = value.z; }
    }
    public ushort3 gba
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; w = value.z; }
    }
    public ushort3 ywx
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; x = value.z; }
    }
    public ushort3 gar
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; x = value.z; }
    }
    public ushort3 ywy
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, y);
    }
    public ushort3 gag
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, y);
    }
    public ushort3 ywz
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; z = value.z; }
    }
    public ushort3 gab
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; z = value.z; }
    }
    public ushort3 yww
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, w);
    }
    public ushort3 gaa
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, w);
    }
    public ushort3 zxx
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
    }
    public ushort3 brr
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
    }
    public ushort3 zxy
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; y = value.z; }
    }
    public ushort3 brg
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; y = value.z; }
    }
    public ushort3 zxz
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
    }
    public ushort3 brb
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
    }
    public ushort3 zxw
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; w = value.z; }
    }
    public ushort3 bra
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; w = value.z; }
    }
    public ushort3 zyx
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; x = value.z; }
    }
    public ushort3 bgr
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; x = value.z; }
    }
    public ushort3 zyy
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
    }
    public ushort3 bgg
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
    }
    public ushort3 zyz
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
    }
    public ushort3 bgb
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
    }
    public ushort3 zyw
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; w = value.z; }
    }
    public ushort3 bga
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; w = value.z; }
    }
    public ushort3 zzx
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
    }
    public ushort3 bbr
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
    }
    public ushort3 zzy
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
    }
    public ushort3 bbg
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
    }
    public ushort3 zzz
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
    }
    public ushort3 bbb
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
    }
    public ushort3 zzw
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, w);
    }
    public ushort3 bba
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, w);
    }
    public ushort3 zwx
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; x = value.z; }
    }
    public ushort3 bar
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; x = value.z; }
    }
    public ushort3 zwy
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; y = value.z; }
    }
    public ushort3 bag
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; y = value.z; }
    }
    public ushort3 zwz
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, z);
    }
    public ushort3 bab
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, z);
    }
    public ushort3 zww
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, w);
    }
    public ushort3 baa
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, w);
    }
    public ushort3 wxx
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, x);
    }
    public ushort3 arr
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, x);
    }
    public ushort3 wxy
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; y = value.z; }
    }
    public ushort3 arg
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; y = value.z; }
    }
    public ushort3 wxz
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; z = value.z; }
    }
    public ushort3 arb
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; z = value.z; }
    }
    public ushort3 wxw
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, w);
    }
    public ushort3 ara
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, w);
    }
    public ushort3 wyx
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; x = value.z; }
    }
    public ushort3 agr
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; x = value.z; }
    }
    public ushort3 wyy
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, y);
    }
    public ushort3 agg
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, y);
    }
    public ushort3 wyz
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; z = value.z; }
    }
    public ushort3 agb
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; z = value.z; }
    }
    public ushort3 wyw
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, w);
    }
    public ushort3 aga
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, w);
    }
    public ushort3 wzx
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; x = value.z; }
    }
    public ushort3 abr
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; x = value.z; }
    }
    public ushort3 wzy
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; y = value.z; }
    }
    public ushort3 abg
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; y = value.z; }
    }
    public ushort3 wzz
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, z);
    }
    public ushort3 abb
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, z);
    }
    public ushort3 wzw
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, w);
    }
    public ushort3 aba
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, w);
    }
    public ushort3 wwx
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, x);
    }
    public ushort3 aar
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, x);
    }
    public ushort3 wwy
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, y);
    }
    public ushort3 aag
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, y);
    }
    public ushort3 wwz
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, z);
    }
    public ushort3 aab
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, z);
    }
    public ushort3 www
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, w);
    }
    public ushort3 aaa
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, w);
    }
}

#endregion // ushort4

#region int4

public partial struct int4 
{
    public int3 xxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
#endif // NET8_0_OR_GREATER
    }
    public int3 rrr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
#endif // NET8_0_OR_GREATER
    }
    public int3 xxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
#endif // NET8_0_OR_GREATER
    }
    public int3 rrg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
#endif // NET8_0_OR_GREATER
    }
    public int3 xxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
#endif // NET8_0_OR_GREATER
    }
    public int3 rrb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
#endif // NET8_0_OR_GREATER
    }
    public int3 xxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, w);
#endif // NET8_0_OR_GREATER
    }
    public int3 rra
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, w);
#endif // NET8_0_OR_GREATER
    }
    public int3 xyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
#endif // NET8_0_OR_GREATER
    }
    public int3 rgr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
#endif // NET8_0_OR_GREATER
    }
    public int3 xyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
#endif // NET8_0_OR_GREATER
    }
    public int3 rgg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
#endif // NET8_0_OR_GREATER
    }
    public int3 xyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(vector & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsInt32(), 
            vector,
            value.vector
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 rgb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(vector & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsInt32(), 
            vector,
            value.vector
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 xyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 rga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 xzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
#endif // NET8_0_OR_GREATER
    }
    public int3 rbr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
#endif // NET8_0_OR_GREATER
    }
    public int3 xzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 rbg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 xzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
#endif // NET8_0_OR_GREATER
    }
    public int3 rbb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
#endif // NET8_0_OR_GREATER
    }
    public int3 xzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 rba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 xwx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, x);
#endif // NET8_0_OR_GREATER
    }
    public int3 rar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, x);
#endif // NET8_0_OR_GREATER
    }
    public int3 xwy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 rag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 xwz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 rab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 xww
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, w);
#endif // NET8_0_OR_GREATER
    }
    public int3 raa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(0, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, w);
#endif // NET8_0_OR_GREATER
    }
    public int3 yxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
#endif // NET8_0_OR_GREATER
    }
    public int3 grr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
#endif // NET8_0_OR_GREATER
    }
    public int3 yxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
#endif // NET8_0_OR_GREATER
    }
    public int3 grg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
#endif // NET8_0_OR_GREATER
    }
    public int3 yxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 grb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 yxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 gra
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 yyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
#endif // NET8_0_OR_GREATER
    }
    public int3 ggr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
#endif // NET8_0_OR_GREATER
    }
    public int3 yyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
#endif // NET8_0_OR_GREATER
    }
    public int3 ggg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
#endif // NET8_0_OR_GREATER
    }
    public int3 yyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
#endif // NET8_0_OR_GREATER
    }
    public int3 ggb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
#endif // NET8_0_OR_GREATER
    }
    public int3 yyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, w);
#endif // NET8_0_OR_GREATER
    }
    public int3 gga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, w);
#endif // NET8_0_OR_GREATER
    }
    public int3 yzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 gbr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 yzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
#endif // NET8_0_OR_GREATER
    }
    public int3 gbg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
#endif // NET8_0_OR_GREATER
    }
    public int3 yzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
#endif // NET8_0_OR_GREATER
    }
    public int3 gbb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
#endif // NET8_0_OR_GREATER
    }
    public int3 yzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 gba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 ywx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 gar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 ywy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, y);
#endif // NET8_0_OR_GREATER
    }
    public int3 gag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, y);
#endif // NET8_0_OR_GREATER
    }
    public int3 ywz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 gab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 yww
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, w);
#endif // NET8_0_OR_GREATER
    }
    public int3 gaa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(1, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, w);
#endif // NET8_0_OR_GREATER
    }
    public int3 zxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
#endif // NET8_0_OR_GREATER
    }
    public int3 brr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
#endif // NET8_0_OR_GREATER
    }
    public int3 zxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 brg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 zxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
#endif // NET8_0_OR_GREATER
    }
    public int3 brb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
#endif // NET8_0_OR_GREATER
    }
    public int3 zxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 bra
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 zyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 bgr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 zyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
#endif // NET8_0_OR_GREATER
    }
    public int3 bgg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
#endif // NET8_0_OR_GREATER
    }
    public int3 zyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
#endif // NET8_0_OR_GREATER
    }
    public int3 bgb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
#endif // NET8_0_OR_GREATER
    }
    public int3 zyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 bga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 zzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
#endif // NET8_0_OR_GREATER
    }
    public int3 bbr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
#endif // NET8_0_OR_GREATER
    }
    public int3 zzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
#endif // NET8_0_OR_GREATER
    }
    public int3 bbg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
#endif // NET8_0_OR_GREATER
    }
    public int3 zzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
#endif // NET8_0_OR_GREATER
    }
    public int3 bbb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
#endif // NET8_0_OR_GREATER
    }
    public int3 zzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, w);
#endif // NET8_0_OR_GREATER
    }
    public int3 bba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, w);
#endif // NET8_0_OR_GREATER
    }
    public int3 zwx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 bar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 zwy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 bag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 zwz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, z);
#endif // NET8_0_OR_GREATER
    }
    public int3 bab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, z);
#endif // NET8_0_OR_GREATER
    }
    public int3 zww
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, w);
#endif // NET8_0_OR_GREATER
    }
    public int3 baa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(2, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, w);
#endif // NET8_0_OR_GREATER
    }
    public int3 wxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, x);
#endif // NET8_0_OR_GREATER
    }
    public int3 arr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, x);
#endif // NET8_0_OR_GREATER
    }
    public int3 wxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 arg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 wxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 arb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 wxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, w);
#endif // NET8_0_OR_GREATER
    }
    public int3 ara
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, w);
#endif // NET8_0_OR_GREATER
    }
    public int3 wyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 agr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 wyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, y);
#endif // NET8_0_OR_GREATER
    }
    public int3 agg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, y);
#endif // NET8_0_OR_GREATER
    }
    public int3 wyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 1, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 1, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 agb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 1, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 1, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 wyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, w);
#endif // NET8_0_OR_GREATER
    }
    public int3 aga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, w);
#endif // NET8_0_OR_GREATER
    }
    public int3 wzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 abr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 wzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 abg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create(0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public int3 wzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, z);
#endif // NET8_0_OR_GREATER
    }
    public int3 abb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, z);
#endif // NET8_0_OR_GREATER
    }
    public int3 wzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, w);
#endif // NET8_0_OR_GREATER
    }
    public int3 aba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, w);
#endif // NET8_0_OR_GREATER
    }
    public int3 wwx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, x);
#endif // NET8_0_OR_GREATER
    }
    public int3 aar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, x);
#endif // NET8_0_OR_GREATER
    }
    public int3 wwy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, y);
#endif // NET8_0_OR_GREATER
    }
    public int3 aag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, y);
#endif // NET8_0_OR_GREATER
    }
    public int3 wwz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, z);
#endif // NET8_0_OR_GREATER
    }
    public int3 aab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, z);
#endif // NET8_0_OR_GREATER
    }
    public int3 www
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, w);
#endif // NET8_0_OR_GREATER
    }
    public int3 aaa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create(3, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, w);
#endif // NET8_0_OR_GREATER
    }
}

#endregion // int4

#region uint4

public partial struct uint4 
{
    public uint3 xxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
#endif // NET8_0_OR_GREATER
    }
    public uint3 rrr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
#endif // NET8_0_OR_GREATER
    }
    public uint3 xxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
#endif // NET8_0_OR_GREATER
    }
    public uint3 rrg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
#endif // NET8_0_OR_GREATER
    }
    public uint3 xxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
#endif // NET8_0_OR_GREATER
    }
    public uint3 rrb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
#endif // NET8_0_OR_GREATER
    }
    public uint3 xxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, w);
#endif // NET8_0_OR_GREATER
    }
    public uint3 rra
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, w);
#endif // NET8_0_OR_GREATER
    }
    public uint3 xyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
#endif // NET8_0_OR_GREATER
    }
    public uint3 rgr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
#endif // NET8_0_OR_GREATER
    }
    public uint3 xyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
#endif // NET8_0_OR_GREATER
    }
    public uint3 rgg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
#endif // NET8_0_OR_GREATER
    }
    public uint3 xyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(vector & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsUInt32(), 
            vector,
            value.vector
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 rgb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(vector & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsUInt32(), 
            vector,
            value.vector
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 xyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 rga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 xzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
#endif // NET8_0_OR_GREATER
    }
    public uint3 rbr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
#endif // NET8_0_OR_GREATER
    }
    public uint3 xzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 rbg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 xzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
#endif // NET8_0_OR_GREATER
    }
    public uint3 rbb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
#endif // NET8_0_OR_GREATER
    }
    public uint3 xzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 rba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 xwx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, x);
#endif // NET8_0_OR_GREATER
    }
    public uint3 rar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, x);
#endif // NET8_0_OR_GREATER
    }
    public uint3 xwy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 rag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 xwz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 rab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 xww
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, w);
#endif // NET8_0_OR_GREATER
    }
    public uint3 raa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, w);
#endif // NET8_0_OR_GREATER
    }
    public uint3 yxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
#endif // NET8_0_OR_GREATER
    }
    public uint3 grr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
#endif // NET8_0_OR_GREATER
    }
    public uint3 yxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
#endif // NET8_0_OR_GREATER
    }
    public uint3 grg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
#endif // NET8_0_OR_GREATER
    }
    public uint3 yxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 grb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 yxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 gra
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 yyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
#endif // NET8_0_OR_GREATER
    }
    public uint3 ggr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
#endif // NET8_0_OR_GREATER
    }
    public uint3 yyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
#endif // NET8_0_OR_GREATER
    }
    public uint3 ggg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
#endif // NET8_0_OR_GREATER
    }
    public uint3 yyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
#endif // NET8_0_OR_GREATER
    }
    public uint3 ggb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
#endif // NET8_0_OR_GREATER
    }
    public uint3 yyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, w);
#endif // NET8_0_OR_GREATER
    }
    public uint3 gga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, w);
#endif // NET8_0_OR_GREATER
    }
    public uint3 yzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 gbr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 yzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
#endif // NET8_0_OR_GREATER
    }
    public uint3 gbg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
#endif // NET8_0_OR_GREATER
    }
    public uint3 yzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
#endif // NET8_0_OR_GREATER
    }
    public uint3 gbb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
#endif // NET8_0_OR_GREATER
    }
    public uint3 yzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 gba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 ywx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 gar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 ywy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, y);
#endif // NET8_0_OR_GREATER
    }
    public uint3 gag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, y);
#endif // NET8_0_OR_GREATER
    }
    public uint3 ywz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 gab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 yww
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, w);
#endif // NET8_0_OR_GREATER
    }
    public uint3 gaa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, w);
#endif // NET8_0_OR_GREATER
    }
    public uint3 zxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
#endif // NET8_0_OR_GREATER
    }
    public uint3 brr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
#endif // NET8_0_OR_GREATER
    }
    public uint3 zxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 brg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 zxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
#endif // NET8_0_OR_GREATER
    }
    public uint3 brb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
#endif // NET8_0_OR_GREATER
    }
    public uint3 zxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 bra
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 zyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 bgr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 zyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
#endif // NET8_0_OR_GREATER
    }
    public uint3 bgg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
#endif // NET8_0_OR_GREATER
    }
    public uint3 zyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
#endif // NET8_0_OR_GREATER
    }
    public uint3 bgb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
#endif // NET8_0_OR_GREATER
    }
    public uint3 zyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 bga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 zzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
#endif // NET8_0_OR_GREATER
    }
    public uint3 bbr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
#endif // NET8_0_OR_GREATER
    }
    public uint3 zzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
#endif // NET8_0_OR_GREATER
    }
    public uint3 bbg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
#endif // NET8_0_OR_GREATER
    }
    public uint3 zzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
#endif // NET8_0_OR_GREATER
    }
    public uint3 bbb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
#endif // NET8_0_OR_GREATER
    }
    public uint3 zzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, w);
#endif // NET8_0_OR_GREATER
    }
    public uint3 bba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, w);
#endif // NET8_0_OR_GREATER
    }
    public uint3 zwx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 bar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 zwy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 bag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 zwz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, z);
#endif // NET8_0_OR_GREATER
    }
    public uint3 bab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, z);
#endif // NET8_0_OR_GREATER
    }
    public uint3 zww
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, w);
#endif // NET8_0_OR_GREATER
    }
    public uint3 baa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, w);
#endif // NET8_0_OR_GREATER
    }
    public uint3 wxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, x);
#endif // NET8_0_OR_GREATER
    }
    public uint3 arr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, x);
#endif // NET8_0_OR_GREATER
    }
    public uint3 wxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 arg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 wxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 arb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 wxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, w);
#endif // NET8_0_OR_GREATER
    }
    public uint3 ara
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, w);
#endif // NET8_0_OR_GREATER
    }
    public uint3 wyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 agr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 wyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, y);
#endif // NET8_0_OR_GREATER
    }
    public uint3 agg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, y);
#endif // NET8_0_OR_GREATER
    }
    public uint3 wyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 1, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 1, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 agb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 1, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 1, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 wyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, w);
#endif // NET8_0_OR_GREATER
    }
    public uint3 aga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, w);
#endif // NET8_0_OR_GREATER
    }
    public uint3 wzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 abr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 wzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 abg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public uint3 wzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, z);
#endif // NET8_0_OR_GREATER
    }
    public uint3 abb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, z);
#endif // NET8_0_OR_GREATER
    }
    public uint3 wzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, w);
#endif // NET8_0_OR_GREATER
    }
    public uint3 aba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, w);
#endif // NET8_0_OR_GREATER
    }
    public uint3 wwx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, x);
#endif // NET8_0_OR_GREATER
    }
    public uint3 aar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, x);
#endif // NET8_0_OR_GREATER
    }
    public uint3 wwy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, y);
#endif // NET8_0_OR_GREATER
    }
    public uint3 aag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, y);
#endif // NET8_0_OR_GREATER
    }
    public uint3 wwz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, z);
#endif // NET8_0_OR_GREATER
    }
    public uint3 aab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, z);
#endif // NET8_0_OR_GREATER
    }
    public uint3 www
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, w);
#endif // NET8_0_OR_GREATER
    }
    public uint3 aaa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, w);
#endif // NET8_0_OR_GREATER
    }
}

#endregion // uint4

#region long4

public partial struct long4 
{
    public long3 xxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
#endif // NET8_0_OR_GREATER
    }
    public long3 rrr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
#endif // NET8_0_OR_GREATER
    }
    public long3 xxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
#endif // NET8_0_OR_GREATER
    }
    public long3 rrg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
#endif // NET8_0_OR_GREATER
    }
    public long3 xxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
#endif // NET8_0_OR_GREATER
    }
    public long3 rrb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
#endif // NET8_0_OR_GREATER
    }
    public long3 xxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, w);
#endif // NET8_0_OR_GREATER
    }
    public long3 rra
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, w);
#endif // NET8_0_OR_GREATER
    }
    public long3 xyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
#endif // NET8_0_OR_GREATER
    }
    public long3 rgr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
#endif // NET8_0_OR_GREATER
    }
    public long3 xyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
#endif // NET8_0_OR_GREATER
    }
    public long3 rgg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
#endif // NET8_0_OR_GREATER
    }
    public long3 xyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(vector & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsInt64(), 
            vector,
            value.vector
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 rgb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(vector & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsInt64(), 
            vector,
            value.vector
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 xyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 rga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 xzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
#endif // NET8_0_OR_GREATER
    }
    public long3 rbr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
#endif // NET8_0_OR_GREATER
    }
    public long3 xzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 rbg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 xzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
#endif // NET8_0_OR_GREATER
    }
    public long3 rbb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
#endif // NET8_0_OR_GREATER
    }
    public long3 xzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 rba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 xwx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, x);
#endif // NET8_0_OR_GREATER
    }
    public long3 rar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, x);
#endif // NET8_0_OR_GREATER
    }
    public long3 xwy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 rag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 xwz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 rab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 xww
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, w);
#endif // NET8_0_OR_GREATER
    }
    public long3 raa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(0, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, w);
#endif // NET8_0_OR_GREATER
    }
    public long3 yxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
#endif // NET8_0_OR_GREATER
    }
    public long3 grr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
#endif // NET8_0_OR_GREATER
    }
    public long3 yxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
#endif // NET8_0_OR_GREATER
    }
    public long3 grg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
#endif // NET8_0_OR_GREATER
    }
    public long3 yxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 grb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 yxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 gra
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 yyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
#endif // NET8_0_OR_GREATER
    }
    public long3 ggr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
#endif // NET8_0_OR_GREATER
    }
    public long3 yyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
#endif // NET8_0_OR_GREATER
    }
    public long3 ggg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
#endif // NET8_0_OR_GREATER
    }
    public long3 yyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
#endif // NET8_0_OR_GREATER
    }
    public long3 ggb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
#endif // NET8_0_OR_GREATER
    }
    public long3 yyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, w);
#endif // NET8_0_OR_GREATER
    }
    public long3 gga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, w);
#endif // NET8_0_OR_GREATER
    }
    public long3 yzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 gbr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 yzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
#endif // NET8_0_OR_GREATER
    }
    public long3 gbg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
#endif // NET8_0_OR_GREATER
    }
    public long3 yzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
#endif // NET8_0_OR_GREATER
    }
    public long3 gbb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
#endif // NET8_0_OR_GREATER
    }
    public long3 yzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 gba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 ywx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 gar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 ywy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, y);
#endif // NET8_0_OR_GREATER
    }
    public long3 gag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, y);
#endif // NET8_0_OR_GREATER
    }
    public long3 ywz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 gab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 yww
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, w);
#endif // NET8_0_OR_GREATER
    }
    public long3 gaa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(1, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, w);
#endif // NET8_0_OR_GREATER
    }
    public long3 zxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
#endif // NET8_0_OR_GREATER
    }
    public long3 brr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
#endif // NET8_0_OR_GREATER
    }
    public long3 zxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 brg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 zxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
#endif // NET8_0_OR_GREATER
    }
    public long3 brb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
#endif // NET8_0_OR_GREATER
    }
    public long3 zxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 bra
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 zyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 bgr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 zyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
#endif // NET8_0_OR_GREATER
    }
    public long3 bgg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
#endif // NET8_0_OR_GREATER
    }
    public long3 zyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
#endif // NET8_0_OR_GREATER
    }
    public long3 bgb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
#endif // NET8_0_OR_GREATER
    }
    public long3 zyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 bga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 zzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
#endif // NET8_0_OR_GREATER
    }
    public long3 bbr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
#endif // NET8_0_OR_GREATER
    }
    public long3 zzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
#endif // NET8_0_OR_GREATER
    }
    public long3 bbg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
#endif // NET8_0_OR_GREATER
    }
    public long3 zzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
#endif // NET8_0_OR_GREATER
    }
    public long3 bbb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
#endif // NET8_0_OR_GREATER
    }
    public long3 zzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, w);
#endif // NET8_0_OR_GREATER
    }
    public long3 bba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, w);
#endif // NET8_0_OR_GREATER
    }
    public long3 zwx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 bar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 zwy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 bag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 zwz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, z);
#endif // NET8_0_OR_GREATER
    }
    public long3 bab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, z);
#endif // NET8_0_OR_GREATER
    }
    public long3 zww
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, w);
#endif // NET8_0_OR_GREATER
    }
    public long3 baa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(2, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, w);
#endif // NET8_0_OR_GREATER
    }
    public long3 wxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, x);
#endif // NET8_0_OR_GREATER
    }
    public long3 arr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, x);
#endif // NET8_0_OR_GREATER
    }
    public long3 wxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 arg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 wxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 arb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 wxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, w);
#endif // NET8_0_OR_GREATER
    }
    public long3 ara
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, w);
#endif // NET8_0_OR_GREATER
    }
    public long3 wyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 agr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 wyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, y);
#endif // NET8_0_OR_GREATER
    }
    public long3 agg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, y);
#endif // NET8_0_OR_GREATER
    }
    public long3 wyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 1, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 1, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 agb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 1, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 1, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 wyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, w);
#endif // NET8_0_OR_GREATER
    }
    public long3 aga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, w);
#endif // NET8_0_OR_GREATER
    }
    public long3 wzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 abr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 wzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 abg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create(0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public long3 wzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, z);
#endif // NET8_0_OR_GREATER
    }
    public long3 abb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, z);
#endif // NET8_0_OR_GREATER
    }
    public long3 wzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, w);
#endif // NET8_0_OR_GREATER
    }
    public long3 aba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, w);
#endif // NET8_0_OR_GREATER
    }
    public long3 wwx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, x);
#endif // NET8_0_OR_GREATER
    }
    public long3 aar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, x);
#endif // NET8_0_OR_GREATER
    }
    public long3 wwy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, y);
#endif // NET8_0_OR_GREATER
    }
    public long3 aag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, y);
#endif // NET8_0_OR_GREATER
    }
    public long3 wwz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, z);
#endif // NET8_0_OR_GREATER
    }
    public long3 aab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, z);
#endif // NET8_0_OR_GREATER
    }
    public long3 www
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, w);
#endif // NET8_0_OR_GREATER
    }
    public long3 aaa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create(3, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, w);
#endif // NET8_0_OR_GREATER
    }
}

#endregion // long4

#region ulong4

public partial struct ulong4 
{
    public ulong3 xxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 rrr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 xxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 rrg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 xxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 rrb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 xxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, w);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 rra
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, w);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 xyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 rgr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 xyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 rgg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 xyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(vector & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsUInt64(), 
            vector,
            value.vector
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 rgb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(vector & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsUInt64(), 
            vector,
            value.vector
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 xyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 rga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 xzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 rbr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 xzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 rbg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 xzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 rbb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 xzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 rba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 xwx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, x);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 rar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, x);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 xwy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 rag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 xwz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 rab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 xww
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, w);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 raa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, w);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 yxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 grr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 yxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 grg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 yxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 grb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 yxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 gra
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 yyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 ggr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 yyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 ggg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 yyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 ggb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 yyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, w);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 gga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, w);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 yzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 gbr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 yzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 gbg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 yzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 gbb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 yzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 gba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 ywx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 gar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 ywy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, y);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 gag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, y);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 ywz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 gab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 yww
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, w);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 gaa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, w);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 zxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 brr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 zxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 brg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 zxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 brb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 zxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 bra
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 zyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 bgr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 zyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 bgg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 zyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 bgb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 zyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 bga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 zzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 bbr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 zzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 bbg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 zzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 bbb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 zzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, w);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 bba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, w);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 zwx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 bar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 zwy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 bag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 zwz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, z);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 bab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, z);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 zww
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, w);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 baa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, w);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 wxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, x);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 arr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, x);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 wxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 arg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 wxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 arb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 wxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, w);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 ara
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, w);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 wyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 agr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 wyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, y);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 agg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, y);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 wyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 1, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 1, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 agb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 1, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 1, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 wyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, w);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 aga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, w);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 wzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 abr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 wzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 abg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public ulong3 wzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, z);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 abb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, z);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 wzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, w);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 aba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, w);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 wwx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, x);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 aar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, x);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 wwy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, y);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 aag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, y);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 wwz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, z);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 aab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, z);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 www
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, w);
#endif // NET8_0_OR_GREATER
    }
    public ulong3 aaa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, w);
#endif // NET8_0_OR_GREATER
    }
}

#endregion // ulong4

#region decimal4

public partial struct decimal4 
{
    public decimal3 xxx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
    }
    public decimal3 rrr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
    }
    public decimal3 xxy
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
    }
    public decimal3 rrg
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
    }
    public decimal3 xxz
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
    }
    public decimal3 rrb
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
    }
    public decimal3 xxw
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, w);
    }
    public decimal3 rra
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, w);
    }
    public decimal3 xyx
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
    }
    public decimal3 rgr
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
    }
    public decimal3 xyy
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
    }
    public decimal3 rgg
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
    }
    public decimal3 xyz
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; z = value.z; }
    }
    public decimal3 rgb
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; z = value.z; }
    }
    public decimal3 xyw
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; w = value.z; }
    }
    public decimal3 rga
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; w = value.z; }
    }
    public decimal3 xzx
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
    }
    public decimal3 rbr
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
    }
    public decimal3 xzy
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; y = value.z; }
    }
    public decimal3 rbg
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; y = value.z; }
    }
    public decimal3 xzz
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
    }
    public decimal3 rbb
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
    }
    public decimal3 xzw
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; w = value.z; }
    }
    public decimal3 rba
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; w = value.z; }
    }
    public decimal3 xwx
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, x);
    }
    public decimal3 rar
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, x);
    }
    public decimal3 xwy
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; y = value.z; }
    }
    public decimal3 rag
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; y = value.z; }
    }
    public decimal3 xwz
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; z = value.z; }
    }
    public decimal3 rab
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; z = value.z; }
    }
    public decimal3 xww
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, w);
    }
    public decimal3 raa
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, w);
    }
    public decimal3 yxx
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
    }
    public decimal3 grr
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
    }
    public decimal3 yxy
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
    }
    public decimal3 grg
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
    }
    public decimal3 yxz
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; z = value.z; }
    }
    public decimal3 grb
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; z = value.z; }
    }
    public decimal3 yxw
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; w = value.z; }
    }
    public decimal3 gra
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; w = value.z; }
    }
    public decimal3 yyx
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
    }
    public decimal3 ggr
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
    }
    public decimal3 yyy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
    }
    public decimal3 ggg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
    }
    public decimal3 yyz
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
    }
    public decimal3 ggb
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
    }
    public decimal3 yyw
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, w);
    }
    public decimal3 gga
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, w);
    }
    public decimal3 yzx
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; x = value.z; }
    }
    public decimal3 gbr
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; x = value.z; }
    }
    public decimal3 yzy
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
    }
    public decimal3 gbg
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
    }
    public decimal3 yzz
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
    }
    public decimal3 gbb
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
    }
    public decimal3 yzw
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; w = value.z; }
    }
    public decimal3 gba
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; w = value.z; }
    }
    public decimal3 ywx
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; x = value.z; }
    }
    public decimal3 gar
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; x = value.z; }
    }
    public decimal3 ywy
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, y);
    }
    public decimal3 gag
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, y);
    }
    public decimal3 ywz
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; z = value.z; }
    }
    public decimal3 gab
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; z = value.z; }
    }
    public decimal3 yww
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, w);
    }
    public decimal3 gaa
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, w);
    }
    public decimal3 zxx
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
    }
    public decimal3 brr
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
    }
    public decimal3 zxy
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; y = value.z; }
    }
    public decimal3 brg
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; y = value.z; }
    }
    public decimal3 zxz
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
    }
    public decimal3 brb
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
    }
    public decimal3 zxw
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; w = value.z; }
    }
    public decimal3 bra
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; w = value.z; }
    }
    public decimal3 zyx
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; x = value.z; }
    }
    public decimal3 bgr
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; x = value.z; }
    }
    public decimal3 zyy
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
    }
    public decimal3 bgg
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
    }
    public decimal3 zyz
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
    }
    public decimal3 bgb
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
    }
    public decimal3 zyw
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; w = value.z; }
    }
    public decimal3 bga
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; w = value.z; }
    }
    public decimal3 zzx
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
    }
    public decimal3 bbr
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
    }
    public decimal3 zzy
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
    }
    public decimal3 bbg
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
    }
    public decimal3 zzz
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
    }
    public decimal3 bbb
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
    }
    public decimal3 zzw
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, w);
    }
    public decimal3 bba
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, w);
    }
    public decimal3 zwx
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; x = value.z; }
    }
    public decimal3 bar
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; x = value.z; }
    }
    public decimal3 zwy
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; y = value.z; }
    }
    public decimal3 bag
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; y = value.z; }
    }
    public decimal3 zwz
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, z);
    }
    public decimal3 bab
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, z);
    }
    public decimal3 zww
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, w);
    }
    public decimal3 baa
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, w);
    }
    public decimal3 wxx
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, x);
    }
    public decimal3 arr
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, x);
    }
    public decimal3 wxy
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; y = value.z; }
    }
    public decimal3 arg
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; y = value.z; }
    }
    public decimal3 wxz
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; z = value.z; }
    }
    public decimal3 arb
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; z = value.z; }
    }
    public decimal3 wxw
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, w);
    }
    public decimal3 ara
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, w);
    }
    public decimal3 wyx
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; x = value.z; }
    }
    public decimal3 agr
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; x = value.z; }
    }
    public decimal3 wyy
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, y);
    }
    public decimal3 agg
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, y);
    }
    public decimal3 wyz
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; z = value.z; }
    }
    public decimal3 agb
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; z = value.z; }
    }
    public decimal3 wyw
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, w);
    }
    public decimal3 aga
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, w);
    }
    public decimal3 wzx
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; x = value.z; }
    }
    public decimal3 abr
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; x = value.z; }
    }
    public decimal3 wzy
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; y = value.z; }
    }
    public decimal3 abg
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; y = value.z; }
    }
    public decimal3 wzz
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, z);
    }
    public decimal3 abb
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, z);
    }
    public decimal3 wzw
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, w);
    }
    public decimal3 aba
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, w);
    }
    public decimal3 wwx
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, x);
    }
    public decimal3 aar
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, x);
    }
    public decimal3 wwy
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, y);
    }
    public decimal3 aag
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, y);
    }
    public decimal3 wwz
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, z);
    }
    public decimal3 aab
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, z);
    }
    public decimal3 www
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, w);
    }
    public decimal3 aaa
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, w);
    }
}

#endregion // decimal4

#region half4

public partial struct half4 
{
    public half3 xxx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
    }
    public half3 rrr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
    }
    public half3 xxy
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
    }
    public half3 rrg
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
    }
    public half3 xxz
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
    }
    public half3 rrb
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
    }
    public half3 xxw
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, w);
    }
    public half3 rra
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, w);
    }
    public half3 xyx
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
    }
    public half3 rgr
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
    }
    public half3 xyy
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
    }
    public half3 rgg
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
    }
    public half3 xyz
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; z = value.z; }
    }
    public half3 rgb
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; z = value.z; }
    }
    public half3 xyw
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; w = value.z; }
    }
    public half3 rga
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; w = value.z; }
    }
    public half3 xzx
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
    }
    public half3 rbr
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
    }
    public half3 xzy
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; y = value.z; }
    }
    public half3 rbg
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; y = value.z; }
    }
    public half3 xzz
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
    }
    public half3 rbb
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
    }
    public half3 xzw
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; w = value.z; }
    }
    public half3 rba
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; w = value.z; }
    }
    public half3 xwx
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, x);
    }
    public half3 rar
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, x);
    }
    public half3 xwy
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; y = value.z; }
    }
    public half3 rag
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; y = value.z; }
    }
    public half3 xwz
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; z = value.z; }
    }
    public half3 rab
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; z = value.z; }
    }
    public half3 xww
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, w);
    }
    public half3 raa
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, w);
    }
    public half3 yxx
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
    }
    public half3 grr
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
    }
    public half3 yxy
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
    }
    public half3 grg
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
    }
    public half3 yxz
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; z = value.z; }
    }
    public half3 grb
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; z = value.z; }
    }
    public half3 yxw
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; w = value.z; }
    }
    public half3 gra
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; w = value.z; }
    }
    public half3 yyx
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
    }
    public half3 ggr
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
    }
    public half3 yyy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
    }
    public half3 ggg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
    }
    public half3 yyz
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
    }
    public half3 ggb
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
    }
    public half3 yyw
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, w);
    }
    public half3 gga
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, w);
    }
    public half3 yzx
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; x = value.z; }
    }
    public half3 gbr
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; x = value.z; }
    }
    public half3 yzy
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
    }
    public half3 gbg
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
    }
    public half3 yzz
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
    }
    public half3 gbb
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
    }
    public half3 yzw
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; w = value.z; }
    }
    public half3 gba
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; w = value.z; }
    }
    public half3 ywx
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; x = value.z; }
    }
    public half3 gar
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; x = value.z; }
    }
    public half3 ywy
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, y);
    }
    public half3 gag
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, y);
    }
    public half3 ywz
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; z = value.z; }
    }
    public half3 gab
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; z = value.z; }
    }
    public half3 yww
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, w);
    }
    public half3 gaa
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, w);
    }
    public half3 zxx
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
    }
    public half3 brr
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
    }
    public half3 zxy
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; y = value.z; }
    }
    public half3 brg
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; y = value.z; }
    }
    public half3 zxz
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
    }
    public half3 brb
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
    }
    public half3 zxw
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; w = value.z; }
    }
    public half3 bra
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; w = value.z; }
    }
    public half3 zyx
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; x = value.z; }
    }
    public half3 bgr
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; x = value.z; }
    }
    public half3 zyy
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
    }
    public half3 bgg
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
    }
    public half3 zyz
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
    }
    public half3 bgb
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
    }
    public half3 zyw
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; w = value.z; }
    }
    public half3 bga
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; w = value.z; }
    }
    public half3 zzx
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
    }
    public half3 bbr
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
    }
    public half3 zzy
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
    }
    public half3 bbg
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
    }
    public half3 zzz
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
    }
    public half3 bbb
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
    }
    public half3 zzw
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, w);
    }
    public half3 bba
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, w);
    }
    public half3 zwx
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; x = value.z; }
    }
    public half3 bar
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; x = value.z; }
    }
    public half3 zwy
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; y = value.z; }
    }
    public half3 bag
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; y = value.z; }
    }
    public half3 zwz
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, z);
    }
    public half3 bab
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, z);
    }
    public half3 zww
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, w);
    }
    public half3 baa
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, w);
    }
    public half3 wxx
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, x);
    }
    public half3 arr
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, x);
    }
    public half3 wxy
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; y = value.z; }
    }
    public half3 arg
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; y = value.z; }
    }
    public half3 wxz
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; z = value.z; }
    }
    public half3 arb
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; z = value.z; }
    }
    public half3 wxw
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, w);
    }
    public half3 ara
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, w);
    }
    public half3 wyx
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; x = value.z; }
    }
    public half3 agr
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; x = value.z; }
    }
    public half3 wyy
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, y);
    }
    public half3 agg
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, y);
    }
    public half3 wyz
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; z = value.z; }
    }
    public half3 agb
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; z = value.z; }
    }
    public half3 wyw
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, w);
    }
    public half3 aga
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, w);
    }
    public half3 wzx
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; x = value.z; }
    }
    public half3 abr
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; x = value.z; }
    }
    public half3 wzy
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; y = value.z; }
    }
    public half3 abg
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; y = value.z; }
    }
    public half3 wzz
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, z);
    }
    public half3 abb
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, z);
    }
    public half3 wzw
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, w);
    }
    public half3 aba
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, w);
    }
    public half3 wwx
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, x);
    }
    public half3 aar
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, x);
    }
    public half3 wwy
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, y);
    }
    public half3 aag
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, y);
    }
    public half3 wwz
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, z);
    }
    public half3 aab
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, z);
    }
    public half3 www
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, w);
    }
    public half3 aaa
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, w);
    }
}

#endregion // half4

#region b16v4

public partial struct b16v4 
{
    public b16v3 xxx
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
    }
    public b16v3 rrr
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
    }
    public b16v3 xxy
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
    }
    public b16v3 rrg
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
    }
    public b16v3 xxz
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
    }
    public b16v3 rrb
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
    }
    public b16v3 xxw
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, w);
    }
    public b16v3 rra
    {
        [MethodImpl(256 | 512)]
        get => new(x, x, w);
    }
    public b16v3 xyx
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
    }
    public b16v3 rgr
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
    }
    public b16v3 xyy
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
    }
    public b16v3 rgg
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
    }
    public b16v3 xyz
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; z = value.z; }
    }
    public b16v3 rgb
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; z = value.z; }
    }
    public b16v3 xyw
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; w = value.z; }
    }
    public b16v3 rga
    {
        [MethodImpl(256 | 512)]
        get => new(x, y, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; w = value.z; }
    }
    public b16v3 xzx
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
    }
    public b16v3 rbr
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
    }
    public b16v3 xzy
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; y = value.z; }
    }
    public b16v3 rbg
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; y = value.z; }
    }
    public b16v3 xzz
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
    }
    public b16v3 rbb
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
    }
    public b16v3 xzw
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; w = value.z; }
    }
    public b16v3 rba
    {
        [MethodImpl(256 | 512)]
        get => new(x, z, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; w = value.z; }
    }
    public b16v3 xwx
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, x);
    }
    public b16v3 rar
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, x);
    }
    public b16v3 xwy
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; y = value.z; }
    }
    public b16v3 rag
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; y = value.z; }
    }
    public b16v3 xwz
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; z = value.z; }
    }
    public b16v3 rab
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; z = value.z; }
    }
    public b16v3 xww
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, w);
    }
    public b16v3 raa
    {
        [MethodImpl(256 | 512)]
        get => new(x, w, w);
    }
    public b16v3 yxx
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
    }
    public b16v3 grr
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
    }
    public b16v3 yxy
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
    }
    public b16v3 grg
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
    }
    public b16v3 yxz
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; z = value.z; }
    }
    public b16v3 grb
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; z = value.z; }
    }
    public b16v3 yxw
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; w = value.z; }
    }
    public b16v3 gra
    {
        [MethodImpl(256 | 512)]
        get => new(y, x, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; w = value.z; }
    }
    public b16v3 yyx
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
    }
    public b16v3 ggr
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
    }
    public b16v3 yyy
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
    }
    public b16v3 ggg
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
    }
    public b16v3 yyz
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
    }
    public b16v3 ggb
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
    }
    public b16v3 yyw
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, w);
    }
    public b16v3 gga
    {
        [MethodImpl(256 | 512)]
        get => new(y, y, w);
    }
    public b16v3 yzx
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; x = value.z; }
    }
    public b16v3 gbr
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; x = value.z; }
    }
    public b16v3 yzy
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
    }
    public b16v3 gbg
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
    }
    public b16v3 yzz
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
    }
    public b16v3 gbb
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
    }
    public b16v3 yzw
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; w = value.z; }
    }
    public b16v3 gba
    {
        [MethodImpl(256 | 512)]
        get => new(y, z, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; w = value.z; }
    }
    public b16v3 ywx
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; x = value.z; }
    }
    public b16v3 gar
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; x = value.z; }
    }
    public b16v3 ywy
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, y);
    }
    public b16v3 gag
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, y);
    }
    public b16v3 ywz
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; z = value.z; }
    }
    public b16v3 gab
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; z = value.z; }
    }
    public b16v3 yww
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, w);
    }
    public b16v3 gaa
    {
        [MethodImpl(256 | 512)]
        get => new(y, w, w);
    }
    public b16v3 zxx
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
    }
    public b16v3 brr
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
    }
    public b16v3 zxy
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; y = value.z; }
    }
    public b16v3 brg
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; y = value.z; }
    }
    public b16v3 zxz
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
    }
    public b16v3 brb
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
    }
    public b16v3 zxw
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; w = value.z; }
    }
    public b16v3 bra
    {
        [MethodImpl(256 | 512)]
        get => new(z, x, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; w = value.z; }
    }
    public b16v3 zyx
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; x = value.z; }
    }
    public b16v3 bgr
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; x = value.z; }
    }
    public b16v3 zyy
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
    }
    public b16v3 bgg
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
    }
    public b16v3 zyz
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
    }
    public b16v3 bgb
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
    }
    public b16v3 zyw
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; w = value.z; }
    }
    public b16v3 bga
    {
        [MethodImpl(256 | 512)]
        get => new(z, y, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; w = value.z; }
    }
    public b16v3 zzx
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
    }
    public b16v3 bbr
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
    }
    public b16v3 zzy
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
    }
    public b16v3 bbg
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
    }
    public b16v3 zzz
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
    }
    public b16v3 bbb
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
    }
    public b16v3 zzw
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, w);
    }
    public b16v3 bba
    {
        [MethodImpl(256 | 512)]
        get => new(z, z, w);
    }
    public b16v3 zwx
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; x = value.z; }
    }
    public b16v3 bar
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; x = value.z; }
    }
    public b16v3 zwy
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; y = value.z; }
    }
    public b16v3 bag
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; y = value.z; }
    }
    public b16v3 zwz
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, z);
    }
    public b16v3 bab
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, z);
    }
    public b16v3 zww
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, w);
    }
    public b16v3 baa
    {
        [MethodImpl(256 | 512)]
        get => new(z, w, w);
    }
    public b16v3 wxx
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, x);
    }
    public b16v3 arr
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, x);
    }
    public b16v3 wxy
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; y = value.z; }
    }
    public b16v3 arg
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; y = value.z; }
    }
    public b16v3 wxz
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; z = value.z; }
    }
    public b16v3 arb
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; z = value.z; }
    }
    public b16v3 wxw
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, w);
    }
    public b16v3 ara
    {
        [MethodImpl(256 | 512)]
        get => new(w, x, w);
    }
    public b16v3 wyx
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; x = value.z; }
    }
    public b16v3 agr
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; x = value.z; }
    }
    public b16v3 wyy
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, y);
    }
    public b16v3 agg
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, y);
    }
    public b16v3 wyz
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; z = value.z; }
    }
    public b16v3 agb
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; z = value.z; }
    }
    public b16v3 wyw
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, w);
    }
    public b16v3 aga
    {
        [MethodImpl(256 | 512)]
        get => new(w, y, w);
    }
    public b16v3 wzx
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; x = value.z; }
    }
    public b16v3 abr
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; x = value.z; }
    }
    public b16v3 wzy
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; y = value.z; }
    }
    public b16v3 abg
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; y = value.z; }
    }
    public b16v3 wzz
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, z);
    }
    public b16v3 abb
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, z);
    }
    public b16v3 wzw
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, w);
    }
    public b16v3 aba
    {
        [MethodImpl(256 | 512)]
        get => new(w, z, w);
    }
    public b16v3 wwx
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, x);
    }
    public b16v3 aar
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, x);
    }
    public b16v3 wwy
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, y);
    }
    public b16v3 aag
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, y);
    }
    public b16v3 wwz
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, z);
    }
    public b16v3 aab
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, z);
    }
    public b16v3 www
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, w);
    }
    public b16v3 aaa
    {
        [MethodImpl(256 | 512)]
        get => new(w, w, w);
    }
}

#endregion // b16v4

#region b32v4

public partial struct b32v4 
{
    public b32v3 xxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 rrr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 xxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 rrg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 xxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 rrb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 xxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, w);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 rra
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, w);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 xyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 rgr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 xyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 rgg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 xyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(vector & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsUInt32(), 
            vector,
            value.vector
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 rgb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(vector & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsUInt32(), 
            vector,
            value.vector
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 xyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 rga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 xzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 rbr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 xzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 rbg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 xzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 rbb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 xzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 rba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 xwx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, x);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 rar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, x);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 xwy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 rag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 xwz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 rab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 xww
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, w);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 raa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)0, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, w);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 yxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 grr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 yxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 grg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 yxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 grb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 yxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 gra
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 yyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 ggr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 yyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 ggg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 yyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 ggb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 yyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, w);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 gga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, w);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 yzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 gbr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 yzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 gbg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 yzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 gbb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 yzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 gba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 ywx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 gar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 ywy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, y);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 gag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, y);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 ywz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 gab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 yww
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, w);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 gaa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)1, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, w);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 zxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 brr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 zxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 brg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 zxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 brb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 zxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 bra
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 zyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 bgr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, 0, -1).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 zyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 bgg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 zyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 bgb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 zyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 bga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 zzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 bbr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 zzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 bbg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 zzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 bbb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 zzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, w);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 bba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, w);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 zwx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 bar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 zwy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 bag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 zwz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, z);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 bab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, z);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 zww
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, w);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 baa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)2, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, w);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 wxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, x);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 arr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 0, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, x);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 wxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 arg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 0, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 wxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 arb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 0, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 wxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, w);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 ara
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 0, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, w);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 wyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 agr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 1, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, 0, -1, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 wyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, y);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 agg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 1, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, y);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 wyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 1, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 1, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 agb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 1, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 1, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 wyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, w);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 aga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 1, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, w);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 wzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 abr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 2, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(0, -1, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 wzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 abg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 2, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        [MethodImpl(256 | 512)]
        set => vector = Vector128.ConditionalSelect(
            Vector128.Create(-1, 0, 0, 0).AsUInt32(), 
            vector,
            Vector128.Shuffle(value.vector, Vector128.Create((uint)0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b32v3 wzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, z);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 abb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 2, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, z);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 wzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, w);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 aba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 2, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, w);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 wwx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, x);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 aar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 3, 0, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, x);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 wwy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, y);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 aag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 3, 1, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, y);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 wwz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, z);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 aab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 3, 2, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, z);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 www
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, w);
#endif // NET8_0_OR_GREATER
    }
    public b32v3 aaa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector128.Shuffle(vector, Vector128.Create((uint)3, 3, 3, 3)) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, w);
#endif // NET8_0_OR_GREATER
    }
}

#endregion // b32v4

#region b64v4

public partial struct b64v4 
{
    public b64v3 xxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 rrr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, x);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 xxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 rrg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, y);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 xxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 rrb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, z);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 xxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, w);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 rra
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, x, w);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 xyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 rgr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, x);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 xyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 rgg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, y);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 xyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(vector & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsUInt64(), 
            vector,
            value.vector
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 rgb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(vector & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsUInt64(), 
            vector,
            value.vector
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 xyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 rga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, y, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 xzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 rbr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, x);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 xzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 rbg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 xzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 rbb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, z);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 xzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 rba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, z, w);
        [MethodImpl(256 | 512)]
        set { x = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 xwx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, x);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 rar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, x);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 xwy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 rag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, y);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 xwz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 rab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, z);
        [MethodImpl(256 | 512)]
        set { x = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 xww
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, w);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 raa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)0, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(x, w, w);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 yxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 grr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, x);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 yxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 grg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, y);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 yxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 grb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 yxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 gra
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, x, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 yyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 ggr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, x);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 yyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 ggg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, y);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 yyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 ggb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, z);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 yyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, w);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 gga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, y, w);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 yzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 gbr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 yzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 gbg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, y);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 yzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 gbb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, z);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 yzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 gba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 0, 1, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, z, w);
        [MethodImpl(256 | 512)]
        set { y = value.x; z = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 ywx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 gar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, x);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 ywy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, y);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 gag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, y);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 ywz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 gab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 0, 2, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, z);
        [MethodImpl(256 | 512)]
        set { y = value.x; w = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 yww
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, w);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 gaa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)1, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(y, w, w);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 zxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 brr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, x);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 zxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 brg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 zxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 brb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, z);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 zxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 bra
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)1, 0, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, x, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; x = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 zyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 bgr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, 0, -1).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 zyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 bgg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, y);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 zyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 bgb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, z);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 zyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 bga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 1, 0, 2))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, y, w);
        [MethodImpl(256 | 512)]
        set { z = value.x; y = value.y; w = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 zzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 bbr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, x);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 zzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 bbg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, y);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 zzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 bbb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, z);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 zzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, w);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 bba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, z, w);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 zwx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 bar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)2, 0, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, x);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 zwy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 bag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 2, 0, 1))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, y);
        [MethodImpl(256 | 512)]
        set { z = value.x; w = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 zwz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, z);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 bab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, z);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 zww
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, w);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 baa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)2, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(z, w, w);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 wxx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, x);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 arr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 0, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, x);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 wxy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 arg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 0, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)1, 2, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 wxz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 arb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 0, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)1, 0, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; x = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 wxw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, w);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 ara
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 0, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, x, w);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 wyx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 agr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 1, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, 0, -1, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)2, 1, 0, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 wyy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, y);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 agg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 1, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, y);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 wyz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 1, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 1, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 agb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 1, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 1, 2, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, z);
        [MethodImpl(256 | 512)]
        set { w = value.x; y = value.y; z = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 wyw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, w);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 aga
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 1, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, y, w);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 wzx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 abr
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 2, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(0, -1, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)2, 0, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, x);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; x = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 wzy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 abg
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 2, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        [MethodImpl(256 | 512)]
        set => vector = Vector256.ConditionalSelect(
            Vector256.Create(-1, 0, 0, 0).AsUInt64(), 
            vector,
            Vector256.Shuffle(value.vector, Vector256.Create((ulong)0, 2, 1, 0))
        );
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, y);
        [MethodImpl(256 | 512)]
        set { w = value.x; z = value.y; y = value.z; }
#endif // NET8_0_OR_GREATER
    }
    public b64v3 wzz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, z);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 abb
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 2, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, z);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 wzw
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, w);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 aba
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 2, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, z, w);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 wwx
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, x);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 aar
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 3, 0, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, x);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 wwy
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, y);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 aag
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 3, 1, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, y);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 wwz
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, z);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 aab
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 3, 2, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, z);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 www
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, w);
#endif // NET8_0_OR_GREATER
    }
    public b64v3 aaa
    {
#if NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(Vector256.Shuffle(vector, Vector256.Create((ulong)3, 3, 3, 3)) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
#else // NET8_0_OR_GREATER
        [MethodImpl(256 | 512)]
        get => new(w, w, w);
#endif // NET8_0_OR_GREATER
    }
}

#endregion // b64v4
