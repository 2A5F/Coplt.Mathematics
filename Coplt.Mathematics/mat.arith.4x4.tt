<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics;
<#
    foreach (var typ in Typ.Typs)
    {
        if (!typ.arith) continue;

        var byteSize = typ.size * 4;
        var bitSize = 8 * byteSize;

        var vecTypeName = $"{typ.name}{4}";
        var typeName = $"{typ.name.Replace('v', 'm')}{4}x{4}";
        var vecTypeName3 = $"{typ.name}{3}";
        var typeName3x3 = $"{typ.name.Replace('v', 'm')}{3}x{3}";

        var quaternionName = $"quaternion{typ.structSuffix}";
#>

#region <#= typeName #>

public partial struct <#= typeName #>
{
    /// <summary>Constructs a <#= typeName #> from a <#= typeName3x3 #> rotation matrix and a <#= vecTypeName3 #> translation vector</summary>
    /// <param name="rotation">The <#= typeName3x3 #> rotation matrix</param>
    /// <param name="translation">The translation vector</param>
    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#= typeName3x3 #> rotation, <#= vecTypeName3 #> translation)
    {
<#
        if (typ.simd)
        {
#>
        #if NET8_0_OR_GREATER
        c0 = new(rotation.c0.vector);
        c1 = new(rotation.c1.vector);
        c2 = new(rotation.c2.vector);
        #else // NET8_0_OR_GREATER
<#
        }
#>
        c0 = new(rotation.c0, default);
        c1 = new(rotation.c1, default);
        c2 = new(rotation.c2, default);
<#
        if (typ.simd)
        {
#>
        #endif // NET8_0_OR_GREATER
<#
        }
#>
        c3 = new(translation, <#= typ.one #>);
    }
<#
        if (typ.f && typ.bin)
        {
#>

    /// <summary>Constructs a <#= typeName #> from a quaternion and a <#= vecTypeName3 #> translation vector</summary>
    /// <param name="rotation">The quaternion rotation</param>
    /// <param name="translation">The translation vector</param>
    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#= quaternionName #> rotation, <#= vecTypeName3 #> translation) 
        : this(new <#= typeName3x3 #>(rotation), translation) {}

    /// <summary>
    /// Returns a <#= typeName #> matrix representing a rotation around a unit axis by an angle in radians
    /// The rotation direction is clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="axis">The axis of rotation</param>
    /// <param name="angle">The angle of rotation in radians</param>
    /// <returns>The <#= typeName #> matrix representing the rotation about an axis</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> AxisAngle(<#= vecTypeName3 #> axis, <#= typ.compType #> angle)
    {
        angle.sincos(out var sina, out var cosa);
        var u = new <#= vecTypeName #>(axis, default);
        var u_inv_cosa = u - u * cosa; // u * (1 - cosa);
        var t = new <#= vecTypeName #>(u.xyz * sina, cosa);

        var ppnp = new <#= typ.maskType #>4(default, default, <#= typ.maskNeg #>, default).as<#= typ.compType #>();
        var nppp = new <#= typ.maskType #>4(<#= typ.maskNeg #>, default, default, default).as<#= typ.compType #>();
        var pnpp = new <#= typ.maskType #>4(default, <#= typ.maskNeg #>, default, default).as<#= typ.compType #>();
        var mask = new <#= typ.sigMaskType #>4(-1, -1, -1, default).as<#= typ.compType #>();

        return new(
            u.xxxx.fma(u_inv_cosa, (t.wzyx ^ ppnp) & mask),
            u.yyyy.fma(u_inv_cosa, (t.zwxx ^ nppp) & mask),
            u.zzzz.fma(u_inv_cosa, (t.yxwx ^ pnpp) & mask),
            new(default, default, default, <#= typ.one #>)
        );
    }

    /// <summary>
    /// Returns a <#= typeName #> rotation matrix constructed by first performing a rotation around the x-axis, then the y-axis and finally the z-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A <#= vecTypeName3 #> vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The <#= typeName #> rotation matrix of the Euler angle rotation in x-y-z order</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> EulerXYZ(<#= vecTypeName3 #> xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            <#= typ.arithCast #>(c.y * c.z),  <#= typ.arithCast #>(c.z * s.x * s.y - c.x * s.z),    <#= typ.arithCast #>(c.x * c.z * s.y + s.x * s.z),    default,
            <#= typ.arithCast #>(c.y * s.z),  <#= typ.arithCast #>(c.x * c.z + s.x * s.y * s.z),    <#= typ.arithCast #>(c.x * s.y * s.z - c.z * s.x),    default,
            <#= typ.arithCast #>(-s.y),       <#= typ.arithCast #>(c.y * s.x),                      <#= typ.arithCast #>(c.x * c.y),                      default,
            default,                        default,                        default,       <#= typ.one #>
        );
    }

    /// <summary>
    /// Returns a <#= typeName #> rotation matrix constructed by first performing a rotation around the x-axis, then the z-axis and finally the y-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A <#= vecTypeName3 #> vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The <#= typeName #> rotation matrix of the Euler angle rotation in x-z-y order</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> EulerXZY(<#= vecTypeName3 #> xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            <#= typ.arithCast #>(c.y * c.z),  <#= typ.arithCast #>(s.x * s.y - c.x * c.y * s.z),    <#= typ.arithCast #>(c.x * s.y + c.y * s.x * s.z),    default,
            <#= typ.arithCast #>(s.z),        <#= typ.arithCast #>(c.x * c.z),                      <#= typ.arithCast #>(-c.z * s.x),                     default,
            <#= typ.arithCast #>(-c.z * s.y), <#= typ.arithCast #>(c.y * s.x + c.x * s.y * s.z),    <#= typ.arithCast #>(c.x * c.y - s.x * s.y * s.z),    default,
            default,                        default,                        default,       <#= typ.one #>
        );
    }

    /// <summary>
    /// Returns a <#= typeName #> rotation matrix constructed by first performing a rotation around the y-axis, then the x-axis and finally the z-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A <#= vecTypeName3 #> vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The <#= typeName #> rotation matrix of the Euler angle rotation in y-x-z order</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> EulerYXZ(<#= vecTypeName3 #> xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            <#= typ.arithCast #>(c.y * c.z - s.x * s.y * s.z),    <#= typ.arithCast #>(-c.x * s.z), <#= typ.arithCast #>(c.z * s.y + c.y * s.x * s.z),    default,
            <#= typ.arithCast #>(c.z * s.x * s.y + c.y * s.z),    <#= typ.arithCast #>(c.x * c.z),  <#= typ.arithCast #>(s.y * s.z - c.y * c.z * s.x),    default,
            <#= typ.arithCast #>(-c.x * s.y),                     <#= typ.arithCast #>(s.x),        <#= typ.arithCast #>(c.x * c.y),                      default,
            default,                        default,                        default,       <#= typ.one #>
        );
    }

    /// <summary>
    /// Returns a <#= typeName #> rotation matrix constructed by first performing a rotation around the y-axis, then the z-axis and finally the x-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A <#= vecTypeName3 #> vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The <#= typeName #> rotation matrix of the Euler angle rotation in y-z-x order</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> EulerYZX(<#= vecTypeName3 #> xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            <#= typ.arithCast #>(c.y * c.z),                      <#= typ.arithCast #>(-s.z),       <#= typ.arithCast #>(c.z * s.y),                      default,
            <#= typ.arithCast #>(s.x * s.y + c.x * c.y * s.z),    <#= typ.arithCast #>(c.x * c.z),  <#= typ.arithCast #>(c.x * s.y * s.z - c.y * s.x),    default,
            <#= typ.arithCast #>(c.y * s.x * s.z - c.x * s.y),    <#= typ.arithCast #>(c.z * s.x),  <#= typ.arithCast #>(c.x * c.y + s.x * s.y * s.z),    default,
            default,                        default,                        default,       <#= typ.one #>
        );
    }

    /// <summary>
    /// Returns a <#= typeName #> rotation matrix constructed by first performing a rotation around the z-axis, then the x-axis and finally the y-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A <#= vecTypeName3 #> vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The <#= typeName #> rotation matrix of the Euler angle rotation in z-x-y order</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> EulerZXY(<#= vecTypeName3 #> xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            <#= typ.arithCast #>(c.y * c.z + s.x * s.y * s.z),    <#= typ.arithCast #>(c.z * s.x * s.y - c.y * s.z),    <#= typ.arithCast #>(c.x * s.y),  default,
            <#= typ.arithCast #>(c.x * s.z),                      <#= typ.arithCast #>(c.x * c.z),                      <#= typ.arithCast #>(-s.x),       default,
            <#= typ.arithCast #>(c.y * s.x * s.z - c.z * s.y),    <#= typ.arithCast #>(c.y * c.z * s.x + s.y * s.z),    <#= typ.arithCast #>(c.x * c.y),  default,
            default,                        default,                        default,       <#= typ.one #>
        );
    }

    /// <summary>
    /// Returns a <#= typeName #> rotation matrix constructed by first performing a rotation around the z-axis, then the y-axis and finally the x-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A <#= vecTypeName3 #> vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The <#= typeName #> rotation matrix of the Euler angle rotation in z-y-x order</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> EulerZYX(<#= vecTypeName3 #> xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            <#= typ.arithCast #>(c.y * c.z),                      <#= typ.arithCast #>(-c.y * s.z),                     <#= typ.arithCast #>(s.y),        default,
            <#= typ.arithCast #>(c.z * s.x * s.y + c.x * s.z),    <#= typ.arithCast #>(c.x * c.z - s.x * s.y * s.z),    <#= typ.arithCast #>(-c.y * s.x), default,
            <#= typ.arithCast #>(s.x * s.z - c.x * c.z * s.y),    <#= typ.arithCast #>(c.z * s.x + c.x * s.y * s.z),    <#= typ.arithCast #>(c.x * c.y),  default,
            default,                        default,                        default,       <#= typ.one #>
        );
    }

    /// <summary>Returns a <#= typeName #> matrix that rotates around the x-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the x-axis towards the origin in radians</param>
    /// <returns>The <#= typeName #> rotation matrix that rotates around the x-axis</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> RotateX(<#= typ.compType #> angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            <#= typ.one #>, default, default, default,
            default, c,     -s,    default,
            default, s,     c,     default,
            default, default, default, <#= typ.one #>
        );
    }

    /// <summary>Returns a <#= typeName #> matrix that rotates around the y-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the y-axis towards the origin in radians</param>
    /// <returns>The <#= typeName #> rotation matrix that rotates around the y-axis</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> RotateY(<#= typ.compType #> angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            c,     default, s,     default,
            default, <#= typ.one #>, default, default,
            -s,    default, c,     default,
            default, default, default, <#= typ.one #>
        );
    }

    /// <summary>Returns a <#= typeName #> matrix that rotates around the z-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the z-axis towards the origin in radians</param>
    /// <returns>The <#= typeName #> rotation matrix that rotates around the z-axis</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> RotateZ(<#= typ.compType #> angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            c,     -s,    default, default,
            s,     c,     default, default,
            default, default, <#= typ.one #>, default,
            default, default, default, <#= typ.one #>
        );
    }

    /// <summary>
    /// Returns a <#= typeName #> view matrix given an eye position, a target point and a unit length up vector.
    /// The up vector is assumed to be unit length, the eye and target points are assumed to be distinct and
    /// the vector between them is assumes to be collinear with the up vector.
    /// </summary>
    /// <param name="eye">The eye position</param>
    /// <param name="target">The view target position</param>
    /// <param name="up">The eye up direction</param>
    /// <returns>The <#= typeName #> view matrix.</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> LookAt(<#= vecTypeName3 #> eye, <#= vecTypeName3 #> target, <#= vecTypeName3 #> up)
    {
        var rot = <#= typeName3x3 #>.LookRotation((target - eye).normalize(), up);
        return new(
            new(rot.c0, default),
            new(rot.c1, default),
            new(rot.c2, default),
            new(eye, <#= typ.one #>)
        );
    }

    /// <summary>
    /// Returns a <#= typeName #> centered orthographic projection matrix
    /// </summary>
    /// <param name="width">The width of the view volume</param>
    /// <param name="height">The height of the view volume</param>
    /// <param name="near">The distance to the near plane</param>
    /// <param name="far">The distance to the far plane</param>
    /// <returns>The <#= typeName #> centered orthographic projection matrix.</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> Ortho(<#= typ.compType #> width, <#= typ.compType #> height, <#= typ.compType #> near, <#= typ.compType #> far)
    {
        var rcpdx = <#= typ.one #> / width;
        var rcpdy = <#= typ.one #> / height;
        var rcpdz = <#= typ.one #> / (far - near);

        return new(
            <#= typ.arithCast #>(<#= typ.two #> * rcpdx),       default,            default,            default,
            default,           <#= typ.arithCast #>(<#= typ.two #> * rcpdy),        default,            default,
            default,           default,            <#= typ.arithCast #>(-<#= typ.two #> * rcpdz),       <#= typ.arithCast #>(-(far + near) * rcpdz),
            default,           default,            default,            <#= typ.one #>
       );
    }

    /// <summary>
    /// Returns a <#= typeName #> off-center orthographic projection matrix
    /// </summary>
    /// <param name="left">The minimum x-coordinate of the view volume</param>
    /// <param name="right">The maximum x-coordinate of the view volume</param>
    /// <param name="bottom">The minimum y-coordinate of the view volume</param>
    /// <param name="top">The minimum y-coordinate of the view volume</param>
    /// <param name="near">The distance to the near plane</param>
    /// <param name="far">The distance to the far plane</param>
    /// <returns>The <#= typeName #> off-center orthographic projection matrix.</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> OrthoOffCenter(<#= typ.compType #> left, <#= typ.compType #> right, <#= typ.compType #> bottom, <#= typ.compType #> top, <#= typ.compType #> near, <#= typ.compType #> far)
    {
        var rcpdx = <#= typ.one #> / (right - left);
        var rcpdy = <#= typ.one #> / (top - bottom);
        var rcpdz = <#= typ.one #> / (far - near);

        return new(
            <#= typ.arithCast #>(<#= typ.two #> * rcpdx),      default,           default,                <#= typ.arithCast #>(-(right + left) * rcpdx),
            default,           <#= typ.arithCast #>(<#= typ.two #> * rcpdy),      default,                <#= typ.arithCast #>(-(top + bottom) * rcpdy),
            default,           default,           <#= typ.arithCast #>(-<#= typ.two #> * rcpdz),          <#= typ.arithCast #>(-(far + near) * rcpdz),
            default,           default,           default,                <#= typ.one #>
        );
    }

    /// <summary>
    /// Returns a <#= typeName #> perspective projection matrix based on field of view
    /// </summary>
    /// <param name="verticalFov">Vertical Field of view in radians</param>
    /// <param name="aspect">X:Y aspect ratio</param>
    /// <param name="near">Distance to near plane. Must be greater than zero</param>
    /// <param name="far">Distance to far plane. Must be greater than zero</param>
    /// <returns>The <#= typeName #> perspective projection matrix</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> PerspectiveFov(<#= typ.compType #> verticalFov, <#= typ.compType #> aspect, <#= typ.compType #> near, <#= typ.compType #> far)
    {
        var cotangent = <#= typ.one #> / math.tan(verticalFov * <#= typ.half #>);
        var rcpdz = <#= typ.one #> / (near - far);

        return new(
            <#= typ.arithCast #>(cotangent / aspect),    default,       default,                   default,
            default,               <#= typ.arithCast #>cotangent,     default,                   default,
            default,               default,       <#= typ.arithCast #>((far + near) * rcpdz),      <#= typ.arithCast #>(<#= typ.two #> * near * far * rcpdz),
            default,               default,       -<#= typ.one #>,                     default
        );
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> PerspectiveOffCenter(<#= typ.compType #> left, <#= typ.compType #> right, <#= typ.compType #> bottom, <#= typ.compType #> top, <#= typ.compType #> near, <#= typ.compType #> far)
    {
        var rcpdz = <#= typ.one #> / (near - far);
        var rcpWidth = <#= typ.one #> / (right - left);
        var rcpHeight = <#= typ.one #> / (top - bottom);

        return new(
            <#= typ.arithCast #>(<#= typ.two #> * near * rcpWidth),        default,                       <#= typ.arithCast #>((left + right) * rcpWidth),     default,
            default,                       <#= typ.arithCast #>(<#= typ.two #> * near * rcpHeight),       <#= typ.arithCast #>((bottom + top) * rcpHeight),    default,
            default,                       default,                       <#= typ.arithCast #>((far + near) * rcpdz),          <#= typ.arithCast #>(<#= typ.two #> * near * far * rcpdz),
            default,                       default,                       -<#= typ.one #>,                         default
        );
    }

    /// <summary>
    /// Returns a <#= typeName #> matrix representing a combined scale-, rotation- and translation transform.
    /// Equivalent to mul(translationTransform, mul(rotationTransform, scaleTransform))
    /// </summary>
    /// <param name="translation">The translation vector</param>
    /// <param name="rotation">The quaternion rotation</param>
    /// <param name="scale">The scaling factors of each axis</param>
    /// <returns>The <#= typeName #> matrix representing the translation, rotation, and scale by the inputs</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> TRS(<#= vecTypeName3 #> translation, <#= quaternionName #> rotation, <#= vecTypeName3 #> scale)
    {
        var r = new <#= typeName3x3 #>(rotation);
        r.c0 *= scale.xxx;
        r.c1 *= scale.yyy;
        r.c2 *= scale.zzz;
        return new(r, translation);
    }
<#
        }
#>

    /// <summary>Returns a <#= typeName #> scale matrix given 3 axis scales</summary>
    /// <param name="s">The uniform scaling factor</param>
    /// <returns>The <#= typeName #> matrix that represents a uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> Scale(<#= typ.compType #> s) => new(
        s,    default, default, default,
        default, s,    default, default,
        default, default, s,    default,
        default, default, default, <#= typ.one #>
    );

    /// <summary>Returns a <#= typeName #> scale matrix given a float3 vector containing the 3 axis scales</summary>
    /// <param name="x">The x-axis scaling factor</param>
    /// <param name="y">The y-axis scaling factor</param>
    /// <param name="z">The z-axis scaling factor</param>
    /// <returns>The <#= typeName #> matrix that represents a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> Scale(<#= typ.compType #> x, <#= typ.compType #> y, <#= typ.compType #> z) => new(
        x,    default, default, default,
        default, y,    default, default,
        default, default, z,    default,
        default, default, default, <#= typ.one #>
    );

    /// <summary>Returns a <#= typeName #> scale matrix given a float3 vector containing the 3 axis scales</summary>
    /// <param name="scales">The vector containing scale factors for each axis</param>
    /// <returns>The <#= typeName #> matrix that represents a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> Scale(<#= vecTypeName3 #> scales) => Scale(scales.x, scales.y, scales.z);

    /// <summary>Returns a <#= typeName #> translation matrix given a float3 translation vector</summary>
    /// <param name="vector">The translation vector</param>
    /// <returns>The <#= typeName #> translation matrix</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> Translate(<#= vecTypeName3 #> vector) => new(
        new(<#= typ.one #>, default, default, default),
        new(default, <#= typ.one #>, default, default),
        new(default, default, <#= typ.one #>, default),
        new(vector, <#= typ.one #>)
    );
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static <#= typ.name #>3 rotate(this <#= typeName #> a, <#= typ.name #>3 b) 
        => b.xxxx.fma(a.c0, b.yyyy.fma(a.c1, b.zzzz * a.c2)).xyz;
        // (a.c0 * b.x + a.c1 * b.y + a.c2 * b.z).xyz;

    [MethodImpl(256 | 512)]
    public static <#= typ.name #>3 transform(this <#= typeName #> a, <#= typ.name #>3 b) 
        => b.xxxx.fma(a.c0, b.yyyy.fma(a.c1, b.zzzz.fma(a.c2, a.c3))).xyz;
        // (a.c0 * b.x + a.c1 * b.y + a.c2 * b.z + a.c3).xyz;
<#
        if (typ.f)
        {
#>

    [MethodImpl(256 | 512)]
    public static <#= typeName #> inverse(this <#= typeName #> m)
    {
        var (c0, c1, c2, c3) = m;

        var r0y_r1y_r0x_r1x = movelh(c1, c0); // (x1, y1, x0, y0)
        var r0z_r1z_r0w_r1w = movelh(c2, c3); // (x2, y2, x3, y3)
        var r2y_r3y_r2x_r3x = movehl(c0, c1); // (z1, w1, z0, w0)
        var r2z_r3z_r2w_r3w = movehl(c3, c2); // (z2, w2, z3, w3)

        var r0_wzyx = shuffle_zx_xz(r0z_r1z_r0w_r1w, r0y_r1y_r0x_r1x); // x3 x2 x1 x0
        var r1_wzyx = shuffle_wy_yw(r0z_r1z_r0w_r1w, r0y_r1y_r0x_r1x); // y3 y2 y1 y0
        var r2_wzyx = shuffle_zx_xz(r2z_r3z_r2w_r3w, r2y_r3y_r2x_r3x); // z3 z2 z1 z0
        var r3_wzyx = shuffle_wy_yw(r2z_r3z_r2w_r3w, r2y_r3y_r2x_r3x); // w3 w2 w1 w0
        var r0_xyzw = r0_wzyx.wzyx; // x0 x1 x2 x3

        var r1y_r2y_r1x_r2x = shuffle_yz_yz(c1, c0); // (y1, z1, y0, z0)
        var r1z_r2z_r1w_r2w = shuffle_yz_yz(c2, c3); // (y2, z2, y3, z3)
        var r3y_r0y_r3x_r0x = shuffle_wx_wx(c1, c0); // (w1, x1, w0, x0)
        var r3z_r0z_r3w_r0w = shuffle_wx_wx(c2, c3); // (w2, x2, w3, x3)

        // Calculate remaining inner term pairs. inner terms have zw=-xy, so we only have to calculate xy and can pack two pairs per vector
        var inner12_23 = r1y_r2y_r1x_r2x * r2z_r3z_r2w_r3w - r1z_r2z_r1w_r2w * r2y_r3y_r2x_r3x;
        var inner02_13 = r0y_r1y_r0x_r1x * r2z_r3z_r2w_r3w - r0z_r1z_r0w_r1w * r2y_r3y_r2x_r3x;
        var inner30_01 = r3z_r0z_r3w_r0w * r0y_r1y_r0x_r1x - r3y_r0y_r3x_r0x * r0z_r1z_r0w_r1w;

        // Expand inner terms back to 4 components. zw signs still need to be flipped
        var inner12 = inner12_23.xzzx;
        var inner23 = inner12_23.ywwy;

        var inner02 = inner02_13.xzzx;
        var inner13 = inner02_13.ywwy;

        // Calculate minors
        var minors0 = r3_wzyx * inner12 - r2_wzyx * inner13 + r1_wzyx * inner23;

        var denom = r0_xyzw * minors0;

        // Horizontal sum of denominator. Free sign flip of z and w compensates for missing flip in inner terms
        denom += denom.yxwz; // x+y        x+y            z+w            z+w
        denom -= denom.zzxx; // x+y-z-w  x+y-z-w        z+w-x-y        z+w-x-y

        var rcp_denom_ppnn = <#= vecTypeName #>.One / denom;
        var rc0 = minors0 * rcp_denom_ppnn;

        var inner30 = inner30_01.xzzx;
        var inner01 = inner30_01.ywwy;

        var minors1 = r2_wzyx * inner30 - r0_wzyx * inner23 - r3_wzyx * inner02;
        var rc1 = minors1 * rcp_denom_ppnn;

        var minors2 = r0_wzyx * inner13 - r1_wzyx * inner30 - r3_wzyx * inner01;
        var rc2 = minors2 * rcp_denom_ppnn;

        var minors3 = r1_wzyx * inner02 - r0_wzyx * inner12 + r2_wzyx * inner01;
        var rc3 = minors3 * rcp_denom_ppnn;

        return new(rc0, rc1, rc2, rc3);
    }

    /// <summary>Fast matrix inverse for rigid transforms (orthonormal basis and translation)</summary>
    /// <param name="m">Matrix to invert</param>
    /// <returns>The inverted matrix</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> fastinverse(this <#= typeName #> m)
    {
        var (c0, c1, c2, pos) = m;

        var t0 = unpacklo(c0, c2);
        var t1 = unpacklo(c1, default);
        var t2 = unpackhi(c0, c2);
        var t3 = unpackhi(c1, default);

        var r0 = unpacklo(t0, t1);
        var r1 = unpackhi(t0, t1);
        var r2 = unpacklo(t2, t3);

        pos = -(r0 * pos.x + r1 * pos.y + r2 * pos.z);
        pos.w = <#= typ.one #>;

        return new(r0, r1, r2, pos);
    }

    /// <summary>Returns the determinant of a <#= typeName #> matrix</summary>
    /// <param name="m">Matrix to use when computing determinant</param>
    /// <returns>The determinant of the matrix</returns>
    [MethodImpl(256 | 512)]
    public static <#= typ.compType #> determinant(this <#= typeName #> m)
    {
        var (c0, c1, c2, c3) = m;

        // var m00 = c1.y * (c2.z * c3.w - c2.w * c3.z) - c2.y * (c1.z * c3.w - c1.w * c3.z) + c3.y * (c1.z * c2.w - c1.w * c2.z);
        // var m01 = c0.y * (c2.z * c3.w - c2.w * c3.z) - c2.y * (c0.z * c3.w - c0.w * c3.z) + c3.y * (c0.z * c2.w - c0.w * c2.z);
        // var m02 = c0.y * (c1.z * c3.w - c1.w * c3.z) - c1.y * (c0.z * c3.w - c0.w * c3.z) + c3.y * (c0.z * c1.w - c0.w * c1.z);
        // var m03 = c0.y * (c1.z * c2.w - c1.w * c2.z) - c1.y * (c0.z * c2.w - c0.w * c2.z) + c2.y * (c0.z * c1.w - c0.w * c1.z);
        
        // var r = c0.x * m00 - c1.x * m01 + c2.x * m02 - c3.x * m03;
        
        var x1_y1_x0_y0 = movelh(c1, c0); // (x1, y1, x0, y0)
        var x2_y2_x3_y3 = movelh(c2, c3); // (x2, y2, x3, y3)
        var z1_w1_z0_w0 = movehl(c0, c1); // (z1, w1, z0, w0)
        var z2_w2_z3_w3 = movehl(c3, c2); // (z2, w2, z3, w3)
        
        var x2_y2_x1_y1 = movelh(c2, c1); // (x2, y2, x1, y1)
        var z2_w2_z1_w1 = movehl(c1, c2); // (z2, w2, z1, w1)

        var x0_x1_x2_x3 = shuffle_zx_xz(x1_y1_x0_y0, x2_y2_x3_y3); // x0 x1 x2 x3

        var y1000 = x1_y1_x0_y0.ywww;
        var z1000 = z1_w1_z0_w0.xzzz;
        var w1000 = z1_w1_z0_w0.ywww;
        var y2211 = x2_y2_x1_y1.yyww;
        var z2211 = z2_w2_z1_w1.xxzz;
        var w2211 = z2_w2_z1_w1.yyww;
        var y3332 = x2_y2_x3_y3.wwwy;
        var z3332 = z2_w2_z3_w3.zzzx;
        var w3332 = z2_w2_z3_w3.wwwy;
        
        var a = y1000 * (z2211 * w3332 - w2211 * z3332) - y2211 * (z1000 * w3332 - w1000 * z3332) + y3332 * (z1000 * w2211 - w1000 * z2211);
        var b = x0_x1_x2_x3 * a;
        var r = b.x - b.y + b.z - b.w;
        
        return <#= typ.arithCast #>r;
    }
<#
        }
#>
}

#endregion // <#= typeName #>
<#
    }
#>
