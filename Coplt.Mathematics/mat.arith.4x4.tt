<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics;
<#
    foreach (var typ in Typ.Typs)
    {
        if (!typ.arith) continue;

        var byteSize = typ.size * 4;
        var bitSize = 8 * byteSize;

        var vecTypeName = $"{typ.name}{4}";
        var typeName = $"{typ.name.Replace('v', 'm')}{4}x{4}";
        var vecTypeName3 = $"{typ.name}{3}";
        var typeName3x3 = $"{typ.name.Replace('v', 'm')}{3}x{3}";
#>

#region <#= typeName #>

public partial struct <#= typeName #>
{
    /// <summary>Constructs a float4x4 from a float3x3 rotation matrix and a float3 translation vector</summary>
    /// <param name="rotation">The float3x3 rotation matrix</param>
    /// <param name="translation">The translation vector</param>
    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#= typeName3x3 #> rotation, <#= vecTypeName3 #> translation)
    {
<#
        if (typ.simd)
        {
#>
        #if NET8_0_OR_GREATER
        c0 = new(rotation.c0.vector);
        c1 = new(rotation.c1.vector);
        c2 = new(rotation.c2.vector);
        #else // NET8_0_OR_GREATER
<#
        }
#>
        c0 = new(rotation.c0, default);
        c1 = new(rotation.c1, default);
        c2 = new(rotation.c2, default);
<#
        if (typ.simd)
        {
#>
        #endif // NET8_0_OR_GREATER
<#
        }
#>
        c3 = new(translation, <#= typ.one #>);
    }
<#
        if (typ.f && typ.bin)
        {
#>

    /// <summary>
    /// Returns a float4x4 matrix representing a rotation around a unit axis by an angle in radians
    /// The rotation direction is clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="axis">The axis of rotation</param>
    /// <param name="angle">The angle of rotation in radians</param>
    /// <returns>The float4x4 matrix representing the rotation about an axis</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> AxisAngle(<#= vecTypeName3 #> axis, <#= typ.compType #> angle)
    {
        angle.sincos(out var sina, out var cosa);
        var u = new <#= vecTypeName #>(axis, default);
        var u_inv_cosa = u - u * cosa; // u * (1 - cosa);
        var t = new <#= vecTypeName #>(u.xyz * sina, cosa);

        var ppnp = new <#= typ.maskType #>4(default, default, <#= typ.maskNeg #>, default).as<#= typ.compType #>();
        var nppp = new <#= typ.maskType #>4(<#= typ.maskNeg #>, default, default, default).as<#= typ.compType #>();
        var pnpp = new <#= typ.maskType #>4(default, <#= typ.maskNeg #>, default, default).as<#= typ.compType #>();
        var mask = new <#= typ.sigMaskType #>4(-1, -1, -1, default).as<#= typ.compType #>();

        return new(
            u.xxxx.fma(u_inv_cosa, (t.wzyx ^ ppnp) & mask),
            u.yyyy.fma(u_inv_cosa, (t.zwxx ^ nppp) & mask),
            u.zzzz.fma(u_inv_cosa, (t.yxwx ^ pnpp) & mask),
            new(default, default, default, <#= typ.one #>)
        );
    }

    /// <summary>
    /// Returns a float4x4 rotation matrix constructed by first performing a rotation around the x-axis, then the y-axis and finally the z-axis
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The float4x4 rotation matrix of the Euler angle rotation in x-y-z order</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> EulerXYZ(<#= vecTypeName3 #> xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            <#= typ.arithCast #>(c.y * c.z),  <#= typ.arithCast #>(c.z * s.x * s.y - c.x * s.z),    <#= typ.arithCast #>(c.x * c.z * s.y + s.x * s.z),    default,
            <#= typ.arithCast #>(c.y * s.z),  <#= typ.arithCast #>(c.x * c.z + s.x * s.y * s.z),    <#= typ.arithCast #>(c.x * s.y * s.z - c.z * s.x),    default,
            <#= typ.arithCast #>(-s.y),       <#= typ.arithCast #>(c.y * s.x),                      <#= typ.arithCast #>(c.x * c.y),                      default,
            default,                        default,                        default,       <#= typ.one #>
        );
    }

    /// <summary>
    /// Returns a float4x4 rotation matrix constructed by first performing a rotation around the x-axis, then the z-axis and finally the y-axis
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The float4x4 rotation matrix of the Euler angle rotation in x-z-y order</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> EulerXZY(<#= vecTypeName3 #> xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            <#= typ.arithCast #>(c.y * c.z),  <#= typ.arithCast #>(s.x * s.y - c.x * c.y * s.z),    <#= typ.arithCast #>(c.x * s.y + c.y * s.x * s.z),    default,
            <#= typ.arithCast #>(s.z),        <#= typ.arithCast #>(c.x * c.z),                      <#= typ.arithCast #>(-c.z * s.x),                     default,
            <#= typ.arithCast #>(-c.z * s.y), <#= typ.arithCast #>(c.y * s.x + c.x * s.y * s.z),    <#= typ.arithCast #>(c.x * c.y - s.x * s.y * s.z),    default,
            default,                        default,                        default,       <#= typ.one #>
        );
    }

    /// <summary>
    /// Returns a float4x4 rotation matrix constructed by first performing a rotation around the y-axis, then the x-axis and finally the z-axis
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The float4x4 rotation matrix of the Euler angle rotation in y-x-z order</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> EulerYXZ(<#= vecTypeName3 #> xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            <#= typ.arithCast #>(c.y * c.z - s.x * s.y * s.z),    <#= typ.arithCast #>(-c.x * s.z), <#= typ.arithCast #>(c.z * s.y + c.y * s.x * s.z),    default,
            <#= typ.arithCast #>(c.z * s.x * s.y + c.y * s.z),    <#= typ.arithCast #>(c.x * c.z),  <#= typ.arithCast #>(s.y * s.z - c.y * c.z * s.x),    default,
            <#= typ.arithCast #>(-c.x * s.y),                     <#= typ.arithCast #>(s.x),        <#= typ.arithCast #>(c.x * c.y),                      default,
            default,                        default,                        default,       <#= typ.one #>
        );
    }

    /// <summary>
    /// Returns a float4x4 rotation matrix constructed by first performing a rotation around the y-axis, then the z-axis and finally the x-axis
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The float4x4 rotation matrix of the Euler angle rotation in y-z-x order</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> EulerYZX(<#= vecTypeName3 #> xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            <#= typ.arithCast #>(c.y * c.z),                      <#= typ.arithCast #>(-s.z),       <#= typ.arithCast #>(c.z * s.y),                      default,
            <#= typ.arithCast #>(s.x * s.y + c.x * c.y * s.z),    <#= typ.arithCast #>(c.x * c.z),  <#= typ.arithCast #>(c.x * s.y * s.z - c.y * s.x),    default,
            <#= typ.arithCast #>(c.y * s.x * s.z - c.x * s.y),    <#= typ.arithCast #>(c.z * s.x),  <#= typ.arithCast #>(c.x * c.y + s.x * s.y * s.z),    default,
            default,                        default,                        default,       <#= typ.one #>
        );
    }

    /// <summary>
    /// Returns a float4x4 rotation matrix constructed by first performing a rotation around the z-axis, then the x-axis and finally the y-axis
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin
    /// This is the default order rotation order in Unity
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The float4x4 rotation matrix of the Euler angle rotation in z-x-y order</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> EulerZXY(<#= vecTypeName3 #> xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            <#= typ.arithCast #>(c.y * c.z + s.x * s.y * s.z),    <#= typ.arithCast #>(c.z * s.x * s.y - c.y * s.z),    <#= typ.arithCast #>(c.x * s.y),  default,
            <#= typ.arithCast #>(c.x * s.z),                      <#= typ.arithCast #>(c.x * c.z),                      <#= typ.arithCast #>(-s.x),       default,
            <#= typ.arithCast #>(c.y * s.x * s.z - c.z * s.y),    <#= typ.arithCast #>(c.y * c.z * s.x + s.y * s.z),    <#= typ.arithCast #>(c.x * c.y),  default,
            default,                        default,                        default,       <#= typ.one #>
        );
    }

    /// <summary>
    /// Returns a float4x4 rotation matrix constructed by first performing a rotation around the z-axis, then the y-axis and finally the x-axis
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The float4x4 rotation matrix of the Euler angle rotation in z-y-x order</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> EulerZYX(<#= vecTypeName3 #> xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            <#= typ.arithCast #>(c.y * c.z),                      <#= typ.arithCast #>(-c.y * s.z),                     <#= typ.arithCast #>(s.y),        default,
            <#= typ.arithCast #>(c.z * s.x * s.y + c.x * s.z),    <#= typ.arithCast #>(c.x * c.z - s.x * s.y * s.z),    <#= typ.arithCast #>(-c.y * s.x), default,
            <#= typ.arithCast #>(s.x * s.z - c.x * c.z * s.y),    <#= typ.arithCast #>(c.z * s.x + c.x * s.y * s.z),    <#= typ.arithCast #>(c.x * c.y),  default,
            default,                        default,                        default,       <#= typ.one #>
        );
    }

    /// <summary>Returns a float4x4 matrix that rotates around the x-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the x-axis towards the origin in radians</param>
    /// <returns>The float4x4 rotation matrix that rotates around the x-axis</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> RotateX(<#= typ.compType #> angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            <#= typ.one #>, default, default, default,
            default, c,     -s,    default,
            default, s,     c,     default,
            default, default, default, <#= typ.one #>
        );
    }

    /// <summary>Returns a float4x4 matrix that rotates around the y-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the y-axis towards the origin in radians</param>
    /// <returns>The float4x4 rotation matrix that rotates around the y-axis</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> RotateY(<#= typ.compType #> angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            c,     default, s,     default,
            default, <#= typ.one #>, default, default,
            -s,    default, c,     default,
            default, default, default, <#= typ.one #>
        );
    }

    /// <summary>Returns a float4x4 matrix that rotates around the z-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the z-axis towards the origin in radians</param>
    /// <returns>The float4x4 rotation matrix that rotates around the z-axis</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> RotateZ(<#= typ.compType #> angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            c,     -s,    default, default,
            s,     c,     default, default,
            default, default, <#= typ.one #>, default,
            default, default, default, <#= typ.one #>
        );
    }
<#
        }
#>

    /// <summary>Returns a float4x4 scale matrix given 3 axis scales</summary>
    /// <param name="s">The uniform scaling factor</param>
    /// <returns>The float4x4 matrix that represents a uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> Scale(<#= typ.compType #> s) => new(
        s,    default, default, default,
        default, s,    default, default,
        default, default, s,    default,
        default, default, default, <#= typ.one #>
    );

    /// <summary>Returns a float4x4 scale matrix given a float3 vector containing the 3 axis scales</summary>
    /// <param name="x">The x-axis scaling factor</param>
    /// <param name="y">The y-axis scaling factor</param>
    /// <param name="z">The z-axis scaling factor</param>
    /// <returns>The float4x4 matrix that represents a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> Scale(<#= typ.compType #> x, <#= typ.compType #> y, <#= typ.compType #> z) => new(
        x,    default, default, default,
        default, y,    default, default,
        default, default, z,    default,
        default, default, default, <#= typ.one #>
    );

    /// <summary>Returns a float4x4 scale matrix given a float3 vector containing the 3 axis scales</summary>
    /// <param name="scales">The vector containing scale factors for each axis</param>
    /// <returns>The float4x4 matrix that represents a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> Scale(<#= vecTypeName3 #> scales) => Scale(scales.x, scales.y, scales.z);

    /// <summary>Returns a float4x4 translation matrix given a float3 translation vector</summary>
    /// <param name="vector">The translation vector</param>
    /// <returns>The float4x4 translation matrix</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> Translate(<#= vecTypeName3 #> vector) => new(
        new(<#= typ.one #>, default, default, default),
        new(default, <#= typ.one #>, default, default),
        new(default, default, <#= typ.one #>, default),
        new(vector, <#= typ.one #>)
    );
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static <#= typ.name #>3 rotate(this <#= typeName #> a, <#= typ.name #>3 b) 
        => b.xxxx.fma(a.c0, b.yyyy.fma(a.c1, b.zzzz * a.c2)).xyz;
        // (a.c0 * b.x + a.c1 * b.y + a.c2 * b.z).xyz;

    [MethodImpl(256 | 512)]
    public static <#= typ.name #>3 transform(this <#= typeName #> a, <#= typ.name #>3 b) 
        => b.xxxx.fma(a.c0, b.yyyy.fma(a.c1, b.zzzz.fma(a.c2, a.c3))).xyz;
        // (a.c0 * b.x + a.c1 * b.y + a.c2 * b.z + a.c3).xyz;
}

#endregion // <#= typeName #>
<#
    }
#>
