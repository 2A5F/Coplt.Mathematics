// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region float2

public partial struct float2 : IEquatable<float2>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<float2, float2, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(float2 other)
    {
        #if NET8_0_OR_GREATER
        return vector.Equals(other.vector);
        #else // NET8_0_OR_GREATER
        return x.Equals(other.x) && y.Equals(other.y);
        #endif // NET8_0_OR_GREATER
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is float2 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        #if NET8_0_OR_GREATER
        return vector.GetHashCode();
        #else // NET8_0_OR_GREATER
        return HashCode.Combine(x, y);
        #endif // NET8_0_OR_GREATER
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float2, float2, bool>.operator ==(float2 left, float2 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float2, float2, bool>.operator !=(float2 left, float2 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(float2 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(float2 other)
    {
        #if NET8_0_OR_GREATER
        return Vector64.EqualsAny(vector, other.vector);
        #else // NET8_0_OR_GREATER
        return x == other.x || y == other.y;
        #endif // NET8_0_OR_GREATER
    }

    #endregion
}

#endregion // float2

#region float3

public partial struct float3 : IEquatable<float3>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<float3, float3, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(float3 other)
    {
        #if NET8_0_OR_GREATER
        return vector.Equals(other.vector);
        #else // NET8_0_OR_GREATER
        return x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);
        #endif // NET8_0_OR_GREATER
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is float3 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        #if NET8_0_OR_GREATER
        return vector.GetHashCode();
        #else // NET8_0_OR_GREATER
        return HashCode.Combine(x, y, z);
        #endif // NET8_0_OR_GREATER
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float3, float3, bool>.operator ==(float3 left, float3 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float3, float3, bool>.operator !=(float3 left, float3 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(float3 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(float3 other)
    {
        #if NET8_0_OR_GREATER
        return Vector128.EqualsAny(vector, other.vector);
        #else // NET8_0_OR_GREATER
        return x == other.x || y == other.y || z == other.z;
        #endif // NET8_0_OR_GREATER
    }

    #endregion
}

#endregion // float3

#region float4

public partial struct float4 : IEquatable<float4>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<float4, float4, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(float4 other)
    {
        #if NET8_0_OR_GREATER
        return vector.Equals(other.vector);
        #else // NET8_0_OR_GREATER
        return x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);
        #endif // NET8_0_OR_GREATER
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is float4 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        #if NET8_0_OR_GREATER
        return vector.GetHashCode();
        #else // NET8_0_OR_GREATER
        return HashCode.Combine(x, y, z, w);
        #endif // NET8_0_OR_GREATER
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float4, float4, bool>.operator ==(float4 left, float4 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float4, float4, bool>.operator !=(float4 left, float4 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(float4 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(float4 other)
    {
        #if NET8_0_OR_GREATER
        return Vector128.EqualsAny(vector, other.vector);
        #else // NET8_0_OR_GREATER
        return x == other.x || y == other.y || z == other.z || w == other.w;
        #endif // NET8_0_OR_GREATER
    }

    #endregion
}

#endregion // float4

#region double2

public partial struct double2 : IEquatable<double2>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<double2, double2, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(double2 other)
    {
        #if NET8_0_OR_GREATER
        return vector.Equals(other.vector);
        #else // NET8_0_OR_GREATER
        return x.Equals(other.x) && y.Equals(other.y);
        #endif // NET8_0_OR_GREATER
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is double2 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        #if NET8_0_OR_GREATER
        return vector.GetHashCode();
        #else // NET8_0_OR_GREATER
        return HashCode.Combine(x, y);
        #endif // NET8_0_OR_GREATER
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double2, double2, bool>.operator ==(double2 left, double2 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double2, double2, bool>.operator !=(double2 left, double2 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(double2 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(double2 other)
    {
        #if NET8_0_OR_GREATER
        return Vector128.EqualsAny(vector, other.vector);
        #else // NET8_0_OR_GREATER
        return x == other.x || y == other.y;
        #endif // NET8_0_OR_GREATER
    }

    #endregion
}

#endregion // double2

#region double3

public partial struct double3 : IEquatable<double3>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<double3, double3, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(double3 other)
    {
        #if NET8_0_OR_GREATER
        return vector.Equals(other.vector);
        #else // NET8_0_OR_GREATER
        return x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);
        #endif // NET8_0_OR_GREATER
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is double3 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        #if NET8_0_OR_GREATER
        return vector.GetHashCode();
        #else // NET8_0_OR_GREATER
        return HashCode.Combine(x, y, z);
        #endif // NET8_0_OR_GREATER
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double3, double3, bool>.operator ==(double3 left, double3 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double3, double3, bool>.operator !=(double3 left, double3 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(double3 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(double3 other)
    {
        #if NET8_0_OR_GREATER
        return Vector256.EqualsAny(vector, other.vector);
        #else // NET8_0_OR_GREATER
        return x == other.x || y == other.y || z == other.z;
        #endif // NET8_0_OR_GREATER
    }

    #endregion
}

#endregion // double3

#region double4

public partial struct double4 : IEquatable<double4>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<double4, double4, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(double4 other)
    {
        #if NET8_0_OR_GREATER
        return vector.Equals(other.vector);
        #else // NET8_0_OR_GREATER
        return x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);
        #endif // NET8_0_OR_GREATER
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is double4 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        #if NET8_0_OR_GREATER
        return vector.GetHashCode();
        #else // NET8_0_OR_GREATER
        return HashCode.Combine(x, y, z, w);
        #endif // NET8_0_OR_GREATER
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double4, double4, bool>.operator ==(double4 left, double4 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double4, double4, bool>.operator !=(double4 left, double4 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(double4 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(double4 other)
    {
        #if NET8_0_OR_GREATER
        return Vector256.EqualsAny(vector, other.vector);
        #else // NET8_0_OR_GREATER
        return x == other.x || y == other.y || z == other.z || w == other.w;
        #endif // NET8_0_OR_GREATER
    }

    #endregion
}

#endregion // double4

#region int2

public partial struct int2 : IEquatable<int2>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<int2, int2, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(int2 other)
    {
        #if NET8_0_OR_GREATER
        return vector.Equals(other.vector);
        #else // NET8_0_OR_GREATER
        return x.Equals(other.x) && y.Equals(other.y);
        #endif // NET8_0_OR_GREATER
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is int2 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        #if NET8_0_OR_GREATER
        return vector.GetHashCode();
        #else // NET8_0_OR_GREATER
        return HashCode.Combine(x, y);
        #endif // NET8_0_OR_GREATER
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int2, int2, bool>.operator ==(int2 left, int2 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int2, int2, bool>.operator !=(int2 left, int2 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(int2 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(int2 other)
    {
        #if NET8_0_OR_GREATER
        return Vector64.EqualsAny(vector, other.vector);
        #else // NET8_0_OR_GREATER
        return x == other.x || y == other.y;
        #endif // NET8_0_OR_GREATER
    }

    #endregion
}

#endregion // int2

#region int3

public partial struct int3 : IEquatable<int3>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<int3, int3, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(int3 other)
    {
        #if NET8_0_OR_GREATER
        return vector.Equals(other.vector);
        #else // NET8_0_OR_GREATER
        return x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);
        #endif // NET8_0_OR_GREATER
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is int3 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        #if NET8_0_OR_GREATER
        return vector.GetHashCode();
        #else // NET8_0_OR_GREATER
        return HashCode.Combine(x, y, z);
        #endif // NET8_0_OR_GREATER
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int3, int3, bool>.operator ==(int3 left, int3 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int3, int3, bool>.operator !=(int3 left, int3 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(int3 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(int3 other)
    {
        #if NET8_0_OR_GREATER
        return Vector128.EqualsAny(vector, other.vector);
        #else // NET8_0_OR_GREATER
        return x == other.x || y == other.y || z == other.z;
        #endif // NET8_0_OR_GREATER
    }

    #endregion
}

#endregion // int3

#region int4

public partial struct int4 : IEquatable<int4>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<int4, int4, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(int4 other)
    {
        #if NET8_0_OR_GREATER
        return vector.Equals(other.vector);
        #else // NET8_0_OR_GREATER
        return x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);
        #endif // NET8_0_OR_GREATER
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is int4 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        #if NET8_0_OR_GREATER
        return vector.GetHashCode();
        #else // NET8_0_OR_GREATER
        return HashCode.Combine(x, y, z, w);
        #endif // NET8_0_OR_GREATER
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int4, int4, bool>.operator ==(int4 left, int4 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int4, int4, bool>.operator !=(int4 left, int4 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(int4 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(int4 other)
    {
        #if NET8_0_OR_GREATER
        return Vector128.EqualsAny(vector, other.vector);
        #else // NET8_0_OR_GREATER
        return x == other.x || y == other.y || z == other.z || w == other.w;
        #endif // NET8_0_OR_GREATER
    }

    #endregion
}

#endregion // int4

#region uint2

public partial struct uint2 : IEquatable<uint2>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<uint2, uint2, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(uint2 other)
    {
        #if NET8_0_OR_GREATER
        return vector.Equals(other.vector);
        #else // NET8_0_OR_GREATER
        return x.Equals(other.x) && y.Equals(other.y);
        #endif // NET8_0_OR_GREATER
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is uint2 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        #if NET8_0_OR_GREATER
        return vector.GetHashCode();
        #else // NET8_0_OR_GREATER
        return HashCode.Combine(x, y);
        #endif // NET8_0_OR_GREATER
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint2, uint2, bool>.operator ==(uint2 left, uint2 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint2, uint2, bool>.operator !=(uint2 left, uint2 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(uint2 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(uint2 other)
    {
        #if NET8_0_OR_GREATER
        return Vector64.EqualsAny(vector, other.vector);
        #else // NET8_0_OR_GREATER
        return x == other.x || y == other.y;
        #endif // NET8_0_OR_GREATER
    }

    #endregion
}

#endregion // uint2

#region uint3

public partial struct uint3 : IEquatable<uint3>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<uint3, uint3, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(uint3 other)
    {
        #if NET8_0_OR_GREATER
        return vector.Equals(other.vector);
        #else // NET8_0_OR_GREATER
        return x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);
        #endif // NET8_0_OR_GREATER
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is uint3 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        #if NET8_0_OR_GREATER
        return vector.GetHashCode();
        #else // NET8_0_OR_GREATER
        return HashCode.Combine(x, y, z);
        #endif // NET8_0_OR_GREATER
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint3, uint3, bool>.operator ==(uint3 left, uint3 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint3, uint3, bool>.operator !=(uint3 left, uint3 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(uint3 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(uint3 other)
    {
        #if NET8_0_OR_GREATER
        return Vector128.EqualsAny(vector, other.vector);
        #else // NET8_0_OR_GREATER
        return x == other.x || y == other.y || z == other.z;
        #endif // NET8_0_OR_GREATER
    }

    #endregion
}

#endregion // uint3

#region uint4

public partial struct uint4 : IEquatable<uint4>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<uint4, uint4, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(uint4 other)
    {
        #if NET8_0_OR_GREATER
        return vector.Equals(other.vector);
        #else // NET8_0_OR_GREATER
        return x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);
        #endif // NET8_0_OR_GREATER
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is uint4 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        #if NET8_0_OR_GREATER
        return vector.GetHashCode();
        #else // NET8_0_OR_GREATER
        return HashCode.Combine(x, y, z, w);
        #endif // NET8_0_OR_GREATER
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint4, uint4, bool>.operator ==(uint4 left, uint4 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint4, uint4, bool>.operator !=(uint4 left, uint4 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(uint4 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(uint4 other)
    {
        #if NET8_0_OR_GREATER
        return Vector128.EqualsAny(vector, other.vector);
        #else // NET8_0_OR_GREATER
        return x == other.x || y == other.y || z == other.z || w == other.w;
        #endif // NET8_0_OR_GREATER
    }

    #endregion
}

#endregion // uint4

#region long2

public partial struct long2 : IEquatable<long2>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<long2, long2, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(long2 other)
    {
        #if NET8_0_OR_GREATER
        return vector.Equals(other.vector);
        #else // NET8_0_OR_GREATER
        return x.Equals(other.x) && y.Equals(other.y);
        #endif // NET8_0_OR_GREATER
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is long2 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        #if NET8_0_OR_GREATER
        return vector.GetHashCode();
        #else // NET8_0_OR_GREATER
        return HashCode.Combine(x, y);
        #endif // NET8_0_OR_GREATER
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long2, long2, bool>.operator ==(long2 left, long2 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long2, long2, bool>.operator !=(long2 left, long2 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(long2 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(long2 other)
    {
        #if NET8_0_OR_GREATER
        return Vector128.EqualsAny(vector, other.vector);
        #else // NET8_0_OR_GREATER
        return x == other.x || y == other.y;
        #endif // NET8_0_OR_GREATER
    }

    #endregion
}

#endregion // long2

#region long3

public partial struct long3 : IEquatable<long3>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<long3, long3, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(long3 other)
    {
        #if NET8_0_OR_GREATER
        return vector.Equals(other.vector);
        #else // NET8_0_OR_GREATER
        return x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);
        #endif // NET8_0_OR_GREATER
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is long3 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        #if NET8_0_OR_GREATER
        return vector.GetHashCode();
        #else // NET8_0_OR_GREATER
        return HashCode.Combine(x, y, z);
        #endif // NET8_0_OR_GREATER
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long3, long3, bool>.operator ==(long3 left, long3 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long3, long3, bool>.operator !=(long3 left, long3 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(long3 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(long3 other)
    {
        #if NET8_0_OR_GREATER
        return Vector256.EqualsAny(vector, other.vector);
        #else // NET8_0_OR_GREATER
        return x == other.x || y == other.y || z == other.z;
        #endif // NET8_0_OR_GREATER
    }

    #endregion
}

#endregion // long3

#region long4

public partial struct long4 : IEquatable<long4>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<long4, long4, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(long4 other)
    {
        #if NET8_0_OR_GREATER
        return vector.Equals(other.vector);
        #else // NET8_0_OR_GREATER
        return x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);
        #endif // NET8_0_OR_GREATER
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is long4 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        #if NET8_0_OR_GREATER
        return vector.GetHashCode();
        #else // NET8_0_OR_GREATER
        return HashCode.Combine(x, y, z, w);
        #endif // NET8_0_OR_GREATER
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long4, long4, bool>.operator ==(long4 left, long4 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long4, long4, bool>.operator !=(long4 left, long4 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(long4 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(long4 other)
    {
        #if NET8_0_OR_GREATER
        return Vector256.EqualsAny(vector, other.vector);
        #else // NET8_0_OR_GREATER
        return x == other.x || y == other.y || z == other.z || w == other.w;
        #endif // NET8_0_OR_GREATER
    }

    #endregion
}

#endregion // long4

#region ulong2

public partial struct ulong2 : IEquatable<ulong2>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<ulong2, ulong2, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(ulong2 other)
    {
        #if NET8_0_OR_GREATER
        return vector.Equals(other.vector);
        #else // NET8_0_OR_GREATER
        return x.Equals(other.x) && y.Equals(other.y);
        #endif // NET8_0_OR_GREATER
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is ulong2 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        #if NET8_0_OR_GREATER
        return vector.GetHashCode();
        #else // NET8_0_OR_GREATER
        return HashCode.Combine(x, y);
        #endif // NET8_0_OR_GREATER
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong2, ulong2, bool>.operator ==(ulong2 left, ulong2 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong2, ulong2, bool>.operator !=(ulong2 left, ulong2 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(ulong2 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(ulong2 other)
    {
        #if NET8_0_OR_GREATER
        return Vector128.EqualsAny(vector, other.vector);
        #else // NET8_0_OR_GREATER
        return x == other.x || y == other.y;
        #endif // NET8_0_OR_GREATER
    }

    #endregion
}

#endregion // ulong2

#region ulong3

public partial struct ulong3 : IEquatable<ulong3>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<ulong3, ulong3, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(ulong3 other)
    {
        #if NET8_0_OR_GREATER
        return vector.Equals(other.vector);
        #else // NET8_0_OR_GREATER
        return x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);
        #endif // NET8_0_OR_GREATER
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is ulong3 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        #if NET8_0_OR_GREATER
        return vector.GetHashCode();
        #else // NET8_0_OR_GREATER
        return HashCode.Combine(x, y, z);
        #endif // NET8_0_OR_GREATER
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong3, ulong3, bool>.operator ==(ulong3 left, ulong3 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong3, ulong3, bool>.operator !=(ulong3 left, ulong3 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(ulong3 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(ulong3 other)
    {
        #if NET8_0_OR_GREATER
        return Vector256.EqualsAny(vector, other.vector);
        #else // NET8_0_OR_GREATER
        return x == other.x || y == other.y || z == other.z;
        #endif // NET8_0_OR_GREATER
    }

    #endregion
}

#endregion // ulong3

#region ulong4

public partial struct ulong4 : IEquatable<ulong4>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<ulong4, ulong4, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(ulong4 other)
    {
        #if NET8_0_OR_GREATER
        return vector.Equals(other.vector);
        #else // NET8_0_OR_GREATER
        return x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);
        #endif // NET8_0_OR_GREATER
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is ulong4 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        #if NET8_0_OR_GREATER
        return vector.GetHashCode();
        #else // NET8_0_OR_GREATER
        return HashCode.Combine(x, y, z, w);
        #endif // NET8_0_OR_GREATER
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong4, ulong4, bool>.operator ==(ulong4 left, ulong4 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong4, ulong4, bool>.operator !=(ulong4 left, ulong4 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(ulong4 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(ulong4 other)
    {
        #if NET8_0_OR_GREATER
        return Vector256.EqualsAny(vector, other.vector);
        #else // NET8_0_OR_GREATER
        return x == other.x || y == other.y || z == other.z || w == other.w;
        #endif // NET8_0_OR_GREATER
    }

    #endregion
}

#endregion // ulong4

#region decimal2

public partial struct decimal2 : IEquatable<decimal2>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<decimal2, decimal2, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(decimal2 other)
    {
        return x.Equals(other.x) && y.Equals(other.y);
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is decimal2 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        return HashCode.Combine(x, y);
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<decimal2, decimal2, bool>.operator ==(decimal2 left, decimal2 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<decimal2, decimal2, bool>.operator !=(decimal2 left, decimal2 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(decimal2 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(decimal2 other)
    {
        return x == other.x || y == other.y;
    }

    #endregion
}

#endregion // decimal2

#region decimal3

public partial struct decimal3 : IEquatable<decimal3>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<decimal3, decimal3, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(decimal3 other)
    {
        return x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is decimal3 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        return HashCode.Combine(x, y, z);
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<decimal3, decimal3, bool>.operator ==(decimal3 left, decimal3 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<decimal3, decimal3, bool>.operator !=(decimal3 left, decimal3 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(decimal3 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(decimal3 other)
    {
        return x == other.x || y == other.y || z == other.z;
    }

    #endregion
}

#endregion // decimal3

#region decimal4

public partial struct decimal4 : IEquatable<decimal4>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<decimal4, decimal4, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(decimal4 other)
    {
        return x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is decimal4 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        return HashCode.Combine(x, y, z, w);
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<decimal4, decimal4, bool>.operator ==(decimal4 left, decimal4 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<decimal4, decimal4, bool>.operator !=(decimal4 left, decimal4 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(decimal4 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(decimal4 other)
    {
        return x == other.x || y == other.y || z == other.z || w == other.w;
    }

    #endregion
}

#endregion // decimal4

#region half2

public partial struct half2 : IEquatable<half2>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<half2, half2, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(half2 other)
    {
        return x.Equals(other.x) && y.Equals(other.y);
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is half2 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        return HashCode.Combine(x, y);
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<half2, half2, bool>.operator ==(half2 left, half2 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<half2, half2, bool>.operator !=(half2 left, half2 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(half2 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(half2 other)
    {
        return x == other.x || y == other.y;
    }

    #endregion
}

#endregion // half2

#region half3

public partial struct half3 : IEquatable<half3>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<half3, half3, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(half3 other)
    {
        return x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is half3 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        return HashCode.Combine(x, y, z);
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<half3, half3, bool>.operator ==(half3 left, half3 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<half3, half3, bool>.operator !=(half3 left, half3 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(half3 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(half3 other)
    {
        return x == other.x || y == other.y || z == other.z;
    }

    #endregion
}

#endregion // half3

#region half4

public partial struct half4 : IEquatable<half4>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<half4, half4, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(half4 other)
    {
        return x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is half4 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        return HashCode.Combine(x, y, z, w);
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<half4, half4, bool>.operator ==(half4 left, half4 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<half4, half4, bool>.operator !=(half4 left, half4 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(half4 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(half4 other)
    {
        return x == other.x || y == other.y || z == other.z || w == other.w;
    }

    #endregion
}

#endregion // half4

#region b16v2

public partial struct b16v2 : IEquatable<b16v2>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<b16v2, b16v2, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(b16v2 other)
    {
        return x.Equals(other.x) && y.Equals(other.y);
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is b16v2 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        return HashCode.Combine(x, y);
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<b16v2, b16v2, bool>.operator ==(b16v2 left, b16v2 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<b16v2, b16v2, bool>.operator !=(b16v2 left, b16v2 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(b16v2 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(b16v2 other)
    {
        return x == other.x || y == other.y;
    }

    #endregion
}

#endregion // b16v2

#region b16v3

public partial struct b16v3 : IEquatable<b16v3>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<b16v3, b16v3, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(b16v3 other)
    {
        return x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is b16v3 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        return HashCode.Combine(x, y, z);
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<b16v3, b16v3, bool>.operator ==(b16v3 left, b16v3 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<b16v3, b16v3, bool>.operator !=(b16v3 left, b16v3 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(b16v3 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(b16v3 other)
    {
        return x == other.x || y == other.y || z == other.z;
    }

    #endregion
}

#endregion // b16v3

#region b16v4

public partial struct b16v4 : IEquatable<b16v4>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<b16v4, b16v4, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(b16v4 other)
    {
        return x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is b16v4 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        return HashCode.Combine(x, y, z, w);
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<b16v4, b16v4, bool>.operator ==(b16v4 left, b16v4 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<b16v4, b16v4, bool>.operator !=(b16v4 left, b16v4 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(b16v4 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(b16v4 other)
    {
        return x == other.x || y == other.y || z == other.z || w == other.w;
    }

    #endregion
}

#endregion // b16v4

#region b32v2

public partial struct b32v2 : IEquatable<b32v2>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<b32v2, b32v2, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(b32v2 other)
    {
        #if NET8_0_OR_GREATER
        return vector.Equals(other.vector);
        #else // NET8_0_OR_GREATER
        return x.Equals(other.x) && y.Equals(other.y);
        #endif // NET8_0_OR_GREATER
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is b32v2 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        #if NET8_0_OR_GREATER
        return vector.GetHashCode();
        #else // NET8_0_OR_GREATER
        return HashCode.Combine(x, y);
        #endif // NET8_0_OR_GREATER
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<b32v2, b32v2, bool>.operator ==(b32v2 left, b32v2 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<b32v2, b32v2, bool>.operator !=(b32v2 left, b32v2 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(b32v2 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(b32v2 other)
    {
        #if NET8_0_OR_GREATER
        return Vector64.EqualsAny(vector, other.vector);
        #else // NET8_0_OR_GREATER
        return x == other.x || y == other.y;
        #endif // NET8_0_OR_GREATER
    }

    #endregion
}

#endregion // b32v2

#region b32v3

public partial struct b32v3 : IEquatable<b32v3>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<b32v3, b32v3, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(b32v3 other)
    {
        #if NET8_0_OR_GREATER
        return vector.Equals(other.vector);
        #else // NET8_0_OR_GREATER
        return x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);
        #endif // NET8_0_OR_GREATER
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is b32v3 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        #if NET8_0_OR_GREATER
        return vector.GetHashCode();
        #else // NET8_0_OR_GREATER
        return HashCode.Combine(x, y, z);
        #endif // NET8_0_OR_GREATER
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<b32v3, b32v3, bool>.operator ==(b32v3 left, b32v3 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<b32v3, b32v3, bool>.operator !=(b32v3 left, b32v3 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(b32v3 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(b32v3 other)
    {
        #if NET8_0_OR_GREATER
        return Vector128.EqualsAny(vector, other.vector);
        #else // NET8_0_OR_GREATER
        return x == other.x || y == other.y || z == other.z;
        #endif // NET8_0_OR_GREATER
    }

    #endregion
}

#endregion // b32v3

#region b32v4

public partial struct b32v4 : IEquatable<b32v4>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<b32v4, b32v4, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(b32v4 other)
    {
        #if NET8_0_OR_GREATER
        return vector.Equals(other.vector);
        #else // NET8_0_OR_GREATER
        return x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);
        #endif // NET8_0_OR_GREATER
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is b32v4 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        #if NET8_0_OR_GREATER
        return vector.GetHashCode();
        #else // NET8_0_OR_GREATER
        return HashCode.Combine(x, y, z, w);
        #endif // NET8_0_OR_GREATER
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<b32v4, b32v4, bool>.operator ==(b32v4 left, b32v4 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<b32v4, b32v4, bool>.operator !=(b32v4 left, b32v4 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(b32v4 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(b32v4 other)
    {
        #if NET8_0_OR_GREATER
        return Vector128.EqualsAny(vector, other.vector);
        #else // NET8_0_OR_GREATER
        return x == other.x || y == other.y || z == other.z || w == other.w;
        #endif // NET8_0_OR_GREATER
    }

    #endregion
}

#endregion // b32v4

#region b64v2

public partial struct b64v2 : IEquatable<b64v2>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<b64v2, b64v2, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(b64v2 other)
    {
        #if NET8_0_OR_GREATER
        return vector.Equals(other.vector);
        #else // NET8_0_OR_GREATER
        return x.Equals(other.x) && y.Equals(other.y);
        #endif // NET8_0_OR_GREATER
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is b64v2 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        #if NET8_0_OR_GREATER
        return vector.GetHashCode();
        #else // NET8_0_OR_GREATER
        return HashCode.Combine(x, y);
        #endif // NET8_0_OR_GREATER
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<b64v2, b64v2, bool>.operator ==(b64v2 left, b64v2 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<b64v2, b64v2, bool>.operator !=(b64v2 left, b64v2 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(b64v2 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(b64v2 other)
    {
        #if NET8_0_OR_GREATER
        return Vector128.EqualsAny(vector, other.vector);
        #else // NET8_0_OR_GREATER
        return x == other.x || y == other.y;
        #endif // NET8_0_OR_GREATER
    }

    #endregion
}

#endregion // b64v2

#region b64v3

public partial struct b64v3 : IEquatable<b64v3>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<b64v3, b64v3, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(b64v3 other)
    {
        #if NET8_0_OR_GREATER
        return vector.Equals(other.vector);
        #else // NET8_0_OR_GREATER
        return x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);
        #endif // NET8_0_OR_GREATER
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is b64v3 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        #if NET8_0_OR_GREATER
        return vector.GetHashCode();
        #else // NET8_0_OR_GREATER
        return HashCode.Combine(x, y, z);
        #endif // NET8_0_OR_GREATER
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<b64v3, b64v3, bool>.operator ==(b64v3 left, b64v3 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<b64v3, b64v3, bool>.operator !=(b64v3 left, b64v3 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(b64v3 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(b64v3 other)
    {
        #if NET8_0_OR_GREATER
        return Vector256.EqualsAny(vector, other.vector);
        #else // NET8_0_OR_GREATER
        return x == other.x || y == other.y || z == other.z;
        #endif // NET8_0_OR_GREATER
    }

    #endregion
}

#endregion // b64v3

#region b64v4

public partial struct b64v4 : IEquatable<b64v4>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<b64v4, b64v4, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(b64v4 other)
    {
        #if NET8_0_OR_GREATER
        return vector.Equals(other.vector);
        #else // NET8_0_OR_GREATER
        return x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);
        #endif // NET8_0_OR_GREATER
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is b64v4 other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
        #if NET8_0_OR_GREATER
        return vector.GetHashCode();
        #else // NET8_0_OR_GREATER
        return HashCode.Combine(x, y, z, w);
        #endif // NET8_0_OR_GREATER
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<b64v4, b64v4, bool>.operator ==(b64v4 left, b64v4 right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<b64v4, b64v4, bool>.operator !=(b64v4 left, b64v4 right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(b64v4 other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(b64v4 other)
    {
        #if NET8_0_OR_GREATER
        return Vector256.EqualsAny(vector, other.vector);
        #else // NET8_0_OR_GREATER
        return x == other.x || y == other.y || z == other.z || w == other.w;
        #endif // NET8_0_OR_GREATER
    }

    #endregion
}

#endregion // b64v4
