// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region float2

public partial struct float2
{
    public static float2 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f); 
    }
    public static float2 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f);
    }
    public static float2 π
    { 
        [MethodImpl(256 | 512)] 
        get => PI;
    }
    public static float2 PI2
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f);
    }
    public static float2 π2
    { 
        [MethodImpl(256 | 512)] 
        get => PI2;
    }
    public static float2 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795862f);
    }
    public static float2 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f); 
    }
    public static float2 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f);
    }
    public static float2 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f);
    }
    public static float2 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f);
    }
}

public static partial class math
{

    [MethodImpl(256 | 512)]
    public static float2 ceil(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Ceiling(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.ceil(), a.y.ceil());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 floor(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector64.Floor(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.floor(), a.y.floor());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 round(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Round(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.round(), a.y.round());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 trunc(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Truncate(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.trunc(), a.y.trunc());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 frac(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - Vector64.Floor(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.frac(), a.y.frac());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 modf(this float2 a, out float2 i)
    {
        #if NET8_0_OR_GREATER
        var r = simd.ModF(a.vector, out var iv);
        i = new(iv);
        return new(r);
        #else // NET8_0_OR_GREATER
        float2 r = new(a.x.modf(out var i0), a.y.modf(out var i1));
        i = new(i0, i1);
        return r;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 rcp(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return float2.One / a;
        #else // NET8_0_OR_GREATER
        return new(a.x.rcp(), a.y.rcp());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 saturate(this float2 a)
    {
        #if NET8_0_OR_GREATER
        return a.clamp(default, float2.One);
        #else // NET8_0_OR_GREATER
        return new(a.x.saturate(), a.y.saturate());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 lerp(this float2 t, float2 start, float2 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 lerp(this float t, float2 start, float2 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(new(t), end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 unlerp(this float2 a, float2 start, float2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float2 unlerp(this float a, float2 start, float2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float2 remap(this float2 a, float2 srcStart, float2 srcEnd, float2 dstStart, float2 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float2 smoothstep(this float2 a, float2 min, float2 max)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * (3.0f - (2.0f * t));
    }

    [MethodImpl(256 | 512)]
    public static float2 reflect(this float2 i, float2 n) => i - 2f * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static float2 project(this float2 a, float2 onto) =>
        (float)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static float2 radians(this float2 a) => a * float2.DegToRad;

    [MethodImpl(256 | 512)]
    public static float2 degrees(this float2 a) => a * float2.RadToDeg;
}

#endregion // float2

#region float3

public partial struct float3
{
    public static float3 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f); 
    }
    public static float3 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f);
    }
    public static float3 π
    { 
        [MethodImpl(256 | 512)] 
        get => PI;
    }
    public static float3 PI2
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f);
    }
    public static float3 π2
    { 
        [MethodImpl(256 | 512)] 
        get => PI2;
    }
    public static float3 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795862f);
    }
    public static float3 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f); 
    }
    public static float3 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f);
    }
    public static float3 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f);
    }
    public static float3 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f);
    }
}

public static partial class math
{

    [MethodImpl(256 | 512)]
    public static float3 ceil(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Ceiling(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.ceil(), a.y.ceil(), a.z.ceil());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 floor(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Floor(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.floor(), a.y.floor(), a.z.floor());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 round(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Round(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.round(), a.y.round(), a.z.round());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 trunc(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Truncate(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.trunc(), a.y.trunc(), a.z.trunc());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 frac(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - Vector128.Floor(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.frac(), a.y.frac(), a.z.frac());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 modf(this float3 a, out float3 i)
    {
        #if NET8_0_OR_GREATER
        var r = simd.ModF(a.vector, out var iv);
        i = new(iv);
        return new(r);
        #else // NET8_0_OR_GREATER
        float3 r = new(a.x.modf(out var i0), a.y.modf(out var i1), a.z.modf(out var i2));
        i = new(i0, i1, i2);
        return r;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 rcp(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return float3.One / a;
        #else // NET8_0_OR_GREATER
        return new(a.x.rcp(), a.y.rcp(), a.z.rcp());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 saturate(this float3 a)
    {
        #if NET8_0_OR_GREATER
        return a.clamp(default, float3.One);
        #else // NET8_0_OR_GREATER
        return new(a.x.saturate(), a.y.saturate(), a.z.saturate());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 lerp(this float3 t, float3 start, float3 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 lerp(this float t, float3 start, float3 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(new(t), end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 unlerp(this float3 a, float3 start, float3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float3 unlerp(this float a, float3 start, float3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float3 remap(this float3 a, float3 srcStart, float3 srcEnd, float3 dstStart, float3 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float3 smoothstep(this float3 a, float3 min, float3 max)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * (3.0f - (2.0f * t));
    }

    [MethodImpl(256 | 512)]
    public static float3 reflect(this float3 i, float3 n) => i - 2f * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static float3 project(this float3 a, float3 onto) =>
        (float)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static float3 radians(this float3 a) => a * float3.DegToRad;

    [MethodImpl(256 | 512)]
    public static float3 degrees(this float3 a) => a * float3.RadToDeg;
}

#endregion // float3

#region float4

public partial struct float4
{
    public static float4 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f); 
    }
    public static float4 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f);
    }
    public static float4 π
    { 
        [MethodImpl(256 | 512)] 
        get => PI;
    }
    public static float4 PI2
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f);
    }
    public static float4 π2
    { 
        [MethodImpl(256 | 512)] 
        get => PI2;
    }
    public static float4 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795862f);
    }
    public static float4 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f); 
    }
    public static float4 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f);
    }
    public static float4 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f);
    }
    public static float4 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f);
    }
}

public static partial class math
{

    [MethodImpl(256 | 512)]
    public static float4 ceil(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Ceiling(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.ceil(), a.y.ceil(), a.z.ceil(), a.w.ceil());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 floor(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Floor(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 round(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Round(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.round(), a.y.round(), a.z.round(), a.w.round());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 trunc(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Truncate(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.trunc(), a.y.trunc(), a.z.trunc(), a.w.trunc());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 frac(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - Vector128.Floor(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.frac(), a.y.frac(), a.z.frac(), a.w.frac());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 modf(this float4 a, out float4 i)
    {
        #if NET8_0_OR_GREATER
        var r = simd.ModF(a.vector, out var iv);
        i = new(iv);
        return new(r);
        #else // NET8_0_OR_GREATER
        float4 r = new(a.x.modf(out var i0), a.y.modf(out var i1), a.z.modf(out var i2), a.w.modf(out var i3));
        i = new(i0, i1, i2, i3);
        return r;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 rcp(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return float4.One / a;
        #else // NET8_0_OR_GREATER
        return new(a.x.rcp(), a.y.rcp(), a.z.rcp(), a.w.rcp());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 saturate(this float4 a)
    {
        #if NET8_0_OR_GREATER
        return a.clamp(default, float4.One);
        #else // NET8_0_OR_GREATER
        return new(a.x.saturate(), a.y.saturate(), a.z.saturate(), a.w.saturate());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 lerp(this float4 t, float4 start, float4 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 lerp(this float t, float4 start, float4 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(new(t), end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 unlerp(this float4 a, float4 start, float4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float4 unlerp(this float a, float4 start, float4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float4 remap(this float4 a, float4 srcStart, float4 srcEnd, float4 dstStart, float4 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float4 smoothstep(this float4 a, float4 min, float4 max)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * (3.0f - (2.0f * t));
    }

    [MethodImpl(256 | 512)]
    public static float4 reflect(this float4 i, float4 n) => i - 2f * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static float4 project(this float4 a, float4 onto) =>
        (float)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static float4 radians(this float4 a) => a * float4.DegToRad;

    [MethodImpl(256 | 512)]
    public static float4 degrees(this float4 a) => a * float4.RadToDeg;
}

#endregion // float4

#region double2

public partial struct double2
{
    public static double2 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277); 
    }
    public static double2 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923);
    }
    public static double2 π
    { 
        [MethodImpl(256 | 512)] 
        get => PI;
    }
    public static double2 PI2
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846);
    }
    public static double2 π2
    { 
        [MethodImpl(256 | 512)] 
        get => PI2;
    }
    public static double2 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795862);
    }
    public static double2 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094); 
    }
    public static double2 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009);
    }
    public static double2 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861);
    }
    public static double2 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144);
    }
}

public static partial class math
{

    [MethodImpl(256 | 512)]
    public static double2 ceil(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Ceiling(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.ceil(), a.y.ceil());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 floor(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector128.Floor(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.floor(), a.y.floor());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 round(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Round(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.round(), a.y.round());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 trunc(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Truncate(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.trunc(), a.y.trunc());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 frac(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - Vector128.Floor(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.frac(), a.y.frac());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 modf(this double2 a, out double2 i)
    {
        #if NET8_0_OR_GREATER
        var r = simd.ModF(a.vector, out var iv);
        i = new(iv);
        return new(r);
        #else // NET8_0_OR_GREATER
        double2 r = new(a.x.modf(out var i0), a.y.modf(out var i1));
        i = new(i0, i1);
        return r;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 rcp(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return double2.One / a;
        #else // NET8_0_OR_GREATER
        return new(a.x.rcp(), a.y.rcp());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 saturate(this double2 a)
    {
        #if NET8_0_OR_GREATER
        return a.clamp(default, double2.One);
        #else // NET8_0_OR_GREATER
        return new(a.x.saturate(), a.y.saturate());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 lerp(this double2 t, double2 start, double2 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 lerp(this double t, double2 start, double2 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(new(t), end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 unlerp(this double2 a, double2 start, double2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double2 unlerp(this double a, double2 start, double2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double2 remap(this double2 a, double2 srcStart, double2 srcEnd, double2 dstStart, double2 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double2 smoothstep(this double2 a, double2 min, double2 max)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * (3.0 - (2.0 * t));
    }

    [MethodImpl(256 | 512)]
    public static double2 reflect(this double2 i, double2 n) => i - 2 * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static double2 project(this double2 a, double2 onto) =>
        (double)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static double2 radians(this double2 a) => a * double2.DegToRad;

    [MethodImpl(256 | 512)]
    public static double2 degrees(this double2 a) => a * double2.RadToDeg;
}

#endregion // double2

#region double3

public partial struct double3
{
    public static double3 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277); 
    }
    public static double3 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923);
    }
    public static double3 π
    { 
        [MethodImpl(256 | 512)] 
        get => PI;
    }
    public static double3 PI2
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846);
    }
    public static double3 π2
    { 
        [MethodImpl(256 | 512)] 
        get => PI2;
    }
    public static double3 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795862);
    }
    public static double3 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094); 
    }
    public static double3 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009);
    }
    public static double3 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861);
    }
    public static double3 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144);
    }
}

public static partial class math
{

    [MethodImpl(256 | 512)]
    public static double3 ceil(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Ceiling(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.ceil(), a.y.ceil(), a.z.ceil());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 floor(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Floor(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.floor(), a.y.floor(), a.z.floor());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 round(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Round(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.round(), a.y.round(), a.z.round());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 trunc(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Truncate(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.trunc(), a.y.trunc(), a.z.trunc());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 frac(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - Vector256.Floor(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.frac(), a.y.frac(), a.z.frac());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 modf(this double3 a, out double3 i)
    {
        #if NET8_0_OR_GREATER
        var r = simd.ModF(a.vector, out var iv);
        i = new(iv);
        return new(r);
        #else // NET8_0_OR_GREATER
        double3 r = new(a.x.modf(out var i0), a.y.modf(out var i1), a.z.modf(out var i2));
        i = new(i0, i1, i2);
        return r;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 rcp(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return double3.One / a;
        #else // NET8_0_OR_GREATER
        return new(a.x.rcp(), a.y.rcp(), a.z.rcp());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 saturate(this double3 a)
    {
        #if NET8_0_OR_GREATER
        return a.clamp(default, double3.One);
        #else // NET8_0_OR_GREATER
        return new(a.x.saturate(), a.y.saturate(), a.z.saturate());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 lerp(this double3 t, double3 start, double3 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 lerp(this double t, double3 start, double3 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(new(t), end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 unlerp(this double3 a, double3 start, double3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double3 unlerp(this double a, double3 start, double3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double3 remap(this double3 a, double3 srcStart, double3 srcEnd, double3 dstStart, double3 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double3 smoothstep(this double3 a, double3 min, double3 max)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * (3.0 - (2.0 * t));
    }

    [MethodImpl(256 | 512)]
    public static double3 reflect(this double3 i, double3 n) => i - 2 * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static double3 project(this double3 a, double3 onto) =>
        (double)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static double3 radians(this double3 a) => a * double3.DegToRad;

    [MethodImpl(256 | 512)]
    public static double3 degrees(this double3 a) => a * double3.RadToDeg;
}

#endregion // double3

#region double4

public partial struct double4
{
    public static double4 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277); 
    }
    public static double4 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923);
    }
    public static double4 π
    { 
        [MethodImpl(256 | 512)] 
        get => PI;
    }
    public static double4 PI2
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846);
    }
    public static double4 π2
    { 
        [MethodImpl(256 | 512)] 
        get => PI2;
    }
    public static double4 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795862);
    }
    public static double4 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094); 
    }
    public static double4 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009);
    }
    public static double4 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861);
    }
    public static double4 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144);
    }
}

public static partial class math
{

    [MethodImpl(256 | 512)]
    public static double4 ceil(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Ceiling(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.ceil(), a.y.ceil(), a.z.ceil(), a.w.ceil());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 floor(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(Vector256.Floor(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 round(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Round(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.round(), a.y.round(), a.z.round(), a.w.round());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 trunc(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(simd.Truncate(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.trunc(), a.y.trunc(), a.z.trunc(), a.w.trunc());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 frac(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return new(a.vector - Vector256.Floor(a.vector));
        #else // NET8_0_OR_GREATER
        return new(a.x.frac(), a.y.frac(), a.z.frac(), a.w.frac());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 modf(this double4 a, out double4 i)
    {
        #if NET8_0_OR_GREATER
        var r = simd.ModF(a.vector, out var iv);
        i = new(iv);
        return new(r);
        #else // NET8_0_OR_GREATER
        double4 r = new(a.x.modf(out var i0), a.y.modf(out var i1), a.z.modf(out var i2), a.w.modf(out var i3));
        i = new(i0, i1, i2, i3);
        return r;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 rcp(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return double4.One / a;
        #else // NET8_0_OR_GREATER
        return new(a.x.rcp(), a.y.rcp(), a.z.rcp(), a.w.rcp());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 saturate(this double4 a)
    {
        #if NET8_0_OR_GREATER
        return a.clamp(default, double4.One);
        #else // NET8_0_OR_GREATER
        return new(a.x.saturate(), a.y.saturate(), a.z.saturate(), a.w.saturate());
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 lerp(this double4 t, double4 start, double4 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 lerp(this double t, double4 start, double4 end)
    {
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(new(t), end - start, start);
        #else // NET8_0_OR_GREATER
        return start + t * (end - start);
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 unlerp(this double4 a, double4 start, double4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double4 unlerp(this double a, double4 start, double4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double4 remap(this double4 a, double4 srcStart, double4 srcEnd, double4 dstStart, double4 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double4 smoothstep(this double4 a, double4 min, double4 max)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * (3.0 - (2.0 * t));
    }

    [MethodImpl(256 | 512)]
    public static double4 reflect(this double4 i, double4 n) => i - 2 * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static double4 project(this double4 a, double4 onto) =>
        (double)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static double4 radians(this double4 a) => a * double4.DegToRad;

    [MethodImpl(256 | 512)]
    public static double4 degrees(this double4 a) => a * double4.RadToDeg;
}

#endregion // double4

#region decimal2

public partial struct decimal2
{
    public static decimal2 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277m); 
    }
    public static decimal2 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923m);
    }
    public static decimal2 π
    { 
        [MethodImpl(256 | 512)] 
        get => PI;
    }
    public static decimal2 PI2
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846m);
    }
    public static decimal2 π2
    { 
        [MethodImpl(256 | 512)] 
        get => PI2;
    }
    public static decimal2 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795862m);
    }
    public static decimal2 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094m); 
    }
    public static decimal2 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009m);
    }
    public static decimal2 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861m);
    }
    public static decimal2 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144m);
    }
}

public static partial class math
{

    [MethodImpl(256 | 512)]
    public static decimal2 ceil(this decimal2 a)
    {
        return new(a.x.ceil(), a.y.ceil());
    }

    [MethodImpl(256 | 512)]
    public static decimal2 floor(this decimal2 a)
    {
        return new(a.x.floor(), a.y.floor());
    }

    [MethodImpl(256 | 512)]
    public static decimal2 round(this decimal2 a)
    {
        return new(a.x.round(), a.y.round());
    }

    [MethodImpl(256 | 512)]
    public static decimal2 trunc(this decimal2 a)
    {
        return new(a.x.trunc(), a.y.trunc());
    }

    [MethodImpl(256 | 512)]
    public static decimal2 frac(this decimal2 a)
    {
        return new(a.x.frac(), a.y.frac());
    }

    [MethodImpl(256 | 512)]
    public static decimal2 modf(this decimal2 a, out decimal2 i)
    {
        decimal2 r = new(a.x.modf(out var i0), a.y.modf(out var i1));
        i = new(i0, i1);
        return r;
    }

    [MethodImpl(256 | 512)]
    public static decimal2 rcp(this decimal2 a)
    {
        return new(a.x.rcp(), a.y.rcp());
    }

    [MethodImpl(256 | 512)]
    public static decimal2 saturate(this decimal2 a)
    {
        return new(a.x.saturate(), a.y.saturate());
    }

    [MethodImpl(256 | 512)]
    public static decimal2 lerp(this decimal2 t, decimal2 start, decimal2 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static decimal2 lerp(this decimal t, decimal2 start, decimal2 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static decimal2 unlerp(this decimal2 a, decimal2 start, decimal2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static decimal2 unlerp(this decimal a, decimal2 start, decimal2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static decimal2 remap(this decimal2 a, decimal2 srcStart, decimal2 srcEnd, decimal2 dstStart, decimal2 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static decimal2 smoothstep(this decimal2 a, decimal2 min, decimal2 max)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * (3.0m - (2.0m * t));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 reflect(this decimal2 i, decimal2 n) => i - 2m * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static decimal2 project(this decimal2 a, decimal2 onto) =>
        (decimal)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static decimal2 radians(this decimal2 a) => a * decimal2.DegToRad;

    [MethodImpl(256 | 512)]
    public static decimal2 degrees(this decimal2 a) => a * decimal2.RadToDeg;
}

#endregion // decimal2

#region decimal3

public partial struct decimal3
{
    public static decimal3 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277m); 
    }
    public static decimal3 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923m);
    }
    public static decimal3 π
    { 
        [MethodImpl(256 | 512)] 
        get => PI;
    }
    public static decimal3 PI2
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846m);
    }
    public static decimal3 π2
    { 
        [MethodImpl(256 | 512)] 
        get => PI2;
    }
    public static decimal3 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795862m);
    }
    public static decimal3 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094m); 
    }
    public static decimal3 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009m);
    }
    public static decimal3 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861m);
    }
    public static decimal3 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144m);
    }
}

public static partial class math
{

    [MethodImpl(256 | 512)]
    public static decimal3 ceil(this decimal3 a)
    {
        return new(a.x.ceil(), a.y.ceil(), a.z.ceil());
    }

    [MethodImpl(256 | 512)]
    public static decimal3 floor(this decimal3 a)
    {
        return new(a.x.floor(), a.y.floor(), a.z.floor());
    }

    [MethodImpl(256 | 512)]
    public static decimal3 round(this decimal3 a)
    {
        return new(a.x.round(), a.y.round(), a.z.round());
    }

    [MethodImpl(256 | 512)]
    public static decimal3 trunc(this decimal3 a)
    {
        return new(a.x.trunc(), a.y.trunc(), a.z.trunc());
    }

    [MethodImpl(256 | 512)]
    public static decimal3 frac(this decimal3 a)
    {
        return new(a.x.frac(), a.y.frac(), a.z.frac());
    }

    [MethodImpl(256 | 512)]
    public static decimal3 modf(this decimal3 a, out decimal3 i)
    {
        decimal3 r = new(a.x.modf(out var i0), a.y.modf(out var i1), a.z.modf(out var i2));
        i = new(i0, i1, i2);
        return r;
    }

    [MethodImpl(256 | 512)]
    public static decimal3 rcp(this decimal3 a)
    {
        return new(a.x.rcp(), a.y.rcp(), a.z.rcp());
    }

    [MethodImpl(256 | 512)]
    public static decimal3 saturate(this decimal3 a)
    {
        return new(a.x.saturate(), a.y.saturate(), a.z.saturate());
    }

    [MethodImpl(256 | 512)]
    public static decimal3 lerp(this decimal3 t, decimal3 start, decimal3 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static decimal3 lerp(this decimal t, decimal3 start, decimal3 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static decimal3 unlerp(this decimal3 a, decimal3 start, decimal3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static decimal3 unlerp(this decimal a, decimal3 start, decimal3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static decimal3 remap(this decimal3 a, decimal3 srcStart, decimal3 srcEnd, decimal3 dstStart, decimal3 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static decimal3 smoothstep(this decimal3 a, decimal3 min, decimal3 max)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * (3.0m - (2.0m * t));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 reflect(this decimal3 i, decimal3 n) => i - 2m * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static decimal3 project(this decimal3 a, decimal3 onto) =>
        (decimal)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static decimal3 radians(this decimal3 a) => a * decimal3.DegToRad;

    [MethodImpl(256 | 512)]
    public static decimal3 degrees(this decimal3 a) => a * decimal3.RadToDeg;
}

#endregion // decimal3

#region decimal4

public partial struct decimal4
{
    public static decimal4 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277m); 
    }
    public static decimal4 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923m);
    }
    public static decimal4 π
    { 
        [MethodImpl(256 | 512)] 
        get => PI;
    }
    public static decimal4 PI2
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846m);
    }
    public static decimal4 π2
    { 
        [MethodImpl(256 | 512)] 
        get => PI2;
    }
    public static decimal4 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795862m);
    }
    public static decimal4 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094m); 
    }
    public static decimal4 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009m);
    }
    public static decimal4 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861m);
    }
    public static decimal4 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144m);
    }
}

public static partial class math
{

    [MethodImpl(256 | 512)]
    public static decimal4 ceil(this decimal4 a)
    {
        return new(a.x.ceil(), a.y.ceil(), a.z.ceil(), a.w.ceil());
    }

    [MethodImpl(256 | 512)]
    public static decimal4 floor(this decimal4 a)
    {
        return new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());
    }

    [MethodImpl(256 | 512)]
    public static decimal4 round(this decimal4 a)
    {
        return new(a.x.round(), a.y.round(), a.z.round(), a.w.round());
    }

    [MethodImpl(256 | 512)]
    public static decimal4 trunc(this decimal4 a)
    {
        return new(a.x.trunc(), a.y.trunc(), a.z.trunc(), a.w.trunc());
    }

    [MethodImpl(256 | 512)]
    public static decimal4 frac(this decimal4 a)
    {
        return new(a.x.frac(), a.y.frac(), a.z.frac(), a.w.frac());
    }

    [MethodImpl(256 | 512)]
    public static decimal4 modf(this decimal4 a, out decimal4 i)
    {
        decimal4 r = new(a.x.modf(out var i0), a.y.modf(out var i1), a.z.modf(out var i2), a.w.modf(out var i3));
        i = new(i0, i1, i2, i3);
        return r;
    }

    [MethodImpl(256 | 512)]
    public static decimal4 rcp(this decimal4 a)
    {
        return new(a.x.rcp(), a.y.rcp(), a.z.rcp(), a.w.rcp());
    }

    [MethodImpl(256 | 512)]
    public static decimal4 saturate(this decimal4 a)
    {
        return new(a.x.saturate(), a.y.saturate(), a.z.saturate(), a.w.saturate());
    }

    [MethodImpl(256 | 512)]
    public static decimal4 lerp(this decimal4 t, decimal4 start, decimal4 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static decimal4 lerp(this decimal t, decimal4 start, decimal4 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static decimal4 unlerp(this decimal4 a, decimal4 start, decimal4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static decimal4 unlerp(this decimal a, decimal4 start, decimal4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static decimal4 remap(this decimal4 a, decimal4 srcStart, decimal4 srcEnd, decimal4 dstStart, decimal4 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static decimal4 smoothstep(this decimal4 a, decimal4 min, decimal4 max)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * (3.0m - (2.0m * t));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 reflect(this decimal4 i, decimal4 n) => i - 2m * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static decimal4 project(this decimal4 a, decimal4 onto) =>
        (decimal)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static decimal4 radians(this decimal4 a) => a * decimal4.DegToRad;

    [MethodImpl(256 | 512)]
    public static decimal4 degrees(this decimal4 a) => a * decimal4.RadToDeg;
}

#endregion // decimal4

#region half2

public partial struct half2
{
    public static half2 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f.half()); 
    }
    public static half2 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f.half());
    }
    public static half2 π
    { 
        [MethodImpl(256 | 512)] 
        get => PI;
    }
    public static half2 PI2
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f.half());
    }
    public static half2 π2
    { 
        [MethodImpl(256 | 512)] 
        get => PI2;
    }
    public static half2 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795862f.half());
    }
    public static half2 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f.half()); 
    }
    public static half2 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f.half());
    }
    public static half2 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f.half());
    }
    public static half2 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f.half());
    }
}

public static partial class math
{

    [MethodImpl(256 | 512)]
    public static half2 ceil(this half2 a)
    {
        return new(a.x.ceil(), a.y.ceil());
    }

    [MethodImpl(256 | 512)]
    public static half2 floor(this half2 a)
    {
        return new(a.x.floor(), a.y.floor());
    }

    [MethodImpl(256 | 512)]
    public static half2 round(this half2 a)
    {
        return new(a.x.round(), a.y.round());
    }

    [MethodImpl(256 | 512)]
    public static half2 trunc(this half2 a)
    {
        return new(a.x.trunc(), a.y.trunc());
    }

    [MethodImpl(256 | 512)]
    public static half2 frac(this half2 a)
    {
        return new(a.x.frac(), a.y.frac());
    }

    [MethodImpl(256 | 512)]
    public static half2 modf(this half2 a, out half2 i)
    {
        half2 r = new(a.x.modf(out var i0), a.y.modf(out var i1));
        i = new(i0, i1);
        return r;
    }

    [MethodImpl(256 | 512)]
    public static half2 rcp(this half2 a)
    {
        return new(a.x.rcp(), a.y.rcp());
    }

    [MethodImpl(256 | 512)]
    public static half2 saturate(this half2 a)
    {
        return new(a.x.saturate(), a.y.saturate());
    }

    [MethodImpl(256 | 512)]
    public static half2 lerp(this half2 t, half2 start, half2 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static half2 lerp(this half t, half2 start, half2 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static half2 unlerp(this half2 a, half2 start, half2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static half2 unlerp(this half a, half2 start, half2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static half2 remap(this half2 a, half2 srcStart, half2 srcEnd, half2 dstStart, half2 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static half2 smoothstep(this half2 a, half2 min, half2 max)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * (3.0f.half() - (2.0f.half() * t));
    }

    [MethodImpl(256 | 512)]
    public static half2 reflect(this half2 i, half2 n) => i - 2f.half() * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static half2 project(this half2 a, half2 onto) =>
        (half)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static half2 radians(this half2 a) => a * half2.DegToRad;

    [MethodImpl(256 | 512)]
    public static half2 degrees(this half2 a) => a * half2.RadToDeg;
}

#endregion // half2

#region half3

public partial struct half3
{
    public static half3 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f.half()); 
    }
    public static half3 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f.half());
    }
    public static half3 π
    { 
        [MethodImpl(256 | 512)] 
        get => PI;
    }
    public static half3 PI2
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f.half());
    }
    public static half3 π2
    { 
        [MethodImpl(256 | 512)] 
        get => PI2;
    }
    public static half3 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795862f.half());
    }
    public static half3 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f.half()); 
    }
    public static half3 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f.half());
    }
    public static half3 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f.half());
    }
    public static half3 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f.half());
    }
}

public static partial class math
{

    [MethodImpl(256 | 512)]
    public static half3 ceil(this half3 a)
    {
        return new(a.x.ceil(), a.y.ceil(), a.z.ceil());
    }

    [MethodImpl(256 | 512)]
    public static half3 floor(this half3 a)
    {
        return new(a.x.floor(), a.y.floor(), a.z.floor());
    }

    [MethodImpl(256 | 512)]
    public static half3 round(this half3 a)
    {
        return new(a.x.round(), a.y.round(), a.z.round());
    }

    [MethodImpl(256 | 512)]
    public static half3 trunc(this half3 a)
    {
        return new(a.x.trunc(), a.y.trunc(), a.z.trunc());
    }

    [MethodImpl(256 | 512)]
    public static half3 frac(this half3 a)
    {
        return new(a.x.frac(), a.y.frac(), a.z.frac());
    }

    [MethodImpl(256 | 512)]
    public static half3 modf(this half3 a, out half3 i)
    {
        half3 r = new(a.x.modf(out var i0), a.y.modf(out var i1), a.z.modf(out var i2));
        i = new(i0, i1, i2);
        return r;
    }

    [MethodImpl(256 | 512)]
    public static half3 rcp(this half3 a)
    {
        return new(a.x.rcp(), a.y.rcp(), a.z.rcp());
    }

    [MethodImpl(256 | 512)]
    public static half3 saturate(this half3 a)
    {
        return new(a.x.saturate(), a.y.saturate(), a.z.saturate());
    }

    [MethodImpl(256 | 512)]
    public static half3 lerp(this half3 t, half3 start, half3 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static half3 lerp(this half t, half3 start, half3 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static half3 unlerp(this half3 a, half3 start, half3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static half3 unlerp(this half a, half3 start, half3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static half3 remap(this half3 a, half3 srcStart, half3 srcEnd, half3 dstStart, half3 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static half3 smoothstep(this half3 a, half3 min, half3 max)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * (3.0f.half() - (2.0f.half() * t));
    }

    [MethodImpl(256 | 512)]
    public static half3 reflect(this half3 i, half3 n) => i - 2f.half() * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static half3 project(this half3 a, half3 onto) =>
        (half)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static half3 radians(this half3 a) => a * half3.DegToRad;

    [MethodImpl(256 | 512)]
    public static half3 degrees(this half3 a) => a * half3.RadToDeg;
}

#endregion // half3

#region half4

public partial struct half4
{
    public static half4 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f.half()); 
    }
    public static half4 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f.half());
    }
    public static half4 π
    { 
        [MethodImpl(256 | 512)] 
        get => PI;
    }
    public static half4 PI2
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f.half());
    }
    public static half4 π2
    { 
        [MethodImpl(256 | 512)] 
        get => PI2;
    }
    public static half4 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795862f.half());
    }
    public static half4 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f.half()); 
    }
    public static half4 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f.half());
    }
    public static half4 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f.half());
    }
    public static half4 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f.half());
    }
}

public static partial class math
{

    [MethodImpl(256 | 512)]
    public static half4 ceil(this half4 a)
    {
        return new(a.x.ceil(), a.y.ceil(), a.z.ceil(), a.w.ceil());
    }

    [MethodImpl(256 | 512)]
    public static half4 floor(this half4 a)
    {
        return new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());
    }

    [MethodImpl(256 | 512)]
    public static half4 round(this half4 a)
    {
        return new(a.x.round(), a.y.round(), a.z.round(), a.w.round());
    }

    [MethodImpl(256 | 512)]
    public static half4 trunc(this half4 a)
    {
        return new(a.x.trunc(), a.y.trunc(), a.z.trunc(), a.w.trunc());
    }

    [MethodImpl(256 | 512)]
    public static half4 frac(this half4 a)
    {
        return new(a.x.frac(), a.y.frac(), a.z.frac(), a.w.frac());
    }

    [MethodImpl(256 | 512)]
    public static half4 modf(this half4 a, out half4 i)
    {
        half4 r = new(a.x.modf(out var i0), a.y.modf(out var i1), a.z.modf(out var i2), a.w.modf(out var i3));
        i = new(i0, i1, i2, i3);
        return r;
    }

    [MethodImpl(256 | 512)]
    public static half4 rcp(this half4 a)
    {
        return new(a.x.rcp(), a.y.rcp(), a.z.rcp(), a.w.rcp());
    }

    [MethodImpl(256 | 512)]
    public static half4 saturate(this half4 a)
    {
        return new(a.x.saturate(), a.y.saturate(), a.z.saturate(), a.w.saturate());
    }

    [MethodImpl(256 | 512)]
    public static half4 lerp(this half4 t, half4 start, half4 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static half4 lerp(this half t, half4 start, half4 end)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static half4 unlerp(this half4 a, half4 start, half4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static half4 unlerp(this half a, half4 start, half4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static half4 remap(this half4 a, half4 srcStart, half4 srcEnd, half4 dstStart, half4 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static half4 smoothstep(this half4 a, half4 min, half4 max)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * (3.0f.half() - (2.0f.half() * t));
    }

    [MethodImpl(256 | 512)]
    public static half4 reflect(this half4 i, half4 n) => i - 2f.half() * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static half4 project(this half4 a, half4 onto) =>
        (half)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static half4 radians(this half4 a) => a * half4.DegToRad;

    [MethodImpl(256 | 512)]
    public static half4 degrees(this half4 a) => a * half4.RadToDeg;
}

#endregion // half4
