// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region float2x2

[Serializable]
[JsonConverter(typeof(float2x2JsonConverter))]
public partial struct float2x2 :
    IMatrix2x2<float>, IMatrixSelf<float2x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static float2x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static float2x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0f); 
    }

    public static float2x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default,
            default, 1.0f
        ); 
    }

    #endregion

    #region fields
    public float2 c0;
    public float2 c1;

    #endregion

    #region getter

    public float m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public float2x2(float2 c0, float2 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public float2x2((float2 c0, float2 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x2((float2 c0, float2 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x2(
        float m00, float m01,
        float m10, float m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x2((
        float m00, float m01,
        float m10, float m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x2((
        float m00, float m01,
        float m10, float m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x2((
        (float m00, float m01) r0,
        (float m10, float m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x2((
        (float m00, float m01) r0,
        (float m10, float m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x2(float value) => new(value);

    [MethodImpl(256 | 512)]
    public float2x2(float value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x2(float2 value) => new(value);

    [MethodImpl(256 | 512)]
    public float2x2(float2 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out float2 c0, out float2 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out float m00, out float m01,
        out float m10, out float m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // deconstruct

    #region index

    public float2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // float2x2

#region float2x3

[Serializable]
[JsonConverter(typeof(float2x3JsonConverter))]
public partial struct float2x3 :
    IMatrix2x3<float>, IMatrixSelf<float2x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static float2x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static float2x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0f); 
    }

    public static float2x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default, default,
            default, 1.0f, default
        ); 
    }

    #endregion

    #region fields
    public float2 c0;
    public float2 c1;
    public float2 c2;

    #endregion

    #region getter

    public float m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public float m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public float2x3(float2 c0, float2 c1, float2 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public float2x3((float2 c0, float2 c1, float2 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x3((float2 c0, float2 c1, float2 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x3(
        float m00, float m01, float m02,
        float m10, float m11, float m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x3((
        float m00, float m01, float m02,
        float m10, float m11, float m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x3((
        float m00, float m01, float m02,
        float m10, float m11, float m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x3((
        (float m00, float m01, float m02) r0,
        (float m10, float m11, float m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x3((
        (float m00, float m01, float m02) r0,
        (float m10, float m11, float m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x3(float value) => new(value);

    [MethodImpl(256 | 512)]
    public float2x3(float value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x3(float2 value) => new(value);

    [MethodImpl(256 | 512)]
    public float2x3(float2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out float2 c0, out float2 c1, out float2 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out float m00, out float m01, out float m02,
        out float m10, out float m11, out float m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // deconstruct

    #region index

    public float2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // float2x3

#region float2x4

[Serializable]
[JsonConverter(typeof(float2x4JsonConverter))]
public partial struct float2x4 :
    IMatrix2x4<float>, IMatrixSelf<float2x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static float2x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static float2x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0f); 
    }

    public static float2x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default, default, default,
            default, 1.0f, default, default
        ); 
    }

    #endregion

    #region fields
    public float2 c0;
    public float2 c1;
    public float2 c2;
    public float2 c3;

    #endregion

    #region getter

    public float m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public float m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public float m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public float m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public float2x4(float2 c0, float2 c1, float2 c2, float2 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public float2x4((float2 c0, float2 c1, float2 c2, float2 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x4((float2 c0, float2 c1, float2 c2, float2 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x4(
        float m00, float m01, float m02, float m03,
        float m10, float m11, float m12, float m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x4((
        float m00, float m01, float m02, float m03,
        float m10, float m11, float m12, float m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x4((
        float m00, float m01, float m02, float m03,
        float m10, float m11, float m12, float m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x4((
        (float m00, float m01, float m02, float m03) r0,
        (float m10, float m11, float m12, float m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x4((
        (float m00, float m01, float m02, float m03) r0,
        (float m10, float m11, float m12, float m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x4(float value) => new(value);

    [MethodImpl(256 | 512)]
    public float2x4(float value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x4(float2 value) => new(value);

    [MethodImpl(256 | 512)]
    public float2x4(float2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out float2 c0, out float2 c1, out float2 c2, out float2 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out float m00, out float m01, out float m02, out float m03,
        out float m10, out float m11, out float m12, out float m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // deconstruct

    #region index

    public float2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // float2x4

#region float3x2

[Serializable]
[JsonConverter(typeof(float3x2JsonConverter))]
public partial struct float3x2 :
    IMatrix3x2<float>, IMatrixSelf<float3x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static float3x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static float3x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0f); 
    }

    public static float3x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default,
            default, 1.0f,
            default, default
        ); 
    }

    #endregion

    #region fields
    public float3 c0;
    public float3 c1;

    #endregion

    #region getter

    public float m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public float m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public float3x2(float3 c0, float3 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public float3x2((float3 c0, float3 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x2((float3 c0, float3 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x2(
        float m00, float m01,
        float m10, float m11,
        float m20, float m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x2((
        float m00, float m01,
        float m10, float m11,
        float m20, float m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x2((
        float m00, float m01,
        float m10, float m11,
        float m20, float m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x2((
        (float m00, float m01) r0,
        (float m10, float m11) r1,
        (float m20, float m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x2((
        (float m00, float m01) r0,
        (float m10, float m11) r1,
        (float m20, float m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x2(float value) => new(value);

    [MethodImpl(256 | 512)]
    public float3x2(float value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x2(float3 value) => new(value);

    [MethodImpl(256 | 512)]
    public float3x2(float3 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out float3 c0, out float3 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out float m00, out float m01,
        out float m10, out float m11,
        out float m20, out float m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // deconstruct

    #region index

    public float3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // float3x2

#region float3x3

[Serializable]
[JsonConverter(typeof(float3x3JsonConverter))]
public partial struct float3x3 :
    IMatrix3x3<float>, IMatrixSelf<float3x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static float3x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static float3x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0f); 
    }

    public static float3x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default, default,
            default, 1.0f, default,
            default, default, 1.0f
        ); 
    }

    #endregion

    #region fields
    public float3 c0;
    public float3 c1;
    public float3 c2;

    #endregion

    #region getter

    public float m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public float m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public float m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public float m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public float m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public float3x3(float3 c0, float3 c1, float3 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public float3x3((float3 c0, float3 c1, float3 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x3((float3 c0, float3 c1, float3 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x3(
        float m00, float m01, float m02,
        float m10, float m11, float m12,
        float m20, float m21, float m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x3((
        float m00, float m01, float m02,
        float m10, float m11, float m12,
        float m20, float m21, float m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x3((
        float m00, float m01, float m02,
        float m10, float m11, float m12,
        float m20, float m21, float m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x3((
        (float m00, float m01, float m02) r0,
        (float m10, float m11, float m12) r1,
        (float m20, float m21, float m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x3((
        (float m00, float m01, float m02) r0,
        (float m10, float m11, float m12) r1,
        (float m20, float m21, float m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x3(float value) => new(value);

    [MethodImpl(256 | 512)]
    public float3x3(float value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x3(float3 value) => new(value);

    [MethodImpl(256 | 512)]
    public float3x3(float3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out float3 c0, out float3 c1, out float3 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out float m00, out float m01, out float m02,
        out float m10, out float m11, out float m12,
        out float m20, out float m21, out float m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // deconstruct

    #region index

    public float3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // float3x3

#region float3x4

[Serializable]
[JsonConverter(typeof(float3x4JsonConverter))]
public partial struct float3x4 :
    IMatrix3x4<float>, IMatrixSelf<float3x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static float3x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static float3x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0f); 
    }

    public static float3x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default, default, default,
            default, 1.0f, default, default,
            default, default, 1.0f, default
        ); 
    }

    #endregion

    #region fields
    public float3 c0;
    public float3 c1;
    public float3 c2;
    public float3 c3;

    #endregion

    #region getter

    public float m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public float m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public float m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public float m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public float m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public float m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public float m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public float m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public float3x4(float3 c0, float3 c1, float3 c2, float3 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public float3x4((float3 c0, float3 c1, float3 c2, float3 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x4((float3 c0, float3 c1, float3 c2, float3 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x4(
        float m00, float m01, float m02, float m03,
        float m10, float m11, float m12, float m13,
        float m20, float m21, float m22, float m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x4((
        float m00, float m01, float m02, float m03,
        float m10, float m11, float m12, float m13,
        float m20, float m21, float m22, float m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x4((
        float m00, float m01, float m02, float m03,
        float m10, float m11, float m12, float m13,
        float m20, float m21, float m22, float m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x4((
        (float m00, float m01, float m02, float m03) r0,
        (float m10, float m11, float m12, float m13) r1,
        (float m20, float m21, float m22, float m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x4((
        (float m00, float m01, float m02, float m03) r0,
        (float m10, float m11, float m12, float m13) r1,
        (float m20, float m21, float m22, float m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x4(float value) => new(value);

    [MethodImpl(256 | 512)]
    public float3x4(float value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x4(float3 value) => new(value);

    [MethodImpl(256 | 512)]
    public float3x4(float3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out float3 c0, out float3 c1, out float3 c2, out float3 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out float m00, out float m01, out float m02, out float m03,
        out float m10, out float m11, out float m12, out float m13,
        out float m20, out float m21, out float m22, out float m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // deconstruct

    #region index

    public float3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // float3x4

#region float4x2

[Serializable]
[JsonConverter(typeof(float4x2JsonConverter))]
public partial struct float4x2 :
    IMatrix4x2<float>, IMatrixSelf<float4x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static float4x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static float4x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0f); 
    }

    public static float4x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default,
            default, 1.0f,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region fields
    public float4 c0;
    public float4 c1;

    #endregion

    #region getter

    public float m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public float m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public float m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public float m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public float4x2(float4 c0, float4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public float4x2((float4 c0, float4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x2((float4 c0, float4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x2(
        float m00, float m01,
        float m10, float m11,
        float m20, float m21,
        float m30, float m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x2((
        float m00, float m01,
        float m10, float m11,
        float m20, float m21,
        float m30, float m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x2((
        float m00, float m01,
        float m10, float m11,
        float m20, float m21,
        float m30, float m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x2((
        (float m00, float m01) r0,
        (float m10, float m11) r1,
        (float m20, float m21) r2,
        (float m30, float m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x2((
        (float m00, float m01) r0,
        (float m10, float m11) r1,
        (float m20, float m21) r2,
        (float m30, float m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x2(float value) => new(value);

    [MethodImpl(256 | 512)]
    public float4x2(float value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x2(float4 value) => new(value);

    [MethodImpl(256 | 512)]
    public float4x2(float4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out float4 c0, out float4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out float m00, out float m01,
        out float m10, out float m11,
        out float m20, out float m21,
        out float m30, out float m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // deconstruct

    #region index

    public float4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // float4x2

#region float4x3

[Serializable]
[JsonConverter(typeof(float4x3JsonConverter))]
public partial struct float4x3 :
    IMatrix4x3<float>, IMatrixSelf<float4x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static float4x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static float4x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0f); 
    }

    public static float4x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default, default,
            default, 1.0f, default,
            default, default, 1.0f,
            default, default, default
        ); 
    }

    #endregion

    #region fields
    public float4 c0;
    public float4 c1;
    public float4 c2;

    #endregion

    #region getter

    public float m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public float m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public float m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public float m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public float m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public float m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public float m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public float m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public float4x3(float4 c0, float4 c1, float4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public float4x3((float4 c0, float4 c1, float4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x3((float4 c0, float4 c1, float4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x3(
        float m00, float m01, float m02,
        float m10, float m11, float m12,
        float m20, float m21, float m22,
        float m30, float m31, float m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x3((
        float m00, float m01, float m02,
        float m10, float m11, float m12,
        float m20, float m21, float m22,
        float m30, float m31, float m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x3((
        float m00, float m01, float m02,
        float m10, float m11, float m12,
        float m20, float m21, float m22,
        float m30, float m31, float m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x3((
        (float m00, float m01, float m02) r0,
        (float m10, float m11, float m12) r1,
        (float m20, float m21, float m22) r2,
        (float m30, float m31, float m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x3((
        (float m00, float m01, float m02) r0,
        (float m10, float m11, float m12) r1,
        (float m20, float m21, float m22) r2,
        (float m30, float m31, float m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x3(float value) => new(value);

    [MethodImpl(256 | 512)]
    public float4x3(float value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x3(float4 value) => new(value);

    [MethodImpl(256 | 512)]
    public float4x3(float4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out float4 c0, out float4 c1, out float4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out float m00, out float m01, out float m02,
        out float m10, out float m11, out float m12,
        out float m20, out float m21, out float m22,
        out float m30, out float m31, out float m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // deconstruct

    #region index

    public float4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // float4x3

#region float4x4

[Serializable]
[JsonConverter(typeof(float4x4JsonConverter))]
public partial struct float4x4 :
    IMatrix4x4<float>, IMatrixSelf<float4x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static float4x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static float4x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0f); 
    }

    public static float4x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default, default, default,
            default, 1.0f, default, default,
            default, default, 1.0f, default,
            default, default, default, 1.0f
        ); 
    }

    #endregion

    #region fields
    public float4 c0;
    public float4 c1;
    public float4 c2;
    public float4 c3;

    #endregion

    #region getter

    public float m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public float m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public float m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public float m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public float m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public float m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public float m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public float m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public float m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public float m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public float m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public float m33
    {
        [MethodImpl(256 | 512)]
        get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public float4x4(float4 c0, float4 c1, float4 c2, float4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public float4x4((float4 c0, float4 c1, float4 c2, float4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x4((float4 c0, float4 c1, float4 c2, float4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x4(
        float m00, float m01, float m02, float m03,
        float m10, float m11, float m12, float m13,
        float m20, float m21, float m22, float m23,
        float m30, float m31, float m32, float m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x4((
        float m00, float m01, float m02, float m03,
        float m10, float m11, float m12, float m13,
        float m20, float m21, float m22, float m23,
        float m30, float m31, float m32, float m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x4((
        float m00, float m01, float m02, float m03,
        float m10, float m11, float m12, float m13,
        float m20, float m21, float m22, float m23,
        float m30, float m31, float m32, float m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x4((
        (float m00, float m01, float m02, float m03) r0,
        (float m10, float m11, float m12, float m13) r1,
        (float m20, float m21, float m22, float m23) r2,
        (float m30, float m31, float m32, float m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x4((
        (float m00, float m01, float m02, float m03) r0,
        (float m10, float m11, float m12, float m13) r1,
        (float m20, float m21, float m22, float m23) r2,
        (float m30, float m31, float m32, float m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x4(float value) => new(value);

    [MethodImpl(256 | 512)]
    public float4x4(float value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x4(float4 value) => new(value);

    [MethodImpl(256 | 512)]
    public float4x4(float4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out float4 c0, out float4 c1, out float4 c2, out float4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out float m00, out float m01, out float m02, out float m03,
        out float m10, out float m11, out float m12, out float m13,
        out float m20, out float m21, out float m22, out float m23,
        out float m30, out float m31, out float m32, out float m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // deconstruct

    #region index

    public float4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // float4x4

#region double2x2

[Serializable]
[JsonConverter(typeof(double2x2JsonConverter))]
public partial struct double2x2 :
    IMatrix2x2<double>, IMatrixSelf<double2x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static double2x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static double2x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0); 
    }

    public static double2x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default,
            default, 1.0
        ); 
    }

    #endregion

    #region fields
    public double2 c0;
    public double2 c1;

    #endregion

    #region getter

    public double m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public double2x2(double2 c0, double2 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public double2x2((double2 c0, double2 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x2((double2 c0, double2 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x2(
        double m00, double m01,
        double m10, double m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x2((
        double m00, double m01,
        double m10, double m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x2((
        double m00, double m01,
        double m10, double m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x2((
        (double m00, double m01) r0,
        (double m10, double m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x2((
        (double m00, double m01) r0,
        (double m10, double m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x2(double value) => new(value);

    [MethodImpl(256 | 512)]
    public double2x2(double value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x2(double2 value) => new(value);

    [MethodImpl(256 | 512)]
    public double2x2(double2 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out double2 c0, out double2 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out double m00, out double m01,
        out double m10, out double m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // deconstruct

    #region index

    public double2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // double2x2

#region double2x3

[Serializable]
[JsonConverter(typeof(double2x3JsonConverter))]
public partial struct double2x3 :
    IMatrix2x3<double>, IMatrixSelf<double2x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static double2x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static double2x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0); 
    }

    public static double2x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default, default,
            default, 1.0, default
        ); 
    }

    #endregion

    #region fields
    public double2 c0;
    public double2 c1;
    public double2 c2;

    #endregion

    #region getter

    public double m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public double m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public double2x3(double2 c0, double2 c1, double2 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public double2x3((double2 c0, double2 c1, double2 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x3((double2 c0, double2 c1, double2 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x3(
        double m00, double m01, double m02,
        double m10, double m11, double m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x3((
        double m00, double m01, double m02,
        double m10, double m11, double m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x3((
        double m00, double m01, double m02,
        double m10, double m11, double m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x3((
        (double m00, double m01, double m02) r0,
        (double m10, double m11, double m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x3((
        (double m00, double m01, double m02) r0,
        (double m10, double m11, double m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x3(double value) => new(value);

    [MethodImpl(256 | 512)]
    public double2x3(double value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x3(double2 value) => new(value);

    [MethodImpl(256 | 512)]
    public double2x3(double2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out double2 c0, out double2 c1, out double2 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out double m00, out double m01, out double m02,
        out double m10, out double m11, out double m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // deconstruct

    #region index

    public double2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // double2x3

#region double2x4

[Serializable]
[JsonConverter(typeof(double2x4JsonConverter))]
public partial struct double2x4 :
    IMatrix2x4<double>, IMatrixSelf<double2x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static double2x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static double2x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0); 
    }

    public static double2x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default, default, default,
            default, 1.0, default, default
        ); 
    }

    #endregion

    #region fields
    public double2 c0;
    public double2 c1;
    public double2 c2;
    public double2 c3;

    #endregion

    #region getter

    public double m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public double m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public double m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public double m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public double2x4(double2 c0, double2 c1, double2 c2, double2 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public double2x4((double2 c0, double2 c1, double2 c2, double2 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x4((double2 c0, double2 c1, double2 c2, double2 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x4(
        double m00, double m01, double m02, double m03,
        double m10, double m11, double m12, double m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x4((
        double m00, double m01, double m02, double m03,
        double m10, double m11, double m12, double m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x4((
        double m00, double m01, double m02, double m03,
        double m10, double m11, double m12, double m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x4((
        (double m00, double m01, double m02, double m03) r0,
        (double m10, double m11, double m12, double m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x4((
        (double m00, double m01, double m02, double m03) r0,
        (double m10, double m11, double m12, double m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x4(double value) => new(value);

    [MethodImpl(256 | 512)]
    public double2x4(double value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x4(double2 value) => new(value);

    [MethodImpl(256 | 512)]
    public double2x4(double2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out double2 c0, out double2 c1, out double2 c2, out double2 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out double m00, out double m01, out double m02, out double m03,
        out double m10, out double m11, out double m12, out double m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // deconstruct

    #region index

    public double2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // double2x4

#region double3x2

[Serializable]
[JsonConverter(typeof(double3x2JsonConverter))]
public partial struct double3x2 :
    IMatrix3x2<double>, IMatrixSelf<double3x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static double3x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static double3x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0); 
    }

    public static double3x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default,
            default, 1.0,
            default, default
        ); 
    }

    #endregion

    #region fields
    public double3 c0;
    public double3 c1;

    #endregion

    #region getter

    public double m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public double m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public double3x2(double3 c0, double3 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public double3x2((double3 c0, double3 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x2((double3 c0, double3 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x2(
        double m00, double m01,
        double m10, double m11,
        double m20, double m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x2((
        double m00, double m01,
        double m10, double m11,
        double m20, double m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x2((
        double m00, double m01,
        double m10, double m11,
        double m20, double m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x2((
        (double m00, double m01) r0,
        (double m10, double m11) r1,
        (double m20, double m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x2((
        (double m00, double m01) r0,
        (double m10, double m11) r1,
        (double m20, double m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x2(double value) => new(value);

    [MethodImpl(256 | 512)]
    public double3x2(double value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x2(double3 value) => new(value);

    [MethodImpl(256 | 512)]
    public double3x2(double3 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out double3 c0, out double3 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out double m00, out double m01,
        out double m10, out double m11,
        out double m20, out double m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // deconstruct

    #region index

    public double3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // double3x2

#region double3x3

[Serializable]
[JsonConverter(typeof(double3x3JsonConverter))]
public partial struct double3x3 :
    IMatrix3x3<double>, IMatrixSelf<double3x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static double3x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static double3x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0); 
    }

    public static double3x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default, default,
            default, 1.0, default,
            default, default, 1.0
        ); 
    }

    #endregion

    #region fields
    public double3 c0;
    public double3 c1;
    public double3 c2;

    #endregion

    #region getter

    public double m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public double m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public double m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public double m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public double m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public double3x3(double3 c0, double3 c1, double3 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public double3x3((double3 c0, double3 c1, double3 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x3((double3 c0, double3 c1, double3 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x3(
        double m00, double m01, double m02,
        double m10, double m11, double m12,
        double m20, double m21, double m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x3((
        double m00, double m01, double m02,
        double m10, double m11, double m12,
        double m20, double m21, double m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x3((
        double m00, double m01, double m02,
        double m10, double m11, double m12,
        double m20, double m21, double m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x3((
        (double m00, double m01, double m02) r0,
        (double m10, double m11, double m12) r1,
        (double m20, double m21, double m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x3((
        (double m00, double m01, double m02) r0,
        (double m10, double m11, double m12) r1,
        (double m20, double m21, double m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x3(double value) => new(value);

    [MethodImpl(256 | 512)]
    public double3x3(double value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x3(double3 value) => new(value);

    [MethodImpl(256 | 512)]
    public double3x3(double3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out double3 c0, out double3 c1, out double3 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out double m00, out double m01, out double m02,
        out double m10, out double m11, out double m12,
        out double m20, out double m21, out double m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // deconstruct

    #region index

    public double3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // double3x3

#region double3x4

[Serializable]
[JsonConverter(typeof(double3x4JsonConverter))]
public partial struct double3x4 :
    IMatrix3x4<double>, IMatrixSelf<double3x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static double3x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static double3x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0); 
    }

    public static double3x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default, default, default,
            default, 1.0, default, default,
            default, default, 1.0, default
        ); 
    }

    #endregion

    #region fields
    public double3 c0;
    public double3 c1;
    public double3 c2;
    public double3 c3;

    #endregion

    #region getter

    public double m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public double m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public double m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public double m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public double m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public double m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public double m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public double m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public double3x4(double3 c0, double3 c1, double3 c2, double3 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public double3x4((double3 c0, double3 c1, double3 c2, double3 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x4((double3 c0, double3 c1, double3 c2, double3 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x4(
        double m00, double m01, double m02, double m03,
        double m10, double m11, double m12, double m13,
        double m20, double m21, double m22, double m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x4((
        double m00, double m01, double m02, double m03,
        double m10, double m11, double m12, double m13,
        double m20, double m21, double m22, double m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x4((
        double m00, double m01, double m02, double m03,
        double m10, double m11, double m12, double m13,
        double m20, double m21, double m22, double m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x4((
        (double m00, double m01, double m02, double m03) r0,
        (double m10, double m11, double m12, double m13) r1,
        (double m20, double m21, double m22, double m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x4((
        (double m00, double m01, double m02, double m03) r0,
        (double m10, double m11, double m12, double m13) r1,
        (double m20, double m21, double m22, double m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x4(double value) => new(value);

    [MethodImpl(256 | 512)]
    public double3x4(double value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x4(double3 value) => new(value);

    [MethodImpl(256 | 512)]
    public double3x4(double3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out double3 c0, out double3 c1, out double3 c2, out double3 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out double m00, out double m01, out double m02, out double m03,
        out double m10, out double m11, out double m12, out double m13,
        out double m20, out double m21, out double m22, out double m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // deconstruct

    #region index

    public double3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // double3x4

#region double4x2

[Serializable]
[JsonConverter(typeof(double4x2JsonConverter))]
public partial struct double4x2 :
    IMatrix4x2<double>, IMatrixSelf<double4x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static double4x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static double4x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0); 
    }

    public static double4x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default,
            default, 1.0,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region fields
    public double4 c0;
    public double4 c1;

    #endregion

    #region getter

    public double m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public double m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public double m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public double m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public double4x2(double4 c0, double4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public double4x2((double4 c0, double4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x2((double4 c0, double4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x2(
        double m00, double m01,
        double m10, double m11,
        double m20, double m21,
        double m30, double m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x2((
        double m00, double m01,
        double m10, double m11,
        double m20, double m21,
        double m30, double m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x2((
        double m00, double m01,
        double m10, double m11,
        double m20, double m21,
        double m30, double m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x2((
        (double m00, double m01) r0,
        (double m10, double m11) r1,
        (double m20, double m21) r2,
        (double m30, double m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x2((
        (double m00, double m01) r0,
        (double m10, double m11) r1,
        (double m20, double m21) r2,
        (double m30, double m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x2(double value) => new(value);

    [MethodImpl(256 | 512)]
    public double4x2(double value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x2(double4 value) => new(value);

    [MethodImpl(256 | 512)]
    public double4x2(double4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out double4 c0, out double4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out double m00, out double m01,
        out double m10, out double m11,
        out double m20, out double m21,
        out double m30, out double m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // deconstruct

    #region index

    public double4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // double4x2

#region double4x3

[Serializable]
[JsonConverter(typeof(double4x3JsonConverter))]
public partial struct double4x3 :
    IMatrix4x3<double>, IMatrixSelf<double4x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static double4x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static double4x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0); 
    }

    public static double4x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default, default,
            default, 1.0, default,
            default, default, 1.0,
            default, default, default
        ); 
    }

    #endregion

    #region fields
    public double4 c0;
    public double4 c1;
    public double4 c2;

    #endregion

    #region getter

    public double m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public double m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public double m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public double m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public double m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public double m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public double m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public double m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public double4x3(double4 c0, double4 c1, double4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public double4x3((double4 c0, double4 c1, double4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x3((double4 c0, double4 c1, double4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x3(
        double m00, double m01, double m02,
        double m10, double m11, double m12,
        double m20, double m21, double m22,
        double m30, double m31, double m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x3((
        double m00, double m01, double m02,
        double m10, double m11, double m12,
        double m20, double m21, double m22,
        double m30, double m31, double m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x3((
        double m00, double m01, double m02,
        double m10, double m11, double m12,
        double m20, double m21, double m22,
        double m30, double m31, double m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x3((
        (double m00, double m01, double m02) r0,
        (double m10, double m11, double m12) r1,
        (double m20, double m21, double m22) r2,
        (double m30, double m31, double m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x3((
        (double m00, double m01, double m02) r0,
        (double m10, double m11, double m12) r1,
        (double m20, double m21, double m22) r2,
        (double m30, double m31, double m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x3(double value) => new(value);

    [MethodImpl(256 | 512)]
    public double4x3(double value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x3(double4 value) => new(value);

    [MethodImpl(256 | 512)]
    public double4x3(double4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out double4 c0, out double4 c1, out double4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out double m00, out double m01, out double m02,
        out double m10, out double m11, out double m12,
        out double m20, out double m21, out double m22,
        out double m30, out double m31, out double m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // deconstruct

    #region index

    public double4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // double4x3

#region double4x4

[Serializable]
[JsonConverter(typeof(double4x4JsonConverter))]
public partial struct double4x4 :
    IMatrix4x4<double>, IMatrixSelf<double4x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static double4x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static double4x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0); 
    }

    public static double4x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default, default, default,
            default, 1.0, default, default,
            default, default, 1.0, default,
            default, default, default, 1.0
        ); 
    }

    #endregion

    #region fields
    public double4 c0;
    public double4 c1;
    public double4 c2;
    public double4 c3;

    #endregion

    #region getter

    public double m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public double m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public double m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public double m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public double m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public double m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public double m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public double m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public double m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public double m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public double m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public double m33
    {
        [MethodImpl(256 | 512)]
        get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public double4x4(double4 c0, double4 c1, double4 c2, double4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public double4x4((double4 c0, double4 c1, double4 c2, double4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x4((double4 c0, double4 c1, double4 c2, double4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x4(
        double m00, double m01, double m02, double m03,
        double m10, double m11, double m12, double m13,
        double m20, double m21, double m22, double m23,
        double m30, double m31, double m32, double m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x4((
        double m00, double m01, double m02, double m03,
        double m10, double m11, double m12, double m13,
        double m20, double m21, double m22, double m23,
        double m30, double m31, double m32, double m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x4((
        double m00, double m01, double m02, double m03,
        double m10, double m11, double m12, double m13,
        double m20, double m21, double m22, double m23,
        double m30, double m31, double m32, double m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x4((
        (double m00, double m01, double m02, double m03) r0,
        (double m10, double m11, double m12, double m13) r1,
        (double m20, double m21, double m22, double m23) r2,
        (double m30, double m31, double m32, double m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x4((
        (double m00, double m01, double m02, double m03) r0,
        (double m10, double m11, double m12, double m13) r1,
        (double m20, double m21, double m22, double m23) r2,
        (double m30, double m31, double m32, double m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x4(double value) => new(value);

    [MethodImpl(256 | 512)]
    public double4x4(double value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x4(double4 value) => new(value);

    [MethodImpl(256 | 512)]
    public double4x4(double4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out double4 c0, out double4 c1, out double4 c2, out double4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out double m00, out double m01, out double m02, out double m03,
        out double m10, out double m11, out double m12, out double m13,
        out double m20, out double m21, out double m22, out double m23,
        out double m30, out double m31, out double m32, out double m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // deconstruct

    #region index

    public double4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // double4x4

#region short2x2

[Serializable]
[JsonConverter(typeof(short2x2JsonConverter))]
public partial struct short2x2 :
    IMatrix2x2<short>, IMatrixSelf<short2x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static short2x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static short2x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new((short)1); 
    }

    public static short2x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (short)1, default,
            default, (short)1
        ); 
    }

    #endregion

    #region fields
    public short2 c0;
    public short2 c1;

    #endregion

    #region getter

    public short m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public short m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public short m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public short m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public short2x2(short2 c0, short2 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public short2x2((short2 c0, short2 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short2x2((short2 c0, short2 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public short2x2(
        short m00, short m01,
        short m10, short m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short2x2((
        short m00, short m01,
        short m10, short m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public short2x2((
        short m00, short m01,
        short m10, short m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short2x2((
        (short m00, short m01) r0,
        (short m10, short m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public short2x2((
        (short m00, short m01) r0,
        (short m10, short m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short2x2(short value) => new(value);

    [MethodImpl(256 | 512)]
    public short2x2(short value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short2x2(short2 value) => new(value);

    [MethodImpl(256 | 512)]
    public short2x2(short2 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out short2 c0, out short2 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out short m00, out short m01,
        out short m10, out short m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // deconstruct

    #region index

    public short2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public short this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // short2x2

#region short2x3

[Serializable]
[JsonConverter(typeof(short2x3JsonConverter))]
public partial struct short2x3 :
    IMatrix2x3<short>, IMatrixSelf<short2x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static short2x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static short2x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new((short)1); 
    }

    public static short2x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (short)1, default, default,
            default, (short)1, default
        ); 
    }

    #endregion

    #region fields
    public short2 c0;
    public short2 c1;
    public short2 c2;

    #endregion

    #region getter

    public short m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public short m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public short m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public short m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public short m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public short m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public short2x3(short2 c0, short2 c1, short2 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public short2x3((short2 c0, short2 c1, short2 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short2x3((short2 c0, short2 c1, short2 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public short2x3(
        short m00, short m01, short m02,
        short m10, short m11, short m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short2x3((
        short m00, short m01, short m02,
        short m10, short m11, short m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public short2x3((
        short m00, short m01, short m02,
        short m10, short m11, short m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short2x3((
        (short m00, short m01, short m02) r0,
        (short m10, short m11, short m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public short2x3((
        (short m00, short m01, short m02) r0,
        (short m10, short m11, short m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short2x3(short value) => new(value);

    [MethodImpl(256 | 512)]
    public short2x3(short value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short2x3(short2 value) => new(value);

    [MethodImpl(256 | 512)]
    public short2x3(short2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out short2 c0, out short2 c1, out short2 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out short m00, out short m01, out short m02,
        out short m10, out short m11, out short m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // deconstruct

    #region index

    public short2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public short this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // short2x3

#region short2x4

[Serializable]
[JsonConverter(typeof(short2x4JsonConverter))]
public partial struct short2x4 :
    IMatrix2x4<short>, IMatrixSelf<short2x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static short2x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static short2x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new((short)1); 
    }

    public static short2x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (short)1, default, default, default,
            default, (short)1, default, default
        ); 
    }

    #endregion

    #region fields
    public short2 c0;
    public short2 c1;
    public short2 c2;
    public short2 c3;

    #endregion

    #region getter

    public short m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public short m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public short m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public short m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public short m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public short m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public short m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public short m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public short2x4(short2 c0, short2 c1, short2 c2, short2 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public short2x4((short2 c0, short2 c1, short2 c2, short2 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short2x4((short2 c0, short2 c1, short2 c2, short2 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public short2x4(
        short m00, short m01, short m02, short m03,
        short m10, short m11, short m12, short m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short2x4((
        short m00, short m01, short m02, short m03,
        short m10, short m11, short m12, short m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public short2x4((
        short m00, short m01, short m02, short m03,
        short m10, short m11, short m12, short m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short2x4((
        (short m00, short m01, short m02, short m03) r0,
        (short m10, short m11, short m12, short m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public short2x4((
        (short m00, short m01, short m02, short m03) r0,
        (short m10, short m11, short m12, short m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short2x4(short value) => new(value);

    [MethodImpl(256 | 512)]
    public short2x4(short value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short2x4(short2 value) => new(value);

    [MethodImpl(256 | 512)]
    public short2x4(short2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out short2 c0, out short2 c1, out short2 c2, out short2 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out short m00, out short m01, out short m02, out short m03,
        out short m10, out short m11, out short m12, out short m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // deconstruct

    #region index

    public short2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public short this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // short2x4

#region short3x2

[Serializable]
[JsonConverter(typeof(short3x2JsonConverter))]
public partial struct short3x2 :
    IMatrix3x2<short>, IMatrixSelf<short3x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static short3x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static short3x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new((short)1); 
    }

    public static short3x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (short)1, default,
            default, (short)1,
            default, default
        ); 
    }

    #endregion

    #region fields
    public short3 c0;
    public short3 c1;

    #endregion

    #region getter

    public short m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public short m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public short m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public short m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public short m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public short m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public short3x2(short3 c0, short3 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public short3x2((short3 c0, short3 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short3x2((short3 c0, short3 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public short3x2(
        short m00, short m01,
        short m10, short m11,
        short m20, short m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short3x2((
        short m00, short m01,
        short m10, short m11,
        short m20, short m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public short3x2((
        short m00, short m01,
        short m10, short m11,
        short m20, short m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short3x2((
        (short m00, short m01) r0,
        (short m10, short m11) r1,
        (short m20, short m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public short3x2((
        (short m00, short m01) r0,
        (short m10, short m11) r1,
        (short m20, short m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short3x2(short value) => new(value);

    [MethodImpl(256 | 512)]
    public short3x2(short value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short3x2(short3 value) => new(value);

    [MethodImpl(256 | 512)]
    public short3x2(short3 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out short3 c0, out short3 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out short m00, out short m01,
        out short m10, out short m11,
        out short m20, out short m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // deconstruct

    #region index

    public short3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public short this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // short3x2

#region short3x3

[Serializable]
[JsonConverter(typeof(short3x3JsonConverter))]
public partial struct short3x3 :
    IMatrix3x3<short>, IMatrixSelf<short3x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static short3x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static short3x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new((short)1); 
    }

    public static short3x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (short)1, default, default,
            default, (short)1, default,
            default, default, (short)1
        ); 
    }

    #endregion

    #region fields
    public short3 c0;
    public short3 c1;
    public short3 c2;

    #endregion

    #region getter

    public short m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public short m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public short m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public short m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public short m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public short m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public short m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public short m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public short m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public short3x3(short3 c0, short3 c1, short3 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public short3x3((short3 c0, short3 c1, short3 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short3x3((short3 c0, short3 c1, short3 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public short3x3(
        short m00, short m01, short m02,
        short m10, short m11, short m12,
        short m20, short m21, short m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short3x3((
        short m00, short m01, short m02,
        short m10, short m11, short m12,
        short m20, short m21, short m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public short3x3((
        short m00, short m01, short m02,
        short m10, short m11, short m12,
        short m20, short m21, short m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short3x3((
        (short m00, short m01, short m02) r0,
        (short m10, short m11, short m12) r1,
        (short m20, short m21, short m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public short3x3((
        (short m00, short m01, short m02) r0,
        (short m10, short m11, short m12) r1,
        (short m20, short m21, short m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short3x3(short value) => new(value);

    [MethodImpl(256 | 512)]
    public short3x3(short value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short3x3(short3 value) => new(value);

    [MethodImpl(256 | 512)]
    public short3x3(short3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out short3 c0, out short3 c1, out short3 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out short m00, out short m01, out short m02,
        out short m10, out short m11, out short m12,
        out short m20, out short m21, out short m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // deconstruct

    #region index

    public short3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public short this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // short3x3

#region short3x4

[Serializable]
[JsonConverter(typeof(short3x4JsonConverter))]
public partial struct short3x4 :
    IMatrix3x4<short>, IMatrixSelf<short3x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static short3x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static short3x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new((short)1); 
    }

    public static short3x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (short)1, default, default, default,
            default, (short)1, default, default,
            default, default, (short)1, default
        ); 
    }

    #endregion

    #region fields
    public short3 c0;
    public short3 c1;
    public short3 c2;
    public short3 c3;

    #endregion

    #region getter

    public short m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public short m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public short m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public short m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public short m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public short m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public short m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public short m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public short m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public short m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public short m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public short m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public short3x4(short3 c0, short3 c1, short3 c2, short3 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public short3x4((short3 c0, short3 c1, short3 c2, short3 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short3x4((short3 c0, short3 c1, short3 c2, short3 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public short3x4(
        short m00, short m01, short m02, short m03,
        short m10, short m11, short m12, short m13,
        short m20, short m21, short m22, short m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short3x4((
        short m00, short m01, short m02, short m03,
        short m10, short m11, short m12, short m13,
        short m20, short m21, short m22, short m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public short3x4((
        short m00, short m01, short m02, short m03,
        short m10, short m11, short m12, short m13,
        short m20, short m21, short m22, short m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short3x4((
        (short m00, short m01, short m02, short m03) r0,
        (short m10, short m11, short m12, short m13) r1,
        (short m20, short m21, short m22, short m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public short3x4((
        (short m00, short m01, short m02, short m03) r0,
        (short m10, short m11, short m12, short m13) r1,
        (short m20, short m21, short m22, short m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short3x4(short value) => new(value);

    [MethodImpl(256 | 512)]
    public short3x4(short value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short3x4(short3 value) => new(value);

    [MethodImpl(256 | 512)]
    public short3x4(short3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out short3 c0, out short3 c1, out short3 c2, out short3 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out short m00, out short m01, out short m02, out short m03,
        out short m10, out short m11, out short m12, out short m13,
        out short m20, out short m21, out short m22, out short m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // deconstruct

    #region index

    public short3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public short this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // short3x4

#region short4x2

[Serializable]
[JsonConverter(typeof(short4x2JsonConverter))]
public partial struct short4x2 :
    IMatrix4x2<short>, IMatrixSelf<short4x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static short4x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static short4x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new((short)1); 
    }

    public static short4x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (short)1, default,
            default, (short)1,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region fields
    public short4 c0;
    public short4 c1;

    #endregion

    #region getter

    public short m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public short m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public short m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public short m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public short m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public short m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public short m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public short m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public short4x2(short4 c0, short4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public short4x2((short4 c0, short4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short4x2((short4 c0, short4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public short4x2(
        short m00, short m01,
        short m10, short m11,
        short m20, short m21,
        short m30, short m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short4x2((
        short m00, short m01,
        short m10, short m11,
        short m20, short m21,
        short m30, short m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public short4x2((
        short m00, short m01,
        short m10, short m11,
        short m20, short m21,
        short m30, short m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short4x2((
        (short m00, short m01) r0,
        (short m10, short m11) r1,
        (short m20, short m21) r2,
        (short m30, short m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public short4x2((
        (short m00, short m01) r0,
        (short m10, short m11) r1,
        (short m20, short m21) r2,
        (short m30, short m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short4x2(short value) => new(value);

    [MethodImpl(256 | 512)]
    public short4x2(short value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short4x2(short4 value) => new(value);

    [MethodImpl(256 | 512)]
    public short4x2(short4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out short4 c0, out short4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out short m00, out short m01,
        out short m10, out short m11,
        out short m20, out short m21,
        out short m30, out short m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // deconstruct

    #region index

    public short4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public short this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // short4x2

#region short4x3

[Serializable]
[JsonConverter(typeof(short4x3JsonConverter))]
public partial struct short4x3 :
    IMatrix4x3<short>, IMatrixSelf<short4x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static short4x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static short4x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new((short)1); 
    }

    public static short4x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (short)1, default, default,
            default, (short)1, default,
            default, default, (short)1,
            default, default, default
        ); 
    }

    #endregion

    #region fields
    public short4 c0;
    public short4 c1;
    public short4 c2;

    #endregion

    #region getter

    public short m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public short m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public short m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public short m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public short m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public short m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public short m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public short m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public short m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public short m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public short m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public short m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public short4x3(short4 c0, short4 c1, short4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public short4x3((short4 c0, short4 c1, short4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short4x3((short4 c0, short4 c1, short4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public short4x3(
        short m00, short m01, short m02,
        short m10, short m11, short m12,
        short m20, short m21, short m22,
        short m30, short m31, short m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short4x3((
        short m00, short m01, short m02,
        short m10, short m11, short m12,
        short m20, short m21, short m22,
        short m30, short m31, short m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public short4x3((
        short m00, short m01, short m02,
        short m10, short m11, short m12,
        short m20, short m21, short m22,
        short m30, short m31, short m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short4x3((
        (short m00, short m01, short m02) r0,
        (short m10, short m11, short m12) r1,
        (short m20, short m21, short m22) r2,
        (short m30, short m31, short m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public short4x3((
        (short m00, short m01, short m02) r0,
        (short m10, short m11, short m12) r1,
        (short m20, short m21, short m22) r2,
        (short m30, short m31, short m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short4x3(short value) => new(value);

    [MethodImpl(256 | 512)]
    public short4x3(short value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short4x3(short4 value) => new(value);

    [MethodImpl(256 | 512)]
    public short4x3(short4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out short4 c0, out short4 c1, out short4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out short m00, out short m01, out short m02,
        out short m10, out short m11, out short m12,
        out short m20, out short m21, out short m22,
        out short m30, out short m31, out short m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // deconstruct

    #region index

    public short4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public short this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // short4x3

#region short4x4

[Serializable]
[JsonConverter(typeof(short4x4JsonConverter))]
public partial struct short4x4 :
    IMatrix4x4<short>, IMatrixSelf<short4x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static short4x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static short4x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new((short)1); 
    }

    public static short4x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (short)1, default, default, default,
            default, (short)1, default, default,
            default, default, (short)1, default,
            default, default, default, (short)1
        ); 
    }

    #endregion

    #region fields
    public short4 c0;
    public short4 c1;
    public short4 c2;
    public short4 c3;

    #endregion

    #region getter

    public short m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public short m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public short m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public short m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public short m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public short m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public short m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public short m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public short m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public short m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public short m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public short m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public short m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public short m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public short m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public short m33
    {
        [MethodImpl(256 | 512)]
        get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public short4x4(short4 c0, short4 c1, short4 c2, short4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public short4x4((short4 c0, short4 c1, short4 c2, short4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short4x4((short4 c0, short4 c1, short4 c2, short4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public short4x4(
        short m00, short m01, short m02, short m03,
        short m10, short m11, short m12, short m13,
        short m20, short m21, short m22, short m23,
        short m30, short m31, short m32, short m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short4x4((
        short m00, short m01, short m02, short m03,
        short m10, short m11, short m12, short m13,
        short m20, short m21, short m22, short m23,
        short m30, short m31, short m32, short m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public short4x4((
        short m00, short m01, short m02, short m03,
        short m10, short m11, short m12, short m13,
        short m20, short m21, short m22, short m23,
        short m30, short m31, short m32, short m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short4x4((
        (short m00, short m01, short m02, short m03) r0,
        (short m10, short m11, short m12, short m13) r1,
        (short m20, short m21, short m22, short m23) r2,
        (short m30, short m31, short m32, short m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public short4x4((
        (short m00, short m01, short m02, short m03) r0,
        (short m10, short m11, short m12, short m13) r1,
        (short m20, short m21, short m22, short m23) r2,
        (short m30, short m31, short m32, short m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short4x4(short value) => new(value);

    [MethodImpl(256 | 512)]
    public short4x4(short value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator short4x4(short4 value) => new(value);

    [MethodImpl(256 | 512)]
    public short4x4(short4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out short4 c0, out short4 c1, out short4 c2, out short4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out short m00, out short m01, out short m02, out short m03,
        out short m10, out short m11, out short m12, out short m13,
        out short m20, out short m21, out short m22, out short m23,
        out short m30, out short m31, out short m32, out short m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // deconstruct

    #region index

    public short4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public short this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // short4x4

#region ushort2x2

[Serializable]
[JsonConverter(typeof(ushort2x2JsonConverter))]
public partial struct ushort2x2 :
    IMatrix2x2<ushort>, IMatrixSelf<ushort2x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static ushort2x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ushort2x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new((ushort)1); 
    }

    public static ushort2x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (ushort)1, default,
            default, (ushort)1
        ); 
    }

    #endregion

    #region fields
    public ushort2 c0;
    public ushort2 c1;

    #endregion

    #region getter

    public ushort m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ushort m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ushort m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ushort m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public ushort2x2(ushort2 c0, ushort2 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public ushort2x2((ushort2 c0, ushort2 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort2x2((ushort2 c0, ushort2 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ushort2x2(
        ushort m00, ushort m01,
        ushort m10, ushort m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort2x2((
        ushort m00, ushort m01,
        ushort m10, ushort m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ushort2x2((
        ushort m00, ushort m01,
        ushort m10, ushort m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort2x2((
        (ushort m00, ushort m01) r0,
        (ushort m10, ushort m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ushort2x2((
        (ushort m00, ushort m01) r0,
        (ushort m10, ushort m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort2x2(ushort value) => new(value);

    [MethodImpl(256 | 512)]
    public ushort2x2(ushort value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort2x2(ushort2 value) => new(value);

    [MethodImpl(256 | 512)]
    public ushort2x2(ushort2 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out ushort2 c0, out ushort2 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out ushort m00, out ushort m01,
        out ushort m10, out ushort m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // deconstruct

    #region index

    public ushort2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ushort this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // ushort2x2

#region ushort2x3

[Serializable]
[JsonConverter(typeof(ushort2x3JsonConverter))]
public partial struct ushort2x3 :
    IMatrix2x3<ushort>, IMatrixSelf<ushort2x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static ushort2x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ushort2x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new((ushort)1); 
    }

    public static ushort2x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (ushort)1, default, default,
            default, (ushort)1, default
        ); 
    }

    #endregion

    #region fields
    public ushort2 c0;
    public ushort2 c1;
    public ushort2 c2;

    #endregion

    #region getter

    public ushort m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ushort m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ushort m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ushort m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ushort m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ushort m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public ushort2x3(ushort2 c0, ushort2 c1, ushort2 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public ushort2x3((ushort2 c0, ushort2 c1, ushort2 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort2x3((ushort2 c0, ushort2 c1, ushort2 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ushort2x3(
        ushort m00, ushort m01, ushort m02,
        ushort m10, ushort m11, ushort m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort2x3((
        ushort m00, ushort m01, ushort m02,
        ushort m10, ushort m11, ushort m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ushort2x3((
        ushort m00, ushort m01, ushort m02,
        ushort m10, ushort m11, ushort m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort2x3((
        (ushort m00, ushort m01, ushort m02) r0,
        (ushort m10, ushort m11, ushort m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ushort2x3((
        (ushort m00, ushort m01, ushort m02) r0,
        (ushort m10, ushort m11, ushort m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort2x3(ushort value) => new(value);

    [MethodImpl(256 | 512)]
    public ushort2x3(ushort value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort2x3(ushort2 value) => new(value);

    [MethodImpl(256 | 512)]
    public ushort2x3(ushort2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out ushort2 c0, out ushort2 c1, out ushort2 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out ushort m00, out ushort m01, out ushort m02,
        out ushort m10, out ushort m11, out ushort m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // deconstruct

    #region index

    public ushort2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ushort this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // ushort2x3

#region ushort2x4

[Serializable]
[JsonConverter(typeof(ushort2x4JsonConverter))]
public partial struct ushort2x4 :
    IMatrix2x4<ushort>, IMatrixSelf<ushort2x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static ushort2x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ushort2x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new((ushort)1); 
    }

    public static ushort2x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (ushort)1, default, default, default,
            default, (ushort)1, default, default
        ); 
    }

    #endregion

    #region fields
    public ushort2 c0;
    public ushort2 c1;
    public ushort2 c2;
    public ushort2 c3;

    #endregion

    #region getter

    public ushort m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ushort m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ushort m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ushort m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public ushort m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ushort m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ushort m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public ushort m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public ushort2x4(ushort2 c0, ushort2 c1, ushort2 c2, ushort2 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public ushort2x4((ushort2 c0, ushort2 c1, ushort2 c2, ushort2 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort2x4((ushort2 c0, ushort2 c1, ushort2 c2, ushort2 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ushort2x4(
        ushort m00, ushort m01, ushort m02, ushort m03,
        ushort m10, ushort m11, ushort m12, ushort m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort2x4((
        ushort m00, ushort m01, ushort m02, ushort m03,
        ushort m10, ushort m11, ushort m12, ushort m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ushort2x4((
        ushort m00, ushort m01, ushort m02, ushort m03,
        ushort m10, ushort m11, ushort m12, ushort m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort2x4((
        (ushort m00, ushort m01, ushort m02, ushort m03) r0,
        (ushort m10, ushort m11, ushort m12, ushort m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ushort2x4((
        (ushort m00, ushort m01, ushort m02, ushort m03) r0,
        (ushort m10, ushort m11, ushort m12, ushort m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort2x4(ushort value) => new(value);

    [MethodImpl(256 | 512)]
    public ushort2x4(ushort value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort2x4(ushort2 value) => new(value);

    [MethodImpl(256 | 512)]
    public ushort2x4(ushort2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out ushort2 c0, out ushort2 c1, out ushort2 c2, out ushort2 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out ushort m00, out ushort m01, out ushort m02, out ushort m03,
        out ushort m10, out ushort m11, out ushort m12, out ushort m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // deconstruct

    #region index

    public ushort2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ushort this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // ushort2x4

#region ushort3x2

[Serializable]
[JsonConverter(typeof(ushort3x2JsonConverter))]
public partial struct ushort3x2 :
    IMatrix3x2<ushort>, IMatrixSelf<ushort3x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static ushort3x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ushort3x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new((ushort)1); 
    }

    public static ushort3x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (ushort)1, default,
            default, (ushort)1,
            default, default
        ); 
    }

    #endregion

    #region fields
    public ushort3 c0;
    public ushort3 c1;

    #endregion

    #region getter

    public ushort m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ushort m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ushort m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ushort m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ushort m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ushort m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public ushort3x2(ushort3 c0, ushort3 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public ushort3x2((ushort3 c0, ushort3 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort3x2((ushort3 c0, ushort3 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ushort3x2(
        ushort m00, ushort m01,
        ushort m10, ushort m11,
        ushort m20, ushort m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort3x2((
        ushort m00, ushort m01,
        ushort m10, ushort m11,
        ushort m20, ushort m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ushort3x2((
        ushort m00, ushort m01,
        ushort m10, ushort m11,
        ushort m20, ushort m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort3x2((
        (ushort m00, ushort m01) r0,
        (ushort m10, ushort m11) r1,
        (ushort m20, ushort m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ushort3x2((
        (ushort m00, ushort m01) r0,
        (ushort m10, ushort m11) r1,
        (ushort m20, ushort m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort3x2(ushort value) => new(value);

    [MethodImpl(256 | 512)]
    public ushort3x2(ushort value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort3x2(ushort3 value) => new(value);

    [MethodImpl(256 | 512)]
    public ushort3x2(ushort3 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out ushort3 c0, out ushort3 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out ushort m00, out ushort m01,
        out ushort m10, out ushort m11,
        out ushort m20, out ushort m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // deconstruct

    #region index

    public ushort3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ushort this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // ushort3x2

#region ushort3x3

[Serializable]
[JsonConverter(typeof(ushort3x3JsonConverter))]
public partial struct ushort3x3 :
    IMatrix3x3<ushort>, IMatrixSelf<ushort3x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static ushort3x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ushort3x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new((ushort)1); 
    }

    public static ushort3x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (ushort)1, default, default,
            default, (ushort)1, default,
            default, default, (ushort)1
        ); 
    }

    #endregion

    #region fields
    public ushort3 c0;
    public ushort3 c1;
    public ushort3 c2;

    #endregion

    #region getter

    public ushort m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ushort m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ushort m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ushort m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ushort m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ushort m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public ushort m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ushort m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public ushort m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public ushort3x3(ushort3 c0, ushort3 c1, ushort3 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public ushort3x3((ushort3 c0, ushort3 c1, ushort3 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort3x3((ushort3 c0, ushort3 c1, ushort3 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ushort3x3(
        ushort m00, ushort m01, ushort m02,
        ushort m10, ushort m11, ushort m12,
        ushort m20, ushort m21, ushort m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort3x3((
        ushort m00, ushort m01, ushort m02,
        ushort m10, ushort m11, ushort m12,
        ushort m20, ushort m21, ushort m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ushort3x3((
        ushort m00, ushort m01, ushort m02,
        ushort m10, ushort m11, ushort m12,
        ushort m20, ushort m21, ushort m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort3x3((
        (ushort m00, ushort m01, ushort m02) r0,
        (ushort m10, ushort m11, ushort m12) r1,
        (ushort m20, ushort m21, ushort m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ushort3x3((
        (ushort m00, ushort m01, ushort m02) r0,
        (ushort m10, ushort m11, ushort m12) r1,
        (ushort m20, ushort m21, ushort m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort3x3(ushort value) => new(value);

    [MethodImpl(256 | 512)]
    public ushort3x3(ushort value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort3x3(ushort3 value) => new(value);

    [MethodImpl(256 | 512)]
    public ushort3x3(ushort3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out ushort3 c0, out ushort3 c1, out ushort3 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out ushort m00, out ushort m01, out ushort m02,
        out ushort m10, out ushort m11, out ushort m12,
        out ushort m20, out ushort m21, out ushort m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // deconstruct

    #region index

    public ushort3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ushort this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // ushort3x3

#region ushort3x4

[Serializable]
[JsonConverter(typeof(ushort3x4JsonConverter))]
public partial struct ushort3x4 :
    IMatrix3x4<ushort>, IMatrixSelf<ushort3x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static ushort3x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ushort3x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new((ushort)1); 
    }

    public static ushort3x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (ushort)1, default, default, default,
            default, (ushort)1, default, default,
            default, default, (ushort)1, default
        ); 
    }

    #endregion

    #region fields
    public ushort3 c0;
    public ushort3 c1;
    public ushort3 c2;
    public ushort3 c3;

    #endregion

    #region getter

    public ushort m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ushort m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ushort m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ushort m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public ushort m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ushort m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ushort m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public ushort m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public ushort m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ushort m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public ushort m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public ushort m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public ushort3x4(ushort3 c0, ushort3 c1, ushort3 c2, ushort3 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public ushort3x4((ushort3 c0, ushort3 c1, ushort3 c2, ushort3 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort3x4((ushort3 c0, ushort3 c1, ushort3 c2, ushort3 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ushort3x4(
        ushort m00, ushort m01, ushort m02, ushort m03,
        ushort m10, ushort m11, ushort m12, ushort m13,
        ushort m20, ushort m21, ushort m22, ushort m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort3x4((
        ushort m00, ushort m01, ushort m02, ushort m03,
        ushort m10, ushort m11, ushort m12, ushort m13,
        ushort m20, ushort m21, ushort m22, ushort m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ushort3x4((
        ushort m00, ushort m01, ushort m02, ushort m03,
        ushort m10, ushort m11, ushort m12, ushort m13,
        ushort m20, ushort m21, ushort m22, ushort m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort3x4((
        (ushort m00, ushort m01, ushort m02, ushort m03) r0,
        (ushort m10, ushort m11, ushort m12, ushort m13) r1,
        (ushort m20, ushort m21, ushort m22, ushort m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ushort3x4((
        (ushort m00, ushort m01, ushort m02, ushort m03) r0,
        (ushort m10, ushort m11, ushort m12, ushort m13) r1,
        (ushort m20, ushort m21, ushort m22, ushort m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort3x4(ushort value) => new(value);

    [MethodImpl(256 | 512)]
    public ushort3x4(ushort value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort3x4(ushort3 value) => new(value);

    [MethodImpl(256 | 512)]
    public ushort3x4(ushort3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out ushort3 c0, out ushort3 c1, out ushort3 c2, out ushort3 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out ushort m00, out ushort m01, out ushort m02, out ushort m03,
        out ushort m10, out ushort m11, out ushort m12, out ushort m13,
        out ushort m20, out ushort m21, out ushort m22, out ushort m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // deconstruct

    #region index

    public ushort3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ushort this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // ushort3x4

#region ushort4x2

[Serializable]
[JsonConverter(typeof(ushort4x2JsonConverter))]
public partial struct ushort4x2 :
    IMatrix4x2<ushort>, IMatrixSelf<ushort4x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static ushort4x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ushort4x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new((ushort)1); 
    }

    public static ushort4x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (ushort)1, default,
            default, (ushort)1,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region fields
    public ushort4 c0;
    public ushort4 c1;

    #endregion

    #region getter

    public ushort m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ushort m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ushort m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ushort m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ushort m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ushort m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public ushort m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public ushort m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public ushort4x2(ushort4 c0, ushort4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public ushort4x2((ushort4 c0, ushort4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort4x2((ushort4 c0, ushort4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ushort4x2(
        ushort m00, ushort m01,
        ushort m10, ushort m11,
        ushort m20, ushort m21,
        ushort m30, ushort m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort4x2((
        ushort m00, ushort m01,
        ushort m10, ushort m11,
        ushort m20, ushort m21,
        ushort m30, ushort m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ushort4x2((
        ushort m00, ushort m01,
        ushort m10, ushort m11,
        ushort m20, ushort m21,
        ushort m30, ushort m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort4x2((
        (ushort m00, ushort m01) r0,
        (ushort m10, ushort m11) r1,
        (ushort m20, ushort m21) r2,
        (ushort m30, ushort m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ushort4x2((
        (ushort m00, ushort m01) r0,
        (ushort m10, ushort m11) r1,
        (ushort m20, ushort m21) r2,
        (ushort m30, ushort m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort4x2(ushort value) => new(value);

    [MethodImpl(256 | 512)]
    public ushort4x2(ushort value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort4x2(ushort4 value) => new(value);

    [MethodImpl(256 | 512)]
    public ushort4x2(ushort4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out ushort4 c0, out ushort4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out ushort m00, out ushort m01,
        out ushort m10, out ushort m11,
        out ushort m20, out ushort m21,
        out ushort m30, out ushort m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // deconstruct

    #region index

    public ushort4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ushort this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // ushort4x2

#region ushort4x3

[Serializable]
[JsonConverter(typeof(ushort4x3JsonConverter))]
public partial struct ushort4x3 :
    IMatrix4x3<ushort>, IMatrixSelf<ushort4x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static ushort4x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ushort4x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new((ushort)1); 
    }

    public static ushort4x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (ushort)1, default, default,
            default, (ushort)1, default,
            default, default, (ushort)1,
            default, default, default
        ); 
    }

    #endregion

    #region fields
    public ushort4 c0;
    public ushort4 c1;
    public ushort4 c2;

    #endregion

    #region getter

    public ushort m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ushort m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ushort m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ushort m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ushort m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ushort m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public ushort m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ushort m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public ushort m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public ushort m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public ushort m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public ushort m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public ushort4x3(ushort4 c0, ushort4 c1, ushort4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public ushort4x3((ushort4 c0, ushort4 c1, ushort4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort4x3((ushort4 c0, ushort4 c1, ushort4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ushort4x3(
        ushort m00, ushort m01, ushort m02,
        ushort m10, ushort m11, ushort m12,
        ushort m20, ushort m21, ushort m22,
        ushort m30, ushort m31, ushort m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort4x3((
        ushort m00, ushort m01, ushort m02,
        ushort m10, ushort m11, ushort m12,
        ushort m20, ushort m21, ushort m22,
        ushort m30, ushort m31, ushort m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ushort4x3((
        ushort m00, ushort m01, ushort m02,
        ushort m10, ushort m11, ushort m12,
        ushort m20, ushort m21, ushort m22,
        ushort m30, ushort m31, ushort m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort4x3((
        (ushort m00, ushort m01, ushort m02) r0,
        (ushort m10, ushort m11, ushort m12) r1,
        (ushort m20, ushort m21, ushort m22) r2,
        (ushort m30, ushort m31, ushort m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ushort4x3((
        (ushort m00, ushort m01, ushort m02) r0,
        (ushort m10, ushort m11, ushort m12) r1,
        (ushort m20, ushort m21, ushort m22) r2,
        (ushort m30, ushort m31, ushort m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort4x3(ushort value) => new(value);

    [MethodImpl(256 | 512)]
    public ushort4x3(ushort value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort4x3(ushort4 value) => new(value);

    [MethodImpl(256 | 512)]
    public ushort4x3(ushort4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out ushort4 c0, out ushort4 c1, out ushort4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out ushort m00, out ushort m01, out ushort m02,
        out ushort m10, out ushort m11, out ushort m12,
        out ushort m20, out ushort m21, out ushort m22,
        out ushort m30, out ushort m31, out ushort m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // deconstruct

    #region index

    public ushort4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ushort this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // ushort4x3

#region ushort4x4

[Serializable]
[JsonConverter(typeof(ushort4x4JsonConverter))]
public partial struct ushort4x4 :
    IMatrix4x4<ushort>, IMatrixSelf<ushort4x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static ushort4x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ushort4x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new((ushort)1); 
    }

    public static ushort4x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (ushort)1, default, default, default,
            default, (ushort)1, default, default,
            default, default, (ushort)1, default,
            default, default, default, (ushort)1
        ); 
    }

    #endregion

    #region fields
    public ushort4 c0;
    public ushort4 c1;
    public ushort4 c2;
    public ushort4 c3;

    #endregion

    #region getter

    public ushort m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ushort m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ushort m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ushort m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public ushort m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ushort m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ushort m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public ushort m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public ushort m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ushort m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public ushort m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public ushort m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public ushort m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public ushort m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public ushort m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public ushort m33
    {
        [MethodImpl(256 | 512)]
        get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public ushort4x4(ushort4 c0, ushort4 c1, ushort4 c2, ushort4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public ushort4x4((ushort4 c0, ushort4 c1, ushort4 c2, ushort4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort4x4((ushort4 c0, ushort4 c1, ushort4 c2, ushort4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ushort4x4(
        ushort m00, ushort m01, ushort m02, ushort m03,
        ushort m10, ushort m11, ushort m12, ushort m13,
        ushort m20, ushort m21, ushort m22, ushort m23,
        ushort m30, ushort m31, ushort m32, ushort m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort4x4((
        ushort m00, ushort m01, ushort m02, ushort m03,
        ushort m10, ushort m11, ushort m12, ushort m13,
        ushort m20, ushort m21, ushort m22, ushort m23,
        ushort m30, ushort m31, ushort m32, ushort m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ushort4x4((
        ushort m00, ushort m01, ushort m02, ushort m03,
        ushort m10, ushort m11, ushort m12, ushort m13,
        ushort m20, ushort m21, ushort m22, ushort m23,
        ushort m30, ushort m31, ushort m32, ushort m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort4x4((
        (ushort m00, ushort m01, ushort m02, ushort m03) r0,
        (ushort m10, ushort m11, ushort m12, ushort m13) r1,
        (ushort m20, ushort m21, ushort m22, ushort m23) r2,
        (ushort m30, ushort m31, ushort m32, ushort m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ushort4x4((
        (ushort m00, ushort m01, ushort m02, ushort m03) r0,
        (ushort m10, ushort m11, ushort m12, ushort m13) r1,
        (ushort m20, ushort m21, ushort m22, ushort m23) r2,
        (ushort m30, ushort m31, ushort m32, ushort m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort4x4(ushort value) => new(value);

    [MethodImpl(256 | 512)]
    public ushort4x4(ushort value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ushort4x4(ushort4 value) => new(value);

    [MethodImpl(256 | 512)]
    public ushort4x4(ushort4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out ushort4 c0, out ushort4 c1, out ushort4 c2, out ushort4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out ushort m00, out ushort m01, out ushort m02, out ushort m03,
        out ushort m10, out ushort m11, out ushort m12, out ushort m13,
        out ushort m20, out ushort m21, out ushort m22, out ushort m23,
        out ushort m30, out ushort m31, out ushort m32, out ushort m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // deconstruct

    #region index

    public ushort4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ushort this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // ushort4x4

#region int2x2

[Serializable]
[JsonConverter(typeof(int2x2JsonConverter))]
public partial struct int2x2 :
    IMatrix2x2<int>, IMatrixSelf<int2x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static int2x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static int2x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1); 
    }

    public static int2x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default,
            default, 1
        ); 
    }

    #endregion

    #region fields
    public int2 c0;
    public int2 c1;

    #endregion

    #region getter

    public int m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public int2x2(int2 c0, int2 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public int2x2((int2 c0, int2 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x2((int2 c0, int2 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x2(
        int m00, int m01,
        int m10, int m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x2((
        int m00, int m01,
        int m10, int m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x2((
        int m00, int m01,
        int m10, int m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x2((
        (int m00, int m01) r0,
        (int m10, int m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x2((
        (int m00, int m01) r0,
        (int m10, int m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x2(int value) => new(value);

    [MethodImpl(256 | 512)]
    public int2x2(int value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x2(int2 value) => new(value);

    [MethodImpl(256 | 512)]
    public int2x2(int2 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out int2 c0, out int2 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out int m00, out int m01,
        out int m10, out int m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // deconstruct

    #region index

    public int2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // int2x2

#region int2x3

[Serializable]
[JsonConverter(typeof(int2x3JsonConverter))]
public partial struct int2x3 :
    IMatrix2x3<int>, IMatrixSelf<int2x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static int2x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static int2x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1); 
    }

    public static int2x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default, default,
            default, 1, default
        ); 
    }

    #endregion

    #region fields
    public int2 c0;
    public int2 c1;
    public int2 c2;

    #endregion

    #region getter

    public int m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public int m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public int2x3(int2 c0, int2 c1, int2 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public int2x3((int2 c0, int2 c1, int2 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x3((int2 c0, int2 c1, int2 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x3(
        int m00, int m01, int m02,
        int m10, int m11, int m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x3((
        int m00, int m01, int m02,
        int m10, int m11, int m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x3((
        int m00, int m01, int m02,
        int m10, int m11, int m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x3((
        (int m00, int m01, int m02) r0,
        (int m10, int m11, int m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x3((
        (int m00, int m01, int m02) r0,
        (int m10, int m11, int m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x3(int value) => new(value);

    [MethodImpl(256 | 512)]
    public int2x3(int value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x3(int2 value) => new(value);

    [MethodImpl(256 | 512)]
    public int2x3(int2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out int2 c0, out int2 c1, out int2 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out int m00, out int m01, out int m02,
        out int m10, out int m11, out int m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // deconstruct

    #region index

    public int2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // int2x3

#region int2x4

[Serializable]
[JsonConverter(typeof(int2x4JsonConverter))]
public partial struct int2x4 :
    IMatrix2x4<int>, IMatrixSelf<int2x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static int2x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static int2x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1); 
    }

    public static int2x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default, default, default,
            default, 1, default, default
        ); 
    }

    #endregion

    #region fields
    public int2 c0;
    public int2 c1;
    public int2 c2;
    public int2 c3;

    #endregion

    #region getter

    public int m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public int m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public int m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public int m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public int2x4(int2 c0, int2 c1, int2 c2, int2 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public int2x4((int2 c0, int2 c1, int2 c2, int2 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x4((int2 c0, int2 c1, int2 c2, int2 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x4(
        int m00, int m01, int m02, int m03,
        int m10, int m11, int m12, int m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x4((
        int m00, int m01, int m02, int m03,
        int m10, int m11, int m12, int m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x4((
        int m00, int m01, int m02, int m03,
        int m10, int m11, int m12, int m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x4((
        (int m00, int m01, int m02, int m03) r0,
        (int m10, int m11, int m12, int m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x4((
        (int m00, int m01, int m02, int m03) r0,
        (int m10, int m11, int m12, int m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x4(int value) => new(value);

    [MethodImpl(256 | 512)]
    public int2x4(int value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x4(int2 value) => new(value);

    [MethodImpl(256 | 512)]
    public int2x4(int2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out int2 c0, out int2 c1, out int2 c2, out int2 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out int m00, out int m01, out int m02, out int m03,
        out int m10, out int m11, out int m12, out int m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // deconstruct

    #region index

    public int2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // int2x4

#region int3x2

[Serializable]
[JsonConverter(typeof(int3x2JsonConverter))]
public partial struct int3x2 :
    IMatrix3x2<int>, IMatrixSelf<int3x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static int3x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static int3x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1); 
    }

    public static int3x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default,
            default, 1,
            default, default
        ); 
    }

    #endregion

    #region fields
    public int3 c0;
    public int3 c1;

    #endregion

    #region getter

    public int m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public int m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public int3x2(int3 c0, int3 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public int3x2((int3 c0, int3 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x2((int3 c0, int3 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x2(
        int m00, int m01,
        int m10, int m11,
        int m20, int m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x2((
        int m00, int m01,
        int m10, int m11,
        int m20, int m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x2((
        int m00, int m01,
        int m10, int m11,
        int m20, int m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x2((
        (int m00, int m01) r0,
        (int m10, int m11) r1,
        (int m20, int m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x2((
        (int m00, int m01) r0,
        (int m10, int m11) r1,
        (int m20, int m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x2(int value) => new(value);

    [MethodImpl(256 | 512)]
    public int3x2(int value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x2(int3 value) => new(value);

    [MethodImpl(256 | 512)]
    public int3x2(int3 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out int3 c0, out int3 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out int m00, out int m01,
        out int m10, out int m11,
        out int m20, out int m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // deconstruct

    #region index

    public int3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // int3x2

#region int3x3

[Serializable]
[JsonConverter(typeof(int3x3JsonConverter))]
public partial struct int3x3 :
    IMatrix3x3<int>, IMatrixSelf<int3x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static int3x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static int3x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1); 
    }

    public static int3x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default, default,
            default, 1, default,
            default, default, 1
        ); 
    }

    #endregion

    #region fields
    public int3 c0;
    public int3 c1;
    public int3 c2;

    #endregion

    #region getter

    public int m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public int m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public int m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public int m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public int m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public int3x3(int3 c0, int3 c1, int3 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public int3x3((int3 c0, int3 c1, int3 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x3((int3 c0, int3 c1, int3 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x3(
        int m00, int m01, int m02,
        int m10, int m11, int m12,
        int m20, int m21, int m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x3((
        int m00, int m01, int m02,
        int m10, int m11, int m12,
        int m20, int m21, int m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x3((
        int m00, int m01, int m02,
        int m10, int m11, int m12,
        int m20, int m21, int m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x3((
        (int m00, int m01, int m02) r0,
        (int m10, int m11, int m12) r1,
        (int m20, int m21, int m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x3((
        (int m00, int m01, int m02) r0,
        (int m10, int m11, int m12) r1,
        (int m20, int m21, int m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x3(int value) => new(value);

    [MethodImpl(256 | 512)]
    public int3x3(int value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x3(int3 value) => new(value);

    [MethodImpl(256 | 512)]
    public int3x3(int3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out int3 c0, out int3 c1, out int3 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out int m00, out int m01, out int m02,
        out int m10, out int m11, out int m12,
        out int m20, out int m21, out int m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // deconstruct

    #region index

    public int3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // int3x3

#region int3x4

[Serializable]
[JsonConverter(typeof(int3x4JsonConverter))]
public partial struct int3x4 :
    IMatrix3x4<int>, IMatrixSelf<int3x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static int3x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static int3x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1); 
    }

    public static int3x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default, default, default,
            default, 1, default, default,
            default, default, 1, default
        ); 
    }

    #endregion

    #region fields
    public int3 c0;
    public int3 c1;
    public int3 c2;
    public int3 c3;

    #endregion

    #region getter

    public int m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public int m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public int m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public int m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public int m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public int m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public int m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public int m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public int3x4(int3 c0, int3 c1, int3 c2, int3 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public int3x4((int3 c0, int3 c1, int3 c2, int3 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x4((int3 c0, int3 c1, int3 c2, int3 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x4(
        int m00, int m01, int m02, int m03,
        int m10, int m11, int m12, int m13,
        int m20, int m21, int m22, int m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x4((
        int m00, int m01, int m02, int m03,
        int m10, int m11, int m12, int m13,
        int m20, int m21, int m22, int m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x4((
        int m00, int m01, int m02, int m03,
        int m10, int m11, int m12, int m13,
        int m20, int m21, int m22, int m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x4((
        (int m00, int m01, int m02, int m03) r0,
        (int m10, int m11, int m12, int m13) r1,
        (int m20, int m21, int m22, int m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x4((
        (int m00, int m01, int m02, int m03) r0,
        (int m10, int m11, int m12, int m13) r1,
        (int m20, int m21, int m22, int m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x4(int value) => new(value);

    [MethodImpl(256 | 512)]
    public int3x4(int value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x4(int3 value) => new(value);

    [MethodImpl(256 | 512)]
    public int3x4(int3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out int3 c0, out int3 c1, out int3 c2, out int3 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out int m00, out int m01, out int m02, out int m03,
        out int m10, out int m11, out int m12, out int m13,
        out int m20, out int m21, out int m22, out int m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // deconstruct

    #region index

    public int3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // int3x4

#region int4x2

[Serializable]
[JsonConverter(typeof(int4x2JsonConverter))]
public partial struct int4x2 :
    IMatrix4x2<int>, IMatrixSelf<int4x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static int4x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static int4x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1); 
    }

    public static int4x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default,
            default, 1,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region fields
    public int4 c0;
    public int4 c1;

    #endregion

    #region getter

    public int m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public int m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public int m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public int m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public int4x2(int4 c0, int4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public int4x2((int4 c0, int4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x2((int4 c0, int4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x2(
        int m00, int m01,
        int m10, int m11,
        int m20, int m21,
        int m30, int m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x2((
        int m00, int m01,
        int m10, int m11,
        int m20, int m21,
        int m30, int m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x2((
        int m00, int m01,
        int m10, int m11,
        int m20, int m21,
        int m30, int m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x2((
        (int m00, int m01) r0,
        (int m10, int m11) r1,
        (int m20, int m21) r2,
        (int m30, int m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x2((
        (int m00, int m01) r0,
        (int m10, int m11) r1,
        (int m20, int m21) r2,
        (int m30, int m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x2(int value) => new(value);

    [MethodImpl(256 | 512)]
    public int4x2(int value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x2(int4 value) => new(value);

    [MethodImpl(256 | 512)]
    public int4x2(int4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out int4 c0, out int4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out int m00, out int m01,
        out int m10, out int m11,
        out int m20, out int m21,
        out int m30, out int m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // deconstruct

    #region index

    public int4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // int4x2

#region int4x3

[Serializable]
[JsonConverter(typeof(int4x3JsonConverter))]
public partial struct int4x3 :
    IMatrix4x3<int>, IMatrixSelf<int4x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static int4x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static int4x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1); 
    }

    public static int4x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default, default,
            default, 1, default,
            default, default, 1,
            default, default, default
        ); 
    }

    #endregion

    #region fields
    public int4 c0;
    public int4 c1;
    public int4 c2;

    #endregion

    #region getter

    public int m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public int m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public int m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public int m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public int m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public int m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public int m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public int m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public int4x3(int4 c0, int4 c1, int4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public int4x3((int4 c0, int4 c1, int4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x3((int4 c0, int4 c1, int4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x3(
        int m00, int m01, int m02,
        int m10, int m11, int m12,
        int m20, int m21, int m22,
        int m30, int m31, int m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x3((
        int m00, int m01, int m02,
        int m10, int m11, int m12,
        int m20, int m21, int m22,
        int m30, int m31, int m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x3((
        int m00, int m01, int m02,
        int m10, int m11, int m12,
        int m20, int m21, int m22,
        int m30, int m31, int m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x3((
        (int m00, int m01, int m02) r0,
        (int m10, int m11, int m12) r1,
        (int m20, int m21, int m22) r2,
        (int m30, int m31, int m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x3((
        (int m00, int m01, int m02) r0,
        (int m10, int m11, int m12) r1,
        (int m20, int m21, int m22) r2,
        (int m30, int m31, int m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x3(int value) => new(value);

    [MethodImpl(256 | 512)]
    public int4x3(int value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x3(int4 value) => new(value);

    [MethodImpl(256 | 512)]
    public int4x3(int4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out int4 c0, out int4 c1, out int4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out int m00, out int m01, out int m02,
        out int m10, out int m11, out int m12,
        out int m20, out int m21, out int m22,
        out int m30, out int m31, out int m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // deconstruct

    #region index

    public int4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // int4x3

#region int4x4

[Serializable]
[JsonConverter(typeof(int4x4JsonConverter))]
public partial struct int4x4 :
    IMatrix4x4<int>, IMatrixSelf<int4x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static int4x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static int4x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1); 
    }

    public static int4x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default, default, default,
            default, 1, default, default,
            default, default, 1, default,
            default, default, default, 1
        ); 
    }

    #endregion

    #region fields
    public int4 c0;
    public int4 c1;
    public int4 c2;
    public int4 c3;

    #endregion

    #region getter

    public int m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public int m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public int m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public int m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public int m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public int m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public int m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public int m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public int m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public int m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public int m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public int m33
    {
        [MethodImpl(256 | 512)]
        get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public int4x4(int4 c0, int4 c1, int4 c2, int4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public int4x4((int4 c0, int4 c1, int4 c2, int4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x4((int4 c0, int4 c1, int4 c2, int4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x4(
        int m00, int m01, int m02, int m03,
        int m10, int m11, int m12, int m13,
        int m20, int m21, int m22, int m23,
        int m30, int m31, int m32, int m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x4((
        int m00, int m01, int m02, int m03,
        int m10, int m11, int m12, int m13,
        int m20, int m21, int m22, int m23,
        int m30, int m31, int m32, int m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x4((
        int m00, int m01, int m02, int m03,
        int m10, int m11, int m12, int m13,
        int m20, int m21, int m22, int m23,
        int m30, int m31, int m32, int m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x4((
        (int m00, int m01, int m02, int m03) r0,
        (int m10, int m11, int m12, int m13) r1,
        (int m20, int m21, int m22, int m23) r2,
        (int m30, int m31, int m32, int m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x4((
        (int m00, int m01, int m02, int m03) r0,
        (int m10, int m11, int m12, int m13) r1,
        (int m20, int m21, int m22, int m23) r2,
        (int m30, int m31, int m32, int m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x4(int value) => new(value);

    [MethodImpl(256 | 512)]
    public int4x4(int value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x4(int4 value) => new(value);

    [MethodImpl(256 | 512)]
    public int4x4(int4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out int4 c0, out int4 c1, out int4 c2, out int4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out int m00, out int m01, out int m02, out int m03,
        out int m10, out int m11, out int m12, out int m13,
        out int m20, out int m21, out int m22, out int m23,
        out int m30, out int m31, out int m32, out int m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // deconstruct

    #region index

    public int4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // int4x4

#region uint2x2

[Serializable]
[JsonConverter(typeof(uint2x2JsonConverter))]
public partial struct uint2x2 :
    IMatrix2x2<uint>, IMatrixSelf<uint2x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static uint2x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static uint2x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1u); 
    }

    public static uint2x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default,
            default, 1u
        ); 
    }

    #endregion

    #region fields
    public uint2 c0;
    public uint2 c1;

    #endregion

    #region getter

    public uint m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public uint2x2(uint2 c0, uint2 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public uint2x2((uint2 c0, uint2 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x2((uint2 c0, uint2 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x2(
        uint m00, uint m01,
        uint m10, uint m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x2((
        uint m00, uint m01,
        uint m10, uint m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x2((
        uint m00, uint m01,
        uint m10, uint m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x2((
        (uint m00, uint m01) r0,
        (uint m10, uint m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x2((
        (uint m00, uint m01) r0,
        (uint m10, uint m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x2(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public uint2x2(uint value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x2(uint2 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint2x2(uint2 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out uint2 c0, out uint2 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out uint m00, out uint m01,
        out uint m10, out uint m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // deconstruct

    #region index

    public uint2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // uint2x2

#region uint2x3

[Serializable]
[JsonConverter(typeof(uint2x3JsonConverter))]
public partial struct uint2x3 :
    IMatrix2x3<uint>, IMatrixSelf<uint2x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static uint2x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static uint2x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1u); 
    }

    public static uint2x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default, default,
            default, 1u, default
        ); 
    }

    #endregion

    #region fields
    public uint2 c0;
    public uint2 c1;
    public uint2 c2;

    #endregion

    #region getter

    public uint m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public uint m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public uint2x3(uint2 c0, uint2 c1, uint2 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public uint2x3((uint2 c0, uint2 c1, uint2 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x3((uint2 c0, uint2 c1, uint2 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x3(
        uint m00, uint m01, uint m02,
        uint m10, uint m11, uint m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x3((
        uint m00, uint m01, uint m02,
        uint m10, uint m11, uint m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x3((
        uint m00, uint m01, uint m02,
        uint m10, uint m11, uint m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x3((
        (uint m00, uint m01, uint m02) r0,
        (uint m10, uint m11, uint m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x3((
        (uint m00, uint m01, uint m02) r0,
        (uint m10, uint m11, uint m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x3(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public uint2x3(uint value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x3(uint2 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint2x3(uint2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out uint2 c0, out uint2 c1, out uint2 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out uint m00, out uint m01, out uint m02,
        out uint m10, out uint m11, out uint m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // deconstruct

    #region index

    public uint2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // uint2x3

#region uint2x4

[Serializable]
[JsonConverter(typeof(uint2x4JsonConverter))]
public partial struct uint2x4 :
    IMatrix2x4<uint>, IMatrixSelf<uint2x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static uint2x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static uint2x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1u); 
    }

    public static uint2x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default, default, default,
            default, 1u, default, default
        ); 
    }

    #endregion

    #region fields
    public uint2 c0;
    public uint2 c1;
    public uint2 c2;
    public uint2 c3;

    #endregion

    #region getter

    public uint m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public uint m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public uint m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public uint m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public uint2x4(uint2 c0, uint2 c1, uint2 c2, uint2 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public uint2x4((uint2 c0, uint2 c1, uint2 c2, uint2 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x4((uint2 c0, uint2 c1, uint2 c2, uint2 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x4(
        uint m00, uint m01, uint m02, uint m03,
        uint m10, uint m11, uint m12, uint m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x4((
        uint m00, uint m01, uint m02, uint m03,
        uint m10, uint m11, uint m12, uint m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x4((
        uint m00, uint m01, uint m02, uint m03,
        uint m10, uint m11, uint m12, uint m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x4((
        (uint m00, uint m01, uint m02, uint m03) r0,
        (uint m10, uint m11, uint m12, uint m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x4((
        (uint m00, uint m01, uint m02, uint m03) r0,
        (uint m10, uint m11, uint m12, uint m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x4(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public uint2x4(uint value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x4(uint2 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint2x4(uint2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out uint2 c0, out uint2 c1, out uint2 c2, out uint2 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out uint m00, out uint m01, out uint m02, out uint m03,
        out uint m10, out uint m11, out uint m12, out uint m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // deconstruct

    #region index

    public uint2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // uint2x4

#region uint3x2

[Serializable]
[JsonConverter(typeof(uint3x2JsonConverter))]
public partial struct uint3x2 :
    IMatrix3x2<uint>, IMatrixSelf<uint3x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static uint3x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static uint3x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1u); 
    }

    public static uint3x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default,
            default, 1u,
            default, default
        ); 
    }

    #endregion

    #region fields
    public uint3 c0;
    public uint3 c1;

    #endregion

    #region getter

    public uint m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public uint m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public uint3x2(uint3 c0, uint3 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public uint3x2((uint3 c0, uint3 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x2((uint3 c0, uint3 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x2(
        uint m00, uint m01,
        uint m10, uint m11,
        uint m20, uint m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x2((
        uint m00, uint m01,
        uint m10, uint m11,
        uint m20, uint m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x2((
        uint m00, uint m01,
        uint m10, uint m11,
        uint m20, uint m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x2((
        (uint m00, uint m01) r0,
        (uint m10, uint m11) r1,
        (uint m20, uint m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x2((
        (uint m00, uint m01) r0,
        (uint m10, uint m11) r1,
        (uint m20, uint m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x2(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public uint3x2(uint value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x2(uint3 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint3x2(uint3 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out uint3 c0, out uint3 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out uint m00, out uint m01,
        out uint m10, out uint m11,
        out uint m20, out uint m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // deconstruct

    #region index

    public uint3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // uint3x2

#region uint3x3

[Serializable]
[JsonConverter(typeof(uint3x3JsonConverter))]
public partial struct uint3x3 :
    IMatrix3x3<uint>, IMatrixSelf<uint3x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static uint3x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static uint3x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1u); 
    }

    public static uint3x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default, default,
            default, 1u, default,
            default, default, 1u
        ); 
    }

    #endregion

    #region fields
    public uint3 c0;
    public uint3 c1;
    public uint3 c2;

    #endregion

    #region getter

    public uint m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public uint m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public uint m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public uint m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public uint m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public uint3x3(uint3 c0, uint3 c1, uint3 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public uint3x3((uint3 c0, uint3 c1, uint3 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x3((uint3 c0, uint3 c1, uint3 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x3(
        uint m00, uint m01, uint m02,
        uint m10, uint m11, uint m12,
        uint m20, uint m21, uint m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x3((
        uint m00, uint m01, uint m02,
        uint m10, uint m11, uint m12,
        uint m20, uint m21, uint m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x3((
        uint m00, uint m01, uint m02,
        uint m10, uint m11, uint m12,
        uint m20, uint m21, uint m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x3((
        (uint m00, uint m01, uint m02) r0,
        (uint m10, uint m11, uint m12) r1,
        (uint m20, uint m21, uint m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x3((
        (uint m00, uint m01, uint m02) r0,
        (uint m10, uint m11, uint m12) r1,
        (uint m20, uint m21, uint m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x3(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public uint3x3(uint value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x3(uint3 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint3x3(uint3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out uint3 c0, out uint3 c1, out uint3 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out uint m00, out uint m01, out uint m02,
        out uint m10, out uint m11, out uint m12,
        out uint m20, out uint m21, out uint m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // deconstruct

    #region index

    public uint3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // uint3x3

#region uint3x4

[Serializable]
[JsonConverter(typeof(uint3x4JsonConverter))]
public partial struct uint3x4 :
    IMatrix3x4<uint>, IMatrixSelf<uint3x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static uint3x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static uint3x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1u); 
    }

    public static uint3x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default, default, default,
            default, 1u, default, default,
            default, default, 1u, default
        ); 
    }

    #endregion

    #region fields
    public uint3 c0;
    public uint3 c1;
    public uint3 c2;
    public uint3 c3;

    #endregion

    #region getter

    public uint m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public uint m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public uint m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public uint m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public uint m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public uint m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public uint m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public uint m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public uint3x4(uint3 c0, uint3 c1, uint3 c2, uint3 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public uint3x4((uint3 c0, uint3 c1, uint3 c2, uint3 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x4((uint3 c0, uint3 c1, uint3 c2, uint3 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x4(
        uint m00, uint m01, uint m02, uint m03,
        uint m10, uint m11, uint m12, uint m13,
        uint m20, uint m21, uint m22, uint m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x4((
        uint m00, uint m01, uint m02, uint m03,
        uint m10, uint m11, uint m12, uint m13,
        uint m20, uint m21, uint m22, uint m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x4((
        uint m00, uint m01, uint m02, uint m03,
        uint m10, uint m11, uint m12, uint m13,
        uint m20, uint m21, uint m22, uint m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x4((
        (uint m00, uint m01, uint m02, uint m03) r0,
        (uint m10, uint m11, uint m12, uint m13) r1,
        (uint m20, uint m21, uint m22, uint m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x4((
        (uint m00, uint m01, uint m02, uint m03) r0,
        (uint m10, uint m11, uint m12, uint m13) r1,
        (uint m20, uint m21, uint m22, uint m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x4(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public uint3x4(uint value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x4(uint3 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint3x4(uint3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out uint3 c0, out uint3 c1, out uint3 c2, out uint3 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out uint m00, out uint m01, out uint m02, out uint m03,
        out uint m10, out uint m11, out uint m12, out uint m13,
        out uint m20, out uint m21, out uint m22, out uint m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // deconstruct

    #region index

    public uint3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // uint3x4

#region uint4x2

[Serializable]
[JsonConverter(typeof(uint4x2JsonConverter))]
public partial struct uint4x2 :
    IMatrix4x2<uint>, IMatrixSelf<uint4x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static uint4x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static uint4x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1u); 
    }

    public static uint4x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default,
            default, 1u,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region fields
    public uint4 c0;
    public uint4 c1;

    #endregion

    #region getter

    public uint m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public uint m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public uint m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public uint m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public uint4x2(uint4 c0, uint4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public uint4x2((uint4 c0, uint4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x2((uint4 c0, uint4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x2(
        uint m00, uint m01,
        uint m10, uint m11,
        uint m20, uint m21,
        uint m30, uint m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x2((
        uint m00, uint m01,
        uint m10, uint m11,
        uint m20, uint m21,
        uint m30, uint m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x2((
        uint m00, uint m01,
        uint m10, uint m11,
        uint m20, uint m21,
        uint m30, uint m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x2((
        (uint m00, uint m01) r0,
        (uint m10, uint m11) r1,
        (uint m20, uint m21) r2,
        (uint m30, uint m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x2((
        (uint m00, uint m01) r0,
        (uint m10, uint m11) r1,
        (uint m20, uint m21) r2,
        (uint m30, uint m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x2(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public uint4x2(uint value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x2(uint4 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint4x2(uint4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out uint4 c0, out uint4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out uint m00, out uint m01,
        out uint m10, out uint m11,
        out uint m20, out uint m21,
        out uint m30, out uint m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // deconstruct

    #region index

    public uint4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // uint4x2

#region uint4x3

[Serializable]
[JsonConverter(typeof(uint4x3JsonConverter))]
public partial struct uint4x3 :
    IMatrix4x3<uint>, IMatrixSelf<uint4x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static uint4x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static uint4x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1u); 
    }

    public static uint4x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default, default,
            default, 1u, default,
            default, default, 1u,
            default, default, default
        ); 
    }

    #endregion

    #region fields
    public uint4 c0;
    public uint4 c1;
    public uint4 c2;

    #endregion

    #region getter

    public uint m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public uint m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public uint m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public uint m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public uint m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public uint m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public uint m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public uint m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public uint4x3(uint4 c0, uint4 c1, uint4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public uint4x3((uint4 c0, uint4 c1, uint4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x3((uint4 c0, uint4 c1, uint4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x3(
        uint m00, uint m01, uint m02,
        uint m10, uint m11, uint m12,
        uint m20, uint m21, uint m22,
        uint m30, uint m31, uint m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x3((
        uint m00, uint m01, uint m02,
        uint m10, uint m11, uint m12,
        uint m20, uint m21, uint m22,
        uint m30, uint m31, uint m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x3((
        uint m00, uint m01, uint m02,
        uint m10, uint m11, uint m12,
        uint m20, uint m21, uint m22,
        uint m30, uint m31, uint m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x3((
        (uint m00, uint m01, uint m02) r0,
        (uint m10, uint m11, uint m12) r1,
        (uint m20, uint m21, uint m22) r2,
        (uint m30, uint m31, uint m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x3((
        (uint m00, uint m01, uint m02) r0,
        (uint m10, uint m11, uint m12) r1,
        (uint m20, uint m21, uint m22) r2,
        (uint m30, uint m31, uint m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x3(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public uint4x3(uint value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x3(uint4 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint4x3(uint4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out uint4 c0, out uint4 c1, out uint4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out uint m00, out uint m01, out uint m02,
        out uint m10, out uint m11, out uint m12,
        out uint m20, out uint m21, out uint m22,
        out uint m30, out uint m31, out uint m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // deconstruct

    #region index

    public uint4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // uint4x3

#region uint4x4

[Serializable]
[JsonConverter(typeof(uint4x4JsonConverter))]
public partial struct uint4x4 :
    IMatrix4x4<uint>, IMatrixSelf<uint4x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static uint4x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static uint4x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1u); 
    }

    public static uint4x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default, default, default,
            default, 1u, default, default,
            default, default, 1u, default,
            default, default, default, 1u
        ); 
    }

    #endregion

    #region fields
    public uint4 c0;
    public uint4 c1;
    public uint4 c2;
    public uint4 c3;

    #endregion

    #region getter

    public uint m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public uint m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public uint m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public uint m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public uint m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public uint m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public uint m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public uint m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public uint m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public uint m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public uint m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public uint m33
    {
        [MethodImpl(256 | 512)]
        get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public uint4x4(uint4 c0, uint4 c1, uint4 c2, uint4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public uint4x4((uint4 c0, uint4 c1, uint4 c2, uint4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x4((uint4 c0, uint4 c1, uint4 c2, uint4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x4(
        uint m00, uint m01, uint m02, uint m03,
        uint m10, uint m11, uint m12, uint m13,
        uint m20, uint m21, uint m22, uint m23,
        uint m30, uint m31, uint m32, uint m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x4((
        uint m00, uint m01, uint m02, uint m03,
        uint m10, uint m11, uint m12, uint m13,
        uint m20, uint m21, uint m22, uint m23,
        uint m30, uint m31, uint m32, uint m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x4((
        uint m00, uint m01, uint m02, uint m03,
        uint m10, uint m11, uint m12, uint m13,
        uint m20, uint m21, uint m22, uint m23,
        uint m30, uint m31, uint m32, uint m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x4((
        (uint m00, uint m01, uint m02, uint m03) r0,
        (uint m10, uint m11, uint m12, uint m13) r1,
        (uint m20, uint m21, uint m22, uint m23) r2,
        (uint m30, uint m31, uint m32, uint m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x4((
        (uint m00, uint m01, uint m02, uint m03) r0,
        (uint m10, uint m11, uint m12, uint m13) r1,
        (uint m20, uint m21, uint m22, uint m23) r2,
        (uint m30, uint m31, uint m32, uint m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x4(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public uint4x4(uint value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x4(uint4 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint4x4(uint4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out uint4 c0, out uint4 c1, out uint4 c2, out uint4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out uint m00, out uint m01, out uint m02, out uint m03,
        out uint m10, out uint m11, out uint m12, out uint m13,
        out uint m20, out uint m21, out uint m22, out uint m23,
        out uint m30, out uint m31, out uint m32, out uint m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // deconstruct

    #region index

    public uint4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // uint4x4

#region long2x2

[Serializable]
[JsonConverter(typeof(long2x2JsonConverter))]
public partial struct long2x2 :
    IMatrix2x2<long>, IMatrixSelf<long2x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static long2x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static long2x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1L); 
    }

    public static long2x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default,
            default, 1L
        ); 
    }

    #endregion

    #region fields
    public long2 c0;
    public long2 c1;

    #endregion

    #region getter

    public long m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public long2x2(long2 c0, long2 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public long2x2((long2 c0, long2 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x2((long2 c0, long2 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x2(
        long m00, long m01,
        long m10, long m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x2((
        long m00, long m01,
        long m10, long m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x2((
        long m00, long m01,
        long m10, long m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x2((
        (long m00, long m01) r0,
        (long m10, long m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x2((
        (long m00, long m01) r0,
        (long m10, long m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x2(long value) => new(value);

    [MethodImpl(256 | 512)]
    public long2x2(long value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x2(long2 value) => new(value);

    [MethodImpl(256 | 512)]
    public long2x2(long2 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out long2 c0, out long2 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out long m00, out long m01,
        out long m10, out long m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // deconstruct

    #region index

    public long2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // long2x2

#region long2x3

[Serializable]
[JsonConverter(typeof(long2x3JsonConverter))]
public partial struct long2x3 :
    IMatrix2x3<long>, IMatrixSelf<long2x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static long2x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static long2x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1L); 
    }

    public static long2x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default, default,
            default, 1L, default
        ); 
    }

    #endregion

    #region fields
    public long2 c0;
    public long2 c1;
    public long2 c2;

    #endregion

    #region getter

    public long m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public long m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public long2x3(long2 c0, long2 c1, long2 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public long2x3((long2 c0, long2 c1, long2 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x3((long2 c0, long2 c1, long2 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x3(
        long m00, long m01, long m02,
        long m10, long m11, long m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x3((
        long m00, long m01, long m02,
        long m10, long m11, long m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x3((
        long m00, long m01, long m02,
        long m10, long m11, long m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x3((
        (long m00, long m01, long m02) r0,
        (long m10, long m11, long m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x3((
        (long m00, long m01, long m02) r0,
        (long m10, long m11, long m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x3(long value) => new(value);

    [MethodImpl(256 | 512)]
    public long2x3(long value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x3(long2 value) => new(value);

    [MethodImpl(256 | 512)]
    public long2x3(long2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out long2 c0, out long2 c1, out long2 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out long m00, out long m01, out long m02,
        out long m10, out long m11, out long m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // deconstruct

    #region index

    public long2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // long2x3

#region long2x4

[Serializable]
[JsonConverter(typeof(long2x4JsonConverter))]
public partial struct long2x4 :
    IMatrix2x4<long>, IMatrixSelf<long2x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static long2x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static long2x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1L); 
    }

    public static long2x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default, default, default,
            default, 1L, default, default
        ); 
    }

    #endregion

    #region fields
    public long2 c0;
    public long2 c1;
    public long2 c2;
    public long2 c3;

    #endregion

    #region getter

    public long m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public long m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public long m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public long m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public long2x4(long2 c0, long2 c1, long2 c2, long2 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public long2x4((long2 c0, long2 c1, long2 c2, long2 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x4((long2 c0, long2 c1, long2 c2, long2 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x4(
        long m00, long m01, long m02, long m03,
        long m10, long m11, long m12, long m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x4((
        long m00, long m01, long m02, long m03,
        long m10, long m11, long m12, long m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x4((
        long m00, long m01, long m02, long m03,
        long m10, long m11, long m12, long m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x4((
        (long m00, long m01, long m02, long m03) r0,
        (long m10, long m11, long m12, long m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x4((
        (long m00, long m01, long m02, long m03) r0,
        (long m10, long m11, long m12, long m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x4(long value) => new(value);

    [MethodImpl(256 | 512)]
    public long2x4(long value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x4(long2 value) => new(value);

    [MethodImpl(256 | 512)]
    public long2x4(long2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out long2 c0, out long2 c1, out long2 c2, out long2 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out long m00, out long m01, out long m02, out long m03,
        out long m10, out long m11, out long m12, out long m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // deconstruct

    #region index

    public long2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // long2x4

#region long3x2

[Serializable]
[JsonConverter(typeof(long3x2JsonConverter))]
public partial struct long3x2 :
    IMatrix3x2<long>, IMatrixSelf<long3x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static long3x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static long3x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1L); 
    }

    public static long3x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default,
            default, 1L,
            default, default
        ); 
    }

    #endregion

    #region fields
    public long3 c0;
    public long3 c1;

    #endregion

    #region getter

    public long m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public long m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public long3x2(long3 c0, long3 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public long3x2((long3 c0, long3 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x2((long3 c0, long3 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x2(
        long m00, long m01,
        long m10, long m11,
        long m20, long m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x2((
        long m00, long m01,
        long m10, long m11,
        long m20, long m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x2((
        long m00, long m01,
        long m10, long m11,
        long m20, long m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x2((
        (long m00, long m01) r0,
        (long m10, long m11) r1,
        (long m20, long m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x2((
        (long m00, long m01) r0,
        (long m10, long m11) r1,
        (long m20, long m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x2(long value) => new(value);

    [MethodImpl(256 | 512)]
    public long3x2(long value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x2(long3 value) => new(value);

    [MethodImpl(256 | 512)]
    public long3x2(long3 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out long3 c0, out long3 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out long m00, out long m01,
        out long m10, out long m11,
        out long m20, out long m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // deconstruct

    #region index

    public long3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // long3x2

#region long3x3

[Serializable]
[JsonConverter(typeof(long3x3JsonConverter))]
public partial struct long3x3 :
    IMatrix3x3<long>, IMatrixSelf<long3x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static long3x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static long3x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1L); 
    }

    public static long3x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default, default,
            default, 1L, default,
            default, default, 1L
        ); 
    }

    #endregion

    #region fields
    public long3 c0;
    public long3 c1;
    public long3 c2;

    #endregion

    #region getter

    public long m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public long m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public long m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public long m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public long m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public long3x3(long3 c0, long3 c1, long3 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public long3x3((long3 c0, long3 c1, long3 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x3((long3 c0, long3 c1, long3 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x3(
        long m00, long m01, long m02,
        long m10, long m11, long m12,
        long m20, long m21, long m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x3((
        long m00, long m01, long m02,
        long m10, long m11, long m12,
        long m20, long m21, long m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x3((
        long m00, long m01, long m02,
        long m10, long m11, long m12,
        long m20, long m21, long m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x3((
        (long m00, long m01, long m02) r0,
        (long m10, long m11, long m12) r1,
        (long m20, long m21, long m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x3((
        (long m00, long m01, long m02) r0,
        (long m10, long m11, long m12) r1,
        (long m20, long m21, long m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x3(long value) => new(value);

    [MethodImpl(256 | 512)]
    public long3x3(long value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x3(long3 value) => new(value);

    [MethodImpl(256 | 512)]
    public long3x3(long3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out long3 c0, out long3 c1, out long3 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out long m00, out long m01, out long m02,
        out long m10, out long m11, out long m12,
        out long m20, out long m21, out long m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // deconstruct

    #region index

    public long3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // long3x3

#region long3x4

[Serializable]
[JsonConverter(typeof(long3x4JsonConverter))]
public partial struct long3x4 :
    IMatrix3x4<long>, IMatrixSelf<long3x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static long3x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static long3x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1L); 
    }

    public static long3x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default, default, default,
            default, 1L, default, default,
            default, default, 1L, default
        ); 
    }

    #endregion

    #region fields
    public long3 c0;
    public long3 c1;
    public long3 c2;
    public long3 c3;

    #endregion

    #region getter

    public long m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public long m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public long m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public long m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public long m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public long m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public long m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public long m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public long3x4(long3 c0, long3 c1, long3 c2, long3 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public long3x4((long3 c0, long3 c1, long3 c2, long3 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x4((long3 c0, long3 c1, long3 c2, long3 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x4(
        long m00, long m01, long m02, long m03,
        long m10, long m11, long m12, long m13,
        long m20, long m21, long m22, long m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x4((
        long m00, long m01, long m02, long m03,
        long m10, long m11, long m12, long m13,
        long m20, long m21, long m22, long m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x4((
        long m00, long m01, long m02, long m03,
        long m10, long m11, long m12, long m13,
        long m20, long m21, long m22, long m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x4((
        (long m00, long m01, long m02, long m03) r0,
        (long m10, long m11, long m12, long m13) r1,
        (long m20, long m21, long m22, long m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x4((
        (long m00, long m01, long m02, long m03) r0,
        (long m10, long m11, long m12, long m13) r1,
        (long m20, long m21, long m22, long m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x4(long value) => new(value);

    [MethodImpl(256 | 512)]
    public long3x4(long value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x4(long3 value) => new(value);

    [MethodImpl(256 | 512)]
    public long3x4(long3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out long3 c0, out long3 c1, out long3 c2, out long3 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out long m00, out long m01, out long m02, out long m03,
        out long m10, out long m11, out long m12, out long m13,
        out long m20, out long m21, out long m22, out long m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // deconstruct

    #region index

    public long3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // long3x4

#region long4x2

[Serializable]
[JsonConverter(typeof(long4x2JsonConverter))]
public partial struct long4x2 :
    IMatrix4x2<long>, IMatrixSelf<long4x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static long4x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static long4x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1L); 
    }

    public static long4x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default,
            default, 1L,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region fields
    public long4 c0;
    public long4 c1;

    #endregion

    #region getter

    public long m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public long m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public long m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public long m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public long4x2(long4 c0, long4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public long4x2((long4 c0, long4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x2((long4 c0, long4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x2(
        long m00, long m01,
        long m10, long m11,
        long m20, long m21,
        long m30, long m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x2((
        long m00, long m01,
        long m10, long m11,
        long m20, long m21,
        long m30, long m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x2((
        long m00, long m01,
        long m10, long m11,
        long m20, long m21,
        long m30, long m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x2((
        (long m00, long m01) r0,
        (long m10, long m11) r1,
        (long m20, long m21) r2,
        (long m30, long m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x2((
        (long m00, long m01) r0,
        (long m10, long m11) r1,
        (long m20, long m21) r2,
        (long m30, long m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x2(long value) => new(value);

    [MethodImpl(256 | 512)]
    public long4x2(long value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x2(long4 value) => new(value);

    [MethodImpl(256 | 512)]
    public long4x2(long4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out long4 c0, out long4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out long m00, out long m01,
        out long m10, out long m11,
        out long m20, out long m21,
        out long m30, out long m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // deconstruct

    #region index

    public long4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // long4x2

#region long4x3

[Serializable]
[JsonConverter(typeof(long4x3JsonConverter))]
public partial struct long4x3 :
    IMatrix4x3<long>, IMatrixSelf<long4x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static long4x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static long4x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1L); 
    }

    public static long4x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default, default,
            default, 1L, default,
            default, default, 1L,
            default, default, default
        ); 
    }

    #endregion

    #region fields
    public long4 c0;
    public long4 c1;
    public long4 c2;

    #endregion

    #region getter

    public long m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public long m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public long m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public long m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public long m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public long m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public long m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public long m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public long4x3(long4 c0, long4 c1, long4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public long4x3((long4 c0, long4 c1, long4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x3((long4 c0, long4 c1, long4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x3(
        long m00, long m01, long m02,
        long m10, long m11, long m12,
        long m20, long m21, long m22,
        long m30, long m31, long m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x3((
        long m00, long m01, long m02,
        long m10, long m11, long m12,
        long m20, long m21, long m22,
        long m30, long m31, long m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x3((
        long m00, long m01, long m02,
        long m10, long m11, long m12,
        long m20, long m21, long m22,
        long m30, long m31, long m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x3((
        (long m00, long m01, long m02) r0,
        (long m10, long m11, long m12) r1,
        (long m20, long m21, long m22) r2,
        (long m30, long m31, long m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x3((
        (long m00, long m01, long m02) r0,
        (long m10, long m11, long m12) r1,
        (long m20, long m21, long m22) r2,
        (long m30, long m31, long m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x3(long value) => new(value);

    [MethodImpl(256 | 512)]
    public long4x3(long value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x3(long4 value) => new(value);

    [MethodImpl(256 | 512)]
    public long4x3(long4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out long4 c0, out long4 c1, out long4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out long m00, out long m01, out long m02,
        out long m10, out long m11, out long m12,
        out long m20, out long m21, out long m22,
        out long m30, out long m31, out long m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // deconstruct

    #region index

    public long4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // long4x3

#region long4x4

[Serializable]
[JsonConverter(typeof(long4x4JsonConverter))]
public partial struct long4x4 :
    IMatrix4x4<long>, IMatrixSelf<long4x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static long4x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static long4x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1L); 
    }

    public static long4x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default, default, default,
            default, 1L, default, default,
            default, default, 1L, default,
            default, default, default, 1L
        ); 
    }

    #endregion

    #region fields
    public long4 c0;
    public long4 c1;
    public long4 c2;
    public long4 c3;

    #endregion

    #region getter

    public long m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public long m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public long m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public long m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public long m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public long m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public long m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public long m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public long m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public long m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public long m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public long m33
    {
        [MethodImpl(256 | 512)]
        get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public long4x4(long4 c0, long4 c1, long4 c2, long4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public long4x4((long4 c0, long4 c1, long4 c2, long4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x4((long4 c0, long4 c1, long4 c2, long4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x4(
        long m00, long m01, long m02, long m03,
        long m10, long m11, long m12, long m13,
        long m20, long m21, long m22, long m23,
        long m30, long m31, long m32, long m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x4((
        long m00, long m01, long m02, long m03,
        long m10, long m11, long m12, long m13,
        long m20, long m21, long m22, long m23,
        long m30, long m31, long m32, long m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x4((
        long m00, long m01, long m02, long m03,
        long m10, long m11, long m12, long m13,
        long m20, long m21, long m22, long m23,
        long m30, long m31, long m32, long m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x4((
        (long m00, long m01, long m02, long m03) r0,
        (long m10, long m11, long m12, long m13) r1,
        (long m20, long m21, long m22, long m23) r2,
        (long m30, long m31, long m32, long m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x4((
        (long m00, long m01, long m02, long m03) r0,
        (long m10, long m11, long m12, long m13) r1,
        (long m20, long m21, long m22, long m23) r2,
        (long m30, long m31, long m32, long m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x4(long value) => new(value);

    [MethodImpl(256 | 512)]
    public long4x4(long value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x4(long4 value) => new(value);

    [MethodImpl(256 | 512)]
    public long4x4(long4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out long4 c0, out long4 c1, out long4 c2, out long4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out long m00, out long m01, out long m02, out long m03,
        out long m10, out long m11, out long m12, out long m13,
        out long m20, out long m21, out long m22, out long m23,
        out long m30, out long m31, out long m32, out long m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // deconstruct

    #region index

    public long4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // long4x4

#region ulong2x2

[Serializable]
[JsonConverter(typeof(ulong2x2JsonConverter))]
public partial struct ulong2x2 :
    IMatrix2x2<ulong>, IMatrixSelf<ulong2x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static ulong2x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ulong2x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1UL); 
    }

    public static ulong2x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default,
            default, 1UL
        ); 
    }

    #endregion

    #region fields
    public ulong2 c0;
    public ulong2 c1;

    #endregion

    #region getter

    public ulong m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public ulong2x2(ulong2 c0, ulong2 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public ulong2x2((ulong2 c0, ulong2 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x2((ulong2 c0, ulong2 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x2(
        ulong m00, ulong m01,
        ulong m10, ulong m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x2((
        ulong m00, ulong m01,
        ulong m10, ulong m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x2((
        ulong m00, ulong m01,
        ulong m10, ulong m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x2((
        (ulong m00, ulong m01) r0,
        (ulong m10, ulong m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x2((
        (ulong m00, ulong m01) r0,
        (ulong m10, ulong m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x2(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong2x2(ulong value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x2(ulong2 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong2x2(ulong2 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out ulong2 c0, out ulong2 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out ulong m00, out ulong m01,
        out ulong m10, out ulong m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // deconstruct

    #region index

    public ulong2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // ulong2x2

#region ulong2x3

[Serializable]
[JsonConverter(typeof(ulong2x3JsonConverter))]
public partial struct ulong2x3 :
    IMatrix2x3<ulong>, IMatrixSelf<ulong2x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static ulong2x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ulong2x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1UL); 
    }

    public static ulong2x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default, default,
            default, 1UL, default
        ); 
    }

    #endregion

    #region fields
    public ulong2 c0;
    public ulong2 c1;
    public ulong2 c2;

    #endregion

    #region getter

    public ulong m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ulong m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public ulong2x3(ulong2 c0, ulong2 c1, ulong2 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public ulong2x3((ulong2 c0, ulong2 c1, ulong2 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x3((ulong2 c0, ulong2 c1, ulong2 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x3(
        ulong m00, ulong m01, ulong m02,
        ulong m10, ulong m11, ulong m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x3((
        ulong m00, ulong m01, ulong m02,
        ulong m10, ulong m11, ulong m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x3((
        ulong m00, ulong m01, ulong m02,
        ulong m10, ulong m11, ulong m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x3((
        (ulong m00, ulong m01, ulong m02) r0,
        (ulong m10, ulong m11, ulong m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x3((
        (ulong m00, ulong m01, ulong m02) r0,
        (ulong m10, ulong m11, ulong m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x3(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong2x3(ulong value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x3(ulong2 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong2x3(ulong2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out ulong2 c0, out ulong2 c1, out ulong2 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out ulong m00, out ulong m01, out ulong m02,
        out ulong m10, out ulong m11, out ulong m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // deconstruct

    #region index

    public ulong2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // ulong2x3

#region ulong2x4

[Serializable]
[JsonConverter(typeof(ulong2x4JsonConverter))]
public partial struct ulong2x4 :
    IMatrix2x4<ulong>, IMatrixSelf<ulong2x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static ulong2x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ulong2x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1UL); 
    }

    public static ulong2x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default, default, default,
            default, 1UL, default, default
        ); 
    }

    #endregion

    #region fields
    public ulong2 c0;
    public ulong2 c1;
    public ulong2 c2;
    public ulong2 c3;

    #endregion

    #region getter

    public ulong m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ulong m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public ulong m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public ulong m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public ulong2x4(ulong2 c0, ulong2 c1, ulong2 c2, ulong2 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public ulong2x4((ulong2 c0, ulong2 c1, ulong2 c2, ulong2 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x4((ulong2 c0, ulong2 c1, ulong2 c2, ulong2 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x4(
        ulong m00, ulong m01, ulong m02, ulong m03,
        ulong m10, ulong m11, ulong m12, ulong m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x4((
        ulong m00, ulong m01, ulong m02, ulong m03,
        ulong m10, ulong m11, ulong m12, ulong m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x4((
        ulong m00, ulong m01, ulong m02, ulong m03,
        ulong m10, ulong m11, ulong m12, ulong m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x4((
        (ulong m00, ulong m01, ulong m02, ulong m03) r0,
        (ulong m10, ulong m11, ulong m12, ulong m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x4((
        (ulong m00, ulong m01, ulong m02, ulong m03) r0,
        (ulong m10, ulong m11, ulong m12, ulong m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x4(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong2x4(ulong value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x4(ulong2 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong2x4(ulong2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out ulong2 c0, out ulong2 c1, out ulong2 c2, out ulong2 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out ulong m00, out ulong m01, out ulong m02, out ulong m03,
        out ulong m10, out ulong m11, out ulong m12, out ulong m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // deconstruct

    #region index

    public ulong2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // ulong2x4

#region ulong3x2

[Serializable]
[JsonConverter(typeof(ulong3x2JsonConverter))]
public partial struct ulong3x2 :
    IMatrix3x2<ulong>, IMatrixSelf<ulong3x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static ulong3x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ulong3x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1UL); 
    }

    public static ulong3x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default,
            default, 1UL,
            default, default
        ); 
    }

    #endregion

    #region fields
    public ulong3 c0;
    public ulong3 c1;

    #endregion

    #region getter

    public ulong m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ulong m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public ulong3x2(ulong3 c0, ulong3 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public ulong3x2((ulong3 c0, ulong3 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x2((ulong3 c0, ulong3 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x2(
        ulong m00, ulong m01,
        ulong m10, ulong m11,
        ulong m20, ulong m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x2((
        ulong m00, ulong m01,
        ulong m10, ulong m11,
        ulong m20, ulong m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x2((
        ulong m00, ulong m01,
        ulong m10, ulong m11,
        ulong m20, ulong m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x2((
        (ulong m00, ulong m01) r0,
        (ulong m10, ulong m11) r1,
        (ulong m20, ulong m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x2((
        (ulong m00, ulong m01) r0,
        (ulong m10, ulong m11) r1,
        (ulong m20, ulong m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x2(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong3x2(ulong value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x2(ulong3 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong3x2(ulong3 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out ulong3 c0, out ulong3 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out ulong m00, out ulong m01,
        out ulong m10, out ulong m11,
        out ulong m20, out ulong m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // deconstruct

    #region index

    public ulong3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // ulong3x2

#region ulong3x3

[Serializable]
[JsonConverter(typeof(ulong3x3JsonConverter))]
public partial struct ulong3x3 :
    IMatrix3x3<ulong>, IMatrixSelf<ulong3x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static ulong3x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ulong3x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1UL); 
    }

    public static ulong3x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default, default,
            default, 1UL, default,
            default, default, 1UL
        ); 
    }

    #endregion

    #region fields
    public ulong3 c0;
    public ulong3 c1;
    public ulong3 c2;

    #endregion

    #region getter

    public ulong m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ulong m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public ulong m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ulong m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public ulong m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public ulong3x3(ulong3 c0, ulong3 c1, ulong3 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public ulong3x3((ulong3 c0, ulong3 c1, ulong3 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x3((ulong3 c0, ulong3 c1, ulong3 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x3(
        ulong m00, ulong m01, ulong m02,
        ulong m10, ulong m11, ulong m12,
        ulong m20, ulong m21, ulong m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x3((
        ulong m00, ulong m01, ulong m02,
        ulong m10, ulong m11, ulong m12,
        ulong m20, ulong m21, ulong m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x3((
        ulong m00, ulong m01, ulong m02,
        ulong m10, ulong m11, ulong m12,
        ulong m20, ulong m21, ulong m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x3((
        (ulong m00, ulong m01, ulong m02) r0,
        (ulong m10, ulong m11, ulong m12) r1,
        (ulong m20, ulong m21, ulong m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x3((
        (ulong m00, ulong m01, ulong m02) r0,
        (ulong m10, ulong m11, ulong m12) r1,
        (ulong m20, ulong m21, ulong m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x3(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong3x3(ulong value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x3(ulong3 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong3x3(ulong3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out ulong3 c0, out ulong3 c1, out ulong3 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out ulong m00, out ulong m01, out ulong m02,
        out ulong m10, out ulong m11, out ulong m12,
        out ulong m20, out ulong m21, out ulong m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // deconstruct

    #region index

    public ulong3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // ulong3x3

#region ulong3x4

[Serializable]
[JsonConverter(typeof(ulong3x4JsonConverter))]
public partial struct ulong3x4 :
    IMatrix3x4<ulong>, IMatrixSelf<ulong3x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static ulong3x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ulong3x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1UL); 
    }

    public static ulong3x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default, default, default,
            default, 1UL, default, default,
            default, default, 1UL, default
        ); 
    }

    #endregion

    #region fields
    public ulong3 c0;
    public ulong3 c1;
    public ulong3 c2;
    public ulong3 c3;

    #endregion

    #region getter

    public ulong m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ulong m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public ulong m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public ulong m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public ulong m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ulong m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public ulong m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public ulong m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public ulong3x4(ulong3 c0, ulong3 c1, ulong3 c2, ulong3 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public ulong3x4((ulong3 c0, ulong3 c1, ulong3 c2, ulong3 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x4((ulong3 c0, ulong3 c1, ulong3 c2, ulong3 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x4(
        ulong m00, ulong m01, ulong m02, ulong m03,
        ulong m10, ulong m11, ulong m12, ulong m13,
        ulong m20, ulong m21, ulong m22, ulong m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x4((
        ulong m00, ulong m01, ulong m02, ulong m03,
        ulong m10, ulong m11, ulong m12, ulong m13,
        ulong m20, ulong m21, ulong m22, ulong m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x4((
        ulong m00, ulong m01, ulong m02, ulong m03,
        ulong m10, ulong m11, ulong m12, ulong m13,
        ulong m20, ulong m21, ulong m22, ulong m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x4((
        (ulong m00, ulong m01, ulong m02, ulong m03) r0,
        (ulong m10, ulong m11, ulong m12, ulong m13) r1,
        (ulong m20, ulong m21, ulong m22, ulong m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x4((
        (ulong m00, ulong m01, ulong m02, ulong m03) r0,
        (ulong m10, ulong m11, ulong m12, ulong m13) r1,
        (ulong m20, ulong m21, ulong m22, ulong m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x4(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong3x4(ulong value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x4(ulong3 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong3x4(ulong3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out ulong3 c0, out ulong3 c1, out ulong3 c2, out ulong3 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out ulong m00, out ulong m01, out ulong m02, out ulong m03,
        out ulong m10, out ulong m11, out ulong m12, out ulong m13,
        out ulong m20, out ulong m21, out ulong m22, out ulong m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // deconstruct

    #region index

    public ulong3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // ulong3x4

#region ulong4x2

[Serializable]
[JsonConverter(typeof(ulong4x2JsonConverter))]
public partial struct ulong4x2 :
    IMatrix4x2<ulong>, IMatrixSelf<ulong4x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static ulong4x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ulong4x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1UL); 
    }

    public static ulong4x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default,
            default, 1UL,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region fields
    public ulong4 c0;
    public ulong4 c1;

    #endregion

    #region getter

    public ulong m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ulong m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public ulong m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public ulong m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public ulong4x2(ulong4 c0, ulong4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public ulong4x2((ulong4 c0, ulong4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x2((ulong4 c0, ulong4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x2(
        ulong m00, ulong m01,
        ulong m10, ulong m11,
        ulong m20, ulong m21,
        ulong m30, ulong m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x2((
        ulong m00, ulong m01,
        ulong m10, ulong m11,
        ulong m20, ulong m21,
        ulong m30, ulong m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x2((
        ulong m00, ulong m01,
        ulong m10, ulong m11,
        ulong m20, ulong m21,
        ulong m30, ulong m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x2((
        (ulong m00, ulong m01) r0,
        (ulong m10, ulong m11) r1,
        (ulong m20, ulong m21) r2,
        (ulong m30, ulong m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x2((
        (ulong m00, ulong m01) r0,
        (ulong m10, ulong m11) r1,
        (ulong m20, ulong m21) r2,
        (ulong m30, ulong m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x2(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong4x2(ulong value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x2(ulong4 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong4x2(ulong4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out ulong4 c0, out ulong4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out ulong m00, out ulong m01,
        out ulong m10, out ulong m11,
        out ulong m20, out ulong m21,
        out ulong m30, out ulong m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // deconstruct

    #region index

    public ulong4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // ulong4x2

#region ulong4x3

[Serializable]
[JsonConverter(typeof(ulong4x3JsonConverter))]
public partial struct ulong4x3 :
    IMatrix4x3<ulong>, IMatrixSelf<ulong4x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static ulong4x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ulong4x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1UL); 
    }

    public static ulong4x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default, default,
            default, 1UL, default,
            default, default, 1UL,
            default, default, default
        ); 
    }

    #endregion

    #region fields
    public ulong4 c0;
    public ulong4 c1;
    public ulong4 c2;

    #endregion

    #region getter

    public ulong m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ulong m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public ulong m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ulong m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public ulong m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public ulong m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public ulong m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public ulong m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public ulong4x3(ulong4 c0, ulong4 c1, ulong4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public ulong4x3((ulong4 c0, ulong4 c1, ulong4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x3((ulong4 c0, ulong4 c1, ulong4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x3(
        ulong m00, ulong m01, ulong m02,
        ulong m10, ulong m11, ulong m12,
        ulong m20, ulong m21, ulong m22,
        ulong m30, ulong m31, ulong m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x3((
        ulong m00, ulong m01, ulong m02,
        ulong m10, ulong m11, ulong m12,
        ulong m20, ulong m21, ulong m22,
        ulong m30, ulong m31, ulong m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x3((
        ulong m00, ulong m01, ulong m02,
        ulong m10, ulong m11, ulong m12,
        ulong m20, ulong m21, ulong m22,
        ulong m30, ulong m31, ulong m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x3((
        (ulong m00, ulong m01, ulong m02) r0,
        (ulong m10, ulong m11, ulong m12) r1,
        (ulong m20, ulong m21, ulong m22) r2,
        (ulong m30, ulong m31, ulong m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x3((
        (ulong m00, ulong m01, ulong m02) r0,
        (ulong m10, ulong m11, ulong m12) r1,
        (ulong m20, ulong m21, ulong m22) r2,
        (ulong m30, ulong m31, ulong m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x3(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong4x3(ulong value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x3(ulong4 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong4x3(ulong4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out ulong4 c0, out ulong4 c1, out ulong4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out ulong m00, out ulong m01, out ulong m02,
        out ulong m10, out ulong m11, out ulong m12,
        out ulong m20, out ulong m21, out ulong m22,
        out ulong m30, out ulong m31, out ulong m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // deconstruct

    #region index

    public ulong4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // ulong4x3

#region ulong4x4

[Serializable]
[JsonConverter(typeof(ulong4x4JsonConverter))]
public partial struct ulong4x4 :
    IMatrix4x4<ulong>, IMatrixSelf<ulong4x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static ulong4x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ulong4x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1UL); 
    }

    public static ulong4x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default, default, default,
            default, 1UL, default, default,
            default, default, 1UL, default,
            default, default, default, 1UL
        ); 
    }

    #endregion

    #region fields
    public ulong4 c0;
    public ulong4 c1;
    public ulong4 c2;
    public ulong4 c3;

    #endregion

    #region getter

    public ulong m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ulong m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public ulong m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public ulong m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public ulong m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ulong m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public ulong m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public ulong m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public ulong m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public ulong m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public ulong m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public ulong m33
    {
        [MethodImpl(256 | 512)]
        get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public ulong4x4(ulong4 c0, ulong4 c1, ulong4 c2, ulong4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public ulong4x4((ulong4 c0, ulong4 c1, ulong4 c2, ulong4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x4((ulong4 c0, ulong4 c1, ulong4 c2, ulong4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x4(
        ulong m00, ulong m01, ulong m02, ulong m03,
        ulong m10, ulong m11, ulong m12, ulong m13,
        ulong m20, ulong m21, ulong m22, ulong m23,
        ulong m30, ulong m31, ulong m32, ulong m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x4((
        ulong m00, ulong m01, ulong m02, ulong m03,
        ulong m10, ulong m11, ulong m12, ulong m13,
        ulong m20, ulong m21, ulong m22, ulong m23,
        ulong m30, ulong m31, ulong m32, ulong m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x4((
        ulong m00, ulong m01, ulong m02, ulong m03,
        ulong m10, ulong m11, ulong m12, ulong m13,
        ulong m20, ulong m21, ulong m22, ulong m23,
        ulong m30, ulong m31, ulong m32, ulong m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x4((
        (ulong m00, ulong m01, ulong m02, ulong m03) r0,
        (ulong m10, ulong m11, ulong m12, ulong m13) r1,
        (ulong m20, ulong m21, ulong m22, ulong m23) r2,
        (ulong m30, ulong m31, ulong m32, ulong m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x4((
        (ulong m00, ulong m01, ulong m02, ulong m03) r0,
        (ulong m10, ulong m11, ulong m12, ulong m13) r1,
        (ulong m20, ulong m21, ulong m22, ulong m23) r2,
        (ulong m30, ulong m31, ulong m32, ulong m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x4(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong4x4(ulong value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x4(ulong4 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong4x4(ulong4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out ulong4 c0, out ulong4 c1, out ulong4 c2, out ulong4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out ulong m00, out ulong m01, out ulong m02, out ulong m03,
        out ulong m10, out ulong m11, out ulong m12, out ulong m13,
        out ulong m20, out ulong m21, out ulong m22, out ulong m23,
        out ulong m30, out ulong m31, out ulong m32, out ulong m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // deconstruct

    #region index

    public ulong4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // ulong4x4

#region decimal2x2

[Serializable]
[JsonConverter(typeof(decimal2x2JsonConverter))]
public partial struct decimal2x2 :
    IMatrix2x2<decimal>, IMatrixSelf<decimal2x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static decimal2x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static decimal2x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1m); 
    }

    public static decimal2x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1m, default,
            default, 1m
        ); 
    }

    #endregion

    #region fields
    public decimal2 c0;
    public decimal2 c1;

    #endregion

    #region getter

    public decimal m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public decimal m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public decimal m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public decimal m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public decimal2x2(decimal2 c0, decimal2 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public decimal2x2((decimal2 c0, decimal2 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal2x2((decimal2 c0, decimal2 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public decimal2x2(
        decimal m00, decimal m01,
        decimal m10, decimal m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal2x2((
        decimal m00, decimal m01,
        decimal m10, decimal m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public decimal2x2((
        decimal m00, decimal m01,
        decimal m10, decimal m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal2x2((
        (decimal m00, decimal m01) r0,
        (decimal m10, decimal m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public decimal2x2((
        (decimal m00, decimal m01) r0,
        (decimal m10, decimal m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal2x2(decimal value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal2x2(decimal value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal2x2(decimal2 value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal2x2(decimal2 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out decimal2 c0, out decimal2 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out decimal m00, out decimal m01,
        out decimal m10, out decimal m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // deconstruct

    #region index

    public decimal2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public decimal this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // decimal2x2

#region decimal2x3

[Serializable]
[JsonConverter(typeof(decimal2x3JsonConverter))]
public partial struct decimal2x3 :
    IMatrix2x3<decimal>, IMatrixSelf<decimal2x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static decimal2x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static decimal2x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1m); 
    }

    public static decimal2x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1m, default, default,
            default, 1m, default
        ); 
    }

    #endregion

    #region fields
    public decimal2 c0;
    public decimal2 c1;
    public decimal2 c2;

    #endregion

    #region getter

    public decimal m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public decimal m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public decimal m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public decimal m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public decimal m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public decimal m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public decimal2x3(decimal2 c0, decimal2 c1, decimal2 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public decimal2x3((decimal2 c0, decimal2 c1, decimal2 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal2x3((decimal2 c0, decimal2 c1, decimal2 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public decimal2x3(
        decimal m00, decimal m01, decimal m02,
        decimal m10, decimal m11, decimal m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal2x3((
        decimal m00, decimal m01, decimal m02,
        decimal m10, decimal m11, decimal m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public decimal2x3((
        decimal m00, decimal m01, decimal m02,
        decimal m10, decimal m11, decimal m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal2x3((
        (decimal m00, decimal m01, decimal m02) r0,
        (decimal m10, decimal m11, decimal m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public decimal2x3((
        (decimal m00, decimal m01, decimal m02) r0,
        (decimal m10, decimal m11, decimal m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal2x3(decimal value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal2x3(decimal value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal2x3(decimal2 value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal2x3(decimal2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out decimal2 c0, out decimal2 c1, out decimal2 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out decimal m00, out decimal m01, out decimal m02,
        out decimal m10, out decimal m11, out decimal m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // deconstruct

    #region index

    public decimal2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public decimal this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // decimal2x3

#region decimal2x4

[Serializable]
[JsonConverter(typeof(decimal2x4JsonConverter))]
public partial struct decimal2x4 :
    IMatrix2x4<decimal>, IMatrixSelf<decimal2x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static decimal2x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static decimal2x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1m); 
    }

    public static decimal2x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1m, default, default, default,
            default, 1m, default, default
        ); 
    }

    #endregion

    #region fields
    public decimal2 c0;
    public decimal2 c1;
    public decimal2 c2;
    public decimal2 c3;

    #endregion

    #region getter

    public decimal m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public decimal m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public decimal m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public decimal m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public decimal m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public decimal m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public decimal m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public decimal m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public decimal2x4(decimal2 c0, decimal2 c1, decimal2 c2, decimal2 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public decimal2x4((decimal2 c0, decimal2 c1, decimal2 c2, decimal2 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal2x4((decimal2 c0, decimal2 c1, decimal2 c2, decimal2 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public decimal2x4(
        decimal m00, decimal m01, decimal m02, decimal m03,
        decimal m10, decimal m11, decimal m12, decimal m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal2x4((
        decimal m00, decimal m01, decimal m02, decimal m03,
        decimal m10, decimal m11, decimal m12, decimal m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public decimal2x4((
        decimal m00, decimal m01, decimal m02, decimal m03,
        decimal m10, decimal m11, decimal m12, decimal m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal2x4((
        (decimal m00, decimal m01, decimal m02, decimal m03) r0,
        (decimal m10, decimal m11, decimal m12, decimal m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public decimal2x4((
        (decimal m00, decimal m01, decimal m02, decimal m03) r0,
        (decimal m10, decimal m11, decimal m12, decimal m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal2x4(decimal value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal2x4(decimal value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal2x4(decimal2 value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal2x4(decimal2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out decimal2 c0, out decimal2 c1, out decimal2 c2, out decimal2 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out decimal m00, out decimal m01, out decimal m02, out decimal m03,
        out decimal m10, out decimal m11, out decimal m12, out decimal m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // deconstruct

    #region index

    public decimal2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public decimal this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // decimal2x4

#region decimal3x2

[Serializable]
[JsonConverter(typeof(decimal3x2JsonConverter))]
public partial struct decimal3x2 :
    IMatrix3x2<decimal>, IMatrixSelf<decimal3x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static decimal3x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static decimal3x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1m); 
    }

    public static decimal3x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1m, default,
            default, 1m,
            default, default
        ); 
    }

    #endregion

    #region fields
    public decimal3 c0;
    public decimal3 c1;

    #endregion

    #region getter

    public decimal m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public decimal m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public decimal m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public decimal m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public decimal m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public decimal m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public decimal3x2(decimal3 c0, decimal3 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public decimal3x2((decimal3 c0, decimal3 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal3x2((decimal3 c0, decimal3 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public decimal3x2(
        decimal m00, decimal m01,
        decimal m10, decimal m11,
        decimal m20, decimal m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal3x2((
        decimal m00, decimal m01,
        decimal m10, decimal m11,
        decimal m20, decimal m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public decimal3x2((
        decimal m00, decimal m01,
        decimal m10, decimal m11,
        decimal m20, decimal m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal3x2((
        (decimal m00, decimal m01) r0,
        (decimal m10, decimal m11) r1,
        (decimal m20, decimal m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public decimal3x2((
        (decimal m00, decimal m01) r0,
        (decimal m10, decimal m11) r1,
        (decimal m20, decimal m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal3x2(decimal value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal3x2(decimal value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal3x2(decimal3 value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal3x2(decimal3 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out decimal3 c0, out decimal3 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out decimal m00, out decimal m01,
        out decimal m10, out decimal m11,
        out decimal m20, out decimal m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // deconstruct

    #region index

    public decimal3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public decimal this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // decimal3x2

#region decimal3x3

[Serializable]
[JsonConverter(typeof(decimal3x3JsonConverter))]
public partial struct decimal3x3 :
    IMatrix3x3<decimal>, IMatrixSelf<decimal3x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static decimal3x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static decimal3x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1m); 
    }

    public static decimal3x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1m, default, default,
            default, 1m, default,
            default, default, 1m
        ); 
    }

    #endregion

    #region fields
    public decimal3 c0;
    public decimal3 c1;
    public decimal3 c2;

    #endregion

    #region getter

    public decimal m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public decimal m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public decimal m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public decimal m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public decimal m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public decimal m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public decimal m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public decimal m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public decimal m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public decimal3x3(decimal3 c0, decimal3 c1, decimal3 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public decimal3x3((decimal3 c0, decimal3 c1, decimal3 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal3x3((decimal3 c0, decimal3 c1, decimal3 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public decimal3x3(
        decimal m00, decimal m01, decimal m02,
        decimal m10, decimal m11, decimal m12,
        decimal m20, decimal m21, decimal m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal3x3((
        decimal m00, decimal m01, decimal m02,
        decimal m10, decimal m11, decimal m12,
        decimal m20, decimal m21, decimal m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public decimal3x3((
        decimal m00, decimal m01, decimal m02,
        decimal m10, decimal m11, decimal m12,
        decimal m20, decimal m21, decimal m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal3x3((
        (decimal m00, decimal m01, decimal m02) r0,
        (decimal m10, decimal m11, decimal m12) r1,
        (decimal m20, decimal m21, decimal m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public decimal3x3((
        (decimal m00, decimal m01, decimal m02) r0,
        (decimal m10, decimal m11, decimal m12) r1,
        (decimal m20, decimal m21, decimal m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal3x3(decimal value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal3x3(decimal value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal3x3(decimal3 value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal3x3(decimal3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out decimal3 c0, out decimal3 c1, out decimal3 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out decimal m00, out decimal m01, out decimal m02,
        out decimal m10, out decimal m11, out decimal m12,
        out decimal m20, out decimal m21, out decimal m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // deconstruct

    #region index

    public decimal3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public decimal this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // decimal3x3

#region decimal3x4

[Serializable]
[JsonConverter(typeof(decimal3x4JsonConverter))]
public partial struct decimal3x4 :
    IMatrix3x4<decimal>, IMatrixSelf<decimal3x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static decimal3x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static decimal3x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1m); 
    }

    public static decimal3x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1m, default, default, default,
            default, 1m, default, default,
            default, default, 1m, default
        ); 
    }

    #endregion

    #region fields
    public decimal3 c0;
    public decimal3 c1;
    public decimal3 c2;
    public decimal3 c3;

    #endregion

    #region getter

    public decimal m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public decimal m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public decimal m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public decimal m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public decimal m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public decimal m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public decimal m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public decimal m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public decimal m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public decimal m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public decimal m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public decimal m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public decimal3x4(decimal3 c0, decimal3 c1, decimal3 c2, decimal3 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public decimal3x4((decimal3 c0, decimal3 c1, decimal3 c2, decimal3 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal3x4((decimal3 c0, decimal3 c1, decimal3 c2, decimal3 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public decimal3x4(
        decimal m00, decimal m01, decimal m02, decimal m03,
        decimal m10, decimal m11, decimal m12, decimal m13,
        decimal m20, decimal m21, decimal m22, decimal m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal3x4((
        decimal m00, decimal m01, decimal m02, decimal m03,
        decimal m10, decimal m11, decimal m12, decimal m13,
        decimal m20, decimal m21, decimal m22, decimal m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public decimal3x4((
        decimal m00, decimal m01, decimal m02, decimal m03,
        decimal m10, decimal m11, decimal m12, decimal m13,
        decimal m20, decimal m21, decimal m22, decimal m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal3x4((
        (decimal m00, decimal m01, decimal m02, decimal m03) r0,
        (decimal m10, decimal m11, decimal m12, decimal m13) r1,
        (decimal m20, decimal m21, decimal m22, decimal m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public decimal3x4((
        (decimal m00, decimal m01, decimal m02, decimal m03) r0,
        (decimal m10, decimal m11, decimal m12, decimal m13) r1,
        (decimal m20, decimal m21, decimal m22, decimal m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal3x4(decimal value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal3x4(decimal value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal3x4(decimal3 value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal3x4(decimal3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out decimal3 c0, out decimal3 c1, out decimal3 c2, out decimal3 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out decimal m00, out decimal m01, out decimal m02, out decimal m03,
        out decimal m10, out decimal m11, out decimal m12, out decimal m13,
        out decimal m20, out decimal m21, out decimal m22, out decimal m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // deconstruct

    #region index

    public decimal3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public decimal this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // decimal3x4

#region decimal4x2

[Serializable]
[JsonConverter(typeof(decimal4x2JsonConverter))]
public partial struct decimal4x2 :
    IMatrix4x2<decimal>, IMatrixSelf<decimal4x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static decimal4x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static decimal4x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1m); 
    }

    public static decimal4x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1m, default,
            default, 1m,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region fields
    public decimal4 c0;
    public decimal4 c1;

    #endregion

    #region getter

    public decimal m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public decimal m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public decimal m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public decimal m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public decimal m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public decimal m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public decimal m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public decimal m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public decimal4x2(decimal4 c0, decimal4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public decimal4x2((decimal4 c0, decimal4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal4x2((decimal4 c0, decimal4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public decimal4x2(
        decimal m00, decimal m01,
        decimal m10, decimal m11,
        decimal m20, decimal m21,
        decimal m30, decimal m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal4x2((
        decimal m00, decimal m01,
        decimal m10, decimal m11,
        decimal m20, decimal m21,
        decimal m30, decimal m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public decimal4x2((
        decimal m00, decimal m01,
        decimal m10, decimal m11,
        decimal m20, decimal m21,
        decimal m30, decimal m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal4x2((
        (decimal m00, decimal m01) r0,
        (decimal m10, decimal m11) r1,
        (decimal m20, decimal m21) r2,
        (decimal m30, decimal m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public decimal4x2((
        (decimal m00, decimal m01) r0,
        (decimal m10, decimal m11) r1,
        (decimal m20, decimal m21) r2,
        (decimal m30, decimal m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal4x2(decimal value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal4x2(decimal value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal4x2(decimal4 value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal4x2(decimal4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out decimal4 c0, out decimal4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out decimal m00, out decimal m01,
        out decimal m10, out decimal m11,
        out decimal m20, out decimal m21,
        out decimal m30, out decimal m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // deconstruct

    #region index

    public decimal4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public decimal this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // decimal4x2

#region decimal4x3

[Serializable]
[JsonConverter(typeof(decimal4x3JsonConverter))]
public partial struct decimal4x3 :
    IMatrix4x3<decimal>, IMatrixSelf<decimal4x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static decimal4x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static decimal4x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1m); 
    }

    public static decimal4x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1m, default, default,
            default, 1m, default,
            default, default, 1m,
            default, default, default
        ); 
    }

    #endregion

    #region fields
    public decimal4 c0;
    public decimal4 c1;
    public decimal4 c2;

    #endregion

    #region getter

    public decimal m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public decimal m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public decimal m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public decimal m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public decimal m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public decimal m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public decimal m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public decimal m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public decimal m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public decimal m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public decimal m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public decimal m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public decimal4x3(decimal4 c0, decimal4 c1, decimal4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public decimal4x3((decimal4 c0, decimal4 c1, decimal4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal4x3((decimal4 c0, decimal4 c1, decimal4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public decimal4x3(
        decimal m00, decimal m01, decimal m02,
        decimal m10, decimal m11, decimal m12,
        decimal m20, decimal m21, decimal m22,
        decimal m30, decimal m31, decimal m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal4x3((
        decimal m00, decimal m01, decimal m02,
        decimal m10, decimal m11, decimal m12,
        decimal m20, decimal m21, decimal m22,
        decimal m30, decimal m31, decimal m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public decimal4x3((
        decimal m00, decimal m01, decimal m02,
        decimal m10, decimal m11, decimal m12,
        decimal m20, decimal m21, decimal m22,
        decimal m30, decimal m31, decimal m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal4x3((
        (decimal m00, decimal m01, decimal m02) r0,
        (decimal m10, decimal m11, decimal m12) r1,
        (decimal m20, decimal m21, decimal m22) r2,
        (decimal m30, decimal m31, decimal m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public decimal4x3((
        (decimal m00, decimal m01, decimal m02) r0,
        (decimal m10, decimal m11, decimal m12) r1,
        (decimal m20, decimal m21, decimal m22) r2,
        (decimal m30, decimal m31, decimal m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal4x3(decimal value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal4x3(decimal value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal4x3(decimal4 value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal4x3(decimal4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out decimal4 c0, out decimal4 c1, out decimal4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out decimal m00, out decimal m01, out decimal m02,
        out decimal m10, out decimal m11, out decimal m12,
        out decimal m20, out decimal m21, out decimal m22,
        out decimal m30, out decimal m31, out decimal m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // deconstruct

    #region index

    public decimal4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public decimal this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // decimal4x3

#region decimal4x4

[Serializable]
[JsonConverter(typeof(decimal4x4JsonConverter))]
public partial struct decimal4x4 :
    IMatrix4x4<decimal>, IMatrixSelf<decimal4x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static decimal4x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static decimal4x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1m); 
    }

    public static decimal4x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1m, default, default, default,
            default, 1m, default, default,
            default, default, 1m, default,
            default, default, default, 1m
        ); 
    }

    #endregion

    #region fields
    public decimal4 c0;
    public decimal4 c1;
    public decimal4 c2;
    public decimal4 c3;

    #endregion

    #region getter

    public decimal m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public decimal m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public decimal m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public decimal m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public decimal m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public decimal m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public decimal m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public decimal m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public decimal m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public decimal m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public decimal m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public decimal m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public decimal m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public decimal m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public decimal m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public decimal m33
    {
        [MethodImpl(256 | 512)]
        get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public decimal4x4(decimal4 c0, decimal4 c1, decimal4 c2, decimal4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public decimal4x4((decimal4 c0, decimal4 c1, decimal4 c2, decimal4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal4x4((decimal4 c0, decimal4 c1, decimal4 c2, decimal4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public decimal4x4(
        decimal m00, decimal m01, decimal m02, decimal m03,
        decimal m10, decimal m11, decimal m12, decimal m13,
        decimal m20, decimal m21, decimal m22, decimal m23,
        decimal m30, decimal m31, decimal m32, decimal m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal4x4((
        decimal m00, decimal m01, decimal m02, decimal m03,
        decimal m10, decimal m11, decimal m12, decimal m13,
        decimal m20, decimal m21, decimal m22, decimal m23,
        decimal m30, decimal m31, decimal m32, decimal m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public decimal4x4((
        decimal m00, decimal m01, decimal m02, decimal m03,
        decimal m10, decimal m11, decimal m12, decimal m13,
        decimal m20, decimal m21, decimal m22, decimal m23,
        decimal m30, decimal m31, decimal m32, decimal m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal4x4((
        (decimal m00, decimal m01, decimal m02, decimal m03) r0,
        (decimal m10, decimal m11, decimal m12, decimal m13) r1,
        (decimal m20, decimal m21, decimal m22, decimal m23) r2,
        (decimal m30, decimal m31, decimal m32, decimal m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public decimal4x4((
        (decimal m00, decimal m01, decimal m02, decimal m03) r0,
        (decimal m10, decimal m11, decimal m12, decimal m13) r1,
        (decimal m20, decimal m21, decimal m22, decimal m23) r2,
        (decimal m30, decimal m31, decimal m32, decimal m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal4x4(decimal value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal4x4(decimal value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal4x4(decimal4 value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal4x4(decimal4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out decimal4 c0, out decimal4 c1, out decimal4 c2, out decimal4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out decimal m00, out decimal m01, out decimal m02, out decimal m03,
        out decimal m10, out decimal m11, out decimal m12, out decimal m13,
        out decimal m20, out decimal m21, out decimal m22, out decimal m23,
        out decimal m30, out decimal m31, out decimal m32, out decimal m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // deconstruct

    #region index

    public decimal4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public decimal this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // decimal4x4

#region half2x2

[Serializable]
[JsonConverter(typeof(half2x2JsonConverter))]
public partial struct half2x2 :
    IMatrix2x2<half>, IMatrixSelf<half2x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static half2x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static half2x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new((half)1.0); 
    }

    public static half2x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (half)1.0, default,
            default, (half)1.0
        ); 
    }

    #endregion

    #region fields
    public half2 c0;
    public half2 c1;

    #endregion

    #region getter

    public half m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public half m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public half m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public half m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public half2x2(half2 c0, half2 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public half2x2((half2 c0, half2 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half2x2((half2 c0, half2 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public half2x2(
        half m00, half m01,
        half m10, half m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half2x2((
        half m00, half m01,
        half m10, half m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public half2x2((
        half m00, half m01,
        half m10, half m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half2x2((
        (half m00, half m01) r0,
        (half m10, half m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public half2x2((
        (half m00, half m01) r0,
        (half m10, half m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half2x2(half value) => new(value);

    [MethodImpl(256 | 512)]
    public half2x2(half value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half2x2(half2 value) => new(value);

    [MethodImpl(256 | 512)]
    public half2x2(half2 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out half2 c0, out half2 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out half m00, out half m01,
        out half m10, out half m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // deconstruct

    #region index

    public half2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public half this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // half2x2

#region half2x3

[Serializable]
[JsonConverter(typeof(half2x3JsonConverter))]
public partial struct half2x3 :
    IMatrix2x3<half>, IMatrixSelf<half2x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static half2x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static half2x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new((half)1.0); 
    }

    public static half2x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (half)1.0, default, default,
            default, (half)1.0, default
        ); 
    }

    #endregion

    #region fields
    public half2 c0;
    public half2 c1;
    public half2 c2;

    #endregion

    #region getter

    public half m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public half m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public half m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public half m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public half m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public half m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public half2x3(half2 c0, half2 c1, half2 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public half2x3((half2 c0, half2 c1, half2 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half2x3((half2 c0, half2 c1, half2 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public half2x3(
        half m00, half m01, half m02,
        half m10, half m11, half m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half2x3((
        half m00, half m01, half m02,
        half m10, half m11, half m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public half2x3((
        half m00, half m01, half m02,
        half m10, half m11, half m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half2x3((
        (half m00, half m01, half m02) r0,
        (half m10, half m11, half m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public half2x3((
        (half m00, half m01, half m02) r0,
        (half m10, half m11, half m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half2x3(half value) => new(value);

    [MethodImpl(256 | 512)]
    public half2x3(half value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half2x3(half2 value) => new(value);

    [MethodImpl(256 | 512)]
    public half2x3(half2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out half2 c0, out half2 c1, out half2 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out half m00, out half m01, out half m02,
        out half m10, out half m11, out half m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // deconstruct

    #region index

    public half2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public half this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // half2x3

#region half2x4

[Serializable]
[JsonConverter(typeof(half2x4JsonConverter))]
public partial struct half2x4 :
    IMatrix2x4<half>, IMatrixSelf<half2x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static half2x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static half2x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new((half)1.0); 
    }

    public static half2x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (half)1.0, default, default, default,
            default, (half)1.0, default, default
        ); 
    }

    #endregion

    #region fields
    public half2 c0;
    public half2 c1;
    public half2 c2;
    public half2 c3;

    #endregion

    #region getter

    public half m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public half m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public half m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public half m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public half m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public half m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public half m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public half m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public half2x4(half2 c0, half2 c1, half2 c2, half2 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public half2x4((half2 c0, half2 c1, half2 c2, half2 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half2x4((half2 c0, half2 c1, half2 c2, half2 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public half2x4(
        half m00, half m01, half m02, half m03,
        half m10, half m11, half m12, half m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half2x4((
        half m00, half m01, half m02, half m03,
        half m10, half m11, half m12, half m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public half2x4((
        half m00, half m01, half m02, half m03,
        half m10, half m11, half m12, half m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half2x4((
        (half m00, half m01, half m02, half m03) r0,
        (half m10, half m11, half m12, half m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public half2x4((
        (half m00, half m01, half m02, half m03) r0,
        (half m10, half m11, half m12, half m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half2x4(half value) => new(value);

    [MethodImpl(256 | 512)]
    public half2x4(half value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half2x4(half2 value) => new(value);

    [MethodImpl(256 | 512)]
    public half2x4(half2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out half2 c0, out half2 c1, out half2 c2, out half2 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out half m00, out half m01, out half m02, out half m03,
        out half m10, out half m11, out half m12, out half m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // deconstruct

    #region index

    public half2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public half this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // half2x4

#region half3x2

[Serializable]
[JsonConverter(typeof(half3x2JsonConverter))]
public partial struct half3x2 :
    IMatrix3x2<half>, IMatrixSelf<half3x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static half3x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static half3x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new((half)1.0); 
    }

    public static half3x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (half)1.0, default,
            default, (half)1.0,
            default, default
        ); 
    }

    #endregion

    #region fields
    public half3 c0;
    public half3 c1;

    #endregion

    #region getter

    public half m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public half m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public half m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public half m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public half m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public half m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public half3x2(half3 c0, half3 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public half3x2((half3 c0, half3 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half3x2((half3 c0, half3 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public half3x2(
        half m00, half m01,
        half m10, half m11,
        half m20, half m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half3x2((
        half m00, half m01,
        half m10, half m11,
        half m20, half m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public half3x2((
        half m00, half m01,
        half m10, half m11,
        half m20, half m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half3x2((
        (half m00, half m01) r0,
        (half m10, half m11) r1,
        (half m20, half m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public half3x2((
        (half m00, half m01) r0,
        (half m10, half m11) r1,
        (half m20, half m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half3x2(half value) => new(value);

    [MethodImpl(256 | 512)]
    public half3x2(half value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half3x2(half3 value) => new(value);

    [MethodImpl(256 | 512)]
    public half3x2(half3 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out half3 c0, out half3 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out half m00, out half m01,
        out half m10, out half m11,
        out half m20, out half m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // deconstruct

    #region index

    public half3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public half this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // half3x2

#region half3x3

[Serializable]
[JsonConverter(typeof(half3x3JsonConverter))]
public partial struct half3x3 :
    IMatrix3x3<half>, IMatrixSelf<half3x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static half3x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static half3x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new((half)1.0); 
    }

    public static half3x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (half)1.0, default, default,
            default, (half)1.0, default,
            default, default, (half)1.0
        ); 
    }

    #endregion

    #region fields
    public half3 c0;
    public half3 c1;
    public half3 c2;

    #endregion

    #region getter

    public half m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public half m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public half m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public half m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public half m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public half m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public half m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public half m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public half m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public half3x3(half3 c0, half3 c1, half3 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public half3x3((half3 c0, half3 c1, half3 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half3x3((half3 c0, half3 c1, half3 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public half3x3(
        half m00, half m01, half m02,
        half m10, half m11, half m12,
        half m20, half m21, half m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half3x3((
        half m00, half m01, half m02,
        half m10, half m11, half m12,
        half m20, half m21, half m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public half3x3((
        half m00, half m01, half m02,
        half m10, half m11, half m12,
        half m20, half m21, half m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half3x3((
        (half m00, half m01, half m02) r0,
        (half m10, half m11, half m12) r1,
        (half m20, half m21, half m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public half3x3((
        (half m00, half m01, half m02) r0,
        (half m10, half m11, half m12) r1,
        (half m20, half m21, half m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half3x3(half value) => new(value);

    [MethodImpl(256 | 512)]
    public half3x3(half value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half3x3(half3 value) => new(value);

    [MethodImpl(256 | 512)]
    public half3x3(half3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out half3 c0, out half3 c1, out half3 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out half m00, out half m01, out half m02,
        out half m10, out half m11, out half m12,
        out half m20, out half m21, out half m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // deconstruct

    #region index

    public half3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public half this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // half3x3

#region half3x4

[Serializable]
[JsonConverter(typeof(half3x4JsonConverter))]
public partial struct half3x4 :
    IMatrix3x4<half>, IMatrixSelf<half3x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static half3x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static half3x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new((half)1.0); 
    }

    public static half3x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (half)1.0, default, default, default,
            default, (half)1.0, default, default,
            default, default, (half)1.0, default
        ); 
    }

    #endregion

    #region fields
    public half3 c0;
    public half3 c1;
    public half3 c2;
    public half3 c3;

    #endregion

    #region getter

    public half m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public half m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public half m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public half m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public half m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public half m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public half m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public half m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public half m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public half m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public half m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public half m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public half3x4(half3 c0, half3 c1, half3 c2, half3 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public half3x4((half3 c0, half3 c1, half3 c2, half3 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half3x4((half3 c0, half3 c1, half3 c2, half3 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public half3x4(
        half m00, half m01, half m02, half m03,
        half m10, half m11, half m12, half m13,
        half m20, half m21, half m22, half m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half3x4((
        half m00, half m01, half m02, half m03,
        half m10, half m11, half m12, half m13,
        half m20, half m21, half m22, half m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public half3x4((
        half m00, half m01, half m02, half m03,
        half m10, half m11, half m12, half m13,
        half m20, half m21, half m22, half m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half3x4((
        (half m00, half m01, half m02, half m03) r0,
        (half m10, half m11, half m12, half m13) r1,
        (half m20, half m21, half m22, half m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public half3x4((
        (half m00, half m01, half m02, half m03) r0,
        (half m10, half m11, half m12, half m13) r1,
        (half m20, half m21, half m22, half m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half3x4(half value) => new(value);

    [MethodImpl(256 | 512)]
    public half3x4(half value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half3x4(half3 value) => new(value);

    [MethodImpl(256 | 512)]
    public half3x4(half3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out half3 c0, out half3 c1, out half3 c2, out half3 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out half m00, out half m01, out half m02, out half m03,
        out half m10, out half m11, out half m12, out half m13,
        out half m20, out half m21, out half m22, out half m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // deconstruct

    #region index

    public half3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public half this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // half3x4

#region half4x2

[Serializable]
[JsonConverter(typeof(half4x2JsonConverter))]
public partial struct half4x2 :
    IMatrix4x2<half>, IMatrixSelf<half4x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static half4x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static half4x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new((half)1.0); 
    }

    public static half4x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (half)1.0, default,
            default, (half)1.0,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region fields
    public half4 c0;
    public half4 c1;

    #endregion

    #region getter

    public half m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public half m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public half m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public half m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public half m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public half m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public half m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public half m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public half4x2(half4 c0, half4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public half4x2((half4 c0, half4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half4x2((half4 c0, half4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public half4x2(
        half m00, half m01,
        half m10, half m11,
        half m20, half m21,
        half m30, half m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half4x2((
        half m00, half m01,
        half m10, half m11,
        half m20, half m21,
        half m30, half m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public half4x2((
        half m00, half m01,
        half m10, half m11,
        half m20, half m21,
        half m30, half m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half4x2((
        (half m00, half m01) r0,
        (half m10, half m11) r1,
        (half m20, half m21) r2,
        (half m30, half m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public half4x2((
        (half m00, half m01) r0,
        (half m10, half m11) r1,
        (half m20, half m21) r2,
        (half m30, half m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half4x2(half value) => new(value);

    [MethodImpl(256 | 512)]
    public half4x2(half value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half4x2(half4 value) => new(value);

    [MethodImpl(256 | 512)]
    public half4x2(half4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out half4 c0, out half4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out half m00, out half m01,
        out half m10, out half m11,
        out half m20, out half m21,
        out half m30, out half m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // deconstruct

    #region index

    public half4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public half this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // half4x2

#region half4x3

[Serializable]
[JsonConverter(typeof(half4x3JsonConverter))]
public partial struct half4x3 :
    IMatrix4x3<half>, IMatrixSelf<half4x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static half4x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static half4x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new((half)1.0); 
    }

    public static half4x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (half)1.0, default, default,
            default, (half)1.0, default,
            default, default, (half)1.0,
            default, default, default
        ); 
    }

    #endregion

    #region fields
    public half4 c0;
    public half4 c1;
    public half4 c2;

    #endregion

    #region getter

    public half m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public half m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public half m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public half m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public half m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public half m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public half m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public half m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public half m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public half m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public half m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public half m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public half4x3(half4 c0, half4 c1, half4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public half4x3((half4 c0, half4 c1, half4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half4x3((half4 c0, half4 c1, half4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public half4x3(
        half m00, half m01, half m02,
        half m10, half m11, half m12,
        half m20, half m21, half m22,
        half m30, half m31, half m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half4x3((
        half m00, half m01, half m02,
        half m10, half m11, half m12,
        half m20, half m21, half m22,
        half m30, half m31, half m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public half4x3((
        half m00, half m01, half m02,
        half m10, half m11, half m12,
        half m20, half m21, half m22,
        half m30, half m31, half m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half4x3((
        (half m00, half m01, half m02) r0,
        (half m10, half m11, half m12) r1,
        (half m20, half m21, half m22) r2,
        (half m30, half m31, half m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public half4x3((
        (half m00, half m01, half m02) r0,
        (half m10, half m11, half m12) r1,
        (half m20, half m21, half m22) r2,
        (half m30, half m31, half m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half4x3(half value) => new(value);

    [MethodImpl(256 | 512)]
    public half4x3(half value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half4x3(half4 value) => new(value);

    [MethodImpl(256 | 512)]
    public half4x3(half4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out half4 c0, out half4 c1, out half4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out half m00, out half m01, out half m02,
        out half m10, out half m11, out half m12,
        out half m20, out half m21, out half m22,
        out half m30, out half m31, out half m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // deconstruct

    #region index

    public half4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public half this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // half4x3

#region half4x4

[Serializable]
[JsonConverter(typeof(half4x4JsonConverter))]
public partial struct half4x4 :
    IMatrix4x4<half>, IMatrixSelf<half4x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static half4x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static half4x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new((half)1.0); 
    }

    public static half4x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (half)1.0, default, default, default,
            default, (half)1.0, default, default,
            default, default, (half)1.0, default,
            default, default, default, (half)1.0
        ); 
    }

    #endregion

    #region fields
    public half4 c0;
    public half4 c1;
    public half4 c2;
    public half4 c3;

    #endregion

    #region getter

    public half m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public half m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public half m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public half m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public half m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public half m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public half m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public half m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public half m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public half m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public half m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public half m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public half m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public half m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public half m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public half m33
    {
        [MethodImpl(256 | 512)]
        get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public half4x4(half4 c0, half4 c1, half4 c2, half4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public half4x4((half4 c0, half4 c1, half4 c2, half4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half4x4((half4 c0, half4 c1, half4 c2, half4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public half4x4(
        half m00, half m01, half m02, half m03,
        half m10, half m11, half m12, half m13,
        half m20, half m21, half m22, half m23,
        half m30, half m31, half m32, half m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half4x4((
        half m00, half m01, half m02, half m03,
        half m10, half m11, half m12, half m13,
        half m20, half m21, half m22, half m23,
        half m30, half m31, half m32, half m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public half4x4((
        half m00, half m01, half m02, half m03,
        half m10, half m11, half m12, half m13,
        half m20, half m21, half m22, half m23,
        half m30, half m31, half m32, half m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half4x4((
        (half m00, half m01, half m02, half m03) r0,
        (half m10, half m11, half m12, half m13) r1,
        (half m20, half m21, half m22, half m23) r2,
        (half m30, half m31, half m32, half m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public half4x4((
        (half m00, half m01, half m02, half m03) r0,
        (half m10, half m11, half m12, half m13) r1,
        (half m20, half m21, half m22, half m23) r2,
        (half m30, half m31, half m32, half m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half4x4(half value) => new(value);

    [MethodImpl(256 | 512)]
    public half4x4(half value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half4x4(half4 value) => new(value);

    [MethodImpl(256 | 512)]
    public half4x4(half4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out half4 c0, out half4 c1, out half4 c2, out half4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out half m00, out half m01, out half m02, out half m03,
        out half m10, out half m11, out half m12, out half m13,
        out half m20, out half m21, out half m22, out half m23,
        out half m30, out half m31, out half m32, out half m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // deconstruct

    #region index

    public half4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public half this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // half4x4

#region b16m2x2

[Serializable]
[JsonConverter(typeof(b16m2x2JsonConverter))]
public partial struct b16m2x2 :
    IMatrix2x2<b16>, IMatrixSelf<b16m2x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static b16m2x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b16m2x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b16m2x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true
        ); 
    }

    #endregion

    #region fields
    public b16v2 c0;
    public b16v2 c1;

    #endregion

    #region getter

    public b16 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b16 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b16 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b16 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b16m2x2(b16v2 c0, b16v2 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b16m2x2((b16v2 c0, b16v2 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m2x2((b16v2 c0, b16v2 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b16m2x2(
        b16 m00, b16 m01,
        b16 m10, b16 m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m2x2((
        b16 m00, b16 m01,
        b16 m10, b16 m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b16m2x2((
        b16 m00, b16 m01,
        b16 m10, b16 m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m2x2((
        (b16 m00, b16 m01) r0,
        (b16 m10, b16 m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b16m2x2((
        (b16 m00, b16 m01) r0,
        (b16 m10, b16 m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m2x2(b16 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m2x2(b16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m2x2(b16v2 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m2x2(b16v2 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out b16v2 c0, out b16v2 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out b16 m00, out b16 m01,
        out b16 m10, out b16 m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // deconstruct

    #region index

    public b16v2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // b16m2x2

#region b16m2x3

[Serializable]
[JsonConverter(typeof(b16m2x3JsonConverter))]
public partial struct b16m2x3 :
    IMatrix2x3<b16>, IMatrixSelf<b16m2x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static b16m2x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b16m2x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b16m2x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default
        ); 
    }

    #endregion

    #region fields
    public b16v2 c0;
    public b16v2 c1;
    public b16v2 c2;

    #endregion

    #region getter

    public b16 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b16 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b16 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b16 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b16 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b16 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b16m2x3(b16v2 c0, b16v2 c1, b16v2 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b16m2x3((b16v2 c0, b16v2 c1, b16v2 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m2x3((b16v2 c0, b16v2 c1, b16v2 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b16m2x3(
        b16 m00, b16 m01, b16 m02,
        b16 m10, b16 m11, b16 m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m2x3((
        b16 m00, b16 m01, b16 m02,
        b16 m10, b16 m11, b16 m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b16m2x3((
        b16 m00, b16 m01, b16 m02,
        b16 m10, b16 m11, b16 m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m2x3((
        (b16 m00, b16 m01, b16 m02) r0,
        (b16 m10, b16 m11, b16 m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b16m2x3((
        (b16 m00, b16 m01, b16 m02) r0,
        (b16 m10, b16 m11, b16 m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m2x3(b16 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m2x3(b16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m2x3(b16v2 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m2x3(b16v2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out b16v2 c0, out b16v2 c1, out b16v2 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out b16 m00, out b16 m01, out b16 m02,
        out b16 m10, out b16 m11, out b16 m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // deconstruct

    #region index

    public b16v2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // b16m2x3

#region b16m2x4

[Serializable]
[JsonConverter(typeof(b16m2x4JsonConverter))]
public partial struct b16m2x4 :
    IMatrix2x4<b16>, IMatrixSelf<b16m2x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static b16m2x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b16m2x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b16m2x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default
        ); 
    }

    #endregion

    #region fields
    public b16v2 c0;
    public b16v2 c1;
    public b16v2 c2;
    public b16v2 c3;

    #endregion

    #region getter

    public b16 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b16 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b16 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b16 m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b16 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b16 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b16 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b16 m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b16m2x4(b16v2 c0, b16v2 c1, b16v2 c2, b16v2 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b16m2x4((b16v2 c0, b16v2 c1, b16v2 c2, b16v2 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m2x4((b16v2 c0, b16v2 c1, b16v2 c2, b16v2 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b16m2x4(
        b16 m00, b16 m01, b16 m02, b16 m03,
        b16 m10, b16 m11, b16 m12, b16 m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m2x4((
        b16 m00, b16 m01, b16 m02, b16 m03,
        b16 m10, b16 m11, b16 m12, b16 m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b16m2x4((
        b16 m00, b16 m01, b16 m02, b16 m03,
        b16 m10, b16 m11, b16 m12, b16 m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m2x4((
        (b16 m00, b16 m01, b16 m02, b16 m03) r0,
        (b16 m10, b16 m11, b16 m12, b16 m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b16m2x4((
        (b16 m00, b16 m01, b16 m02, b16 m03) r0,
        (b16 m10, b16 m11, b16 m12, b16 m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m2x4(b16 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m2x4(b16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m2x4(b16v2 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m2x4(b16v2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out b16v2 c0, out b16v2 c1, out b16v2 c2, out b16v2 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out b16 m00, out b16 m01, out b16 m02, out b16 m03,
        out b16 m10, out b16 m11, out b16 m12, out b16 m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // deconstruct

    #region index

    public b16v2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // b16m2x4

#region b16m3x2

[Serializable]
[JsonConverter(typeof(b16m3x2JsonConverter))]
public partial struct b16m3x2 :
    IMatrix3x2<b16>, IMatrixSelf<b16m3x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static b16m3x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b16m3x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b16m3x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true,
            default, default
        ); 
    }

    #endregion

    #region fields
    public b16v3 c0;
    public b16v3 c1;

    #endregion

    #region getter

    public b16 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b16 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b16 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b16 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b16 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b16 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b16m3x2(b16v3 c0, b16v3 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b16m3x2((b16v3 c0, b16v3 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m3x2((b16v3 c0, b16v3 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b16m3x2(
        b16 m00, b16 m01,
        b16 m10, b16 m11,
        b16 m20, b16 m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m3x2((
        b16 m00, b16 m01,
        b16 m10, b16 m11,
        b16 m20, b16 m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b16m3x2((
        b16 m00, b16 m01,
        b16 m10, b16 m11,
        b16 m20, b16 m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m3x2((
        (b16 m00, b16 m01) r0,
        (b16 m10, b16 m11) r1,
        (b16 m20, b16 m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b16m3x2((
        (b16 m00, b16 m01) r0,
        (b16 m10, b16 m11) r1,
        (b16 m20, b16 m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m3x2(b16 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m3x2(b16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m3x2(b16v3 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m3x2(b16v3 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out b16v3 c0, out b16v3 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out b16 m00, out b16 m01,
        out b16 m10, out b16 m11,
        out b16 m20, out b16 m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // deconstruct

    #region index

    public b16v3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // b16m3x2

#region b16m3x3

[Serializable]
[JsonConverter(typeof(b16m3x3JsonConverter))]
public partial struct b16m3x3 :
    IMatrix3x3<b16>, IMatrixSelf<b16m3x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static b16m3x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b16m3x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b16m3x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default,
            default, default, true
        ); 
    }

    #endregion

    #region fields
    public b16v3 c0;
    public b16v3 c1;
    public b16v3 c2;

    #endregion

    #region getter

    public b16 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b16 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b16 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b16 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b16 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b16 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b16 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b16 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b16 m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b16m3x3(b16v3 c0, b16v3 c1, b16v3 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b16m3x3((b16v3 c0, b16v3 c1, b16v3 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m3x3((b16v3 c0, b16v3 c1, b16v3 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b16m3x3(
        b16 m00, b16 m01, b16 m02,
        b16 m10, b16 m11, b16 m12,
        b16 m20, b16 m21, b16 m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m3x3((
        b16 m00, b16 m01, b16 m02,
        b16 m10, b16 m11, b16 m12,
        b16 m20, b16 m21, b16 m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b16m3x3((
        b16 m00, b16 m01, b16 m02,
        b16 m10, b16 m11, b16 m12,
        b16 m20, b16 m21, b16 m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m3x3((
        (b16 m00, b16 m01, b16 m02) r0,
        (b16 m10, b16 m11, b16 m12) r1,
        (b16 m20, b16 m21, b16 m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b16m3x3((
        (b16 m00, b16 m01, b16 m02) r0,
        (b16 m10, b16 m11, b16 m12) r1,
        (b16 m20, b16 m21, b16 m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m3x3(b16 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m3x3(b16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m3x3(b16v3 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m3x3(b16v3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out b16v3 c0, out b16v3 c1, out b16v3 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out b16 m00, out b16 m01, out b16 m02,
        out b16 m10, out b16 m11, out b16 m12,
        out b16 m20, out b16 m21, out b16 m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // deconstruct

    #region index

    public b16v3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // b16m3x3

#region b16m3x4

[Serializable]
[JsonConverter(typeof(b16m3x4JsonConverter))]
public partial struct b16m3x4 :
    IMatrix3x4<b16>, IMatrixSelf<b16m3x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static b16m3x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b16m3x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b16m3x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default,
            default, default, true, default
        ); 
    }

    #endregion

    #region fields
    public b16v3 c0;
    public b16v3 c1;
    public b16v3 c2;
    public b16v3 c3;

    #endregion

    #region getter

    public b16 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b16 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b16 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b16 m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b16 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b16 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b16 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b16 m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public b16 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b16 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b16 m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b16 m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b16m3x4(b16v3 c0, b16v3 c1, b16v3 c2, b16v3 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b16m3x4((b16v3 c0, b16v3 c1, b16v3 c2, b16v3 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m3x4((b16v3 c0, b16v3 c1, b16v3 c2, b16v3 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b16m3x4(
        b16 m00, b16 m01, b16 m02, b16 m03,
        b16 m10, b16 m11, b16 m12, b16 m13,
        b16 m20, b16 m21, b16 m22, b16 m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m3x4((
        b16 m00, b16 m01, b16 m02, b16 m03,
        b16 m10, b16 m11, b16 m12, b16 m13,
        b16 m20, b16 m21, b16 m22, b16 m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b16m3x4((
        b16 m00, b16 m01, b16 m02, b16 m03,
        b16 m10, b16 m11, b16 m12, b16 m13,
        b16 m20, b16 m21, b16 m22, b16 m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m3x4((
        (b16 m00, b16 m01, b16 m02, b16 m03) r0,
        (b16 m10, b16 m11, b16 m12, b16 m13) r1,
        (b16 m20, b16 m21, b16 m22, b16 m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b16m3x4((
        (b16 m00, b16 m01, b16 m02, b16 m03) r0,
        (b16 m10, b16 m11, b16 m12, b16 m13) r1,
        (b16 m20, b16 m21, b16 m22, b16 m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m3x4(b16 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m3x4(b16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m3x4(b16v3 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m3x4(b16v3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out b16v3 c0, out b16v3 c1, out b16v3 c2, out b16v3 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out b16 m00, out b16 m01, out b16 m02, out b16 m03,
        out b16 m10, out b16 m11, out b16 m12, out b16 m13,
        out b16 m20, out b16 m21, out b16 m22, out b16 m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // deconstruct

    #region index

    public b16v3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // b16m3x4

#region b16m4x2

[Serializable]
[JsonConverter(typeof(b16m4x2JsonConverter))]
public partial struct b16m4x2 :
    IMatrix4x2<b16>, IMatrixSelf<b16m4x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static b16m4x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b16m4x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b16m4x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region fields
    public b16v4 c0;
    public b16v4 c1;

    #endregion

    #region getter

    public b16 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b16 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b16 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b16 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b16 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b16 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b16 m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b16 m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b16m4x2(b16v4 c0, b16v4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b16m4x2((b16v4 c0, b16v4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m4x2((b16v4 c0, b16v4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b16m4x2(
        b16 m00, b16 m01,
        b16 m10, b16 m11,
        b16 m20, b16 m21,
        b16 m30, b16 m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m4x2((
        b16 m00, b16 m01,
        b16 m10, b16 m11,
        b16 m20, b16 m21,
        b16 m30, b16 m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b16m4x2((
        b16 m00, b16 m01,
        b16 m10, b16 m11,
        b16 m20, b16 m21,
        b16 m30, b16 m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m4x2((
        (b16 m00, b16 m01) r0,
        (b16 m10, b16 m11) r1,
        (b16 m20, b16 m21) r2,
        (b16 m30, b16 m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b16m4x2((
        (b16 m00, b16 m01) r0,
        (b16 m10, b16 m11) r1,
        (b16 m20, b16 m21) r2,
        (b16 m30, b16 m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m4x2(b16 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m4x2(b16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m4x2(b16v4 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m4x2(b16v4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out b16v4 c0, out b16v4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out b16 m00, out b16 m01,
        out b16 m10, out b16 m11,
        out b16 m20, out b16 m21,
        out b16 m30, out b16 m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // deconstruct

    #region index

    public b16v4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // b16m4x2

#region b16m4x3

[Serializable]
[JsonConverter(typeof(b16m4x3JsonConverter))]
public partial struct b16m4x3 :
    IMatrix4x3<b16>, IMatrixSelf<b16m4x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static b16m4x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b16m4x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b16m4x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default,
            default, default, true,
            default, default, default
        ); 
    }

    #endregion

    #region fields
    public b16v4 c0;
    public b16v4 c1;
    public b16v4 c2;

    #endregion

    #region getter

    public b16 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b16 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b16 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b16 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b16 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b16 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b16 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b16 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b16 m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b16 m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b16 m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public b16 m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b16m4x3(b16v4 c0, b16v4 c1, b16v4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b16m4x3((b16v4 c0, b16v4 c1, b16v4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m4x3((b16v4 c0, b16v4 c1, b16v4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b16m4x3(
        b16 m00, b16 m01, b16 m02,
        b16 m10, b16 m11, b16 m12,
        b16 m20, b16 m21, b16 m22,
        b16 m30, b16 m31, b16 m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m4x3((
        b16 m00, b16 m01, b16 m02,
        b16 m10, b16 m11, b16 m12,
        b16 m20, b16 m21, b16 m22,
        b16 m30, b16 m31, b16 m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b16m4x3((
        b16 m00, b16 m01, b16 m02,
        b16 m10, b16 m11, b16 m12,
        b16 m20, b16 m21, b16 m22,
        b16 m30, b16 m31, b16 m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m4x3((
        (b16 m00, b16 m01, b16 m02) r0,
        (b16 m10, b16 m11, b16 m12) r1,
        (b16 m20, b16 m21, b16 m22) r2,
        (b16 m30, b16 m31, b16 m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b16m4x3((
        (b16 m00, b16 m01, b16 m02) r0,
        (b16 m10, b16 m11, b16 m12) r1,
        (b16 m20, b16 m21, b16 m22) r2,
        (b16 m30, b16 m31, b16 m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m4x3(b16 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m4x3(b16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m4x3(b16v4 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m4x3(b16v4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out b16v4 c0, out b16v4 c1, out b16v4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out b16 m00, out b16 m01, out b16 m02,
        out b16 m10, out b16 m11, out b16 m12,
        out b16 m20, out b16 m21, out b16 m22,
        out b16 m30, out b16 m31, out b16 m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // deconstruct

    #region index

    public b16v4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // b16m4x3

#region b16m4x4

[Serializable]
[JsonConverter(typeof(b16m4x4JsonConverter))]
public partial struct b16m4x4 :
    IMatrix4x4<b16>, IMatrixSelf<b16m4x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static b16m4x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b16m4x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b16m4x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default,
            default, default, true, default,
            default, default, default, true
        ); 
    }

    #endregion

    #region fields
    public b16v4 c0;
    public b16v4 c1;
    public b16v4 c2;
    public b16v4 c3;

    #endregion

    #region getter

    public b16 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b16 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b16 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b16 m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b16 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b16 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b16 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b16 m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public b16 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b16 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b16 m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b16 m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public b16 m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b16 m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public b16 m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public b16 m33
    {
        [MethodImpl(256 | 512)]
        get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b16m4x4(b16v4 c0, b16v4 c1, b16v4 c2, b16v4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b16m4x4((b16v4 c0, b16v4 c1, b16v4 c2, b16v4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m4x4((b16v4 c0, b16v4 c1, b16v4 c2, b16v4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b16m4x4(
        b16 m00, b16 m01, b16 m02, b16 m03,
        b16 m10, b16 m11, b16 m12, b16 m13,
        b16 m20, b16 m21, b16 m22, b16 m23,
        b16 m30, b16 m31, b16 m32, b16 m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m4x4((
        b16 m00, b16 m01, b16 m02, b16 m03,
        b16 m10, b16 m11, b16 m12, b16 m13,
        b16 m20, b16 m21, b16 m22, b16 m23,
        b16 m30, b16 m31, b16 m32, b16 m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b16m4x4((
        b16 m00, b16 m01, b16 m02, b16 m03,
        b16 m10, b16 m11, b16 m12, b16 m13,
        b16 m20, b16 m21, b16 m22, b16 m23,
        b16 m30, b16 m31, b16 m32, b16 m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m4x4((
        (b16 m00, b16 m01, b16 m02, b16 m03) r0,
        (b16 m10, b16 m11, b16 m12, b16 m13) r1,
        (b16 m20, b16 m21, b16 m22, b16 m23) r2,
        (b16 m30, b16 m31, b16 m32, b16 m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b16m4x4((
        (b16 m00, b16 m01, b16 m02, b16 m03) r0,
        (b16 m10, b16 m11, b16 m12, b16 m13) r1,
        (b16 m20, b16 m21, b16 m22, b16 m23) r2,
        (b16 m30, b16 m31, b16 m32, b16 m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m4x4(b16 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m4x4(b16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m4x4(b16v4 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m4x4(b16v4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out b16v4 c0, out b16v4 c1, out b16v4 c2, out b16v4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out b16 m00, out b16 m01, out b16 m02, out b16 m03,
        out b16 m10, out b16 m11, out b16 m12, out b16 m13,
        out b16 m20, out b16 m21, out b16 m22, out b16 m23,
        out b16 m30, out b16 m31, out b16 m32, out b16 m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // deconstruct

    #region index

    public b16v4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // b16m4x4

#region b32m2x2

[Serializable]
[JsonConverter(typeof(b32m2x2JsonConverter))]
public partial struct b32m2x2 :
    IMatrix2x2<b32>, IMatrixSelf<b32m2x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static b32m2x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b32m2x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b32m2x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true
        ); 
    }

    #endregion

    #region fields
    public b32v2 c0;
    public b32v2 c1;

    #endregion

    #region getter

    public b32 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b32m2x2(b32v2 c0, b32v2 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b32m2x2((b32v2 c0, b32v2 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x2((b32v2 c0, b32v2 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x2(
        b32 m00, b32 m01,
        b32 m10, b32 m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x2((
        b32 m00, b32 m01,
        b32 m10, b32 m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x2((
        b32 m00, b32 m01,
        b32 m10, b32 m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x2((
        (b32 m00, b32 m01) r0,
        (b32 m10, b32 m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x2((
        (b32 m00, b32 m01) r0,
        (b32 m10, b32 m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x2(b32 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m2x2(b32 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x2(b32v2 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m2x2(b32v2 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out b32v2 c0, out b32v2 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out b32 m00, out b32 m01,
        out b32 m10, out b32 m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // deconstruct

    #region index

    public b32v2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // b32m2x2

#region b32m2x3

[Serializable]
[JsonConverter(typeof(b32m2x3JsonConverter))]
public partial struct b32m2x3 :
    IMatrix2x3<b32>, IMatrixSelf<b32m2x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static b32m2x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b32m2x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b32m2x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default
        ); 
    }

    #endregion

    #region fields
    public b32v2 c0;
    public b32v2 c1;
    public b32v2 c2;

    #endregion

    #region getter

    public b32 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b32 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b32m2x3(b32v2 c0, b32v2 c1, b32v2 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b32m2x3((b32v2 c0, b32v2 c1, b32v2 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x3((b32v2 c0, b32v2 c1, b32v2 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x3(
        b32 m00, b32 m01, b32 m02,
        b32 m10, b32 m11, b32 m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x3((
        b32 m00, b32 m01, b32 m02,
        b32 m10, b32 m11, b32 m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x3((
        b32 m00, b32 m01, b32 m02,
        b32 m10, b32 m11, b32 m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x3((
        (b32 m00, b32 m01, b32 m02) r0,
        (b32 m10, b32 m11, b32 m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x3((
        (b32 m00, b32 m01, b32 m02) r0,
        (b32 m10, b32 m11, b32 m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x3(b32 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m2x3(b32 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x3(b32v2 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m2x3(b32v2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out b32v2 c0, out b32v2 c1, out b32v2 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out b32 m00, out b32 m01, out b32 m02,
        out b32 m10, out b32 m11, out b32 m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // deconstruct

    #region index

    public b32v2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // b32m2x3

#region b32m2x4

[Serializable]
[JsonConverter(typeof(b32m2x4JsonConverter))]
public partial struct b32m2x4 :
    IMatrix2x4<b32>, IMatrixSelf<b32m2x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static b32m2x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b32m2x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b32m2x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default
        ); 
    }

    #endregion

    #region fields
    public b32v2 c0;
    public b32v2 c1;
    public b32v2 c2;
    public b32v2 c3;

    #endregion

    #region getter

    public b32 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b32 m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b32 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b32 m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b32m2x4(b32v2 c0, b32v2 c1, b32v2 c2, b32v2 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b32m2x4((b32v2 c0, b32v2 c1, b32v2 c2, b32v2 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x4((b32v2 c0, b32v2 c1, b32v2 c2, b32v2 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x4(
        b32 m00, b32 m01, b32 m02, b32 m03,
        b32 m10, b32 m11, b32 m12, b32 m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x4((
        b32 m00, b32 m01, b32 m02, b32 m03,
        b32 m10, b32 m11, b32 m12, b32 m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x4((
        b32 m00, b32 m01, b32 m02, b32 m03,
        b32 m10, b32 m11, b32 m12, b32 m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x4((
        (b32 m00, b32 m01, b32 m02, b32 m03) r0,
        (b32 m10, b32 m11, b32 m12, b32 m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x4((
        (b32 m00, b32 m01, b32 m02, b32 m03) r0,
        (b32 m10, b32 m11, b32 m12, b32 m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x4(b32 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m2x4(b32 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x4(b32v2 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m2x4(b32v2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out b32v2 c0, out b32v2 c1, out b32v2 c2, out b32v2 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out b32 m00, out b32 m01, out b32 m02, out b32 m03,
        out b32 m10, out b32 m11, out b32 m12, out b32 m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // deconstruct

    #region index

    public b32v2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // b32m2x4

#region b32m3x2

[Serializable]
[JsonConverter(typeof(b32m3x2JsonConverter))]
public partial struct b32m3x2 :
    IMatrix3x2<b32>, IMatrixSelf<b32m3x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static b32m3x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b32m3x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b32m3x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true,
            default, default
        ); 
    }

    #endregion

    #region fields
    public b32v3 c0;
    public b32v3 c1;

    #endregion

    #region getter

    public b32 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b32 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b32m3x2(b32v3 c0, b32v3 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b32m3x2((b32v3 c0, b32v3 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x2((b32v3 c0, b32v3 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x2(
        b32 m00, b32 m01,
        b32 m10, b32 m11,
        b32 m20, b32 m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x2((
        b32 m00, b32 m01,
        b32 m10, b32 m11,
        b32 m20, b32 m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x2((
        b32 m00, b32 m01,
        b32 m10, b32 m11,
        b32 m20, b32 m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x2((
        (b32 m00, b32 m01) r0,
        (b32 m10, b32 m11) r1,
        (b32 m20, b32 m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x2((
        (b32 m00, b32 m01) r0,
        (b32 m10, b32 m11) r1,
        (b32 m20, b32 m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x2(b32 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m3x2(b32 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x2(b32v3 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m3x2(b32v3 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out b32v3 c0, out b32v3 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out b32 m00, out b32 m01,
        out b32 m10, out b32 m11,
        out b32 m20, out b32 m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // deconstruct

    #region index

    public b32v3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // b32m3x2

#region b32m3x3

[Serializable]
[JsonConverter(typeof(b32m3x3JsonConverter))]
public partial struct b32m3x3 :
    IMatrix3x3<b32>, IMatrixSelf<b32m3x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static b32m3x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b32m3x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b32m3x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default,
            default, default, true
        ); 
    }

    #endregion

    #region fields
    public b32v3 c0;
    public b32v3 c1;
    public b32v3 c2;

    #endregion

    #region getter

    public b32 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b32 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b32 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b32 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b32 m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b32m3x3(b32v3 c0, b32v3 c1, b32v3 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b32m3x3((b32v3 c0, b32v3 c1, b32v3 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x3((b32v3 c0, b32v3 c1, b32v3 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x3(
        b32 m00, b32 m01, b32 m02,
        b32 m10, b32 m11, b32 m12,
        b32 m20, b32 m21, b32 m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x3((
        b32 m00, b32 m01, b32 m02,
        b32 m10, b32 m11, b32 m12,
        b32 m20, b32 m21, b32 m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x3((
        b32 m00, b32 m01, b32 m02,
        b32 m10, b32 m11, b32 m12,
        b32 m20, b32 m21, b32 m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x3((
        (b32 m00, b32 m01, b32 m02) r0,
        (b32 m10, b32 m11, b32 m12) r1,
        (b32 m20, b32 m21, b32 m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x3((
        (b32 m00, b32 m01, b32 m02) r0,
        (b32 m10, b32 m11, b32 m12) r1,
        (b32 m20, b32 m21, b32 m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x3(b32 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m3x3(b32 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x3(b32v3 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m3x3(b32v3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out b32v3 c0, out b32v3 c1, out b32v3 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out b32 m00, out b32 m01, out b32 m02,
        out b32 m10, out b32 m11, out b32 m12,
        out b32 m20, out b32 m21, out b32 m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // deconstruct

    #region index

    public b32v3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // b32m3x3

#region b32m3x4

[Serializable]
[JsonConverter(typeof(b32m3x4JsonConverter))]
public partial struct b32m3x4 :
    IMatrix3x4<b32>, IMatrixSelf<b32m3x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static b32m3x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b32m3x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b32m3x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default,
            default, default, true, default
        ); 
    }

    #endregion

    #region fields
    public b32v3 c0;
    public b32v3 c1;
    public b32v3 c2;
    public b32v3 c3;

    #endregion

    #region getter

    public b32 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b32 m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b32 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b32 m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public b32 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b32 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b32 m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b32 m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b32m3x4(b32v3 c0, b32v3 c1, b32v3 c2, b32v3 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b32m3x4((b32v3 c0, b32v3 c1, b32v3 c2, b32v3 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x4((b32v3 c0, b32v3 c1, b32v3 c2, b32v3 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x4(
        b32 m00, b32 m01, b32 m02, b32 m03,
        b32 m10, b32 m11, b32 m12, b32 m13,
        b32 m20, b32 m21, b32 m22, b32 m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x4((
        b32 m00, b32 m01, b32 m02, b32 m03,
        b32 m10, b32 m11, b32 m12, b32 m13,
        b32 m20, b32 m21, b32 m22, b32 m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x4((
        b32 m00, b32 m01, b32 m02, b32 m03,
        b32 m10, b32 m11, b32 m12, b32 m13,
        b32 m20, b32 m21, b32 m22, b32 m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x4((
        (b32 m00, b32 m01, b32 m02, b32 m03) r0,
        (b32 m10, b32 m11, b32 m12, b32 m13) r1,
        (b32 m20, b32 m21, b32 m22, b32 m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x4((
        (b32 m00, b32 m01, b32 m02, b32 m03) r0,
        (b32 m10, b32 m11, b32 m12, b32 m13) r1,
        (b32 m20, b32 m21, b32 m22, b32 m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x4(b32 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m3x4(b32 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x4(b32v3 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m3x4(b32v3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out b32v3 c0, out b32v3 c1, out b32v3 c2, out b32v3 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out b32 m00, out b32 m01, out b32 m02, out b32 m03,
        out b32 m10, out b32 m11, out b32 m12, out b32 m13,
        out b32 m20, out b32 m21, out b32 m22, out b32 m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // deconstruct

    #region index

    public b32v3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // b32m3x4

#region b32m4x2

[Serializable]
[JsonConverter(typeof(b32m4x2JsonConverter))]
public partial struct b32m4x2 :
    IMatrix4x2<b32>, IMatrixSelf<b32m4x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static b32m4x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b32m4x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b32m4x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region fields
    public b32v4 c0;
    public b32v4 c1;

    #endregion

    #region getter

    public b32 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b32 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b32 m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b32 m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b32m4x2(b32v4 c0, b32v4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b32m4x2((b32v4 c0, b32v4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x2((b32v4 c0, b32v4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x2(
        b32 m00, b32 m01,
        b32 m10, b32 m11,
        b32 m20, b32 m21,
        b32 m30, b32 m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x2((
        b32 m00, b32 m01,
        b32 m10, b32 m11,
        b32 m20, b32 m21,
        b32 m30, b32 m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x2((
        b32 m00, b32 m01,
        b32 m10, b32 m11,
        b32 m20, b32 m21,
        b32 m30, b32 m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x2((
        (b32 m00, b32 m01) r0,
        (b32 m10, b32 m11) r1,
        (b32 m20, b32 m21) r2,
        (b32 m30, b32 m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x2((
        (b32 m00, b32 m01) r0,
        (b32 m10, b32 m11) r1,
        (b32 m20, b32 m21) r2,
        (b32 m30, b32 m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x2(b32 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m4x2(b32 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x2(b32v4 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m4x2(b32v4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out b32v4 c0, out b32v4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out b32 m00, out b32 m01,
        out b32 m10, out b32 m11,
        out b32 m20, out b32 m21,
        out b32 m30, out b32 m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // deconstruct

    #region index

    public b32v4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // b32m4x2

#region b32m4x3

[Serializable]
[JsonConverter(typeof(b32m4x3JsonConverter))]
public partial struct b32m4x3 :
    IMatrix4x3<b32>, IMatrixSelf<b32m4x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static b32m4x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b32m4x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b32m4x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default,
            default, default, true,
            default, default, default
        ); 
    }

    #endregion

    #region fields
    public b32v4 c0;
    public b32v4 c1;
    public b32v4 c2;

    #endregion

    #region getter

    public b32 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b32 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b32 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b32 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b32 m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b32 m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b32 m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public b32 m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b32m4x3(b32v4 c0, b32v4 c1, b32v4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b32m4x3((b32v4 c0, b32v4 c1, b32v4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x3((b32v4 c0, b32v4 c1, b32v4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x3(
        b32 m00, b32 m01, b32 m02,
        b32 m10, b32 m11, b32 m12,
        b32 m20, b32 m21, b32 m22,
        b32 m30, b32 m31, b32 m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x3((
        b32 m00, b32 m01, b32 m02,
        b32 m10, b32 m11, b32 m12,
        b32 m20, b32 m21, b32 m22,
        b32 m30, b32 m31, b32 m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x3((
        b32 m00, b32 m01, b32 m02,
        b32 m10, b32 m11, b32 m12,
        b32 m20, b32 m21, b32 m22,
        b32 m30, b32 m31, b32 m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x3((
        (b32 m00, b32 m01, b32 m02) r0,
        (b32 m10, b32 m11, b32 m12) r1,
        (b32 m20, b32 m21, b32 m22) r2,
        (b32 m30, b32 m31, b32 m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x3((
        (b32 m00, b32 m01, b32 m02) r0,
        (b32 m10, b32 m11, b32 m12) r1,
        (b32 m20, b32 m21, b32 m22) r2,
        (b32 m30, b32 m31, b32 m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x3(b32 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m4x3(b32 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x3(b32v4 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m4x3(b32v4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out b32v4 c0, out b32v4 c1, out b32v4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out b32 m00, out b32 m01, out b32 m02,
        out b32 m10, out b32 m11, out b32 m12,
        out b32 m20, out b32 m21, out b32 m22,
        out b32 m30, out b32 m31, out b32 m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // deconstruct

    #region index

    public b32v4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // b32m4x3

#region b32m4x4

[Serializable]
[JsonConverter(typeof(b32m4x4JsonConverter))]
public partial struct b32m4x4 :
    IMatrix4x4<b32>, IMatrixSelf<b32m4x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static b32m4x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b32m4x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b32m4x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default,
            default, default, true, default,
            default, default, default, true
        ); 
    }

    #endregion

    #region fields
    public b32v4 c0;
    public b32v4 c1;
    public b32v4 c2;
    public b32v4 c3;

    #endregion

    #region getter

    public b32 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b32 m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b32 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b32 m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public b32 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b32 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b32 m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b32 m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public b32 m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b32 m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public b32 m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public b32 m33
    {
        [MethodImpl(256 | 512)]
        get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b32m4x4(b32v4 c0, b32v4 c1, b32v4 c2, b32v4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b32m4x4((b32v4 c0, b32v4 c1, b32v4 c2, b32v4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x4((b32v4 c0, b32v4 c1, b32v4 c2, b32v4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x4(
        b32 m00, b32 m01, b32 m02, b32 m03,
        b32 m10, b32 m11, b32 m12, b32 m13,
        b32 m20, b32 m21, b32 m22, b32 m23,
        b32 m30, b32 m31, b32 m32, b32 m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x4((
        b32 m00, b32 m01, b32 m02, b32 m03,
        b32 m10, b32 m11, b32 m12, b32 m13,
        b32 m20, b32 m21, b32 m22, b32 m23,
        b32 m30, b32 m31, b32 m32, b32 m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x4((
        b32 m00, b32 m01, b32 m02, b32 m03,
        b32 m10, b32 m11, b32 m12, b32 m13,
        b32 m20, b32 m21, b32 m22, b32 m23,
        b32 m30, b32 m31, b32 m32, b32 m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x4((
        (b32 m00, b32 m01, b32 m02, b32 m03) r0,
        (b32 m10, b32 m11, b32 m12, b32 m13) r1,
        (b32 m20, b32 m21, b32 m22, b32 m23) r2,
        (b32 m30, b32 m31, b32 m32, b32 m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x4((
        (b32 m00, b32 m01, b32 m02, b32 m03) r0,
        (b32 m10, b32 m11, b32 m12, b32 m13) r1,
        (b32 m20, b32 m21, b32 m22, b32 m23) r2,
        (b32 m30, b32 m31, b32 m32, b32 m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x4(b32 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m4x4(b32 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x4(b32v4 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m4x4(b32v4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out b32v4 c0, out b32v4 c1, out b32v4 c2, out b32v4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out b32 m00, out b32 m01, out b32 m02, out b32 m03,
        out b32 m10, out b32 m11, out b32 m12, out b32 m13,
        out b32 m20, out b32 m21, out b32 m22, out b32 m23,
        out b32 m30, out b32 m31, out b32 m32, out b32 m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // deconstruct

    #region index

    public b32v4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // b32m4x4

#region b64m2x2

[Serializable]
[JsonConverter(typeof(b64m2x2JsonConverter))]
public partial struct b64m2x2 :
    IMatrix2x2<b64>, IMatrixSelf<b64m2x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static b64m2x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b64m2x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b64m2x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true
        ); 
    }

    #endregion

    #region fields
    public b64v2 c0;
    public b64v2 c1;

    #endregion

    #region getter

    public b64 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b64m2x2(b64v2 c0, b64v2 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b64m2x2((b64v2 c0, b64v2 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x2((b64v2 c0, b64v2 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x2(
        b64 m00, b64 m01,
        b64 m10, b64 m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x2((
        b64 m00, b64 m01,
        b64 m10, b64 m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x2((
        b64 m00, b64 m01,
        b64 m10, b64 m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x2((
        (b64 m00, b64 m01) r0,
        (b64 m10, b64 m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x2((
        (b64 m00, b64 m01) r0,
        (b64 m10, b64 m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x2(b64 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m2x2(b64 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x2(b64v2 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m2x2(b64v2 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out b64v2 c0, out b64v2 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out b64 m00, out b64 m01,
        out b64 m10, out b64 m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // deconstruct

    #region index

    public b64v2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // b64m2x2

#region b64m2x3

[Serializable]
[JsonConverter(typeof(b64m2x3JsonConverter))]
public partial struct b64m2x3 :
    IMatrix2x3<b64>, IMatrixSelf<b64m2x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static b64m2x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b64m2x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b64m2x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default
        ); 
    }

    #endregion

    #region fields
    public b64v2 c0;
    public b64v2 c1;
    public b64v2 c2;

    #endregion

    #region getter

    public b64 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b64 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b64m2x3(b64v2 c0, b64v2 c1, b64v2 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b64m2x3((b64v2 c0, b64v2 c1, b64v2 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x3((b64v2 c0, b64v2 c1, b64v2 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x3(
        b64 m00, b64 m01, b64 m02,
        b64 m10, b64 m11, b64 m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x3((
        b64 m00, b64 m01, b64 m02,
        b64 m10, b64 m11, b64 m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x3((
        b64 m00, b64 m01, b64 m02,
        b64 m10, b64 m11, b64 m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x3((
        (b64 m00, b64 m01, b64 m02) r0,
        (b64 m10, b64 m11, b64 m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x3((
        (b64 m00, b64 m01, b64 m02) r0,
        (b64 m10, b64 m11, b64 m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x3(b64 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m2x3(b64 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x3(b64v2 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m2x3(b64v2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out b64v2 c0, out b64v2 c1, out b64v2 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out b64 m00, out b64 m01, out b64 m02,
        out b64 m10, out b64 m11, out b64 m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // deconstruct

    #region index

    public b64v2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // b64m2x3

#region b64m2x4

[Serializable]
[JsonConverter(typeof(b64m2x4JsonConverter))]
public partial struct b64m2x4 :
    IMatrix2x4<b64>, IMatrixSelf<b64m2x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static b64m2x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b64m2x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b64m2x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default
        ); 
    }

    #endregion

    #region fields
    public b64v2 c0;
    public b64v2 c1;
    public b64v2 c2;
    public b64v2 c3;

    #endregion

    #region getter

    public b64 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b64 m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b64 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b64 m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b64m2x4(b64v2 c0, b64v2 c1, b64v2 c2, b64v2 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b64m2x4((b64v2 c0, b64v2 c1, b64v2 c2, b64v2 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x4((b64v2 c0, b64v2 c1, b64v2 c2, b64v2 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x4(
        b64 m00, b64 m01, b64 m02, b64 m03,
        b64 m10, b64 m11, b64 m12, b64 m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x4((
        b64 m00, b64 m01, b64 m02, b64 m03,
        b64 m10, b64 m11, b64 m12, b64 m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x4((
        b64 m00, b64 m01, b64 m02, b64 m03,
        b64 m10, b64 m11, b64 m12, b64 m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x4((
        (b64 m00, b64 m01, b64 m02, b64 m03) r0,
        (b64 m10, b64 m11, b64 m12, b64 m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x4((
        (b64 m00, b64 m01, b64 m02, b64 m03) r0,
        (b64 m10, b64 m11, b64 m12, b64 m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x4(b64 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m2x4(b64 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x4(b64v2 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m2x4(b64v2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out b64v2 c0, out b64v2 c1, out b64v2 c2, out b64v2 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out b64 m00, out b64 m01, out b64 m02, out b64 m03,
        out b64 m10, out b64 m11, out b64 m12, out b64 m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // deconstruct

    #region index

    public b64v2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // b64m2x4

#region b64m3x2

[Serializable]
[JsonConverter(typeof(b64m3x2JsonConverter))]
public partial struct b64m3x2 :
    IMatrix3x2<b64>, IMatrixSelf<b64m3x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static b64m3x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b64m3x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b64m3x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true,
            default, default
        ); 
    }

    #endregion

    #region fields
    public b64v3 c0;
    public b64v3 c1;

    #endregion

    #region getter

    public b64 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b64 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b64m3x2(b64v3 c0, b64v3 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b64m3x2((b64v3 c0, b64v3 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x2((b64v3 c0, b64v3 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x2(
        b64 m00, b64 m01,
        b64 m10, b64 m11,
        b64 m20, b64 m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x2((
        b64 m00, b64 m01,
        b64 m10, b64 m11,
        b64 m20, b64 m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x2((
        b64 m00, b64 m01,
        b64 m10, b64 m11,
        b64 m20, b64 m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x2((
        (b64 m00, b64 m01) r0,
        (b64 m10, b64 m11) r1,
        (b64 m20, b64 m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x2((
        (b64 m00, b64 m01) r0,
        (b64 m10, b64 m11) r1,
        (b64 m20, b64 m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x2(b64 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m3x2(b64 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x2(b64v3 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m3x2(b64v3 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out b64v3 c0, out b64v3 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out b64 m00, out b64 m01,
        out b64 m10, out b64 m11,
        out b64 m20, out b64 m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // deconstruct

    #region index

    public b64v3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // b64m3x2

#region b64m3x3

[Serializable]
[JsonConverter(typeof(b64m3x3JsonConverter))]
public partial struct b64m3x3 :
    IMatrix3x3<b64>, IMatrixSelf<b64m3x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static b64m3x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b64m3x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b64m3x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default,
            default, default, true
        ); 
    }

    #endregion

    #region fields
    public b64v3 c0;
    public b64v3 c1;
    public b64v3 c2;

    #endregion

    #region getter

    public b64 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b64 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b64 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b64 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b64 m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b64m3x3(b64v3 c0, b64v3 c1, b64v3 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b64m3x3((b64v3 c0, b64v3 c1, b64v3 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x3((b64v3 c0, b64v3 c1, b64v3 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x3(
        b64 m00, b64 m01, b64 m02,
        b64 m10, b64 m11, b64 m12,
        b64 m20, b64 m21, b64 m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x3((
        b64 m00, b64 m01, b64 m02,
        b64 m10, b64 m11, b64 m12,
        b64 m20, b64 m21, b64 m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x3((
        b64 m00, b64 m01, b64 m02,
        b64 m10, b64 m11, b64 m12,
        b64 m20, b64 m21, b64 m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x3((
        (b64 m00, b64 m01, b64 m02) r0,
        (b64 m10, b64 m11, b64 m12) r1,
        (b64 m20, b64 m21, b64 m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x3((
        (b64 m00, b64 m01, b64 m02) r0,
        (b64 m10, b64 m11, b64 m12) r1,
        (b64 m20, b64 m21, b64 m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x3(b64 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m3x3(b64 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x3(b64v3 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m3x3(b64v3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out b64v3 c0, out b64v3 c1, out b64v3 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out b64 m00, out b64 m01, out b64 m02,
        out b64 m10, out b64 m11, out b64 m12,
        out b64 m20, out b64 m21, out b64 m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // deconstruct

    #region index

    public b64v3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // b64m3x3

#region b64m3x4

[Serializable]
[JsonConverter(typeof(b64m3x4JsonConverter))]
public partial struct b64m3x4 :
    IMatrix3x4<b64>, IMatrixSelf<b64m3x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static b64m3x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b64m3x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b64m3x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default,
            default, default, true, default
        ); 
    }

    #endregion

    #region fields
    public b64v3 c0;
    public b64v3 c1;
    public b64v3 c2;
    public b64v3 c3;

    #endregion

    #region getter

    public b64 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b64 m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b64 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b64 m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public b64 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b64 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b64 m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b64 m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b64m3x4(b64v3 c0, b64v3 c1, b64v3 c2, b64v3 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b64m3x4((b64v3 c0, b64v3 c1, b64v3 c2, b64v3 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x4((b64v3 c0, b64v3 c1, b64v3 c2, b64v3 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x4(
        b64 m00, b64 m01, b64 m02, b64 m03,
        b64 m10, b64 m11, b64 m12, b64 m13,
        b64 m20, b64 m21, b64 m22, b64 m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x4((
        b64 m00, b64 m01, b64 m02, b64 m03,
        b64 m10, b64 m11, b64 m12, b64 m13,
        b64 m20, b64 m21, b64 m22, b64 m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x4((
        b64 m00, b64 m01, b64 m02, b64 m03,
        b64 m10, b64 m11, b64 m12, b64 m13,
        b64 m20, b64 m21, b64 m22, b64 m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x4((
        (b64 m00, b64 m01, b64 m02, b64 m03) r0,
        (b64 m10, b64 m11, b64 m12, b64 m13) r1,
        (b64 m20, b64 m21, b64 m22, b64 m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x4((
        (b64 m00, b64 m01, b64 m02, b64 m03) r0,
        (b64 m10, b64 m11, b64 m12, b64 m13) r1,
        (b64 m20, b64 m21, b64 m22, b64 m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x4(b64 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m3x4(b64 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x4(b64v3 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m3x4(b64v3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out b64v3 c0, out b64v3 c1, out b64v3 c2, out b64v3 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out b64 m00, out b64 m01, out b64 m02, out b64 m03,
        out b64 m10, out b64 m11, out b64 m12, out b64 m13,
        out b64 m20, out b64 m21, out b64 m22, out b64 m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // deconstruct

    #region index

    public b64v3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // b64m3x4

#region b64m4x2

[Serializable]
[JsonConverter(typeof(b64m4x2JsonConverter))]
public partial struct b64m4x2 :
    IMatrix4x2<b64>, IMatrixSelf<b64m4x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static b64m4x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b64m4x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b64m4x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region fields
    public b64v4 c0;
    public b64v4 c1;

    #endregion

    #region getter

    public b64 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b64 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b64 m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b64 m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b64m4x2(b64v4 c0, b64v4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b64m4x2((b64v4 c0, b64v4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x2((b64v4 c0, b64v4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x2(
        b64 m00, b64 m01,
        b64 m10, b64 m11,
        b64 m20, b64 m21,
        b64 m30, b64 m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x2((
        b64 m00, b64 m01,
        b64 m10, b64 m11,
        b64 m20, b64 m21,
        b64 m30, b64 m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x2((
        b64 m00, b64 m01,
        b64 m10, b64 m11,
        b64 m20, b64 m21,
        b64 m30, b64 m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x2((
        (b64 m00, b64 m01) r0,
        (b64 m10, b64 m11) r1,
        (b64 m20, b64 m21) r2,
        (b64 m30, b64 m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x2((
        (b64 m00, b64 m01) r0,
        (b64 m10, b64 m11) r1,
        (b64 m20, b64 m21) r2,
        (b64 m30, b64 m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x2(b64 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m4x2(b64 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x2(b64v4 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m4x2(b64v4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out b64v4 c0, out b64v4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out b64 m00, out b64 m01,
        out b64 m10, out b64 m11,
        out b64 m20, out b64 m21,
        out b64 m30, out b64 m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // deconstruct

    #region index

    public b64v4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // b64m4x2

#region b64m4x3

[Serializable]
[JsonConverter(typeof(b64m4x3JsonConverter))]
public partial struct b64m4x3 :
    IMatrix4x3<b64>, IMatrixSelf<b64m4x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static b64m4x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b64m4x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b64m4x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default,
            default, default, true,
            default, default, default
        ); 
    }

    #endregion

    #region fields
    public b64v4 c0;
    public b64v4 c1;
    public b64v4 c2;

    #endregion

    #region getter

    public b64 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b64 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b64 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b64 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b64 m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b64 m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b64 m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public b64 m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b64m4x3(b64v4 c0, b64v4 c1, b64v4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b64m4x3((b64v4 c0, b64v4 c1, b64v4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x3((b64v4 c0, b64v4 c1, b64v4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x3(
        b64 m00, b64 m01, b64 m02,
        b64 m10, b64 m11, b64 m12,
        b64 m20, b64 m21, b64 m22,
        b64 m30, b64 m31, b64 m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x3((
        b64 m00, b64 m01, b64 m02,
        b64 m10, b64 m11, b64 m12,
        b64 m20, b64 m21, b64 m22,
        b64 m30, b64 m31, b64 m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x3((
        b64 m00, b64 m01, b64 m02,
        b64 m10, b64 m11, b64 m12,
        b64 m20, b64 m21, b64 m22,
        b64 m30, b64 m31, b64 m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x3((
        (b64 m00, b64 m01, b64 m02) r0,
        (b64 m10, b64 m11, b64 m12) r1,
        (b64 m20, b64 m21, b64 m22) r2,
        (b64 m30, b64 m31, b64 m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x3((
        (b64 m00, b64 m01, b64 m02) r0,
        (b64 m10, b64 m11, b64 m12) r1,
        (b64 m20, b64 m21, b64 m22) r2,
        (b64 m30, b64 m31, b64 m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x3(b64 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m4x3(b64 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x3(b64v4 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m4x3(b64v4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out b64v4 c0, out b64v4 c1, out b64v4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out b64 m00, out b64 m01, out b64 m02,
        out b64 m10, out b64 m11, out b64 m12,
        out b64 m20, out b64 m21, out b64 m22,
        out b64 m30, out b64 m31, out b64 m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // deconstruct

    #region index

    public b64v4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // b64m4x3

#region b64m4x4

[Serializable]
[JsonConverter(typeof(b64m4x4JsonConverter))]
public partial struct b64m4x4 :
    IMatrix4x4<b64>, IMatrixSelf<b64m4x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static b64m4x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b64m4x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b64m4x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default,
            default, default, true, default,
            default, default, default, true
        ); 
    }

    #endregion

    #region fields
    public b64v4 c0;
    public b64v4 c1;
    public b64v4 c2;
    public b64v4 c3;

    #endregion

    #region getter

    public b64 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b64 m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b64 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b64 m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public b64 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b64 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b64 m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b64 m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public b64 m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b64 m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public b64 m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public b64 m33
    {
        [MethodImpl(256 | 512)]
        get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b64m4x4(b64v4 c0, b64v4 c1, b64v4 c2, b64v4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b64m4x4((b64v4 c0, b64v4 c1, b64v4 c2, b64v4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x4((b64v4 c0, b64v4 c1, b64v4 c2, b64v4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x4(
        b64 m00, b64 m01, b64 m02, b64 m03,
        b64 m10, b64 m11, b64 m12, b64 m13,
        b64 m20, b64 m21, b64 m22, b64 m23,
        b64 m30, b64 m31, b64 m32, b64 m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x4((
        b64 m00, b64 m01, b64 m02, b64 m03,
        b64 m10, b64 m11, b64 m12, b64 m13,
        b64 m20, b64 m21, b64 m22, b64 m23,
        b64 m30, b64 m31, b64 m32, b64 m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x4((
        b64 m00, b64 m01, b64 m02, b64 m03,
        b64 m10, b64 m11, b64 m12, b64 m13,
        b64 m20, b64 m21, b64 m22, b64 m23,
        b64 m30, b64 m31, b64 m32, b64 m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x4((
        (b64 m00, b64 m01, b64 m02, b64 m03) r0,
        (b64 m10, b64 m11, b64 m12, b64 m13) r1,
        (b64 m20, b64 m21, b64 m22, b64 m23) r2,
        (b64 m30, b64 m31, b64 m32, b64 m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x4((
        (b64 m00, b64 m01, b64 m02, b64 m03) r0,
        (b64 m10, b64 m11, b64 m12, b64 m13) r1,
        (b64 m20, b64 m21, b64 m22, b64 m23) r2,
        (b64 m30, b64 m31, b64 m32, b64 m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x4(b64 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m4x4(b64 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x4(b64v4 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m4x4(b64v4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region deconstruct
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(out b64v4 c0, out b64v4 c1, out b64v4 c2, out b64v4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public void Deconstruct(
        out b64 m00, out b64 m01, out b64 m02, out b64 m03,
        out b64 m10, out b64 m11, out b64 m12, out b64 m13,
        out b64 m20, out b64 m21, out b64 m22, out b64 m23,
        out b64 m30, out b64 m31, out b64 m32, out b64 m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // deconstruct

    #region index

    public b64v4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // index
}

#endregion // b64m4x4
