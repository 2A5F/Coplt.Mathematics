// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region float2x2

[Serializable]
public partial struct float2x2 :
    IMatrix2x2<float>, IMatrixSelf<float2x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static float2x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static float2x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0f); 
    }

    public static float2x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default,
            default, 1.0f
        ); 
    }

    #endregion

    #region fields
    public float2 c0;
    public float2 c1;

    #endregion

    #region getter

    public float m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public float2x2(float2 c0, float2 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public float2x2(
        float m00, float m01,
        float m10, float m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x2(float value) => new(value);

    [MethodImpl(256 | 512)]
    public float2x2(float value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x2(float2 value) => new(value);

    [MethodImpl(256 | 512)]
    public float2x2(float2 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public float2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // float2x2

#region float2x3

[Serializable]
public partial struct float2x3 :
    IMatrix2x3<float>, IMatrixSelf<float2x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static float2x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static float2x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0f); 
    }

    public static float2x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default, default,
            default, 1.0f, default
        ); 
    }

    #endregion

    #region fields
    public float2 c0;
    public float2 c1;
    public float2 c2;

    #endregion

    #region getter

    public float m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public float m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public float2x3(float2 c0, float2 c1, float2 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public float2x3(
        float m00, float m01, float m02,
        float m10, float m11, float m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x3(float value) => new(value);

    [MethodImpl(256 | 512)]
    public float2x3(float value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x3(float2 value) => new(value);

    [MethodImpl(256 | 512)]
    public float2x3(float2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public float2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // float2x3

#region float2x4

[Serializable]
public partial struct float2x4 :
    IMatrix2x4<float>, IMatrixSelf<float2x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static float2x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static float2x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0f); 
    }

    public static float2x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default, default, default,
            default, 1.0f, default, default
        ); 
    }

    #endregion

    #region fields
    public float2 c0;
    public float2 c1;
    public float2 c2;
    public float2 c3;

    #endregion

    #region getter

    public float m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public float m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public float m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public float m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public float2x4(float2 c0, float2 c1, float2 c2, float2 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public float2x4(
        float m00, float m01, float m02, float m03,
        float m10, float m11, float m12, float m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x4(float value) => new(value);

    [MethodImpl(256 | 512)]
    public float2x4(float value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x4(float2 value) => new(value);

    [MethodImpl(256 | 512)]
    public float2x4(float2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public float2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // float2x4

#region float3x2

[Serializable]
public partial struct float3x2 :
    IMatrix3x2<float>, IMatrixSelf<float3x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static float3x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static float3x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0f); 
    }

    public static float3x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default,
            default, 1.0f,
            default, default
        ); 
    }

    #endregion

    #region fields
    public float3 c0;
    public float3 c1;

    #endregion

    #region getter

    public float m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public float m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public float3x2(float3 c0, float3 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public float3x2(
        float m00, float m01,
        float m10, float m11,
        float m20, float m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x2(float value) => new(value);

    [MethodImpl(256 | 512)]
    public float3x2(float value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x2(float3 value) => new(value);

    [MethodImpl(256 | 512)]
    public float3x2(float3 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public float3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // float3x2

#region float3x3

[Serializable]
public partial struct float3x3 :
    IMatrix3x3<float>, IMatrixSelf<float3x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static float3x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static float3x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0f); 
    }

    public static float3x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default, default,
            default, 1.0f, default,
            default, default, 1.0f
        ); 
    }

    #endregion

    #region fields
    public float3 c0;
    public float3 c1;
    public float3 c2;

    #endregion

    #region getter

    public float m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public float m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public float m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public float m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public float m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public float3x3(float3 c0, float3 c1, float3 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public float3x3(
        float m00, float m01, float m02,
        float m10, float m11, float m12,
        float m20, float m21, float m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x3(float value) => new(value);

    [MethodImpl(256 | 512)]
    public float3x3(float value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x3(float3 value) => new(value);

    [MethodImpl(256 | 512)]
    public float3x3(float3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public float3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // float3x3

#region float3x4

[Serializable]
public partial struct float3x4 :
    IMatrix3x4<float>, IMatrixSelf<float3x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static float3x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static float3x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0f); 
    }

    public static float3x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default, default, default,
            default, 1.0f, default, default,
            default, default, 1.0f, default
        ); 
    }

    #endregion

    #region fields
    public float3 c0;
    public float3 c1;
    public float3 c2;
    public float3 c3;

    #endregion

    #region getter

    public float m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public float m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public float m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public float m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public float m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public float m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public float m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public float m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public float3x4(float3 c0, float3 c1, float3 c2, float3 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public float3x4(
        float m00, float m01, float m02, float m03,
        float m10, float m11, float m12, float m13,
        float m20, float m21, float m22, float m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x4(float value) => new(value);

    [MethodImpl(256 | 512)]
    public float3x4(float value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x4(float3 value) => new(value);

    [MethodImpl(256 | 512)]
    public float3x4(float3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public float3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // float3x4

#region float4x2

[Serializable]
public partial struct float4x2 :
    IMatrix4x2<float>, IMatrixSelf<float4x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static float4x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static float4x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0f); 
    }

    public static float4x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default,
            default, 1.0f,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region fields
    public float4 c0;
    public float4 c1;

    #endregion

    #region getter

    public float m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public float m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public float m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public float m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public float4x2(float4 c0, float4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public float4x2(
        float m00, float m01,
        float m10, float m11,
        float m20, float m21,
        float m30, float m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x2(float value) => new(value);

    [MethodImpl(256 | 512)]
    public float4x2(float value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x2(float4 value) => new(value);

    [MethodImpl(256 | 512)]
    public float4x2(float4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public float4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // float4x2

#region float4x3

[Serializable]
public partial struct float4x3 :
    IMatrix4x3<float>, IMatrixSelf<float4x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static float4x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static float4x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0f); 
    }

    public static float4x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default, default,
            default, 1.0f, default,
            default, default, 1.0f,
            default, default, default
        ); 
    }

    #endregion

    #region fields
    public float4 c0;
    public float4 c1;
    public float4 c2;

    #endregion

    #region getter

    public float m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public float m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public float m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public float m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public float m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public float m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public float m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public float m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public float4x3(float4 c0, float4 c1, float4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public float4x3(
        float m00, float m01, float m02,
        float m10, float m11, float m12,
        float m20, float m21, float m22,
        float m30, float m31, float m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x3(float value) => new(value);

    [MethodImpl(256 | 512)]
    public float4x3(float value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x3(float4 value) => new(value);

    [MethodImpl(256 | 512)]
    public float4x3(float4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public float4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // float4x3

#region float4x4

[Serializable]
public partial struct float4x4 :
    IMatrix4x4<float>, IMatrixSelf<float4x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static float4x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static float4x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0f); 
    }

    public static float4x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default, default, default,
            default, 1.0f, default, default,
            default, default, 1.0f, default,
            default, default, default, 1.0f
        ); 
    }

    #endregion

    #region fields
    public float4 c0;
    public float4 c1;
    public float4 c2;
    public float4 c3;

    #endregion

    #region getter

    public float m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public float m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public float m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public float m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public float m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public float m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public float m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public float m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public float m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public float m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public float m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public float m33
    {
        [MethodImpl(256 | 512)]
        get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public float4x4(float4 c0, float4 c1, float4 c2, float4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public float4x4(
        float m00, float m01, float m02, float m03,
        float m10, float m11, float m12, float m13,
        float m20, float m21, float m22, float m23,
        float m30, float m31, float m32, float m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x4(float value) => new(value);

    [MethodImpl(256 | 512)]
    public float4x4(float value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x4(float4 value) => new(value);

    [MethodImpl(256 | 512)]
    public float4x4(float4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public float4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // float4x4

#region double2x2

[Serializable]
public partial struct double2x2 :
    IMatrix2x2<double>, IMatrixSelf<double2x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static double2x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static double2x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0); 
    }

    public static double2x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default,
            default, 1.0
        ); 
    }

    #endregion

    #region fields
    public double2 c0;
    public double2 c1;

    #endregion

    #region getter

    public double m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public double2x2(double2 c0, double2 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public double2x2(
        double m00, double m01,
        double m10, double m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x2(double value) => new(value);

    [MethodImpl(256 | 512)]
    public double2x2(double value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x2(double2 value) => new(value);

    [MethodImpl(256 | 512)]
    public double2x2(double2 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public double2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // double2x2

#region double2x3

[Serializable]
public partial struct double2x3 :
    IMatrix2x3<double>, IMatrixSelf<double2x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static double2x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static double2x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0); 
    }

    public static double2x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default, default,
            default, 1.0, default
        ); 
    }

    #endregion

    #region fields
    public double2 c0;
    public double2 c1;
    public double2 c2;

    #endregion

    #region getter

    public double m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public double m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public double2x3(double2 c0, double2 c1, double2 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public double2x3(
        double m00, double m01, double m02,
        double m10, double m11, double m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x3(double value) => new(value);

    [MethodImpl(256 | 512)]
    public double2x3(double value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x3(double2 value) => new(value);

    [MethodImpl(256 | 512)]
    public double2x3(double2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public double2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // double2x3

#region double2x4

[Serializable]
public partial struct double2x4 :
    IMatrix2x4<double>, IMatrixSelf<double2x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static double2x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static double2x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0); 
    }

    public static double2x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default, default, default,
            default, 1.0, default, default
        ); 
    }

    #endregion

    #region fields
    public double2 c0;
    public double2 c1;
    public double2 c2;
    public double2 c3;

    #endregion

    #region getter

    public double m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public double m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public double m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public double m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public double2x4(double2 c0, double2 c1, double2 c2, double2 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public double2x4(
        double m00, double m01, double m02, double m03,
        double m10, double m11, double m12, double m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x4(double value) => new(value);

    [MethodImpl(256 | 512)]
    public double2x4(double value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x4(double2 value) => new(value);

    [MethodImpl(256 | 512)]
    public double2x4(double2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public double2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // double2x4

#region double3x2

[Serializable]
public partial struct double3x2 :
    IMatrix3x2<double>, IMatrixSelf<double3x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static double3x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static double3x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0); 
    }

    public static double3x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default,
            default, 1.0,
            default, default
        ); 
    }

    #endregion

    #region fields
    public double3 c0;
    public double3 c1;

    #endregion

    #region getter

    public double m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public double m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public double3x2(double3 c0, double3 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public double3x2(
        double m00, double m01,
        double m10, double m11,
        double m20, double m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x2(double value) => new(value);

    [MethodImpl(256 | 512)]
    public double3x2(double value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x2(double3 value) => new(value);

    [MethodImpl(256 | 512)]
    public double3x2(double3 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public double3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // double3x2

#region double3x3

[Serializable]
public partial struct double3x3 :
    IMatrix3x3<double>, IMatrixSelf<double3x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static double3x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static double3x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0); 
    }

    public static double3x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default, default,
            default, 1.0, default,
            default, default, 1.0
        ); 
    }

    #endregion

    #region fields
    public double3 c0;
    public double3 c1;
    public double3 c2;

    #endregion

    #region getter

    public double m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public double m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public double m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public double m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public double m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public double3x3(double3 c0, double3 c1, double3 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public double3x3(
        double m00, double m01, double m02,
        double m10, double m11, double m12,
        double m20, double m21, double m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x3(double value) => new(value);

    [MethodImpl(256 | 512)]
    public double3x3(double value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x3(double3 value) => new(value);

    [MethodImpl(256 | 512)]
    public double3x3(double3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public double3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // double3x3

#region double3x4

[Serializable]
public partial struct double3x4 :
    IMatrix3x4<double>, IMatrixSelf<double3x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static double3x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static double3x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0); 
    }

    public static double3x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default, default, default,
            default, 1.0, default, default,
            default, default, 1.0, default
        ); 
    }

    #endregion

    #region fields
    public double3 c0;
    public double3 c1;
    public double3 c2;
    public double3 c3;

    #endregion

    #region getter

    public double m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public double m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public double m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public double m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public double m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public double m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public double m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public double m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public double3x4(double3 c0, double3 c1, double3 c2, double3 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public double3x4(
        double m00, double m01, double m02, double m03,
        double m10, double m11, double m12, double m13,
        double m20, double m21, double m22, double m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x4(double value) => new(value);

    [MethodImpl(256 | 512)]
    public double3x4(double value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x4(double3 value) => new(value);

    [MethodImpl(256 | 512)]
    public double3x4(double3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public double3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // double3x4

#region double4x2

[Serializable]
public partial struct double4x2 :
    IMatrix4x2<double>, IMatrixSelf<double4x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static double4x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static double4x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0); 
    }

    public static double4x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default,
            default, 1.0,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region fields
    public double4 c0;
    public double4 c1;

    #endregion

    #region getter

    public double m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public double m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public double m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public double m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public double4x2(double4 c0, double4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public double4x2(
        double m00, double m01,
        double m10, double m11,
        double m20, double m21,
        double m30, double m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x2(double value) => new(value);

    [MethodImpl(256 | 512)]
    public double4x2(double value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x2(double4 value) => new(value);

    [MethodImpl(256 | 512)]
    public double4x2(double4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public double4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // double4x2

#region double4x3

[Serializable]
public partial struct double4x3 :
    IMatrix4x3<double>, IMatrixSelf<double4x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static double4x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static double4x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0); 
    }

    public static double4x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default, default,
            default, 1.0, default,
            default, default, 1.0,
            default, default, default
        ); 
    }

    #endregion

    #region fields
    public double4 c0;
    public double4 c1;
    public double4 c2;

    #endregion

    #region getter

    public double m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public double m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public double m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public double m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public double m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public double m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public double m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public double m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public double4x3(double4 c0, double4 c1, double4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public double4x3(
        double m00, double m01, double m02,
        double m10, double m11, double m12,
        double m20, double m21, double m22,
        double m30, double m31, double m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x3(double value) => new(value);

    [MethodImpl(256 | 512)]
    public double4x3(double value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x3(double4 value) => new(value);

    [MethodImpl(256 | 512)]
    public double4x3(double4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public double4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // double4x3

#region double4x4

[Serializable]
public partial struct double4x4 :
    IMatrix4x4<double>, IMatrixSelf<double4x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static double4x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static double4x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0); 
    }

    public static double4x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default, default, default,
            default, 1.0, default, default,
            default, default, 1.0, default,
            default, default, default, 1.0
        ); 
    }

    #endregion

    #region fields
    public double4 c0;
    public double4 c1;
    public double4 c2;
    public double4 c3;

    #endregion

    #region getter

    public double m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public double m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public double m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public double m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public double m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public double m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public double m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public double m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public double m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public double m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public double m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public double m33
    {
        [MethodImpl(256 | 512)]
        get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public double4x4(double4 c0, double4 c1, double4 c2, double4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public double4x4(
        double m00, double m01, double m02, double m03,
        double m10, double m11, double m12, double m13,
        double m20, double m21, double m22, double m23,
        double m30, double m31, double m32, double m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x4(double value) => new(value);

    [MethodImpl(256 | 512)]
    public double4x4(double value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x4(double4 value) => new(value);

    [MethodImpl(256 | 512)]
    public double4x4(double4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public double4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // double4x4

#region int2x2

[Serializable]
public partial struct int2x2 :
    IMatrix2x2<int>, IMatrixSelf<int2x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static int2x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static int2x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1); 
    }

    public static int2x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default,
            default, 1
        ); 
    }

    #endregion

    #region fields
    public int2 c0;
    public int2 c1;

    #endregion

    #region getter

    public int m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public int2x2(int2 c0, int2 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public int2x2(
        int m00, int m01,
        int m10, int m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x2(int value) => new(value);

    [MethodImpl(256 | 512)]
    public int2x2(int value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x2(int2 value) => new(value);

    [MethodImpl(256 | 512)]
    public int2x2(int2 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public int2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // int2x2

#region int2x3

[Serializable]
public partial struct int2x3 :
    IMatrix2x3<int>, IMatrixSelf<int2x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static int2x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static int2x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1); 
    }

    public static int2x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default, default,
            default, 1, default
        ); 
    }

    #endregion

    #region fields
    public int2 c0;
    public int2 c1;
    public int2 c2;

    #endregion

    #region getter

    public int m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public int m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public int2x3(int2 c0, int2 c1, int2 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public int2x3(
        int m00, int m01, int m02,
        int m10, int m11, int m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x3(int value) => new(value);

    [MethodImpl(256 | 512)]
    public int2x3(int value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x3(int2 value) => new(value);

    [MethodImpl(256 | 512)]
    public int2x3(int2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public int2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // int2x3

#region int2x4

[Serializable]
public partial struct int2x4 :
    IMatrix2x4<int>, IMatrixSelf<int2x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static int2x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static int2x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1); 
    }

    public static int2x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default, default, default,
            default, 1, default, default
        ); 
    }

    #endregion

    #region fields
    public int2 c0;
    public int2 c1;
    public int2 c2;
    public int2 c3;

    #endregion

    #region getter

    public int m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public int m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public int m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public int m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public int2x4(int2 c0, int2 c1, int2 c2, int2 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public int2x4(
        int m00, int m01, int m02, int m03,
        int m10, int m11, int m12, int m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x4(int value) => new(value);

    [MethodImpl(256 | 512)]
    public int2x4(int value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x4(int2 value) => new(value);

    [MethodImpl(256 | 512)]
    public int2x4(int2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public int2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // int2x4

#region int3x2

[Serializable]
public partial struct int3x2 :
    IMatrix3x2<int>, IMatrixSelf<int3x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static int3x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static int3x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1); 
    }

    public static int3x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default,
            default, 1,
            default, default
        ); 
    }

    #endregion

    #region fields
    public int3 c0;
    public int3 c1;

    #endregion

    #region getter

    public int m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public int m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public int3x2(int3 c0, int3 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public int3x2(
        int m00, int m01,
        int m10, int m11,
        int m20, int m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x2(int value) => new(value);

    [MethodImpl(256 | 512)]
    public int3x2(int value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x2(int3 value) => new(value);

    [MethodImpl(256 | 512)]
    public int3x2(int3 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public int3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // int3x2

#region int3x3

[Serializable]
public partial struct int3x3 :
    IMatrix3x3<int>, IMatrixSelf<int3x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static int3x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static int3x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1); 
    }

    public static int3x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default, default,
            default, 1, default,
            default, default, 1
        ); 
    }

    #endregion

    #region fields
    public int3 c0;
    public int3 c1;
    public int3 c2;

    #endregion

    #region getter

    public int m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public int m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public int m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public int m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public int m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public int3x3(int3 c0, int3 c1, int3 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public int3x3(
        int m00, int m01, int m02,
        int m10, int m11, int m12,
        int m20, int m21, int m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x3(int value) => new(value);

    [MethodImpl(256 | 512)]
    public int3x3(int value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x3(int3 value) => new(value);

    [MethodImpl(256 | 512)]
    public int3x3(int3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public int3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // int3x3

#region int3x4

[Serializable]
public partial struct int3x4 :
    IMatrix3x4<int>, IMatrixSelf<int3x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static int3x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static int3x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1); 
    }

    public static int3x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default, default, default,
            default, 1, default, default,
            default, default, 1, default
        ); 
    }

    #endregion

    #region fields
    public int3 c0;
    public int3 c1;
    public int3 c2;
    public int3 c3;

    #endregion

    #region getter

    public int m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public int m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public int m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public int m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public int m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public int m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public int m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public int m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public int3x4(int3 c0, int3 c1, int3 c2, int3 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public int3x4(
        int m00, int m01, int m02, int m03,
        int m10, int m11, int m12, int m13,
        int m20, int m21, int m22, int m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x4(int value) => new(value);

    [MethodImpl(256 | 512)]
    public int3x4(int value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x4(int3 value) => new(value);

    [MethodImpl(256 | 512)]
    public int3x4(int3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public int3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // int3x4

#region int4x2

[Serializable]
public partial struct int4x2 :
    IMatrix4x2<int>, IMatrixSelf<int4x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static int4x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static int4x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1); 
    }

    public static int4x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default,
            default, 1,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region fields
    public int4 c0;
    public int4 c1;

    #endregion

    #region getter

    public int m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public int m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public int m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public int m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public int4x2(int4 c0, int4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public int4x2(
        int m00, int m01,
        int m10, int m11,
        int m20, int m21,
        int m30, int m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x2(int value) => new(value);

    [MethodImpl(256 | 512)]
    public int4x2(int value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x2(int4 value) => new(value);

    [MethodImpl(256 | 512)]
    public int4x2(int4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public int4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // int4x2

#region int4x3

[Serializable]
public partial struct int4x3 :
    IMatrix4x3<int>, IMatrixSelf<int4x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static int4x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static int4x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1); 
    }

    public static int4x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default, default,
            default, 1, default,
            default, default, 1,
            default, default, default
        ); 
    }

    #endregion

    #region fields
    public int4 c0;
    public int4 c1;
    public int4 c2;

    #endregion

    #region getter

    public int m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public int m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public int m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public int m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public int m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public int m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public int m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public int m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public int4x3(int4 c0, int4 c1, int4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public int4x3(
        int m00, int m01, int m02,
        int m10, int m11, int m12,
        int m20, int m21, int m22,
        int m30, int m31, int m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x3(int value) => new(value);

    [MethodImpl(256 | 512)]
    public int4x3(int value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x3(int4 value) => new(value);

    [MethodImpl(256 | 512)]
    public int4x3(int4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public int4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // int4x3

#region int4x4

[Serializable]
public partial struct int4x4 :
    IMatrix4x4<int>, IMatrixSelf<int4x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static int4x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static int4x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1); 
    }

    public static int4x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default, default, default,
            default, 1, default, default,
            default, default, 1, default,
            default, default, default, 1
        ); 
    }

    #endregion

    #region fields
    public int4 c0;
    public int4 c1;
    public int4 c2;
    public int4 c3;

    #endregion

    #region getter

    public int m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public int m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public int m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public int m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public int m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public int m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public int m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public int m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public int m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public int m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public int m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public int m33
    {
        [MethodImpl(256 | 512)]
        get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public int4x4(int4 c0, int4 c1, int4 c2, int4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public int4x4(
        int m00, int m01, int m02, int m03,
        int m10, int m11, int m12, int m13,
        int m20, int m21, int m22, int m23,
        int m30, int m31, int m32, int m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x4(int value) => new(value);

    [MethodImpl(256 | 512)]
    public int4x4(int value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x4(int4 value) => new(value);

    [MethodImpl(256 | 512)]
    public int4x4(int4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public int4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // int4x4

#region uint2x2

[Serializable]
public partial struct uint2x2 :
    IMatrix2x2<uint>, IMatrixSelf<uint2x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static uint2x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static uint2x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1u); 
    }

    public static uint2x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default,
            default, 1u
        ); 
    }

    #endregion

    #region fields
    public uint2 c0;
    public uint2 c1;

    #endregion

    #region getter

    public uint m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public uint2x2(uint2 c0, uint2 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public uint2x2(
        uint m00, uint m01,
        uint m10, uint m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x2(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public uint2x2(uint value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x2(uint2 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint2x2(uint2 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public uint2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // uint2x2

#region uint2x3

[Serializable]
public partial struct uint2x3 :
    IMatrix2x3<uint>, IMatrixSelf<uint2x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static uint2x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static uint2x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1u); 
    }

    public static uint2x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default, default,
            default, 1u, default
        ); 
    }

    #endregion

    #region fields
    public uint2 c0;
    public uint2 c1;
    public uint2 c2;

    #endregion

    #region getter

    public uint m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public uint m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public uint2x3(uint2 c0, uint2 c1, uint2 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public uint2x3(
        uint m00, uint m01, uint m02,
        uint m10, uint m11, uint m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x3(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public uint2x3(uint value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x3(uint2 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint2x3(uint2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public uint2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // uint2x3

#region uint2x4

[Serializable]
public partial struct uint2x4 :
    IMatrix2x4<uint>, IMatrixSelf<uint2x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static uint2x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static uint2x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1u); 
    }

    public static uint2x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default, default, default,
            default, 1u, default, default
        ); 
    }

    #endregion

    #region fields
    public uint2 c0;
    public uint2 c1;
    public uint2 c2;
    public uint2 c3;

    #endregion

    #region getter

    public uint m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public uint m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public uint m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public uint m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public uint2x4(uint2 c0, uint2 c1, uint2 c2, uint2 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public uint2x4(
        uint m00, uint m01, uint m02, uint m03,
        uint m10, uint m11, uint m12, uint m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x4(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public uint2x4(uint value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x4(uint2 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint2x4(uint2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public uint2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // uint2x4

#region uint3x2

[Serializable]
public partial struct uint3x2 :
    IMatrix3x2<uint>, IMatrixSelf<uint3x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static uint3x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static uint3x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1u); 
    }

    public static uint3x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default,
            default, 1u,
            default, default
        ); 
    }

    #endregion

    #region fields
    public uint3 c0;
    public uint3 c1;

    #endregion

    #region getter

    public uint m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public uint m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public uint3x2(uint3 c0, uint3 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public uint3x2(
        uint m00, uint m01,
        uint m10, uint m11,
        uint m20, uint m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x2(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public uint3x2(uint value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x2(uint3 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint3x2(uint3 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public uint3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // uint3x2

#region uint3x3

[Serializable]
public partial struct uint3x3 :
    IMatrix3x3<uint>, IMatrixSelf<uint3x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static uint3x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static uint3x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1u); 
    }

    public static uint3x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default, default,
            default, 1u, default,
            default, default, 1u
        ); 
    }

    #endregion

    #region fields
    public uint3 c0;
    public uint3 c1;
    public uint3 c2;

    #endregion

    #region getter

    public uint m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public uint m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public uint m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public uint m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public uint m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public uint3x3(uint3 c0, uint3 c1, uint3 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public uint3x3(
        uint m00, uint m01, uint m02,
        uint m10, uint m11, uint m12,
        uint m20, uint m21, uint m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x3(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public uint3x3(uint value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x3(uint3 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint3x3(uint3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public uint3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // uint3x3

#region uint3x4

[Serializable]
public partial struct uint3x4 :
    IMatrix3x4<uint>, IMatrixSelf<uint3x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static uint3x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static uint3x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1u); 
    }

    public static uint3x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default, default, default,
            default, 1u, default, default,
            default, default, 1u, default
        ); 
    }

    #endregion

    #region fields
    public uint3 c0;
    public uint3 c1;
    public uint3 c2;
    public uint3 c3;

    #endregion

    #region getter

    public uint m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public uint m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public uint m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public uint m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public uint m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public uint m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public uint m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public uint m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public uint3x4(uint3 c0, uint3 c1, uint3 c2, uint3 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public uint3x4(
        uint m00, uint m01, uint m02, uint m03,
        uint m10, uint m11, uint m12, uint m13,
        uint m20, uint m21, uint m22, uint m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x4(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public uint3x4(uint value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x4(uint3 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint3x4(uint3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public uint3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // uint3x4

#region uint4x2

[Serializable]
public partial struct uint4x2 :
    IMatrix4x2<uint>, IMatrixSelf<uint4x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static uint4x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static uint4x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1u); 
    }

    public static uint4x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default,
            default, 1u,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region fields
    public uint4 c0;
    public uint4 c1;

    #endregion

    #region getter

    public uint m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public uint m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public uint m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public uint m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public uint4x2(uint4 c0, uint4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public uint4x2(
        uint m00, uint m01,
        uint m10, uint m11,
        uint m20, uint m21,
        uint m30, uint m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x2(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public uint4x2(uint value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x2(uint4 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint4x2(uint4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public uint4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // uint4x2

#region uint4x3

[Serializable]
public partial struct uint4x3 :
    IMatrix4x3<uint>, IMatrixSelf<uint4x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static uint4x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static uint4x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1u); 
    }

    public static uint4x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default, default,
            default, 1u, default,
            default, default, 1u,
            default, default, default
        ); 
    }

    #endregion

    #region fields
    public uint4 c0;
    public uint4 c1;
    public uint4 c2;

    #endregion

    #region getter

    public uint m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public uint m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public uint m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public uint m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public uint m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public uint m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public uint m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public uint m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public uint4x3(uint4 c0, uint4 c1, uint4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public uint4x3(
        uint m00, uint m01, uint m02,
        uint m10, uint m11, uint m12,
        uint m20, uint m21, uint m22,
        uint m30, uint m31, uint m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x3(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public uint4x3(uint value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x3(uint4 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint4x3(uint4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public uint4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // uint4x3

#region uint4x4

[Serializable]
public partial struct uint4x4 :
    IMatrix4x4<uint>, IMatrixSelf<uint4x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static uint4x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static uint4x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1u); 
    }

    public static uint4x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default, default, default,
            default, 1u, default, default,
            default, default, 1u, default,
            default, default, default, 1u
        ); 
    }

    #endregion

    #region fields
    public uint4 c0;
    public uint4 c1;
    public uint4 c2;
    public uint4 c3;

    #endregion

    #region getter

    public uint m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public uint m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public uint m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public uint m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public uint m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public uint m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public uint m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public uint m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public uint m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public uint m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public uint m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public uint m33
    {
        [MethodImpl(256 | 512)]
        get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public uint4x4(uint4 c0, uint4 c1, uint4 c2, uint4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public uint4x4(
        uint m00, uint m01, uint m02, uint m03,
        uint m10, uint m11, uint m12, uint m13,
        uint m20, uint m21, uint m22, uint m23,
        uint m30, uint m31, uint m32, uint m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x4(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public uint4x4(uint value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x4(uint4 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint4x4(uint4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public uint4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // uint4x4

#region long2x2

[Serializable]
public partial struct long2x2 :
    IMatrix2x2<long>, IMatrixSelf<long2x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static long2x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static long2x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1L); 
    }

    public static long2x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default,
            default, 1L
        ); 
    }

    #endregion

    #region fields
    public long2 c0;
    public long2 c1;

    #endregion

    #region getter

    public long m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public long2x2(long2 c0, long2 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public long2x2(
        long m00, long m01,
        long m10, long m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x2(long value) => new(value);

    [MethodImpl(256 | 512)]
    public long2x2(long value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x2(long2 value) => new(value);

    [MethodImpl(256 | 512)]
    public long2x2(long2 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public long2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // long2x2

#region long2x3

[Serializable]
public partial struct long2x3 :
    IMatrix2x3<long>, IMatrixSelf<long2x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static long2x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static long2x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1L); 
    }

    public static long2x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default, default,
            default, 1L, default
        ); 
    }

    #endregion

    #region fields
    public long2 c0;
    public long2 c1;
    public long2 c2;

    #endregion

    #region getter

    public long m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public long m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public long2x3(long2 c0, long2 c1, long2 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public long2x3(
        long m00, long m01, long m02,
        long m10, long m11, long m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x3(long value) => new(value);

    [MethodImpl(256 | 512)]
    public long2x3(long value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x3(long2 value) => new(value);

    [MethodImpl(256 | 512)]
    public long2x3(long2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public long2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // long2x3

#region long2x4

[Serializable]
public partial struct long2x4 :
    IMatrix2x4<long>, IMatrixSelf<long2x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static long2x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static long2x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1L); 
    }

    public static long2x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default, default, default,
            default, 1L, default, default
        ); 
    }

    #endregion

    #region fields
    public long2 c0;
    public long2 c1;
    public long2 c2;
    public long2 c3;

    #endregion

    #region getter

    public long m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public long m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public long m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public long m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public long2x4(long2 c0, long2 c1, long2 c2, long2 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public long2x4(
        long m00, long m01, long m02, long m03,
        long m10, long m11, long m12, long m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x4(long value) => new(value);

    [MethodImpl(256 | 512)]
    public long2x4(long value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x4(long2 value) => new(value);

    [MethodImpl(256 | 512)]
    public long2x4(long2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public long2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // long2x4

#region long3x2

[Serializable]
public partial struct long3x2 :
    IMatrix3x2<long>, IMatrixSelf<long3x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static long3x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static long3x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1L); 
    }

    public static long3x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default,
            default, 1L,
            default, default
        ); 
    }

    #endregion

    #region fields
    public long3 c0;
    public long3 c1;

    #endregion

    #region getter

    public long m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public long m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public long3x2(long3 c0, long3 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public long3x2(
        long m00, long m01,
        long m10, long m11,
        long m20, long m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x2(long value) => new(value);

    [MethodImpl(256 | 512)]
    public long3x2(long value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x2(long3 value) => new(value);

    [MethodImpl(256 | 512)]
    public long3x2(long3 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public long3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // long3x2

#region long3x3

[Serializable]
public partial struct long3x3 :
    IMatrix3x3<long>, IMatrixSelf<long3x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static long3x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static long3x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1L); 
    }

    public static long3x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default, default,
            default, 1L, default,
            default, default, 1L
        ); 
    }

    #endregion

    #region fields
    public long3 c0;
    public long3 c1;
    public long3 c2;

    #endregion

    #region getter

    public long m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public long m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public long m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public long m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public long m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public long3x3(long3 c0, long3 c1, long3 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public long3x3(
        long m00, long m01, long m02,
        long m10, long m11, long m12,
        long m20, long m21, long m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x3(long value) => new(value);

    [MethodImpl(256 | 512)]
    public long3x3(long value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x3(long3 value) => new(value);

    [MethodImpl(256 | 512)]
    public long3x3(long3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public long3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // long3x3

#region long3x4

[Serializable]
public partial struct long3x4 :
    IMatrix3x4<long>, IMatrixSelf<long3x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static long3x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static long3x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1L); 
    }

    public static long3x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default, default, default,
            default, 1L, default, default,
            default, default, 1L, default
        ); 
    }

    #endregion

    #region fields
    public long3 c0;
    public long3 c1;
    public long3 c2;
    public long3 c3;

    #endregion

    #region getter

    public long m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public long m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public long m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public long m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public long m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public long m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public long m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public long m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public long3x4(long3 c0, long3 c1, long3 c2, long3 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public long3x4(
        long m00, long m01, long m02, long m03,
        long m10, long m11, long m12, long m13,
        long m20, long m21, long m22, long m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x4(long value) => new(value);

    [MethodImpl(256 | 512)]
    public long3x4(long value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x4(long3 value) => new(value);

    [MethodImpl(256 | 512)]
    public long3x4(long3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public long3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // long3x4

#region long4x2

[Serializable]
public partial struct long4x2 :
    IMatrix4x2<long>, IMatrixSelf<long4x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static long4x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static long4x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1L); 
    }

    public static long4x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default,
            default, 1L,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region fields
    public long4 c0;
    public long4 c1;

    #endregion

    #region getter

    public long m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public long m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public long m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public long m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public long4x2(long4 c0, long4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public long4x2(
        long m00, long m01,
        long m10, long m11,
        long m20, long m21,
        long m30, long m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x2(long value) => new(value);

    [MethodImpl(256 | 512)]
    public long4x2(long value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x2(long4 value) => new(value);

    [MethodImpl(256 | 512)]
    public long4x2(long4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public long4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // long4x2

#region long4x3

[Serializable]
public partial struct long4x3 :
    IMatrix4x3<long>, IMatrixSelf<long4x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static long4x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static long4x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1L); 
    }

    public static long4x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default, default,
            default, 1L, default,
            default, default, 1L,
            default, default, default
        ); 
    }

    #endregion

    #region fields
    public long4 c0;
    public long4 c1;
    public long4 c2;

    #endregion

    #region getter

    public long m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public long m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public long m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public long m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public long m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public long m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public long m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public long m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public long4x3(long4 c0, long4 c1, long4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public long4x3(
        long m00, long m01, long m02,
        long m10, long m11, long m12,
        long m20, long m21, long m22,
        long m30, long m31, long m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x3(long value) => new(value);

    [MethodImpl(256 | 512)]
    public long4x3(long value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x3(long4 value) => new(value);

    [MethodImpl(256 | 512)]
    public long4x3(long4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public long4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // long4x3

#region long4x4

[Serializable]
public partial struct long4x4 :
    IMatrix4x4<long>, IMatrixSelf<long4x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static long4x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static long4x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1L); 
    }

    public static long4x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default, default, default,
            default, 1L, default, default,
            default, default, 1L, default,
            default, default, default, 1L
        ); 
    }

    #endregion

    #region fields
    public long4 c0;
    public long4 c1;
    public long4 c2;
    public long4 c3;

    #endregion

    #region getter

    public long m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public long m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public long m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public long m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public long m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public long m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public long m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public long m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public long m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public long m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public long m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public long m33
    {
        [MethodImpl(256 | 512)]
        get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public long4x4(long4 c0, long4 c1, long4 c2, long4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public long4x4(
        long m00, long m01, long m02, long m03,
        long m10, long m11, long m12, long m13,
        long m20, long m21, long m22, long m23,
        long m30, long m31, long m32, long m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x4(long value) => new(value);

    [MethodImpl(256 | 512)]
    public long4x4(long value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x4(long4 value) => new(value);

    [MethodImpl(256 | 512)]
    public long4x4(long4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public long4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // long4x4

#region ulong2x2

[Serializable]
public partial struct ulong2x2 :
    IMatrix2x2<ulong>, IMatrixSelf<ulong2x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static ulong2x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ulong2x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1UL); 
    }

    public static ulong2x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default,
            default, 1UL
        ); 
    }

    #endregion

    #region fields
    public ulong2 c0;
    public ulong2 c1;

    #endregion

    #region getter

    public ulong m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public ulong2x2(ulong2 c0, ulong2 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public ulong2x2(
        ulong m00, ulong m01,
        ulong m10, ulong m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x2(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong2x2(ulong value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x2(ulong2 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong2x2(ulong2 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public ulong2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // ulong2x2

#region ulong2x3

[Serializable]
public partial struct ulong2x3 :
    IMatrix2x3<ulong>, IMatrixSelf<ulong2x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static ulong2x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ulong2x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1UL); 
    }

    public static ulong2x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default, default,
            default, 1UL, default
        ); 
    }

    #endregion

    #region fields
    public ulong2 c0;
    public ulong2 c1;
    public ulong2 c2;

    #endregion

    #region getter

    public ulong m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ulong m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public ulong2x3(ulong2 c0, ulong2 c1, ulong2 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public ulong2x3(
        ulong m00, ulong m01, ulong m02,
        ulong m10, ulong m11, ulong m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x3(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong2x3(ulong value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x3(ulong2 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong2x3(ulong2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public ulong2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // ulong2x3

#region ulong2x4

[Serializable]
public partial struct ulong2x4 :
    IMatrix2x4<ulong>, IMatrixSelf<ulong2x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static ulong2x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ulong2x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1UL); 
    }

    public static ulong2x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default, default, default,
            default, 1UL, default, default
        ); 
    }

    #endregion

    #region fields
    public ulong2 c0;
    public ulong2 c1;
    public ulong2 c2;
    public ulong2 c3;

    #endregion

    #region getter

    public ulong m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ulong m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public ulong m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public ulong m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public ulong2x4(ulong2 c0, ulong2 c1, ulong2 c2, ulong2 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public ulong2x4(
        ulong m00, ulong m01, ulong m02, ulong m03,
        ulong m10, ulong m11, ulong m12, ulong m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x4(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong2x4(ulong value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x4(ulong2 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong2x4(ulong2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public ulong2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // ulong2x4

#region ulong3x2

[Serializable]
public partial struct ulong3x2 :
    IMatrix3x2<ulong>, IMatrixSelf<ulong3x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static ulong3x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ulong3x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1UL); 
    }

    public static ulong3x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default,
            default, 1UL,
            default, default
        ); 
    }

    #endregion

    #region fields
    public ulong3 c0;
    public ulong3 c1;

    #endregion

    #region getter

    public ulong m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ulong m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public ulong3x2(ulong3 c0, ulong3 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public ulong3x2(
        ulong m00, ulong m01,
        ulong m10, ulong m11,
        ulong m20, ulong m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x2(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong3x2(ulong value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x2(ulong3 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong3x2(ulong3 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public ulong3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // ulong3x2

#region ulong3x3

[Serializable]
public partial struct ulong3x3 :
    IMatrix3x3<ulong>, IMatrixSelf<ulong3x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static ulong3x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ulong3x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1UL); 
    }

    public static ulong3x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default, default,
            default, 1UL, default,
            default, default, 1UL
        ); 
    }

    #endregion

    #region fields
    public ulong3 c0;
    public ulong3 c1;
    public ulong3 c2;

    #endregion

    #region getter

    public ulong m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ulong m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public ulong m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ulong m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public ulong m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public ulong3x3(ulong3 c0, ulong3 c1, ulong3 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public ulong3x3(
        ulong m00, ulong m01, ulong m02,
        ulong m10, ulong m11, ulong m12,
        ulong m20, ulong m21, ulong m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x3(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong3x3(ulong value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x3(ulong3 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong3x3(ulong3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public ulong3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // ulong3x3

#region ulong3x4

[Serializable]
public partial struct ulong3x4 :
    IMatrix3x4<ulong>, IMatrixSelf<ulong3x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static ulong3x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ulong3x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1UL); 
    }

    public static ulong3x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default, default, default,
            default, 1UL, default, default,
            default, default, 1UL, default
        ); 
    }

    #endregion

    #region fields
    public ulong3 c0;
    public ulong3 c1;
    public ulong3 c2;
    public ulong3 c3;

    #endregion

    #region getter

    public ulong m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ulong m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public ulong m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public ulong m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public ulong m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ulong m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public ulong m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public ulong m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public ulong3x4(ulong3 c0, ulong3 c1, ulong3 c2, ulong3 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public ulong3x4(
        ulong m00, ulong m01, ulong m02, ulong m03,
        ulong m10, ulong m11, ulong m12, ulong m13,
        ulong m20, ulong m21, ulong m22, ulong m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x4(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong3x4(ulong value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x4(ulong3 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong3x4(ulong3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public ulong3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // ulong3x4

#region ulong4x2

[Serializable]
public partial struct ulong4x2 :
    IMatrix4x2<ulong>, IMatrixSelf<ulong4x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static ulong4x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ulong4x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1UL); 
    }

    public static ulong4x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default,
            default, 1UL,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region fields
    public ulong4 c0;
    public ulong4 c1;

    #endregion

    #region getter

    public ulong m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ulong m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public ulong m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public ulong m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public ulong4x2(ulong4 c0, ulong4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public ulong4x2(
        ulong m00, ulong m01,
        ulong m10, ulong m11,
        ulong m20, ulong m21,
        ulong m30, ulong m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x2(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong4x2(ulong value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x2(ulong4 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong4x2(ulong4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public ulong4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // ulong4x2

#region ulong4x3

[Serializable]
public partial struct ulong4x3 :
    IMatrix4x3<ulong>, IMatrixSelf<ulong4x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static ulong4x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ulong4x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1UL); 
    }

    public static ulong4x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default, default,
            default, 1UL, default,
            default, default, 1UL,
            default, default, default
        ); 
    }

    #endregion

    #region fields
    public ulong4 c0;
    public ulong4 c1;
    public ulong4 c2;

    #endregion

    #region getter

    public ulong m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ulong m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public ulong m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ulong m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public ulong m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public ulong m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public ulong m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public ulong m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public ulong4x3(ulong4 c0, ulong4 c1, ulong4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public ulong4x3(
        ulong m00, ulong m01, ulong m02,
        ulong m10, ulong m11, ulong m12,
        ulong m20, ulong m21, ulong m22,
        ulong m30, ulong m31, ulong m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x3(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong4x3(ulong value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x3(ulong4 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong4x3(ulong4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public ulong4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // ulong4x3

#region ulong4x4

[Serializable]
public partial struct ulong4x4 :
    IMatrix4x4<ulong>, IMatrixSelf<ulong4x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static ulong4x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ulong4x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1UL); 
    }

    public static ulong4x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default, default, default,
            default, 1UL, default, default,
            default, default, 1UL, default,
            default, default, default, 1UL
        ); 
    }

    #endregion

    #region fields
    public ulong4 c0;
    public ulong4 c1;
    public ulong4 c2;
    public ulong4 c3;

    #endregion

    #region getter

    public ulong m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ulong m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public ulong m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public ulong m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public ulong m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ulong m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public ulong m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public ulong m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public ulong m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public ulong m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public ulong m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public ulong m33
    {
        [MethodImpl(256 | 512)]
        get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public ulong4x4(ulong4 c0, ulong4 c1, ulong4 c2, ulong4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public ulong4x4(
        ulong m00, ulong m01, ulong m02, ulong m03,
        ulong m10, ulong m11, ulong m12, ulong m13,
        ulong m20, ulong m21, ulong m22, ulong m23,
        ulong m30, ulong m31, ulong m32, ulong m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x4(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong4x4(ulong value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x4(ulong4 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong4x4(ulong4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public ulong4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // ulong4x4

#region decimal2x2

[Serializable]
public partial struct decimal2x2 :
    IMatrix2x2<decimal>, IMatrixSelf<decimal2x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static decimal2x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static decimal2x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1m); 
    }

    public static decimal2x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1m, default,
            default, 1m
        ); 
    }

    #endregion

    #region fields
    public decimal2 c0;
    public decimal2 c1;

    #endregion

    #region getter

    public decimal m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public decimal m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public decimal m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public decimal m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public decimal2x2(decimal2 c0, decimal2 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public decimal2x2(
        decimal m00, decimal m01,
        decimal m10, decimal m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal2x2(decimal value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal2x2(decimal value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal2x2(decimal2 value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal2x2(decimal2 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public decimal2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public decimal this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // decimal2x2

#region decimal2x3

[Serializable]
public partial struct decimal2x3 :
    IMatrix2x3<decimal>, IMatrixSelf<decimal2x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static decimal2x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static decimal2x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1m); 
    }

    public static decimal2x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1m, default, default,
            default, 1m, default
        ); 
    }

    #endregion

    #region fields
    public decimal2 c0;
    public decimal2 c1;
    public decimal2 c2;

    #endregion

    #region getter

    public decimal m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public decimal m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public decimal m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public decimal m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public decimal m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public decimal m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public decimal2x3(decimal2 c0, decimal2 c1, decimal2 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public decimal2x3(
        decimal m00, decimal m01, decimal m02,
        decimal m10, decimal m11, decimal m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal2x3(decimal value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal2x3(decimal value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal2x3(decimal2 value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal2x3(decimal2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public decimal2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public decimal this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // decimal2x3

#region decimal2x4

[Serializable]
public partial struct decimal2x4 :
    IMatrix2x4<decimal>, IMatrixSelf<decimal2x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static decimal2x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static decimal2x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1m); 
    }

    public static decimal2x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1m, default, default, default,
            default, 1m, default, default
        ); 
    }

    #endregion

    #region fields
    public decimal2 c0;
    public decimal2 c1;
    public decimal2 c2;
    public decimal2 c3;

    #endregion

    #region getter

    public decimal m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public decimal m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public decimal m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public decimal m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public decimal m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public decimal m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public decimal m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public decimal m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public decimal2x4(decimal2 c0, decimal2 c1, decimal2 c2, decimal2 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public decimal2x4(
        decimal m00, decimal m01, decimal m02, decimal m03,
        decimal m10, decimal m11, decimal m12, decimal m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal2x4(decimal value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal2x4(decimal value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal2x4(decimal2 value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal2x4(decimal2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public decimal2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public decimal this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // decimal2x4

#region decimal3x2

[Serializable]
public partial struct decimal3x2 :
    IMatrix3x2<decimal>, IMatrixSelf<decimal3x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static decimal3x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static decimal3x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1m); 
    }

    public static decimal3x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1m, default,
            default, 1m,
            default, default
        ); 
    }

    #endregion

    #region fields
    public decimal3 c0;
    public decimal3 c1;

    #endregion

    #region getter

    public decimal m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public decimal m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public decimal m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public decimal m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public decimal m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public decimal m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public decimal3x2(decimal3 c0, decimal3 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public decimal3x2(
        decimal m00, decimal m01,
        decimal m10, decimal m11,
        decimal m20, decimal m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal3x2(decimal value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal3x2(decimal value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal3x2(decimal3 value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal3x2(decimal3 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public decimal3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public decimal this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // decimal3x2

#region decimal3x3

[Serializable]
public partial struct decimal3x3 :
    IMatrix3x3<decimal>, IMatrixSelf<decimal3x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static decimal3x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static decimal3x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1m); 
    }

    public static decimal3x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1m, default, default,
            default, 1m, default,
            default, default, 1m
        ); 
    }

    #endregion

    #region fields
    public decimal3 c0;
    public decimal3 c1;
    public decimal3 c2;

    #endregion

    #region getter

    public decimal m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public decimal m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public decimal m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public decimal m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public decimal m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public decimal m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public decimal m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public decimal m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public decimal m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public decimal3x3(decimal3 c0, decimal3 c1, decimal3 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public decimal3x3(
        decimal m00, decimal m01, decimal m02,
        decimal m10, decimal m11, decimal m12,
        decimal m20, decimal m21, decimal m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal3x3(decimal value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal3x3(decimal value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal3x3(decimal3 value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal3x3(decimal3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public decimal3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public decimal this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // decimal3x3

#region decimal3x4

[Serializable]
public partial struct decimal3x4 :
    IMatrix3x4<decimal>, IMatrixSelf<decimal3x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static decimal3x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static decimal3x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1m); 
    }

    public static decimal3x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1m, default, default, default,
            default, 1m, default, default,
            default, default, 1m, default
        ); 
    }

    #endregion

    #region fields
    public decimal3 c0;
    public decimal3 c1;
    public decimal3 c2;
    public decimal3 c3;

    #endregion

    #region getter

    public decimal m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public decimal m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public decimal m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public decimal m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public decimal m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public decimal m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public decimal m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public decimal m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public decimal m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public decimal m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public decimal m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public decimal m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public decimal3x4(decimal3 c0, decimal3 c1, decimal3 c2, decimal3 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public decimal3x4(
        decimal m00, decimal m01, decimal m02, decimal m03,
        decimal m10, decimal m11, decimal m12, decimal m13,
        decimal m20, decimal m21, decimal m22, decimal m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal3x4(decimal value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal3x4(decimal value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal3x4(decimal3 value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal3x4(decimal3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public decimal3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public decimal this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // decimal3x4

#region decimal4x2

[Serializable]
public partial struct decimal4x2 :
    IMatrix4x2<decimal>, IMatrixSelf<decimal4x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static decimal4x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static decimal4x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1m); 
    }

    public static decimal4x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1m, default,
            default, 1m,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region fields
    public decimal4 c0;
    public decimal4 c1;

    #endregion

    #region getter

    public decimal m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public decimal m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public decimal m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public decimal m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public decimal m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public decimal m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public decimal m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public decimal m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public decimal4x2(decimal4 c0, decimal4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public decimal4x2(
        decimal m00, decimal m01,
        decimal m10, decimal m11,
        decimal m20, decimal m21,
        decimal m30, decimal m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal4x2(decimal value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal4x2(decimal value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal4x2(decimal4 value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal4x2(decimal4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public decimal4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public decimal this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // decimal4x2

#region decimal4x3

[Serializable]
public partial struct decimal4x3 :
    IMatrix4x3<decimal>, IMatrixSelf<decimal4x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static decimal4x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static decimal4x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1m); 
    }

    public static decimal4x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1m, default, default,
            default, 1m, default,
            default, default, 1m,
            default, default, default
        ); 
    }

    #endregion

    #region fields
    public decimal4 c0;
    public decimal4 c1;
    public decimal4 c2;

    #endregion

    #region getter

    public decimal m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public decimal m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public decimal m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public decimal m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public decimal m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public decimal m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public decimal m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public decimal m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public decimal m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public decimal m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public decimal m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public decimal m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public decimal4x3(decimal4 c0, decimal4 c1, decimal4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public decimal4x3(
        decimal m00, decimal m01, decimal m02,
        decimal m10, decimal m11, decimal m12,
        decimal m20, decimal m21, decimal m22,
        decimal m30, decimal m31, decimal m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal4x3(decimal value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal4x3(decimal value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal4x3(decimal4 value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal4x3(decimal4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public decimal4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public decimal this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // decimal4x3

#region decimal4x4

[Serializable]
public partial struct decimal4x4 :
    IMatrix4x4<decimal>, IMatrixSelf<decimal4x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static decimal4x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static decimal4x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1m); 
    }

    public static decimal4x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1m, default, default, default,
            default, 1m, default, default,
            default, default, 1m, default,
            default, default, default, 1m
        ); 
    }

    #endregion

    #region fields
    public decimal4 c0;
    public decimal4 c1;
    public decimal4 c2;
    public decimal4 c3;

    #endregion

    #region getter

    public decimal m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public decimal m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public decimal m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public decimal m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public decimal m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public decimal m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public decimal m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public decimal m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public decimal m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public decimal m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public decimal m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public decimal m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public decimal m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public decimal m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public decimal m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public decimal m33
    {
        [MethodImpl(256 | 512)]
        get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public decimal4x4(decimal4 c0, decimal4 c1, decimal4 c2, decimal4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public decimal4x4(
        decimal m00, decimal m01, decimal m02, decimal m03,
        decimal m10, decimal m11, decimal m12, decimal m13,
        decimal m20, decimal m21, decimal m22, decimal m23,
        decimal m30, decimal m31, decimal m32, decimal m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal4x4(decimal value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal4x4(decimal value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal4x4(decimal4 value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal4x4(decimal4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public decimal4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public decimal this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // decimal4x4

#region half2x2

[Serializable]
public partial struct half2x2 :
    IMatrix2x2<half>, IMatrixSelf<half2x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static half2x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static half2x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new((half)1.0); 
    }

    public static half2x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (half)1.0, default,
            default, (half)1.0
        ); 
    }

    #endregion

    #region fields
    public half2 c0;
    public half2 c1;

    #endregion

    #region getter

    public half m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public half m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public half m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public half m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public half2x2(half2 c0, half2 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public half2x2(
        half m00, half m01,
        half m10, half m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half2x2(half value) => new(value);

    [MethodImpl(256 | 512)]
    public half2x2(half value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half2x2(half2 value) => new(value);

    [MethodImpl(256 | 512)]
    public half2x2(half2 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public half2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public half this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // half2x2

#region half2x3

[Serializable]
public partial struct half2x3 :
    IMatrix2x3<half>, IMatrixSelf<half2x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static half2x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static half2x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new((half)1.0); 
    }

    public static half2x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (half)1.0, default, default,
            default, (half)1.0, default
        ); 
    }

    #endregion

    #region fields
    public half2 c0;
    public half2 c1;
    public half2 c2;

    #endregion

    #region getter

    public half m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public half m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public half m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public half m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public half m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public half m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public half2x3(half2 c0, half2 c1, half2 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public half2x3(
        half m00, half m01, half m02,
        half m10, half m11, half m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half2x3(half value) => new(value);

    [MethodImpl(256 | 512)]
    public half2x3(half value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half2x3(half2 value) => new(value);

    [MethodImpl(256 | 512)]
    public half2x3(half2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public half2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public half this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // half2x3

#region half2x4

[Serializable]
public partial struct half2x4 :
    IMatrix2x4<half>, IMatrixSelf<half2x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static half2x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static half2x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new((half)1.0); 
    }

    public static half2x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (half)1.0, default, default, default,
            default, (half)1.0, default, default
        ); 
    }

    #endregion

    #region fields
    public half2 c0;
    public half2 c1;
    public half2 c2;
    public half2 c3;

    #endregion

    #region getter

    public half m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public half m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public half m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public half m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public half m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public half m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public half m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public half m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public half2x4(half2 c0, half2 c1, half2 c2, half2 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public half2x4(
        half m00, half m01, half m02, half m03,
        half m10, half m11, half m12, half m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half2x4(half value) => new(value);

    [MethodImpl(256 | 512)]
    public half2x4(half value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half2x4(half2 value) => new(value);

    [MethodImpl(256 | 512)]
    public half2x4(half2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public half2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public half this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // half2x4

#region half3x2

[Serializable]
public partial struct half3x2 :
    IMatrix3x2<half>, IMatrixSelf<half3x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static half3x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static half3x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new((half)1.0); 
    }

    public static half3x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (half)1.0, default,
            default, (half)1.0,
            default, default
        ); 
    }

    #endregion

    #region fields
    public half3 c0;
    public half3 c1;

    #endregion

    #region getter

    public half m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public half m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public half m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public half m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public half m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public half m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public half3x2(half3 c0, half3 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public half3x2(
        half m00, half m01,
        half m10, half m11,
        half m20, half m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half3x2(half value) => new(value);

    [MethodImpl(256 | 512)]
    public half3x2(half value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half3x2(half3 value) => new(value);

    [MethodImpl(256 | 512)]
    public half3x2(half3 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public half3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public half this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // half3x2

#region half3x3

[Serializable]
public partial struct half3x3 :
    IMatrix3x3<half>, IMatrixSelf<half3x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static half3x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static half3x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new((half)1.0); 
    }

    public static half3x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (half)1.0, default, default,
            default, (half)1.0, default,
            default, default, (half)1.0
        ); 
    }

    #endregion

    #region fields
    public half3 c0;
    public half3 c1;
    public half3 c2;

    #endregion

    #region getter

    public half m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public half m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public half m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public half m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public half m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public half m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public half m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public half m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public half m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public half3x3(half3 c0, half3 c1, half3 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public half3x3(
        half m00, half m01, half m02,
        half m10, half m11, half m12,
        half m20, half m21, half m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half3x3(half value) => new(value);

    [MethodImpl(256 | 512)]
    public half3x3(half value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half3x3(half3 value) => new(value);

    [MethodImpl(256 | 512)]
    public half3x3(half3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public half3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public half this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // half3x3

#region half3x4

[Serializable]
public partial struct half3x4 :
    IMatrix3x4<half>, IMatrixSelf<half3x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static half3x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static half3x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new((half)1.0); 
    }

    public static half3x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (half)1.0, default, default, default,
            default, (half)1.0, default, default,
            default, default, (half)1.0, default
        ); 
    }

    #endregion

    #region fields
    public half3 c0;
    public half3 c1;
    public half3 c2;
    public half3 c3;

    #endregion

    #region getter

    public half m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public half m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public half m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public half m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public half m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public half m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public half m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public half m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public half m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public half m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public half m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public half m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public half3x4(half3 c0, half3 c1, half3 c2, half3 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public half3x4(
        half m00, half m01, half m02, half m03,
        half m10, half m11, half m12, half m13,
        half m20, half m21, half m22, half m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half3x4(half value) => new(value);

    [MethodImpl(256 | 512)]
    public half3x4(half value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half3x4(half3 value) => new(value);

    [MethodImpl(256 | 512)]
    public half3x4(half3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public half3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public half this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // half3x4

#region half4x2

[Serializable]
public partial struct half4x2 :
    IMatrix4x2<half>, IMatrixSelf<half4x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static half4x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static half4x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new((half)1.0); 
    }

    public static half4x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (half)1.0, default,
            default, (half)1.0,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region fields
    public half4 c0;
    public half4 c1;

    #endregion

    #region getter

    public half m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public half m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public half m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public half m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public half m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public half m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public half m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public half m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public half4x2(half4 c0, half4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public half4x2(
        half m00, half m01,
        half m10, half m11,
        half m20, half m21,
        half m30, half m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half4x2(half value) => new(value);

    [MethodImpl(256 | 512)]
    public half4x2(half value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half4x2(half4 value) => new(value);

    [MethodImpl(256 | 512)]
    public half4x2(half4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public half4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public half this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // half4x2

#region half4x3

[Serializable]
public partial struct half4x3 :
    IMatrix4x3<half>, IMatrixSelf<half4x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static half4x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static half4x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new((half)1.0); 
    }

    public static half4x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (half)1.0, default, default,
            default, (half)1.0, default,
            default, default, (half)1.0,
            default, default, default
        ); 
    }

    #endregion

    #region fields
    public half4 c0;
    public half4 c1;
    public half4 c2;

    #endregion

    #region getter

    public half m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public half m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public half m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public half m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public half m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public half m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public half m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public half m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public half m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public half m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public half m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public half m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public half4x3(half4 c0, half4 c1, half4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public half4x3(
        half m00, half m01, half m02,
        half m10, half m11, half m12,
        half m20, half m21, half m22,
        half m30, half m31, half m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half4x3(half value) => new(value);

    [MethodImpl(256 | 512)]
    public half4x3(half value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half4x3(half4 value) => new(value);

    [MethodImpl(256 | 512)]
    public half4x3(half4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public half4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public half this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // half4x3

#region half4x4

[Serializable]
public partial struct half4x4 :
    IMatrix4x4<half>, IMatrixSelf<half4x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static half4x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static half4x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new((half)1.0); 
    }

    public static half4x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            (half)1.0, default, default, default,
            default, (half)1.0, default, default,
            default, default, (half)1.0, default,
            default, default, default, (half)1.0
        ); 
    }

    #endregion

    #region fields
    public half4 c0;
    public half4 c1;
    public half4 c2;
    public half4 c3;

    #endregion

    #region getter

    public half m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public half m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public half m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public half m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public half m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public half m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public half m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public half m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public half m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public half m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public half m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public half m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public half m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public half m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public half m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public half m33
    {
        [MethodImpl(256 | 512)]
        get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public half4x4(half4 c0, half4 c1, half4 c2, half4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public half4x4(
        half m00, half m01, half m02, half m03,
        half m10, half m11, half m12, half m13,
        half m20, half m21, half m22, half m23,
        half m30, half m31, half m32, half m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half4x4(half value) => new(value);

    [MethodImpl(256 | 512)]
    public half4x4(half value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half4x4(half4 value) => new(value);

    [MethodImpl(256 | 512)]
    public half4x4(half4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public half4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public half this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // half4x4

#region b16m2x2

[Serializable]
public partial struct b16m2x2 :
    IMatrix2x2<b16>, IMatrixSelf<b16m2x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static b16m2x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b16m2x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b16m2x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true
        ); 
    }

    #endregion

    #region fields
    public b16v2 c0;
    public b16v2 c1;

    #endregion

    #region getter

    public b16 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b16 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b16 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b16 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b16m2x2(b16v2 c0, b16v2 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b16m2x2(
        b16 m00, b16 m01,
        b16 m10, b16 m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m2x2(b16 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m2x2(b16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m2x2(b16v2 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m2x2(b16v2 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public b16v2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // b16m2x2

#region b16m2x3

[Serializable]
public partial struct b16m2x3 :
    IMatrix2x3<b16>, IMatrixSelf<b16m2x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static b16m2x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b16m2x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b16m2x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default
        ); 
    }

    #endregion

    #region fields
    public b16v2 c0;
    public b16v2 c1;
    public b16v2 c2;

    #endregion

    #region getter

    public b16 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b16 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b16 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b16 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b16 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b16 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b16m2x3(b16v2 c0, b16v2 c1, b16v2 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b16m2x3(
        b16 m00, b16 m01, b16 m02,
        b16 m10, b16 m11, b16 m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m2x3(b16 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m2x3(b16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m2x3(b16v2 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m2x3(b16v2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public b16v2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // b16m2x3

#region b16m2x4

[Serializable]
public partial struct b16m2x4 :
    IMatrix2x4<b16>, IMatrixSelf<b16m2x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static b16m2x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b16m2x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b16m2x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default
        ); 
    }

    #endregion

    #region fields
    public b16v2 c0;
    public b16v2 c1;
    public b16v2 c2;
    public b16v2 c3;

    #endregion

    #region getter

    public b16 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b16 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b16 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b16 m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b16 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b16 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b16 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b16 m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b16m2x4(b16v2 c0, b16v2 c1, b16v2 c2, b16v2 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b16m2x4(
        b16 m00, b16 m01, b16 m02, b16 m03,
        b16 m10, b16 m11, b16 m12, b16 m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m2x4(b16 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m2x4(b16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m2x4(b16v2 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m2x4(b16v2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public b16v2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // b16m2x4

#region b16m3x2

[Serializable]
public partial struct b16m3x2 :
    IMatrix3x2<b16>, IMatrixSelf<b16m3x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static b16m3x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b16m3x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b16m3x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true,
            default, default
        ); 
    }

    #endregion

    #region fields
    public b16v3 c0;
    public b16v3 c1;

    #endregion

    #region getter

    public b16 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b16 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b16 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b16 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b16 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b16 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b16m3x2(b16v3 c0, b16v3 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b16m3x2(
        b16 m00, b16 m01,
        b16 m10, b16 m11,
        b16 m20, b16 m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m3x2(b16 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m3x2(b16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m3x2(b16v3 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m3x2(b16v3 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public b16v3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // b16m3x2

#region b16m3x3

[Serializable]
public partial struct b16m3x3 :
    IMatrix3x3<b16>, IMatrixSelf<b16m3x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static b16m3x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b16m3x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b16m3x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default,
            default, default, true
        ); 
    }

    #endregion

    #region fields
    public b16v3 c0;
    public b16v3 c1;
    public b16v3 c2;

    #endregion

    #region getter

    public b16 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b16 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b16 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b16 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b16 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b16 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b16 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b16 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b16 m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b16m3x3(b16v3 c0, b16v3 c1, b16v3 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b16m3x3(
        b16 m00, b16 m01, b16 m02,
        b16 m10, b16 m11, b16 m12,
        b16 m20, b16 m21, b16 m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m3x3(b16 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m3x3(b16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m3x3(b16v3 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m3x3(b16v3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public b16v3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // b16m3x3

#region b16m3x4

[Serializable]
public partial struct b16m3x4 :
    IMatrix3x4<b16>, IMatrixSelf<b16m3x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static b16m3x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b16m3x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b16m3x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default,
            default, default, true, default
        ); 
    }

    #endregion

    #region fields
    public b16v3 c0;
    public b16v3 c1;
    public b16v3 c2;
    public b16v3 c3;

    #endregion

    #region getter

    public b16 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b16 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b16 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b16 m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b16 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b16 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b16 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b16 m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public b16 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b16 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b16 m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b16 m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b16m3x4(b16v3 c0, b16v3 c1, b16v3 c2, b16v3 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b16m3x4(
        b16 m00, b16 m01, b16 m02, b16 m03,
        b16 m10, b16 m11, b16 m12, b16 m13,
        b16 m20, b16 m21, b16 m22, b16 m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m3x4(b16 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m3x4(b16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m3x4(b16v3 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m3x4(b16v3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public b16v3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // b16m3x4

#region b16m4x2

[Serializable]
public partial struct b16m4x2 :
    IMatrix4x2<b16>, IMatrixSelf<b16m4x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static b16m4x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b16m4x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b16m4x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region fields
    public b16v4 c0;
    public b16v4 c1;

    #endregion

    #region getter

    public b16 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b16 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b16 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b16 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b16 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b16 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b16 m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b16 m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b16m4x2(b16v4 c0, b16v4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b16m4x2(
        b16 m00, b16 m01,
        b16 m10, b16 m11,
        b16 m20, b16 m21,
        b16 m30, b16 m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m4x2(b16 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m4x2(b16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m4x2(b16v4 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m4x2(b16v4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public b16v4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // b16m4x2

#region b16m4x3

[Serializable]
public partial struct b16m4x3 :
    IMatrix4x3<b16>, IMatrixSelf<b16m4x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static b16m4x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b16m4x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b16m4x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default,
            default, default, true,
            default, default, default
        ); 
    }

    #endregion

    #region fields
    public b16v4 c0;
    public b16v4 c1;
    public b16v4 c2;

    #endregion

    #region getter

    public b16 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b16 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b16 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b16 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b16 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b16 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b16 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b16 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b16 m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b16 m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b16 m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public b16 m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b16m4x3(b16v4 c0, b16v4 c1, b16v4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b16m4x3(
        b16 m00, b16 m01, b16 m02,
        b16 m10, b16 m11, b16 m12,
        b16 m20, b16 m21, b16 m22,
        b16 m30, b16 m31, b16 m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m4x3(b16 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m4x3(b16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m4x3(b16v4 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m4x3(b16v4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public b16v4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // b16m4x3

#region b16m4x4

[Serializable]
public partial struct b16m4x4 :
    IMatrix4x4<b16>, IMatrixSelf<b16m4x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static b16m4x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b16m4x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b16m4x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default,
            default, default, true, default,
            default, default, default, true
        ); 
    }

    #endregion

    #region fields
    public b16v4 c0;
    public b16v4 c1;
    public b16v4 c2;
    public b16v4 c3;

    #endregion

    #region getter

    public b16 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b16 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b16 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b16 m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b16 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b16 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b16 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b16 m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public b16 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b16 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b16 m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b16 m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public b16 m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b16 m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public b16 m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public b16 m33
    {
        [MethodImpl(256 | 512)]
        get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b16m4x4(b16v4 c0, b16v4 c1, b16v4 c2, b16v4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b16m4x4(
        b16 m00, b16 m01, b16 m02, b16 m03,
        b16 m10, b16 m11, b16 m12, b16 m13,
        b16 m20, b16 m21, b16 m22, b16 m23,
        b16 m30, b16 m31, b16 m32, b16 m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m4x4(b16 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m4x4(b16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16m4x4(b16v4 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16m4x4(b16v4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public b16v4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // b16m4x4

#region b32m2x2

[Serializable]
public partial struct b32m2x2 :
    IMatrix2x2<b32>, IMatrixSelf<b32m2x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static b32m2x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b32m2x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b32m2x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true
        ); 
    }

    #endregion

    #region fields
    public b32v2 c0;
    public b32v2 c1;

    #endregion

    #region getter

    public b32 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b32m2x2(b32v2 c0, b32v2 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b32m2x2(
        b32 m00, b32 m01,
        b32 m10, b32 m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x2(b32 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m2x2(b32 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x2(b32v2 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m2x2(b32v2 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public b32v2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // b32m2x2

#region b32m2x3

[Serializable]
public partial struct b32m2x3 :
    IMatrix2x3<b32>, IMatrixSelf<b32m2x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static b32m2x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b32m2x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b32m2x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default
        ); 
    }

    #endregion

    #region fields
    public b32v2 c0;
    public b32v2 c1;
    public b32v2 c2;

    #endregion

    #region getter

    public b32 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b32 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b32m2x3(b32v2 c0, b32v2 c1, b32v2 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b32m2x3(
        b32 m00, b32 m01, b32 m02,
        b32 m10, b32 m11, b32 m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x3(b32 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m2x3(b32 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x3(b32v2 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m2x3(b32v2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public b32v2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // b32m2x3

#region b32m2x4

[Serializable]
public partial struct b32m2x4 :
    IMatrix2x4<b32>, IMatrixSelf<b32m2x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static b32m2x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b32m2x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b32m2x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default
        ); 
    }

    #endregion

    #region fields
    public b32v2 c0;
    public b32v2 c1;
    public b32v2 c2;
    public b32v2 c3;

    #endregion

    #region getter

    public b32 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b32 m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b32 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b32 m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b32m2x4(b32v2 c0, b32v2 c1, b32v2 c2, b32v2 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b32m2x4(
        b32 m00, b32 m01, b32 m02, b32 m03,
        b32 m10, b32 m11, b32 m12, b32 m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x4(b32 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m2x4(b32 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x4(b32v2 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m2x4(b32v2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public b32v2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // b32m2x4

#region b32m3x2

[Serializable]
public partial struct b32m3x2 :
    IMatrix3x2<b32>, IMatrixSelf<b32m3x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static b32m3x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b32m3x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b32m3x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true,
            default, default
        ); 
    }

    #endregion

    #region fields
    public b32v3 c0;
    public b32v3 c1;

    #endregion

    #region getter

    public b32 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b32 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b32m3x2(b32v3 c0, b32v3 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b32m3x2(
        b32 m00, b32 m01,
        b32 m10, b32 m11,
        b32 m20, b32 m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x2(b32 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m3x2(b32 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x2(b32v3 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m3x2(b32v3 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public b32v3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // b32m3x2

#region b32m3x3

[Serializable]
public partial struct b32m3x3 :
    IMatrix3x3<b32>, IMatrixSelf<b32m3x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static b32m3x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b32m3x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b32m3x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default,
            default, default, true
        ); 
    }

    #endregion

    #region fields
    public b32v3 c0;
    public b32v3 c1;
    public b32v3 c2;

    #endregion

    #region getter

    public b32 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b32 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b32 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b32 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b32 m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b32m3x3(b32v3 c0, b32v3 c1, b32v3 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b32m3x3(
        b32 m00, b32 m01, b32 m02,
        b32 m10, b32 m11, b32 m12,
        b32 m20, b32 m21, b32 m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x3(b32 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m3x3(b32 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x3(b32v3 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m3x3(b32v3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public b32v3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // b32m3x3

#region b32m3x4

[Serializable]
public partial struct b32m3x4 :
    IMatrix3x4<b32>, IMatrixSelf<b32m3x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static b32m3x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b32m3x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b32m3x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default,
            default, default, true, default
        ); 
    }

    #endregion

    #region fields
    public b32v3 c0;
    public b32v3 c1;
    public b32v3 c2;
    public b32v3 c3;

    #endregion

    #region getter

    public b32 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b32 m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b32 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b32 m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public b32 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b32 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b32 m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b32 m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b32m3x4(b32v3 c0, b32v3 c1, b32v3 c2, b32v3 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b32m3x4(
        b32 m00, b32 m01, b32 m02, b32 m03,
        b32 m10, b32 m11, b32 m12, b32 m13,
        b32 m20, b32 m21, b32 m22, b32 m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x4(b32 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m3x4(b32 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x4(b32v3 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m3x4(b32v3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public b32v3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // b32m3x4

#region b32m4x2

[Serializable]
public partial struct b32m4x2 :
    IMatrix4x2<b32>, IMatrixSelf<b32m4x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static b32m4x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b32m4x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b32m4x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region fields
    public b32v4 c0;
    public b32v4 c1;

    #endregion

    #region getter

    public b32 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b32 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b32 m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b32 m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b32m4x2(b32v4 c0, b32v4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b32m4x2(
        b32 m00, b32 m01,
        b32 m10, b32 m11,
        b32 m20, b32 m21,
        b32 m30, b32 m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x2(b32 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m4x2(b32 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x2(b32v4 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m4x2(b32v4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public b32v4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // b32m4x2

#region b32m4x3

[Serializable]
public partial struct b32m4x3 :
    IMatrix4x3<b32>, IMatrixSelf<b32m4x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static b32m4x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b32m4x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b32m4x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default,
            default, default, true,
            default, default, default
        ); 
    }

    #endregion

    #region fields
    public b32v4 c0;
    public b32v4 c1;
    public b32v4 c2;

    #endregion

    #region getter

    public b32 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b32 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b32 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b32 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b32 m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b32 m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b32 m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public b32 m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b32m4x3(b32v4 c0, b32v4 c1, b32v4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b32m4x3(
        b32 m00, b32 m01, b32 m02,
        b32 m10, b32 m11, b32 m12,
        b32 m20, b32 m21, b32 m22,
        b32 m30, b32 m31, b32 m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x3(b32 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m4x3(b32 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x3(b32v4 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m4x3(b32v4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public b32v4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // b32m4x3

#region b32m4x4

[Serializable]
public partial struct b32m4x4 :
    IMatrix4x4<b32>, IMatrixSelf<b32m4x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static b32m4x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b32m4x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b32m4x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default,
            default, default, true, default,
            default, default, default, true
        ); 
    }

    #endregion

    #region fields
    public b32v4 c0;
    public b32v4 c1;
    public b32v4 c2;
    public b32v4 c3;

    #endregion

    #region getter

    public b32 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b32 m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b32 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b32 m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public b32 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b32 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b32 m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b32 m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public b32 m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b32 m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public b32 m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public b32 m33
    {
        [MethodImpl(256 | 512)]
        get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b32m4x4(b32v4 c0, b32v4 c1, b32v4 c2, b32v4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b32m4x4(
        b32 m00, b32 m01, b32 m02, b32 m03,
        b32 m10, b32 m11, b32 m12, b32 m13,
        b32 m20, b32 m21, b32 m22, b32 m23,
        b32 m30, b32 m31, b32 m32, b32 m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x4(b32 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m4x4(b32 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x4(b32v4 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32m4x4(b32v4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public b32v4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // b32m4x4

#region b64m2x2

[Serializable]
public partial struct b64m2x2 :
    IMatrix2x2<b64>, IMatrixSelf<b64m2x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static b64m2x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b64m2x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b64m2x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true
        ); 
    }

    #endregion

    #region fields
    public b64v2 c0;
    public b64v2 c1;

    #endregion

    #region getter

    public b64 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b64m2x2(b64v2 c0, b64v2 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b64m2x2(
        b64 m00, b64 m01,
        b64 m10, b64 m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x2(b64 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m2x2(b64 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x2(b64v2 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m2x2(b64v2 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public b64v2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // b64m2x2

#region b64m2x3

[Serializable]
public partial struct b64m2x3 :
    IMatrix2x3<b64>, IMatrixSelf<b64m2x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static b64m2x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b64m2x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b64m2x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default
        ); 
    }

    #endregion

    #region fields
    public b64v2 c0;
    public b64v2 c1;
    public b64v2 c2;

    #endregion

    #region getter

    public b64 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b64 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b64m2x3(b64v2 c0, b64v2 c1, b64v2 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b64m2x3(
        b64 m00, b64 m01, b64 m02,
        b64 m10, b64 m11, b64 m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x3(b64 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m2x3(b64 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x3(b64v2 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m2x3(b64v2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public b64v2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // b64m2x3

#region b64m2x4

[Serializable]
public partial struct b64m2x4 :
    IMatrix2x4<b64>, IMatrixSelf<b64m2x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static b64m2x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b64m2x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b64m2x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default
        ); 
    }

    #endregion

    #region fields
    public b64v2 c0;
    public b64v2 c1;
    public b64v2 c2;
    public b64v2 c3;

    #endregion

    #region getter

    public b64 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b64 m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b64 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b64 m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b64m2x4(b64v2 c0, b64v2 c1, b64v2 c2, b64v2 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b64m2x4(
        b64 m00, b64 m01, b64 m02, b64 m03,
        b64 m10, b64 m11, b64 m12, b64 m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x4(b64 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m2x4(b64 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x4(b64v2 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m2x4(b64v2 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public b64v2 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // b64m2x4

#region b64m3x2

[Serializable]
public partial struct b64m3x2 :
    IMatrix3x2<b64>, IMatrixSelf<b64m3x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static b64m3x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b64m3x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b64m3x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true,
            default, default
        ); 
    }

    #endregion

    #region fields
    public b64v3 c0;
    public b64v3 c1;

    #endregion

    #region getter

    public b64 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b64 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b64m3x2(b64v3 c0, b64v3 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b64m3x2(
        b64 m00, b64 m01,
        b64 m10, b64 m11,
        b64 m20, b64 m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x2(b64 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m3x2(b64 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x2(b64v3 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m3x2(b64v3 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public b64v3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // b64m3x2

#region b64m3x3

[Serializable]
public partial struct b64m3x3 :
    IMatrix3x3<b64>, IMatrixSelf<b64m3x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static b64m3x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b64m3x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b64m3x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default,
            default, default, true
        ); 
    }

    #endregion

    #region fields
    public b64v3 c0;
    public b64v3 c1;
    public b64v3 c2;

    #endregion

    #region getter

    public b64 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b64 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b64 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b64 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b64 m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b64m3x3(b64v3 c0, b64v3 c1, b64v3 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b64m3x3(
        b64 m00, b64 m01, b64 m02,
        b64 m10, b64 m11, b64 m12,
        b64 m20, b64 m21, b64 m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x3(b64 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m3x3(b64 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x3(b64v3 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m3x3(b64v3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public b64v3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // b64m3x3

#region b64m3x4

[Serializable]
public partial struct b64m3x4 :
    IMatrix3x4<b64>, IMatrixSelf<b64m3x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static b64m3x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b64m3x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b64m3x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default,
            default, default, true, default
        ); 
    }

    #endregion

    #region fields
    public b64v3 c0;
    public b64v3 c1;
    public b64v3 c2;
    public b64v3 c3;

    #endregion

    #region getter

    public b64 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b64 m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b64 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b64 m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public b64 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b64 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b64 m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b64 m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b64m3x4(b64v3 c0, b64v3 c1, b64v3 c2, b64v3 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b64m3x4(
        b64 m00, b64 m01, b64 m02, b64 m03,
        b64 m10, b64 m11, b64 m12, b64 m13,
        b64 m20, b64 m21, b64 m22, b64 m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x4(b64 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m3x4(b64 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x4(b64v3 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m3x4(b64v3 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public b64v3 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // b64m3x4

#region b64m4x2

[Serializable]
public partial struct b64m4x2 :
    IMatrix4x2<b64>, IMatrixSelf<b64m4x2>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static b64m4x2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b64m4x2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b64m4x2 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region fields
    public b64v4 c0;
    public b64v4 c1;

    #endregion

    #region getter

    public b64 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b64 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b64 m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b64 m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b64m4x2(b64v4 c0, b64v4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b64m4x2(
        b64 m00, b64 m01,
        b64 m10, b64 m11,
        b64 m20, b64 m21,
        b64 m30, b64 m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x2(b64 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m4x2(b64 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x2(b64v4 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m4x2(b64v4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Index

    public b64v4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // b64m4x2

#region b64m4x3

[Serializable]
public partial struct b64m4x3 :
    IMatrix4x3<b64>, IMatrixSelf<b64m4x3>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static b64m4x3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b64m4x3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b64m4x3 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default,
            default, default, true,
            default, default, default
        ); 
    }

    #endregion

    #region fields
    public b64v4 c0;
    public b64v4 c1;
    public b64v4 c2;

    #endregion

    #region getter

    public b64 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b64 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b64 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b64 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b64 m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b64 m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b64 m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public b64 m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b64m4x3(b64v4 c0, b64v4 c1, b64v4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b64m4x3(
        b64 m00, b64 m01, b64 m02,
        b64 m10, b64 m11, b64 m12,
        b64 m20, b64 m21, b64 m22,
        b64 m30, b64 m31, b64 m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x3(b64 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m4x3(b64 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x3(b64v4 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m4x3(b64v4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Index

    public b64v4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // b64m4x3

#region b64m4x4

[Serializable]
public partial struct b64m4x4 :
    IMatrix4x4<b64>, IMatrixSelf<b64m4x4>
{
    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static b64m4x4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b64m4x4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    public static b64m4x4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default,
            default, default, true, default,
            default, default, default, true
        ); 
    }

    #endregion

    #region fields
    public b64v4 c0;
    public b64v4 c1;
    public b64v4 c2;
    public b64v4 c3;

    #endregion

    #region getter

    public b64 m00
    {
        [MethodImpl(256 | 512)]
        get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64 m01
    {
        [MethodImpl(256 | 512)]
        get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64 m02
    {
        [MethodImpl(256 | 512)]
        get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b64 m03
    {
        [MethodImpl(256 | 512)]
        get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b64 m10
    {
        [MethodImpl(256 | 512)]
        get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64 m11
    {
        [MethodImpl(256 | 512)]
        get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64 m12
    {
        [MethodImpl(256 | 512)]
        get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b64 m13
    {
        [MethodImpl(256 | 512)]
        get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public b64 m20
    {
        [MethodImpl(256 | 512)]
        get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b64 m21
    {
        [MethodImpl(256 | 512)]
        get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b64 m22
    {
        [MethodImpl(256 | 512)]
        get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b64 m23
    {
        [MethodImpl(256 | 512)]
        get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public b64 m30
    {
        [MethodImpl(256 | 512)]
        get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b64 m31
    {
        [MethodImpl(256 | 512)]
        get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public b64 m32
    {
        [MethodImpl(256 | 512)]
        get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public b64 m33
    {
        [MethodImpl(256 | 512)]
        get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    #endregion

    #region ctor

    [MethodImpl(256 | 512)]
    public b64m4x4(b64v4 c0, b64v4 c1, b64v4 c2, b64v4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b64m4x4(
        b64 m00, b64 m01, b64 m02, b64 m03,
        b64 m10, b64 m11, b64 m12, b64 m13,
        b64 m20, b64 m21, b64 m22, b64 m23,
        b64 m30, b64 m31, b64 m32, b64 m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x4(b64 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m4x4(b64 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x4(b64v4 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64m4x4(b64v4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Index

    public b64v4 this[int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index
}

#endregion // b64m4x4
