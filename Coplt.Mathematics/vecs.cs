// generated by template, do not modify manually

using System;
#if NET8_0_OR_GREATER
using System.Numerics;
using System.Runtime.Intrinsics;
#endif
using System.Runtime.CompilerServices;
using System.Diagnostics.CodeAnalysis;
using half = System.Half;

namespace Coplt.Mathematics;
#region float2

public partial struct float2 : 
    IVector2<float>, IVectorSelf<float2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 64; 
    }

    public static float2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static float2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0f); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector64<float> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector64<float>(float2 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector64<float> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector64<float> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector64<float> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public float x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public float y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private float _x;
    public float x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private float _y;
    public float y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    #endif // NET8_0_OR_GREATER
    public float r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public float g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal float2(Vector64<float> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static float2 UnsafeFromInner(Vector64<float> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public float2(float x, float y)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.Create(x, y);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2(float value) => new(value);

    [MethodImpl(256 | 512)]
    public float2(float value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.Create(value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 Scalar(float value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal float2(float value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

}

#endregion // float2
#region float3

public partial struct float3 : 
    IVector3<float>, IVectorSelf<float3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128; 
    }

    public static float3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static float3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0f); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<float> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<float>(float3 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<float> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<float> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<float> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public float x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public float y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public float z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private float _x;
    public float x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private float _y;
    public float y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private float _z;
    public float z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private float _align;
    #endif // NET8_0_OR_GREATER
    public float r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public float g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public float b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal float3(Vector128<float> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static float3 UnsafeFromInner(Vector128<float> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public float3(float x, float y, float z)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y, z, default);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3(float value) => new(value);

    [MethodImpl(256 | 512)]
    public float3(float value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(value, value, value, default);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 Scalar(float value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal float3(float value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

}

#endregion // float3
#region float4

public partial struct float4 : 
    IVector4<float>, IVectorSelf<float4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128; 
    }

    public static float4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static float4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0f); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<float> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<float>(float4 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<float> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<float> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<float> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public float x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public float y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public float z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public float w
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(3);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private float _x;
    public float x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private float _y;
    public float y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private float _z;
    public float z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private float _w;
    public float w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    #endif // NET8_0_OR_GREATER
    public float r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public float g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public float b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public float a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal float4(Vector128<float> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static float4 UnsafeFromInner(Vector128<float> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public float4(float x, float y, float z, float w)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y, z, w);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4(float value) => new(value);

    [MethodImpl(256 | 512)]
    public float4(float value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        w = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 Scalar(float value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal float4(float value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

}

#endregion // float4
#region double2

public partial struct double2 : 
    IVector2<double>, IVectorSelf<double2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128; 
    }

    public static double2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static double2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<double> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<double>(double2 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<double> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<double> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<double> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public double x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public double y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private double _x;
    public double x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private double _y;
    public double y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    #endif // NET8_0_OR_GREATER
    public double r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public double g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal double2(Vector128<double> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static double2 UnsafeFromInner(Vector128<double> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public double2(double x, double y)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2(double value) => new(value);

    [MethodImpl(256 | 512)]
    public double2(double value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 Scalar(double value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal double2(double value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

}

#endregion // double2
#region double3

public partial struct double3 : 
    IVector3<double>, IVectorSelf<double3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 32; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 256; 
    }

    public static double3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static double3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector256<double> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector256<double>(double3 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector256<double> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector256<double> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector256<double> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public double x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public double y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public double z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private double _x;
    public double x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private double _y;
    public double y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private double _z;
    public double z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private double _align;
    #endif // NET8_0_OR_GREATER
    public double r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public double g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public double b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal double3(Vector256<double> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static double3 UnsafeFromInner(Vector256<double> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public double3(double x, double y, double z)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(x, y, z, default);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3(double value) => new(value);

    [MethodImpl(256 | 512)]
    public double3(double value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(value, value, value, default);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 Scalar(double value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal double3(double value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

}

#endregion // double3
#region double4

public partial struct double4 : 
    IVector4<double>, IVectorSelf<double4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 32; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 256; 
    }

    public static double4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static double4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector256<double> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector256<double>(double4 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector256<double> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector256<double> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector256<double> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public double x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public double y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public double z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public double w
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(3);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private double _x;
    public double x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private double _y;
    public double y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private double _z;
    public double z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private double _w;
    public double w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    #endif // NET8_0_OR_GREATER
    public double r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public double g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public double b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public double a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal double4(Vector256<double> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static double4 UnsafeFromInner(Vector256<double> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public double4(double x, double y, double z, double w)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(x, y, z, w);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4(double value) => new(value);

    [MethodImpl(256 | 512)]
    public double4(double value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        w = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 Scalar(double value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal double4(double value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

}

#endregion // double4
#region int2

public partial struct int2 : 
    IVector2<int>, IVectorSelf<int2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 64; 
    }

    public static int2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static int2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector64<int> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector64<int>(int2 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector64<int> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector64<int> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector64<int> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public int x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public int y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private int _x;
    public int x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private int _y;
    public int y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    #endif // NET8_0_OR_GREATER
    public int r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public int g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal int2(Vector64<int> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static int2 UnsafeFromInner(Vector64<int> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public int2(int x, int y)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.Create(x, y);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2(int value) => new(value);

    [MethodImpl(256 | 512)]
    public int2(int value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.Create(value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 Scalar(int value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal int2(int value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

}

#endregion // int2
#region int3

public partial struct int3 : 
    IVector3<int>, IVectorSelf<int3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128; 
    }

    public static int3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static int3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<int> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<int>(int3 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<int> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<int> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<int> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public int x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public int y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public int z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private int _x;
    public int x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private int _y;
    public int y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private int _z;
    public int z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private int _align;
    #endif // NET8_0_OR_GREATER
    public int r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public int g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public int b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal int3(Vector128<int> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static int3 UnsafeFromInner(Vector128<int> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public int3(int x, int y, int z)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y, z, default);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3(int value) => new(value);

    [MethodImpl(256 | 512)]
    public int3(int value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(value, value, value, default);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 Scalar(int value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal int3(int value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

}

#endregion // int3
#region int4

public partial struct int4 : 
    IVector4<int>, IVectorSelf<int4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128; 
    }

    public static int4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static int4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<int> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<int>(int4 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<int> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<int> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<int> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public int x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public int y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public int z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public int w
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(3);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private int _x;
    public int x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private int _y;
    public int y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private int _z;
    public int z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private int _w;
    public int w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    #endif // NET8_0_OR_GREATER
    public int r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public int g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public int b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public int a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal int4(Vector128<int> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static int4 UnsafeFromInner(Vector128<int> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public int4(int x, int y, int z, int w)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y, z, w);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4(int value) => new(value);

    [MethodImpl(256 | 512)]
    public int4(int value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        w = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 Scalar(int value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal int4(int value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

}

#endregion // int4
#region uint2

public partial struct uint2 : 
    IVector2<uint>, IVectorSelf<uint2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 64; 
    }

    public static uint2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static uint2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1u); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector64<uint> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector64<uint>(uint2 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector64<uint> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector64<uint> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector64<uint> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public uint x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public uint y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private uint _x;
    public uint x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private uint _y;
    public uint y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    #endif // NET8_0_OR_GREATER
    public uint r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public uint g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal uint2(Vector64<uint> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static uint2 UnsafeFromInner(Vector64<uint> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public uint2(uint x, uint y)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.Create(x, y);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public uint2(uint value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.Create(value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 Scalar(uint value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal uint2(uint value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

}

#endregion // uint2
#region uint3

public partial struct uint3 : 
    IVector3<uint>, IVectorSelf<uint3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128; 
    }

    public static uint3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static uint3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1u); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<uint> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<uint>(uint3 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<uint> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<uint> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<uint> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public uint x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public uint y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public uint z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private uint _x;
    public uint x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private uint _y;
    public uint y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private uint _z;
    public uint z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private uint _align;
    #endif // NET8_0_OR_GREATER
    public uint r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public uint g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public uint b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal uint3(Vector128<uint> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static uint3 UnsafeFromInner(Vector128<uint> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public uint3(uint x, uint y, uint z)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y, z, default);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public uint3(uint value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(value, value, value, default);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 Scalar(uint value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal uint3(uint value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

}

#endregion // uint3
#region uint4

public partial struct uint4 : 
    IVector4<uint>, IVectorSelf<uint4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128; 
    }

    public static uint4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static uint4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1u); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<uint> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<uint>(uint4 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<uint> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<uint> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<uint> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public uint x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public uint y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public uint z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public uint w
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(3);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private uint _x;
    public uint x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private uint _y;
    public uint y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private uint _z;
    public uint z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private uint _w;
    public uint w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    #endif // NET8_0_OR_GREATER
    public uint r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public uint g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public uint b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public uint a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal uint4(Vector128<uint> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static uint4 UnsafeFromInner(Vector128<uint> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public uint4(uint x, uint y, uint z, uint w)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y, z, w);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public uint4(uint value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        w = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 Scalar(uint value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal uint4(uint value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

}

#endregion // uint4
#region long2

public partial struct long2 : 
    IVector2<long>, IVectorSelf<long2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128; 
    }

    public static long2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static long2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1L); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<long> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<long>(long2 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<long> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<long> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<long> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public long x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public long y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private long _x;
    public long x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private long _y;
    public long y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    #endif // NET8_0_OR_GREATER
    public long r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public long g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal long2(Vector128<long> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static long2 UnsafeFromInner(Vector128<long> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public long2(long x, long y)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2(long value) => new(value);

    [MethodImpl(256 | 512)]
    public long2(long value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 Scalar(long value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal long2(long value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

}

#endregion // long2
#region long3

public partial struct long3 : 
    IVector3<long>, IVectorSelf<long3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 32; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 256; 
    }

    public static long3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static long3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1L); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector256<long> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector256<long>(long3 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector256<long> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector256<long> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector256<long> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public long x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public long y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public long z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private long _x;
    public long x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private long _y;
    public long y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private long _z;
    public long z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private long _align;
    #endif // NET8_0_OR_GREATER
    public long r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public long g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public long b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal long3(Vector256<long> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static long3 UnsafeFromInner(Vector256<long> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public long3(long x, long y, long z)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(x, y, z, default);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3(long value) => new(value);

    [MethodImpl(256 | 512)]
    public long3(long value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(value, value, value, default);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 Scalar(long value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal long3(long value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

}

#endregion // long3
#region long4

public partial struct long4 : 
    IVector4<long>, IVectorSelf<long4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 32; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 256; 
    }

    public static long4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static long4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1L); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector256<long> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector256<long>(long4 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector256<long> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector256<long> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector256<long> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public long x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public long y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public long z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public long w
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(3);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private long _x;
    public long x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private long _y;
    public long y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private long _z;
    public long z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private long _w;
    public long w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    #endif // NET8_0_OR_GREATER
    public long r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public long g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public long b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public long a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal long4(Vector256<long> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static long4 UnsafeFromInner(Vector256<long> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public long4(long x, long y, long z, long w)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(x, y, z, w);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4(long value) => new(value);

    [MethodImpl(256 | 512)]
    public long4(long value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        w = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 Scalar(long value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal long4(long value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

}

#endregion // long4
#region ulong2

public partial struct ulong2 : 
    IVector2<ulong>, IVectorSelf<ulong2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128; 
    }

    public static ulong2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ulong2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1UL); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<ulong> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<ulong>(ulong2 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<ulong> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<ulong> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<ulong> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public ulong x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public ulong y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private ulong _x;
    public ulong x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private ulong _y;
    public ulong y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    #endif // NET8_0_OR_GREATER
    public ulong r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public ulong g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal ulong2(Vector128<ulong> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static ulong2 UnsafeFromInner(Vector128<ulong> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public ulong2(ulong x, ulong y)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong2(ulong value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 Scalar(ulong value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal ulong2(ulong value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

}

#endregion // ulong2
#region ulong3

public partial struct ulong3 : 
    IVector3<ulong>, IVectorSelf<ulong3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 32; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 256; 
    }

    public static ulong3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ulong3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1UL); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector256<ulong> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector256<ulong>(ulong3 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector256<ulong> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector256<ulong> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector256<ulong> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public ulong x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public ulong y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public ulong z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private ulong _x;
    public ulong x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private ulong _y;
    public ulong y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private ulong _z;
    public ulong z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private ulong _align;
    #endif // NET8_0_OR_GREATER
    public ulong r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public ulong g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public ulong b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal ulong3(Vector256<ulong> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static ulong3 UnsafeFromInner(Vector256<ulong> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public ulong3(ulong x, ulong y, ulong z)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(x, y, z, default);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong3(ulong value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(value, value, value, default);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 Scalar(ulong value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal ulong3(ulong value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

}

#endregion // ulong3
#region ulong4

public partial struct ulong4 : 
    IVector4<ulong>, IVectorSelf<ulong4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 32; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 256; 
    }

    public static ulong4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ulong4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1UL); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector256<ulong> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector256<ulong>(ulong4 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector256<ulong> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector256<ulong> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector256<ulong> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public ulong x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public ulong y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public ulong z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public ulong w
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(3);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private ulong _x;
    public ulong x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private ulong _y;
    public ulong y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private ulong _z;
    public ulong z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private ulong _w;
    public ulong w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    #endif // NET8_0_OR_GREATER
    public ulong r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public ulong g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public ulong b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public ulong a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal ulong4(Vector256<ulong> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static ulong4 UnsafeFromInner(Vector256<ulong> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public ulong4(ulong x, ulong y, ulong z, ulong w)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(x, y, z, w);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong4(ulong value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        w = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 Scalar(ulong value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal ulong4(ulong value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

}

#endregion // ulong4
#region decimal2

public partial struct decimal2 : 
    IVector2<decimal>, IVectorSelf<decimal2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 32; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 256; 
    }

    public static decimal2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static decimal2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1m); 
    }

    #endregion

    #region fields

    private decimal _x;
    public decimal x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private decimal _y;
    public decimal y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    public decimal r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public decimal g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public decimal2(decimal x, decimal y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal2(decimal value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal2(decimal value)
    {
        x = value;
        y = value;
    }

    [MethodImpl(256 | 512)]
    public static decimal2 Scalar(decimal value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal decimal2(decimal value, is_scalar _)
    {
        x = value;
    }

    #endregion // ctors

}

#endregion // decimal2
#region decimal3

public partial struct decimal3 : 
    IVector3<decimal>, IVectorSelf<decimal3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 64; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 512; 
    }

    public static decimal3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static decimal3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1m); 
    }

    #endregion

    #region fields

    private decimal _x;
    public decimal x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private decimal _y;
    public decimal y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private decimal _z;
    public decimal z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private decimal _align;
    public decimal r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public decimal g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public decimal b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public decimal3(decimal x, decimal y, decimal z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal3(decimal value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal3(decimal value)
    {
        x = value;
        y = value;
        z = value;
    }

    [MethodImpl(256 | 512)]
    public static decimal3 Scalar(decimal value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal decimal3(decimal value, is_scalar _)
    {
        x = value;
    }

    #endregion // ctors

}

#endregion // decimal3
#region decimal4

public partial struct decimal4 : 
    IVector4<decimal>, IVectorSelf<decimal4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 64; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 512; 
    }

    public static decimal4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static decimal4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1m); 
    }

    #endregion

    #region fields

    private decimal _x;
    public decimal x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private decimal _y;
    public decimal y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private decimal _z;
    public decimal z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private decimal _w;
    public decimal w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    public decimal r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public decimal g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public decimal b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public decimal a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public decimal4(decimal x, decimal y, decimal z, decimal w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal4(decimal value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal4(decimal value)
    {
        x = value;
        y = value;
        z = value;
        w = value;
    }

    [MethodImpl(256 | 512)]
    public static decimal4 Scalar(decimal value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal decimal4(decimal value, is_scalar _)
    {
        x = value;
    }

    #endregion // ctors

}

#endregion // decimal4
#region half2

public partial struct half2 : 
    IVector2<half>, IVectorSelf<half2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 32; 
    }

    public static half2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static half2 One
    { 
        [MethodImpl(256 | 512)]
        get => new((half)1.0); 
    }

    #endregion

    #region fields

    private half _x;
    public half x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private half _y;
    public half y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    public half r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public half g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public half2(half x, half y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half2(half value) => new(value);

    [MethodImpl(256 | 512)]
    public half2(half value)
    {
        x = value;
        y = value;
    }

    [MethodImpl(256 | 512)]
    public static half2 Scalar(half value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal half2(half value, is_scalar _)
    {
        x = value;
    }

    #endregion // ctors

}

#endregion // half2
#region half3

public partial struct half3 : 
    IVector3<half>, IVectorSelf<half3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 64; 
    }

    public static half3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static half3 One
    { 
        [MethodImpl(256 | 512)]
        get => new((half)1.0); 
    }

    #endregion

    #region fields

    private half _x;
    public half x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private half _y;
    public half y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private half _z;
    public half z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private half _align;
    public half r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public half g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public half b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public half3(half x, half y, half z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half3(half value) => new(value);

    [MethodImpl(256 | 512)]
    public half3(half value)
    {
        x = value;
        y = value;
        z = value;
    }

    [MethodImpl(256 | 512)]
    public static half3 Scalar(half value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal half3(half value, is_scalar _)
    {
        x = value;
    }

    #endregion // ctors

}

#endregion // half3
#region half4

public partial struct half4 : 
    IVector4<half>, IVectorSelf<half4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 64; 
    }

    public static half4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static half4 One
    { 
        [MethodImpl(256 | 512)]
        get => new((half)1.0); 
    }

    #endregion

    #region fields

    private half _x;
    public half x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private half _y;
    public half y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private half _z;
    public half z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private half _w;
    public half w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    public half r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public half g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public half b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public half a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public half4(half x, half y, half z, half w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half4(half value) => new(value);

    [MethodImpl(256 | 512)]
    public half4(half value)
    {
        x = value;
        y = value;
        z = value;
        w = value;
    }

    [MethodImpl(256 | 512)]
    public static half4 Scalar(half value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal half4(half value, is_scalar _)
    {
        x = value;
    }

    #endregion // ctors

}

#endregion // half4
#region bool2

public partial struct bool2 : 
    IVector2<bool>, IVectorSelf<bool2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 2; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static bool2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static bool2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    #endregion

    #region fields

    private bool _x;
    public bool x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private bool _y;
    public bool y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    public bool r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public bool g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public bool2(bool x, bool y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator bool2(bool value) => new(value);

    [MethodImpl(256 | 512)]
    public bool2(bool value)
    {
        x = value;
        y = value;
    }

    [MethodImpl(256 | 512)]
    public static bool2 Scalar(bool value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal bool2(bool value, is_scalar _)
    {
        x = value;
    }

    #endregion // ctors

}

#endregion // bool2
#region bool3

public partial struct bool3 : 
    IVector3<bool>, IVectorSelf<bool3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 32; 
    }

    public static bool3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static bool3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    #endregion

    #region fields

    private bool _x;
    public bool x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private bool _y;
    public bool y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private bool _z;
    public bool z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private bool _align;
    public bool r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public bool g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public bool b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public bool3(bool x, bool y, bool z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator bool3(bool value) => new(value);

    [MethodImpl(256 | 512)]
    public bool3(bool value)
    {
        x = value;
        y = value;
        z = value;
    }

    [MethodImpl(256 | 512)]
    public static bool3 Scalar(bool value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal bool3(bool value, is_scalar _)
    {
        x = value;
    }

    #endregion // ctors

}

#endregion // bool3
#region bool4

public partial struct bool4 : 
    IVector4<bool>, IVectorSelf<bool4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 32; 
    }

    public static bool4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static bool4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    #endregion

    #region fields

    private bool _x;
    public bool x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private bool _y;
    public bool y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private bool _z;
    public bool z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private bool _w;
    public bool w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    public bool r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public bool g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public bool b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public bool a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public bool4(bool x, bool y, bool z, bool w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator bool4(bool value) => new(value);

    [MethodImpl(256 | 512)]
    public bool4(bool value)
    {
        x = value;
        y = value;
        z = value;
        w = value;
    }

    [MethodImpl(256 | 512)]
    public static bool4 Scalar(bool value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal bool4(bool value, is_scalar _)
    {
        x = value;
    }

    #endregion // ctors

}

#endregion // bool4
