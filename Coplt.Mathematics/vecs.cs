// generated by template, do not modify manually

namespace Coplt.Mathematics;
#region float2

[Serializable]
[JsonConverter(typeof(float2JsonConverter))]
public partial struct float2 : 
    IVector2<float>, IVectorSelf<float2>, IVectorSelf<float, float2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 8;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 64;
    }

    public static float2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static float2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0f);
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector64<float> vector;
    
    #region Unsafe Inner

    [MethodImpl(256 | 512)]
    public static explicit operator Vector64<float>(float2 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector64<float> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector64<float> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector64<float> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public float x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public float y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private float _x;
    public float x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private float _y;
    public float y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    #endif // NET8_0_OR_GREATER
    public float r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public float g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal float2(Vector64<float> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static float2 UnsafeFromInner(Vector64<float> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public float2(float x, float y)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.Create(x, y);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public float2((float x, float y) tuple) : this(tuple.x, tuple.y) {}

    [MethodImpl(256 | 512)]
    public static implicit operator float2((float x, float y) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator float2(float value) => new(value);

    [MethodImpl(256 | 512)]
    public float2(float value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.Create(value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 Scalar(float value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal float2(float value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        this.x = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 Load(ReadOnlySpan<float> span) => new(span);

    [MethodImpl(256 | 512)]
    public float2(ReadOnlySpan<float> span)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.LoadUnsafe(in MemoryMarshal.Cast<float, float>(span)[0]);
        #else // NET8_0_OR_GREATER
        this.x = span[0];
        this.y = span[1];
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static unsafe float2 Load(float* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe float2(float* ptr)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.Load((float*)ptr);
        #else // NET8_0_OR_GREATER
        this.x = ptr[0];
        this.y = ptr[1];
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out float x, out float y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // deconstruct

    #region index

    public float this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // float2
#region float3

[Serializable]
[JsonConverter(typeof(float3JsonConverter))]
public partial struct float3 : 
    IVector3<float>, IVectorSelf<float3>, IVectorSelf<float, float3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128;
    }

    public static float3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static float3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0f);
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<float> vector;
    
    #region Unsafe Inner

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<float>(float3 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<float> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<float> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<float> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public float x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public float y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public float z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private float _x;
    public float x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private float _y;
    public float y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private float _z;
    public float z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private float _align;
    #endif // NET8_0_OR_GREATER
    public float r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public float g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public float b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal float3(Vector128<float> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static float3 UnsafeFromInner(Vector128<float> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public float3(float x, float y, float z)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y, z, default);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public float3((float x, float y, float z) tuple) : this(tuple.x, tuple.y, tuple.z) {}

    [MethodImpl(256 | 512)]
    public static implicit operator float3((float x, float y, float z) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator float3(float value) => new(value);

    [MethodImpl(256 | 512)]
    public float3(float value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(value, value, value, default);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 Scalar(float value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal float3(float value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        this.x = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 Load(ReadOnlySpan<float> span) => new(span);

    [MethodImpl(256 | 512)]
    public float3(ReadOnlySpan<float> span)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.LoadUnsafe(in MemoryMarshal.Cast<float, float>(span)[0]);
        #else // NET8_0_OR_GREATER
        this.x = span[0];
        this.y = span[1];
        this.z = span[2];
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static unsafe float3 Load(float* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe float3(float* ptr)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Load((float*)ptr);
        #else // NET8_0_OR_GREATER
        this.x = ptr[0];
        this.y = ptr[1];
        this.z = ptr[2];
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out float x, out float y, out float z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // deconstruct

    #region index

    public float this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // float3
#region float4

[Serializable]
[JsonConverter(typeof(float4JsonConverter))]
public partial struct float4 : 
    IVector4<float>, IVectorSelf<float4>, IVectorSelf<float, float4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128;
    }

    public static float4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static float4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0f);
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<float> vector;
    
    #region Unsafe Inner

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<float>(float4 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<float> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<float> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<float> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public float x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public float y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public float z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public float w
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(3);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private float _x;
    public float x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private float _y;
    public float y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private float _z;
    public float z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private float _w;
    public float w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    #endif // NET8_0_OR_GREATER
    public float r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public float g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public float b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public float a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal float4(Vector128<float> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static float4 UnsafeFromInner(Vector128<float> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public float4(float x, float y, float z, float w)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y, z, w);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public float4((float x, float y, float z, float w) tuple) : this(tuple.x, tuple.y, tuple.z, tuple.w) {}

    [MethodImpl(256 | 512)]
    public static implicit operator float4((float x, float y, float z, float w) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator float4(float value) => new(value);

    [MethodImpl(256 | 512)]
    public float4(float value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        w = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 Scalar(float value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal float4(float value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        this.x = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 Load(ReadOnlySpan<float> span) => new(span);

    [MethodImpl(256 | 512)]
    public float4(ReadOnlySpan<float> span)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.LoadUnsafe(in MemoryMarshal.Cast<float, float>(span)[0]);
        #else // NET8_0_OR_GREATER
        this.x = span[0];
        this.y = span[1];
        this.z = span[2];
        this.w = span[3];
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static unsafe float4 Load(float* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe float4(float* ptr)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Load((float*)ptr);
        #else // NET8_0_OR_GREATER
        this.x = ptr[0];
        this.y = ptr[1];
        this.z = ptr[2];
        this.w = ptr[3];
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out float x, out float y, out float z, out float w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // deconstruct

    #region index

    public float this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // float4
#region double2

[Serializable]
[JsonConverter(typeof(double2JsonConverter))]
public partial struct double2 : 
    IVector2<double>, IVectorSelf<double2>, IVectorSelf<double, double2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128;
    }

    public static double2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static double2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0);
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<double> vector;
    
    #region Unsafe Inner

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<double>(double2 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<double> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<double> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<double> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public double x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public double y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private double _x;
    public double x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private double _y;
    public double y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    #endif // NET8_0_OR_GREATER
    public double r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public double g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal double2(Vector128<double> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static double2 UnsafeFromInner(Vector128<double> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public double2(double x, double y)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public double2((double x, double y) tuple) : this(tuple.x, tuple.y) {}

    [MethodImpl(256 | 512)]
    public static implicit operator double2((double x, double y) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator double2(double value) => new(value);

    [MethodImpl(256 | 512)]
    public double2(double value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 Scalar(double value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal double2(double value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        this.x = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 Load(ReadOnlySpan<double> span) => new(span);

    [MethodImpl(256 | 512)]
    public double2(ReadOnlySpan<double> span)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.LoadUnsafe(in MemoryMarshal.Cast<double, double>(span)[0]);
        #else // NET8_0_OR_GREATER
        this.x = span[0];
        this.y = span[1];
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static unsafe double2 Load(double* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe double2(double* ptr)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Load((double*)ptr);
        #else // NET8_0_OR_GREATER
        this.x = ptr[0];
        this.y = ptr[1];
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out double x, out double y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // deconstruct

    #region index

    public double this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // double2
#region double3

[Serializable]
[JsonConverter(typeof(double3JsonConverter))]
public partial struct double3 : 
    IVector3<double>, IVectorSelf<double3>, IVectorSelf<double, double3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 32;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 256;
    }

    public static double3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static double3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0);
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector256<double> vector;
    
    #region Unsafe Inner

    [MethodImpl(256 | 512)]
    public static explicit operator Vector256<double>(double3 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector256<double> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector256<double> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector256<double> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public double x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public double y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public double z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private double _x;
    public double x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private double _y;
    public double y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private double _z;
    public double z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private double _align;
    #endif // NET8_0_OR_GREATER
    public double r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public double g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public double b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal double3(Vector256<double> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static double3 UnsafeFromInner(Vector256<double> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public double3(double x, double y, double z)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(x, y, z, default);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public double3((double x, double y, double z) tuple) : this(tuple.x, tuple.y, tuple.z) {}

    [MethodImpl(256 | 512)]
    public static implicit operator double3((double x, double y, double z) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator double3(double value) => new(value);

    [MethodImpl(256 | 512)]
    public double3(double value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(value, value, value, default);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 Scalar(double value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal double3(double value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        this.x = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 Load(ReadOnlySpan<double> span) => new(span);

    [MethodImpl(256 | 512)]
    public double3(ReadOnlySpan<double> span)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.LoadUnsafe(in MemoryMarshal.Cast<double, double>(span)[0]);
        #else // NET8_0_OR_GREATER
        this.x = span[0];
        this.y = span[1];
        this.z = span[2];
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static unsafe double3 Load(double* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe double3(double* ptr)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Load((double*)ptr);
        #else // NET8_0_OR_GREATER
        this.x = ptr[0];
        this.y = ptr[1];
        this.z = ptr[2];
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out double x, out double y, out double z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // deconstruct

    #region index

    public double this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // double3
#region double4

[Serializable]
[JsonConverter(typeof(double4JsonConverter))]
public partial struct double4 : 
    IVector4<double>, IVectorSelf<double4>, IVectorSelf<double, double4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 32;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 256;
    }

    public static double4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static double4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0);
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector256<double> vector;
    
    #region Unsafe Inner

    [MethodImpl(256 | 512)]
    public static explicit operator Vector256<double>(double4 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector256<double> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector256<double> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector256<double> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public double x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public double y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public double z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public double w
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(3);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private double _x;
    public double x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private double _y;
    public double y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private double _z;
    public double z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private double _w;
    public double w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    #endif // NET8_0_OR_GREATER
    public double r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public double g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public double b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public double a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal double4(Vector256<double> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static double4 UnsafeFromInner(Vector256<double> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public double4(double x, double y, double z, double w)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(x, y, z, w);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public double4((double x, double y, double z, double w) tuple) : this(tuple.x, tuple.y, tuple.z, tuple.w) {}

    [MethodImpl(256 | 512)]
    public static implicit operator double4((double x, double y, double z, double w) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator double4(double value) => new(value);

    [MethodImpl(256 | 512)]
    public double4(double value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        w = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 Scalar(double value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal double4(double value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        this.x = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 Load(ReadOnlySpan<double> span) => new(span);

    [MethodImpl(256 | 512)]
    public double4(ReadOnlySpan<double> span)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.LoadUnsafe(in MemoryMarshal.Cast<double, double>(span)[0]);
        #else // NET8_0_OR_GREATER
        this.x = span[0];
        this.y = span[1];
        this.z = span[2];
        this.w = span[3];
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static unsafe double4 Load(double* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe double4(double* ptr)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Load((double*)ptr);
        #else // NET8_0_OR_GREATER
        this.x = ptr[0];
        this.y = ptr[1];
        this.z = ptr[2];
        this.w = ptr[3];
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out double x, out double y, out double z, out double w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // deconstruct

    #region index

    public double this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // double4
#region short2

[Serializable]
[JsonConverter(typeof(short2JsonConverter))]
public partial struct short2 : 
    IVector2<short>, IVectorSelf<short2>, IVectorSelf<short, short2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 4;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 32;
    }

    public static short2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static short2 One
    { 
        [MethodImpl(256 | 512)]
        get => new((short)1);
    }

    #endregion

    #region fields

    private short _x;
    public short x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private short _y;
    public short y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    public short r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public short g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public short2(short x, short y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public short2((short x, short y) tuple) : this(tuple.x, tuple.y) {}

    [MethodImpl(256 | 512)]
    public static implicit operator short2((short x, short y) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator short2(short value) => new(value);

    [MethodImpl(256 | 512)]
    public short2(short value)
    {
        x = value;
        y = value;
    }

    [MethodImpl(256 | 512)]
    public static short2 Scalar(short value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal short2(short value, is_scalar _)
    {
        this.x = value;
    }

    [MethodImpl(256 | 512)]
    public static short2 Load(ReadOnlySpan<short> span) => new(span);

    [MethodImpl(256 | 512)]
    public short2(ReadOnlySpan<short> span)
    {
        this.x = span[0];
        this.y = span[1];
    }

    [MethodImpl(256 | 512)]
    public static unsafe short2 Load(short* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe short2(short* ptr)
    {
        this.x = ptr[0];
        this.y = ptr[1];
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out short x, out short y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // deconstruct

    #region index

    public short this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // short2
#region short3

[Serializable]
[JsonConverter(typeof(short3JsonConverter))]
public partial struct short3 : 
    IVector3<short>, IVectorSelf<short3>, IVectorSelf<short, short3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 8;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 64;
    }

    public static short3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static short3 One
    { 
        [MethodImpl(256 | 512)]
        get => new((short)1);
    }

    #endregion

    #region fields

    private short _x;
    public short x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private short _y;
    public short y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private short _z;
    public short z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private short _align;
    public short r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public short g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public short b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public short3(short x, short y, short z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public short3((short x, short y, short z) tuple) : this(tuple.x, tuple.y, tuple.z) {}

    [MethodImpl(256 | 512)]
    public static implicit operator short3((short x, short y, short z) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator short3(short value) => new(value);

    [MethodImpl(256 | 512)]
    public short3(short value)
    {
        x = value;
        y = value;
        z = value;
    }

    [MethodImpl(256 | 512)]
    public static short3 Scalar(short value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal short3(short value, is_scalar _)
    {
        this.x = value;
    }

    [MethodImpl(256 | 512)]
    public static short3 Load(ReadOnlySpan<short> span) => new(span);

    [MethodImpl(256 | 512)]
    public short3(ReadOnlySpan<short> span)
    {
        this.x = span[0];
        this.y = span[1];
        this.z = span[2];
    }

    [MethodImpl(256 | 512)]
    public static unsafe short3 Load(short* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe short3(short* ptr)
    {
        this.x = ptr[0];
        this.y = ptr[1];
        this.z = ptr[2];
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out short x, out short y, out short z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // deconstruct

    #region index

    public short this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // short3
#region short4

[Serializable]
[JsonConverter(typeof(short4JsonConverter))]
public partial struct short4 : 
    IVector4<short>, IVectorSelf<short4>, IVectorSelf<short, short4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 8;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 64;
    }

    public static short4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static short4 One
    { 
        [MethodImpl(256 | 512)]
        get => new((short)1);
    }

    #endregion

    #region fields

    private short _x;
    public short x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private short _y;
    public short y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private short _z;
    public short z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private short _w;
    public short w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    public short r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public short g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public short b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public short a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public short4(short x, short y, short z, short w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public short4((short x, short y, short z, short w) tuple) : this(tuple.x, tuple.y, tuple.z, tuple.w) {}

    [MethodImpl(256 | 512)]
    public static implicit operator short4((short x, short y, short z, short w) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator short4(short value) => new(value);

    [MethodImpl(256 | 512)]
    public short4(short value)
    {
        x = value;
        y = value;
        z = value;
        w = value;
    }

    [MethodImpl(256 | 512)]
    public static short4 Scalar(short value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal short4(short value, is_scalar _)
    {
        this.x = value;
    }

    [MethodImpl(256 | 512)]
    public static short4 Load(ReadOnlySpan<short> span) => new(span);

    [MethodImpl(256 | 512)]
    public short4(ReadOnlySpan<short> span)
    {
        this.x = span[0];
        this.y = span[1];
        this.z = span[2];
        this.w = span[3];
    }

    [MethodImpl(256 | 512)]
    public static unsafe short4 Load(short* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe short4(short* ptr)
    {
        this.x = ptr[0];
        this.y = ptr[1];
        this.z = ptr[2];
        this.w = ptr[3];
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out short x, out short y, out short z, out short w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // deconstruct

    #region index

    public short this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // short4
#region ushort2

[Serializable]
[JsonConverter(typeof(ushort2JsonConverter))]
public partial struct ushort2 : 
    IVector2<ushort>, IVectorSelf<ushort2>, IVectorSelf<ushort, ushort2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 4;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 32;
    }

    public static ushort2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static ushort2 One
    { 
        [MethodImpl(256 | 512)]
        get => new((ushort)1);
    }

    #endregion

    #region fields

    private ushort _x;
    public ushort x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private ushort _y;
    public ushort y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    public ushort r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public ushort g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public ushort2(ushort x, ushort y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public ushort2((ushort x, ushort y) tuple) : this(tuple.x, tuple.y) {}

    [MethodImpl(256 | 512)]
    public static implicit operator ushort2((ushort x, ushort y) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator ushort2(ushort value) => new(value);

    [MethodImpl(256 | 512)]
    public ushort2(ushort value)
    {
        x = value;
        y = value;
    }

    [MethodImpl(256 | 512)]
    public static ushort2 Scalar(ushort value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal ushort2(ushort value, is_scalar _)
    {
        this.x = value;
    }

    [MethodImpl(256 | 512)]
    public static ushort2 Load(ReadOnlySpan<ushort> span) => new(span);

    [MethodImpl(256 | 512)]
    public ushort2(ReadOnlySpan<ushort> span)
    {
        this.x = span[0];
        this.y = span[1];
    }

    [MethodImpl(256 | 512)]
    public static unsafe ushort2 Load(ushort* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe ushort2(ushort* ptr)
    {
        this.x = ptr[0];
        this.y = ptr[1];
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out ushort x, out ushort y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // deconstruct

    #region index

    public ushort this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // ushort2
#region ushort3

[Serializable]
[JsonConverter(typeof(ushort3JsonConverter))]
public partial struct ushort3 : 
    IVector3<ushort>, IVectorSelf<ushort3>, IVectorSelf<ushort, ushort3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 8;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 64;
    }

    public static ushort3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static ushort3 One
    { 
        [MethodImpl(256 | 512)]
        get => new((ushort)1);
    }

    #endregion

    #region fields

    private ushort _x;
    public ushort x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private ushort _y;
    public ushort y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private ushort _z;
    public ushort z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private ushort _align;
    public ushort r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public ushort g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public ushort b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public ushort3(ushort x, ushort y, ushort z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public ushort3((ushort x, ushort y, ushort z) tuple) : this(tuple.x, tuple.y, tuple.z) {}

    [MethodImpl(256 | 512)]
    public static implicit operator ushort3((ushort x, ushort y, ushort z) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator ushort3(ushort value) => new(value);

    [MethodImpl(256 | 512)]
    public ushort3(ushort value)
    {
        x = value;
        y = value;
        z = value;
    }

    [MethodImpl(256 | 512)]
    public static ushort3 Scalar(ushort value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal ushort3(ushort value, is_scalar _)
    {
        this.x = value;
    }

    [MethodImpl(256 | 512)]
    public static ushort3 Load(ReadOnlySpan<ushort> span) => new(span);

    [MethodImpl(256 | 512)]
    public ushort3(ReadOnlySpan<ushort> span)
    {
        this.x = span[0];
        this.y = span[1];
        this.z = span[2];
    }

    [MethodImpl(256 | 512)]
    public static unsafe ushort3 Load(ushort* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe ushort3(ushort* ptr)
    {
        this.x = ptr[0];
        this.y = ptr[1];
        this.z = ptr[2];
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out ushort x, out ushort y, out ushort z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // deconstruct

    #region index

    public ushort this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // ushort3
#region ushort4

[Serializable]
[JsonConverter(typeof(ushort4JsonConverter))]
public partial struct ushort4 : 
    IVector4<ushort>, IVectorSelf<ushort4>, IVectorSelf<ushort, ushort4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 8;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 64;
    }

    public static ushort4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static ushort4 One
    { 
        [MethodImpl(256 | 512)]
        get => new((ushort)1);
    }

    #endregion

    #region fields

    private ushort _x;
    public ushort x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private ushort _y;
    public ushort y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private ushort _z;
    public ushort z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private ushort _w;
    public ushort w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    public ushort r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public ushort g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public ushort b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public ushort a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public ushort4(ushort x, ushort y, ushort z, ushort w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public ushort4((ushort x, ushort y, ushort z, ushort w) tuple) : this(tuple.x, tuple.y, tuple.z, tuple.w) {}

    [MethodImpl(256 | 512)]
    public static implicit operator ushort4((ushort x, ushort y, ushort z, ushort w) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator ushort4(ushort value) => new(value);

    [MethodImpl(256 | 512)]
    public ushort4(ushort value)
    {
        x = value;
        y = value;
        z = value;
        w = value;
    }

    [MethodImpl(256 | 512)]
    public static ushort4 Scalar(ushort value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal ushort4(ushort value, is_scalar _)
    {
        this.x = value;
    }

    [MethodImpl(256 | 512)]
    public static ushort4 Load(ReadOnlySpan<ushort> span) => new(span);

    [MethodImpl(256 | 512)]
    public ushort4(ReadOnlySpan<ushort> span)
    {
        this.x = span[0];
        this.y = span[1];
        this.z = span[2];
        this.w = span[3];
    }

    [MethodImpl(256 | 512)]
    public static unsafe ushort4 Load(ushort* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe ushort4(ushort* ptr)
    {
        this.x = ptr[0];
        this.y = ptr[1];
        this.z = ptr[2];
        this.w = ptr[3];
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out ushort x, out ushort y, out ushort z, out ushort w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // deconstruct

    #region index

    public ushort this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // ushort4
#region int2

[Serializable]
[JsonConverter(typeof(int2JsonConverter))]
public partial struct int2 : 
    IVector2<int>, IVectorSelf<int2>, IVectorSelf<int, int2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 8;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 64;
    }

    public static int2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static int2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1);
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector64<int> vector;
    
    #region Unsafe Inner

    [MethodImpl(256 | 512)]
    public static explicit operator Vector64<int>(int2 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector64<int> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector64<int> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector64<int> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public int x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public int y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private int _x;
    public int x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private int _y;
    public int y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    #endif // NET8_0_OR_GREATER
    public int r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public int g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal int2(Vector64<int> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static int2 UnsafeFromInner(Vector64<int> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public int2(int x, int y)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.Create(x, y);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public int2((int x, int y) tuple) : this(tuple.x, tuple.y) {}

    [MethodImpl(256 | 512)]
    public static implicit operator int2((int x, int y) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator int2(int value) => new(value);

    [MethodImpl(256 | 512)]
    public int2(int value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.Create(value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 Scalar(int value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal int2(int value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        this.x = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 Load(ReadOnlySpan<int> span) => new(span);

    [MethodImpl(256 | 512)]
    public int2(ReadOnlySpan<int> span)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.LoadUnsafe(in MemoryMarshal.Cast<int, int>(span)[0]);
        #else // NET8_0_OR_GREATER
        this.x = span[0];
        this.y = span[1];
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static unsafe int2 Load(int* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe int2(int* ptr)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.Load((int*)ptr);
        #else // NET8_0_OR_GREATER
        this.x = ptr[0];
        this.y = ptr[1];
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out int x, out int y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // deconstruct

    #region index

    public int this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // int2
#region int3

[Serializable]
[JsonConverter(typeof(int3JsonConverter))]
public partial struct int3 : 
    IVector3<int>, IVectorSelf<int3>, IVectorSelf<int, int3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128;
    }

    public static int3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static int3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1);
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<int> vector;
    
    #region Unsafe Inner

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<int>(int3 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<int> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<int> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<int> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public int x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public int y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public int z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private int _x;
    public int x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private int _y;
    public int y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private int _z;
    public int z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private int _align;
    #endif // NET8_0_OR_GREATER
    public int r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public int g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public int b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal int3(Vector128<int> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static int3 UnsafeFromInner(Vector128<int> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public int3(int x, int y, int z)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y, z, default);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public int3((int x, int y, int z) tuple) : this(tuple.x, tuple.y, tuple.z) {}

    [MethodImpl(256 | 512)]
    public static implicit operator int3((int x, int y, int z) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator int3(int value) => new(value);

    [MethodImpl(256 | 512)]
    public int3(int value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(value, value, value, default);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 Scalar(int value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal int3(int value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        this.x = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 Load(ReadOnlySpan<int> span) => new(span);

    [MethodImpl(256 | 512)]
    public int3(ReadOnlySpan<int> span)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.LoadUnsafe(in MemoryMarshal.Cast<int, int>(span)[0]);
        #else // NET8_0_OR_GREATER
        this.x = span[0];
        this.y = span[1];
        this.z = span[2];
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static unsafe int3 Load(int* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe int3(int* ptr)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Load((int*)ptr);
        #else // NET8_0_OR_GREATER
        this.x = ptr[0];
        this.y = ptr[1];
        this.z = ptr[2];
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out int x, out int y, out int z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // deconstruct

    #region index

    public int this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // int3
#region int4

[Serializable]
[JsonConverter(typeof(int4JsonConverter))]
public partial struct int4 : 
    IVector4<int>, IVectorSelf<int4>, IVectorSelf<int, int4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128;
    }

    public static int4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static int4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1);
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<int> vector;
    
    #region Unsafe Inner

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<int>(int4 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<int> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<int> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<int> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public int x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public int y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public int z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public int w
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(3);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private int _x;
    public int x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private int _y;
    public int y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private int _z;
    public int z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private int _w;
    public int w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    #endif // NET8_0_OR_GREATER
    public int r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public int g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public int b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public int a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal int4(Vector128<int> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static int4 UnsafeFromInner(Vector128<int> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public int4(int x, int y, int z, int w)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y, z, w);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public int4((int x, int y, int z, int w) tuple) : this(tuple.x, tuple.y, tuple.z, tuple.w) {}

    [MethodImpl(256 | 512)]
    public static implicit operator int4((int x, int y, int z, int w) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator int4(int value) => new(value);

    [MethodImpl(256 | 512)]
    public int4(int value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        w = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 Scalar(int value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal int4(int value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        this.x = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 Load(ReadOnlySpan<int> span) => new(span);

    [MethodImpl(256 | 512)]
    public int4(ReadOnlySpan<int> span)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.LoadUnsafe(in MemoryMarshal.Cast<int, int>(span)[0]);
        #else // NET8_0_OR_GREATER
        this.x = span[0];
        this.y = span[1];
        this.z = span[2];
        this.w = span[3];
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static unsafe int4 Load(int* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe int4(int* ptr)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Load((int*)ptr);
        #else // NET8_0_OR_GREATER
        this.x = ptr[0];
        this.y = ptr[1];
        this.z = ptr[2];
        this.w = ptr[3];
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out int x, out int y, out int z, out int w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // deconstruct

    #region index

    public int this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // int4
#region uint2

[Serializable]
[JsonConverter(typeof(uint2JsonConverter))]
public partial struct uint2 : 
    IVector2<uint>, IVectorSelf<uint2>, IVectorSelf<uint, uint2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 8;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 64;
    }

    public static uint2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static uint2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1u);
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector64<uint> vector;
    
    #region Unsafe Inner

    [MethodImpl(256 | 512)]
    public static explicit operator Vector64<uint>(uint2 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector64<uint> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector64<uint> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector64<uint> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public uint x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public uint y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private uint _x;
    public uint x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private uint _y;
    public uint y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    #endif // NET8_0_OR_GREATER
    public uint r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public uint g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal uint2(Vector64<uint> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static uint2 UnsafeFromInner(Vector64<uint> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public uint2(uint x, uint y)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.Create(x, y);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public uint2((uint x, uint y) tuple) : this(tuple.x, tuple.y) {}

    [MethodImpl(256 | 512)]
    public static implicit operator uint2((uint x, uint y) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator uint2(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public uint2(uint value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.Create((uint)value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 Scalar(uint value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal uint2(uint value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        this.x = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 Load(ReadOnlySpan<uint> span) => new(span);

    [MethodImpl(256 | 512)]
    public uint2(ReadOnlySpan<uint> span)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.LoadUnsafe(in MemoryMarshal.Cast<uint, uint>(span)[0]);
        #else // NET8_0_OR_GREATER
        this.x = span[0];
        this.y = span[1];
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static unsafe uint2 Load(uint* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe uint2(uint* ptr)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.Load((uint*)ptr);
        #else // NET8_0_OR_GREATER
        this.x = ptr[0];
        this.y = ptr[1];
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out uint x, out uint y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // deconstruct

    #region index

    public uint this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // uint2
#region uint3

[Serializable]
[JsonConverter(typeof(uint3JsonConverter))]
public partial struct uint3 : 
    IVector3<uint>, IVectorSelf<uint3>, IVectorSelf<uint, uint3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128;
    }

    public static uint3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static uint3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1u);
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<uint> vector;
    
    #region Unsafe Inner

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<uint>(uint3 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<uint> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<uint> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<uint> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public uint x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public uint y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public uint z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private uint _x;
    public uint x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private uint _y;
    public uint y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private uint _z;
    public uint z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private uint _align;
    #endif // NET8_0_OR_GREATER
    public uint r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public uint g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public uint b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal uint3(Vector128<uint> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static uint3 UnsafeFromInner(Vector128<uint> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public uint3(uint x, uint y, uint z)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y, z, default);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public uint3((uint x, uint y, uint z) tuple) : this(tuple.x, tuple.y, tuple.z) {}

    [MethodImpl(256 | 512)]
    public static implicit operator uint3((uint x, uint y, uint z) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator uint3(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public uint3(uint value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create((uint)value, value, value, default);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 Scalar(uint value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal uint3(uint value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        this.x = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 Load(ReadOnlySpan<uint> span) => new(span);

    [MethodImpl(256 | 512)]
    public uint3(ReadOnlySpan<uint> span)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.LoadUnsafe(in MemoryMarshal.Cast<uint, uint>(span)[0]);
        #else // NET8_0_OR_GREATER
        this.x = span[0];
        this.y = span[1];
        this.z = span[2];
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static unsafe uint3 Load(uint* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe uint3(uint* ptr)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Load((uint*)ptr);
        #else // NET8_0_OR_GREATER
        this.x = ptr[0];
        this.y = ptr[1];
        this.z = ptr[2];
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out uint x, out uint y, out uint z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // deconstruct

    #region index

    public uint this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // uint3
#region uint4

[Serializable]
[JsonConverter(typeof(uint4JsonConverter))]
public partial struct uint4 : 
    IVector4<uint>, IVectorSelf<uint4>, IVectorSelf<uint, uint4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128;
    }

    public static uint4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static uint4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1u);
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<uint> vector;
    
    #region Unsafe Inner

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<uint>(uint4 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<uint> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<uint> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<uint> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public uint x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public uint y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public uint z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public uint w
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(3);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private uint _x;
    public uint x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private uint _y;
    public uint y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private uint _z;
    public uint z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private uint _w;
    public uint w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    #endif // NET8_0_OR_GREATER
    public uint r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public uint g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public uint b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public uint a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal uint4(Vector128<uint> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static uint4 UnsafeFromInner(Vector128<uint> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public uint4(uint x, uint y, uint z, uint w)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y, z, w);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public uint4((uint x, uint y, uint z, uint w) tuple) : this(tuple.x, tuple.y, tuple.z, tuple.w) {}

    [MethodImpl(256 | 512)]
    public static implicit operator uint4((uint x, uint y, uint z, uint w) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator uint4(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public uint4(uint value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create((uint)value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        w = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 Scalar(uint value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal uint4(uint value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        this.x = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 Load(ReadOnlySpan<uint> span) => new(span);

    [MethodImpl(256 | 512)]
    public uint4(ReadOnlySpan<uint> span)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.LoadUnsafe(in MemoryMarshal.Cast<uint, uint>(span)[0]);
        #else // NET8_0_OR_GREATER
        this.x = span[0];
        this.y = span[1];
        this.z = span[2];
        this.w = span[3];
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static unsafe uint4 Load(uint* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe uint4(uint* ptr)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Load((uint*)ptr);
        #else // NET8_0_OR_GREATER
        this.x = ptr[0];
        this.y = ptr[1];
        this.z = ptr[2];
        this.w = ptr[3];
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out uint x, out uint y, out uint z, out uint w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // deconstruct

    #region index

    public uint this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // uint4
#region long2

[Serializable]
[JsonConverter(typeof(long2JsonConverter))]
public partial struct long2 : 
    IVector2<long>, IVectorSelf<long2>, IVectorSelf<long, long2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128;
    }

    public static long2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static long2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1L);
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<long> vector;
    
    #region Unsafe Inner

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<long>(long2 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<long> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<long> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<long> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public long x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public long y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private long _x;
    public long x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private long _y;
    public long y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    #endif // NET8_0_OR_GREATER
    public long r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public long g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal long2(Vector128<long> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static long2 UnsafeFromInner(Vector128<long> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public long2(long x, long y)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public long2((long x, long y) tuple) : this(tuple.x, tuple.y) {}

    [MethodImpl(256 | 512)]
    public static implicit operator long2((long x, long y) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator long2(long value) => new(value);

    [MethodImpl(256 | 512)]
    public long2(long value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 Scalar(long value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal long2(long value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        this.x = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 Load(ReadOnlySpan<long> span) => new(span);

    [MethodImpl(256 | 512)]
    public long2(ReadOnlySpan<long> span)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.LoadUnsafe(in MemoryMarshal.Cast<long, long>(span)[0]);
        #else // NET8_0_OR_GREATER
        this.x = span[0];
        this.y = span[1];
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static unsafe long2 Load(long* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe long2(long* ptr)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Load((long*)ptr);
        #else // NET8_0_OR_GREATER
        this.x = ptr[0];
        this.y = ptr[1];
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out long x, out long y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // deconstruct

    #region index

    public long this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // long2
#region long3

[Serializable]
[JsonConverter(typeof(long3JsonConverter))]
public partial struct long3 : 
    IVector3<long>, IVectorSelf<long3>, IVectorSelf<long, long3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 32;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 256;
    }

    public static long3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static long3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1L);
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector256<long> vector;
    
    #region Unsafe Inner

    [MethodImpl(256 | 512)]
    public static explicit operator Vector256<long>(long3 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector256<long> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector256<long> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector256<long> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public long x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public long y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public long z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private long _x;
    public long x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private long _y;
    public long y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private long _z;
    public long z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private long _align;
    #endif // NET8_0_OR_GREATER
    public long r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public long g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public long b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal long3(Vector256<long> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static long3 UnsafeFromInner(Vector256<long> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public long3(long x, long y, long z)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(x, y, z, default);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public long3((long x, long y, long z) tuple) : this(tuple.x, tuple.y, tuple.z) {}

    [MethodImpl(256 | 512)]
    public static implicit operator long3((long x, long y, long z) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator long3(long value) => new(value);

    [MethodImpl(256 | 512)]
    public long3(long value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(value, value, value, default);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 Scalar(long value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal long3(long value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        this.x = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 Load(ReadOnlySpan<long> span) => new(span);

    [MethodImpl(256 | 512)]
    public long3(ReadOnlySpan<long> span)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.LoadUnsafe(in MemoryMarshal.Cast<long, long>(span)[0]);
        #else // NET8_0_OR_GREATER
        this.x = span[0];
        this.y = span[1];
        this.z = span[2];
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static unsafe long3 Load(long* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe long3(long* ptr)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Load((long*)ptr);
        #else // NET8_0_OR_GREATER
        this.x = ptr[0];
        this.y = ptr[1];
        this.z = ptr[2];
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out long x, out long y, out long z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // deconstruct

    #region index

    public long this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // long3
#region long4

[Serializable]
[JsonConverter(typeof(long4JsonConverter))]
public partial struct long4 : 
    IVector4<long>, IVectorSelf<long4>, IVectorSelf<long, long4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 32;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 256;
    }

    public static long4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static long4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1L);
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector256<long> vector;
    
    #region Unsafe Inner

    [MethodImpl(256 | 512)]
    public static explicit operator Vector256<long>(long4 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector256<long> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector256<long> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector256<long> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public long x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public long y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public long z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public long w
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(3);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private long _x;
    public long x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private long _y;
    public long y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private long _z;
    public long z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private long _w;
    public long w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    #endif // NET8_0_OR_GREATER
    public long r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public long g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public long b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public long a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal long4(Vector256<long> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static long4 UnsafeFromInner(Vector256<long> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public long4(long x, long y, long z, long w)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(x, y, z, w);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public long4((long x, long y, long z, long w) tuple) : this(tuple.x, tuple.y, tuple.z, tuple.w) {}

    [MethodImpl(256 | 512)]
    public static implicit operator long4((long x, long y, long z, long w) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator long4(long value) => new(value);

    [MethodImpl(256 | 512)]
    public long4(long value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        w = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 Scalar(long value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal long4(long value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        this.x = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 Load(ReadOnlySpan<long> span) => new(span);

    [MethodImpl(256 | 512)]
    public long4(ReadOnlySpan<long> span)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.LoadUnsafe(in MemoryMarshal.Cast<long, long>(span)[0]);
        #else // NET8_0_OR_GREATER
        this.x = span[0];
        this.y = span[1];
        this.z = span[2];
        this.w = span[3];
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static unsafe long4 Load(long* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe long4(long* ptr)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Load((long*)ptr);
        #else // NET8_0_OR_GREATER
        this.x = ptr[0];
        this.y = ptr[1];
        this.z = ptr[2];
        this.w = ptr[3];
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out long x, out long y, out long z, out long w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // deconstruct

    #region index

    public long this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // long4
#region ulong2

[Serializable]
[JsonConverter(typeof(ulong2JsonConverter))]
public partial struct ulong2 : 
    IVector2<ulong>, IVectorSelf<ulong2>, IVectorSelf<ulong, ulong2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128;
    }

    public static ulong2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static ulong2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1UL);
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<ulong> vector;
    
    #region Unsafe Inner

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<ulong>(ulong2 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<ulong> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<ulong> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<ulong> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public ulong x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public ulong y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private ulong _x;
    public ulong x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private ulong _y;
    public ulong y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    #endif // NET8_0_OR_GREATER
    public ulong r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public ulong g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal ulong2(Vector128<ulong> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static ulong2 UnsafeFromInner(Vector128<ulong> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public ulong2(ulong x, ulong y)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public ulong2((ulong x, ulong y) tuple) : this(tuple.x, tuple.y) {}

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2((ulong x, ulong y) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong2(ulong value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create((ulong)value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 Scalar(ulong value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal ulong2(ulong value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        this.x = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 Load(ReadOnlySpan<ulong> span) => new(span);

    [MethodImpl(256 | 512)]
    public ulong2(ReadOnlySpan<ulong> span)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.LoadUnsafe(in MemoryMarshal.Cast<ulong, ulong>(span)[0]);
        #else // NET8_0_OR_GREATER
        this.x = span[0];
        this.y = span[1];
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static unsafe ulong2 Load(ulong* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe ulong2(ulong* ptr)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Load((ulong*)ptr);
        #else // NET8_0_OR_GREATER
        this.x = ptr[0];
        this.y = ptr[1];
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out ulong x, out ulong y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // deconstruct

    #region index

    public ulong this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // ulong2
#region ulong3

[Serializable]
[JsonConverter(typeof(ulong3JsonConverter))]
public partial struct ulong3 : 
    IVector3<ulong>, IVectorSelf<ulong3>, IVectorSelf<ulong, ulong3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 32;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 256;
    }

    public static ulong3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static ulong3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1UL);
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector256<ulong> vector;
    
    #region Unsafe Inner

    [MethodImpl(256 | 512)]
    public static explicit operator Vector256<ulong>(ulong3 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector256<ulong> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector256<ulong> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector256<ulong> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public ulong x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public ulong y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public ulong z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private ulong _x;
    public ulong x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private ulong _y;
    public ulong y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private ulong _z;
    public ulong z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private ulong _align;
    #endif // NET8_0_OR_GREATER
    public ulong r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public ulong g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public ulong b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal ulong3(Vector256<ulong> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static ulong3 UnsafeFromInner(Vector256<ulong> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public ulong3(ulong x, ulong y, ulong z)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(x, y, z, default);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public ulong3((ulong x, ulong y, ulong z) tuple) : this(tuple.x, tuple.y, tuple.z) {}

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3((ulong x, ulong y, ulong z) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong3(ulong value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create((ulong)value, value, value, default);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 Scalar(ulong value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal ulong3(ulong value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        this.x = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 Load(ReadOnlySpan<ulong> span) => new(span);

    [MethodImpl(256 | 512)]
    public ulong3(ReadOnlySpan<ulong> span)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.LoadUnsafe(in MemoryMarshal.Cast<ulong, ulong>(span)[0]);
        #else // NET8_0_OR_GREATER
        this.x = span[0];
        this.y = span[1];
        this.z = span[2];
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static unsafe ulong3 Load(ulong* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe ulong3(ulong* ptr)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Load((ulong*)ptr);
        #else // NET8_0_OR_GREATER
        this.x = ptr[0];
        this.y = ptr[1];
        this.z = ptr[2];
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out ulong x, out ulong y, out ulong z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // deconstruct

    #region index

    public ulong this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // ulong3
#region ulong4

[Serializable]
[JsonConverter(typeof(ulong4JsonConverter))]
public partial struct ulong4 : 
    IVector4<ulong>, IVectorSelf<ulong4>, IVectorSelf<ulong, ulong4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 32;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 256;
    }

    public static ulong4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static ulong4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1UL);
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector256<ulong> vector;
    
    #region Unsafe Inner

    [MethodImpl(256 | 512)]
    public static explicit operator Vector256<ulong>(ulong4 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector256<ulong> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector256<ulong> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector256<ulong> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public ulong x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public ulong y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public ulong z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public ulong w
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(3);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private ulong _x;
    public ulong x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private ulong _y;
    public ulong y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private ulong _z;
    public ulong z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private ulong _w;
    public ulong w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    #endif // NET8_0_OR_GREATER
    public ulong r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public ulong g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public ulong b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public ulong a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal ulong4(Vector256<ulong> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static ulong4 UnsafeFromInner(Vector256<ulong> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public ulong4(ulong x, ulong y, ulong z, ulong w)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(x, y, z, w);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public ulong4((ulong x, ulong y, ulong z, ulong w) tuple) : this(tuple.x, tuple.y, tuple.z, tuple.w) {}

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4((ulong x, ulong y, ulong z, ulong w) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong4(ulong value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create((ulong)value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        w = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 Scalar(ulong value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal ulong4(ulong value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        this.x = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 Load(ReadOnlySpan<ulong> span) => new(span);

    [MethodImpl(256 | 512)]
    public ulong4(ReadOnlySpan<ulong> span)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.LoadUnsafe(in MemoryMarshal.Cast<ulong, ulong>(span)[0]);
        #else // NET8_0_OR_GREATER
        this.x = span[0];
        this.y = span[1];
        this.z = span[2];
        this.w = span[3];
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static unsafe ulong4 Load(ulong* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe ulong4(ulong* ptr)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Load((ulong*)ptr);
        #else // NET8_0_OR_GREATER
        this.x = ptr[0];
        this.y = ptr[1];
        this.z = ptr[2];
        this.w = ptr[3];
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out ulong x, out ulong y, out ulong z, out ulong w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // deconstruct

    #region index

    public ulong this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // ulong4
#region decimal2

[Serializable]
[JsonConverter(typeof(decimal2JsonConverter))]
public partial struct decimal2 : 
    IVector2<decimal>, IVectorSelf<decimal2>, IVectorSelf<decimal, decimal2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 32;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 256;
    }

    public static decimal2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static decimal2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1m);
    }

    #endregion

    #region fields

    private decimal _x;
    public decimal x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private decimal _y;
    public decimal y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    public decimal r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public decimal g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public decimal2(decimal x, decimal y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public decimal2((decimal x, decimal y) tuple) : this(tuple.x, tuple.y) {}

    [MethodImpl(256 | 512)]
    public static implicit operator decimal2((decimal x, decimal y) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator decimal2(decimal value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal2(decimal value)
    {
        x = value;
        y = value;
    }

    [MethodImpl(256 | 512)]
    public static decimal2 Scalar(decimal value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal decimal2(decimal value, is_scalar _)
    {
        this.x = value;
    }

    [MethodImpl(256 | 512)]
    public static decimal2 Load(ReadOnlySpan<decimal> span) => new(span);

    [MethodImpl(256 | 512)]
    public decimal2(ReadOnlySpan<decimal> span)
    {
        this.x = span[0];
        this.y = span[1];
    }

    [MethodImpl(256 | 512)]
    public static unsafe decimal2 Load(decimal* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe decimal2(decimal* ptr)
    {
        this.x = ptr[0];
        this.y = ptr[1];
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out decimal x, out decimal y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // deconstruct

    #region index

    public decimal this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // decimal2
#region decimal3

[Serializable]
[JsonConverter(typeof(decimal3JsonConverter))]
public partial struct decimal3 : 
    IVector3<decimal>, IVectorSelf<decimal3>, IVectorSelf<decimal, decimal3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 64;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 512;
    }

    public static decimal3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static decimal3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1m);
    }

    #endregion

    #region fields

    private decimal _x;
    public decimal x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private decimal _y;
    public decimal y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private decimal _z;
    public decimal z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private decimal _align;
    public decimal r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public decimal g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public decimal b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public decimal3(decimal x, decimal y, decimal z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public decimal3((decimal x, decimal y, decimal z) tuple) : this(tuple.x, tuple.y, tuple.z) {}

    [MethodImpl(256 | 512)]
    public static implicit operator decimal3((decimal x, decimal y, decimal z) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator decimal3(decimal value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal3(decimal value)
    {
        x = value;
        y = value;
        z = value;
    }

    [MethodImpl(256 | 512)]
    public static decimal3 Scalar(decimal value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal decimal3(decimal value, is_scalar _)
    {
        this.x = value;
    }

    [MethodImpl(256 | 512)]
    public static decimal3 Load(ReadOnlySpan<decimal> span) => new(span);

    [MethodImpl(256 | 512)]
    public decimal3(ReadOnlySpan<decimal> span)
    {
        this.x = span[0];
        this.y = span[1];
        this.z = span[2];
    }

    [MethodImpl(256 | 512)]
    public static unsafe decimal3 Load(decimal* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe decimal3(decimal* ptr)
    {
        this.x = ptr[0];
        this.y = ptr[1];
        this.z = ptr[2];
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out decimal x, out decimal y, out decimal z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // deconstruct

    #region index

    public decimal this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // decimal3
#region decimal4

[Serializable]
[JsonConverter(typeof(decimal4JsonConverter))]
public partial struct decimal4 : 
    IVector4<decimal>, IVectorSelf<decimal4>, IVectorSelf<decimal, decimal4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 64;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 512;
    }

    public static decimal4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static decimal4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1m);
    }

    #endregion

    #region fields

    private decimal _x;
    public decimal x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private decimal _y;
    public decimal y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private decimal _z;
    public decimal z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private decimal _w;
    public decimal w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    public decimal r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public decimal g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public decimal b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public decimal a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public decimal4(decimal x, decimal y, decimal z, decimal w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public decimal4((decimal x, decimal y, decimal z, decimal w) tuple) : this(tuple.x, tuple.y, tuple.z, tuple.w) {}

    [MethodImpl(256 | 512)]
    public static implicit operator decimal4((decimal x, decimal y, decimal z, decimal w) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator decimal4(decimal value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal4(decimal value)
    {
        x = value;
        y = value;
        z = value;
        w = value;
    }

    [MethodImpl(256 | 512)]
    public static decimal4 Scalar(decimal value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal decimal4(decimal value, is_scalar _)
    {
        this.x = value;
    }

    [MethodImpl(256 | 512)]
    public static decimal4 Load(ReadOnlySpan<decimal> span) => new(span);

    [MethodImpl(256 | 512)]
    public decimal4(ReadOnlySpan<decimal> span)
    {
        this.x = span[0];
        this.y = span[1];
        this.z = span[2];
        this.w = span[3];
    }

    [MethodImpl(256 | 512)]
    public static unsafe decimal4 Load(decimal* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe decimal4(decimal* ptr)
    {
        this.x = ptr[0];
        this.y = ptr[1];
        this.z = ptr[2];
        this.w = ptr[3];
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out decimal x, out decimal y, out decimal z, out decimal w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // deconstruct

    #region index

    public decimal this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // decimal4
#region half2

[Serializable]
[JsonConverter(typeof(half2JsonConverter))]
public partial struct half2 : 
    IVector2<half>, IVectorSelf<half2>, IVectorSelf<half, half2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 4;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 32;
    }

    public static half2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static half2 One
    { 
        [MethodImpl(256 | 512)]
        get => new((half)1.0);
    }

    #endregion

    #region fields

    private half _x;
    public half x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private half _y;
    public half y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    public half r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public half g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public half2(half x, half y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public half2((half x, half y) tuple) : this(tuple.x, tuple.y) {}

    [MethodImpl(256 | 512)]
    public static implicit operator half2((half x, half y) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator half2(half value) => new(value);

    [MethodImpl(256 | 512)]
    public half2(half value)
    {
        x = value;
        y = value;
    }

    [MethodImpl(256 | 512)]
    public static half2 Scalar(half value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal half2(half value, is_scalar _)
    {
        this.x = value;
    }

    [MethodImpl(256 | 512)]
    public static half2 Load(ReadOnlySpan<half> span) => new(span);

    [MethodImpl(256 | 512)]
    public half2(ReadOnlySpan<half> span)
    {
        this.x = span[0];
        this.y = span[1];
    }

    [MethodImpl(256 | 512)]
    public static unsafe half2 Load(half* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe half2(half* ptr)
    {
        this.x = ptr[0];
        this.y = ptr[1];
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out half x, out half y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // deconstruct

    #region index

    public half this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // half2
#region half3

[Serializable]
[JsonConverter(typeof(half3JsonConverter))]
public partial struct half3 : 
    IVector3<half>, IVectorSelf<half3>, IVectorSelf<half, half3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 8;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 64;
    }

    public static half3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static half3 One
    { 
        [MethodImpl(256 | 512)]
        get => new((half)1.0);
    }

    #endregion

    #region fields

    private half _x;
    public half x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private half _y;
    public half y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private half _z;
    public half z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private half _align;
    public half r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public half g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public half b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public half3(half x, half y, half z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public half3((half x, half y, half z) tuple) : this(tuple.x, tuple.y, tuple.z) {}

    [MethodImpl(256 | 512)]
    public static implicit operator half3((half x, half y, half z) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator half3(half value) => new(value);

    [MethodImpl(256 | 512)]
    public half3(half value)
    {
        x = value;
        y = value;
        z = value;
    }

    [MethodImpl(256 | 512)]
    public static half3 Scalar(half value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal half3(half value, is_scalar _)
    {
        this.x = value;
    }

    [MethodImpl(256 | 512)]
    public static half3 Load(ReadOnlySpan<half> span) => new(span);

    [MethodImpl(256 | 512)]
    public half3(ReadOnlySpan<half> span)
    {
        this.x = span[0];
        this.y = span[1];
        this.z = span[2];
    }

    [MethodImpl(256 | 512)]
    public static unsafe half3 Load(half* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe half3(half* ptr)
    {
        this.x = ptr[0];
        this.y = ptr[1];
        this.z = ptr[2];
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out half x, out half y, out half z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // deconstruct

    #region index

    public half this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // half3
#region half4

[Serializable]
[JsonConverter(typeof(half4JsonConverter))]
public partial struct half4 : 
    IVector4<half>, IVectorSelf<half4>, IVectorSelf<half, half4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 8;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 64;
    }

    public static half4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static half4 One
    { 
        [MethodImpl(256 | 512)]
        get => new((half)1.0);
    }

    #endregion

    #region fields

    private half _x;
    public half x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private half _y;
    public half y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private half _z;
    public half z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private half _w;
    public half w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    public half r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public half g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public half b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public half a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public half4(half x, half y, half z, half w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public half4((half x, half y, half z, half w) tuple) : this(tuple.x, tuple.y, tuple.z, tuple.w) {}

    [MethodImpl(256 | 512)]
    public static implicit operator half4((half x, half y, half z, half w) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator half4(half value) => new(value);

    [MethodImpl(256 | 512)]
    public half4(half value)
    {
        x = value;
        y = value;
        z = value;
        w = value;
    }

    [MethodImpl(256 | 512)]
    public static half4 Scalar(half value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal half4(half value, is_scalar _)
    {
        this.x = value;
    }

    [MethodImpl(256 | 512)]
    public static half4 Load(ReadOnlySpan<half> span) => new(span);

    [MethodImpl(256 | 512)]
    public half4(ReadOnlySpan<half> span)
    {
        this.x = span[0];
        this.y = span[1];
        this.z = span[2];
        this.w = span[3];
    }

    [MethodImpl(256 | 512)]
    public static unsafe half4 Load(half* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe half4(half* ptr)
    {
        this.x = ptr[0];
        this.y = ptr[1];
        this.z = ptr[2];
        this.w = ptr[3];
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out half x, out half y, out half z, out half w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // deconstruct

    #region index

    public half this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // half4
#region b16v2

[Serializable]
[JsonConverter(typeof(b16v2JsonConverter))]
public partial struct b16v2 : 
    IVector2<b16>, IVectorSelf<b16v2>, IVectorSelf<b16, b16v2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 4;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 32;
    }

    public static b16v2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static b16v2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true);
    }

    #endregion

    #region fields

    private b16 _x;
    public b16 x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private b16 _y;
    public b16 y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    public b16 r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public b16 g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public b16v2(b16 x, b16 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public b16v2((b16 x, b16 y) tuple) : this(tuple.x, tuple.y) {}

    [MethodImpl(256 | 512)]
    public static implicit operator b16v2((b16 x, b16 y) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator b16v2(b16 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16v2(b16 value)
    {
        x = value;
        y = value;
    }

    [MethodImpl(256 | 512)]
    public static b16v2 Scalar(b16 value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal b16v2(b16 value, is_scalar _)
    {
        this.x = value;
    }

    [MethodImpl(256 | 512)]
    public static b16v2 Load(ReadOnlySpan<b16> span) => new(span);

    [MethodImpl(256 | 512)]
    public b16v2(ReadOnlySpan<b16> span)
    {
        this.x = span[0];
        this.y = span[1];
    }

    [MethodImpl(256 | 512)]
    public static unsafe b16v2 Load(b16* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe b16v2(b16* ptr)
    {
        this.x = ptr[0];
        this.y = ptr[1];
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out b16 x, out b16 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // deconstruct

    #region index

    public b16 this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // b16v2
#region b16v3

[Serializable]
[JsonConverter(typeof(b16v3JsonConverter))]
public partial struct b16v3 : 
    IVector3<b16>, IVectorSelf<b16v3>, IVectorSelf<b16, b16v3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 8;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 64;
    }

    public static b16v3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static b16v3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true);
    }

    #endregion

    #region fields

    private b16 _x;
    public b16 x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private b16 _y;
    public b16 y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private b16 _z;
    public b16 z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private b16 _align;
    public b16 r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public b16 g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public b16 b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public b16v3(b16 x, b16 y, b16 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public b16v3((b16 x, b16 y, b16 z) tuple) : this(tuple.x, tuple.y, tuple.z) {}

    [MethodImpl(256 | 512)]
    public static implicit operator b16v3((b16 x, b16 y, b16 z) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator b16v3(b16 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16v3(b16 value)
    {
        x = value;
        y = value;
        z = value;
    }

    [MethodImpl(256 | 512)]
    public static b16v3 Scalar(b16 value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal b16v3(b16 value, is_scalar _)
    {
        this.x = value;
    }

    [MethodImpl(256 | 512)]
    public static b16v3 Load(ReadOnlySpan<b16> span) => new(span);

    [MethodImpl(256 | 512)]
    public b16v3(ReadOnlySpan<b16> span)
    {
        this.x = span[0];
        this.y = span[1];
        this.z = span[2];
    }

    [MethodImpl(256 | 512)]
    public static unsafe b16v3 Load(b16* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe b16v3(b16* ptr)
    {
        this.x = ptr[0];
        this.y = ptr[1];
        this.z = ptr[2];
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out b16 x, out b16 y, out b16 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // deconstruct

    #region index

    public b16 this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // b16v3
#region b16v4

[Serializable]
[JsonConverter(typeof(b16v4JsonConverter))]
public partial struct b16v4 : 
    IVector4<b16>, IVectorSelf<b16v4>, IVectorSelf<b16, b16v4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 8;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 64;
    }

    public static b16v4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static b16v4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true);
    }

    #endregion

    #region fields

    private b16 _x;
    public b16 x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private b16 _y;
    public b16 y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private b16 _z;
    public b16 z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private b16 _w;
    public b16 w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    public b16 r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public b16 g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public b16 b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public b16 a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public b16v4(b16 x, b16 y, b16 z, b16 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public b16v4((b16 x, b16 y, b16 z, b16 w) tuple) : this(tuple.x, tuple.y, tuple.z, tuple.w) {}

    [MethodImpl(256 | 512)]
    public static implicit operator b16v4((b16 x, b16 y, b16 z, b16 w) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator b16v4(b16 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16v4(b16 value)
    {
        x = value;
        y = value;
        z = value;
        w = value;
    }

    [MethodImpl(256 | 512)]
    public static b16v4 Scalar(b16 value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal b16v4(b16 value, is_scalar _)
    {
        this.x = value;
    }

    [MethodImpl(256 | 512)]
    public static b16v4 Load(ReadOnlySpan<b16> span) => new(span);

    [MethodImpl(256 | 512)]
    public b16v4(ReadOnlySpan<b16> span)
    {
        this.x = span[0];
        this.y = span[1];
        this.z = span[2];
        this.w = span[3];
    }

    [MethodImpl(256 | 512)]
    public static unsafe b16v4 Load(b16* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe b16v4(b16* ptr)
    {
        this.x = ptr[0];
        this.y = ptr[1];
        this.z = ptr[2];
        this.w = ptr[3];
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out b16 x, out b16 y, out b16 z, out b16 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // deconstruct

    #region index

    public b16 this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // b16v4
#region b32v2

[Serializable]
[JsonConverter(typeof(b32v2JsonConverter))]
public partial struct b32v2 : 
    IVector2<b32>, IVectorSelf<b32v2>, IVectorSelf<b32, b32v2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 8;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 64;
    }

    public static b32v2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static b32v2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true);
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector64<uint> vector;
    
    #region Unsafe Inner

    [MethodImpl(256 | 512)]
    public static explicit operator Vector64<uint>(b32v2 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector64<uint> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector64<uint> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector64<uint> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public b32 x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public b32 y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private b32 _x;
    public b32 x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private b32 _y;
    public b32 y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    #endif // NET8_0_OR_GREATER
    public b32 r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public b32 g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal b32v2(Vector64<uint> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static b32v2 UnsafeFromInner(Vector64<uint> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public b32v2(b32 x, b32 y)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.Create(x, y);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public b32v2((b32 x, b32 y) tuple) : this(tuple.x, tuple.y) {}

    [MethodImpl(256 | 512)]
    public static implicit operator b32v2((b32 x, b32 y) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v2(b32 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32v2(b32 value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.Create((uint)value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b32v2 Scalar(b32 value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal b32v2(b32 value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.CreateScalar((uint)value);
        #else // NET8_0_OR_GREATER
        this.x = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b32v2 Load(ReadOnlySpan<b32> span) => new(span);

    [MethodImpl(256 | 512)]
    public b32v2(ReadOnlySpan<b32> span)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.LoadUnsafe(in MemoryMarshal.Cast<b32, uint>(span)[0]);
        #else // NET8_0_OR_GREATER
        this.x = span[0];
        this.y = span[1];
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static unsafe b32v2 Load(b32* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe b32v2(b32* ptr)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.Load((uint*)ptr);
        #else // NET8_0_OR_GREATER
        this.x = ptr[0];
        this.y = ptr[1];
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out b32 x, out b32 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // deconstruct

    #region index

    public b32 this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // b32v2
#region b32v3

[Serializable]
[JsonConverter(typeof(b32v3JsonConverter))]
public partial struct b32v3 : 
    IVector3<b32>, IVectorSelf<b32v3>, IVectorSelf<b32, b32v3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128;
    }

    public static b32v3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static b32v3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true);
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<uint> vector;
    
    #region Unsafe Inner

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<uint>(b32v3 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<uint> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<uint> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<uint> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public b32 x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public b32 y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public b32 z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private b32 _x;
    public b32 x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private b32 _y;
    public b32 y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private b32 _z;
    public b32 z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private b32 _align;
    #endif // NET8_0_OR_GREATER
    public b32 r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public b32 g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public b32 b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal b32v3(Vector128<uint> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static b32v3 UnsafeFromInner(Vector128<uint> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public b32v3(b32 x, b32 y, b32 z)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y, z, default);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public b32v3((b32 x, b32 y, b32 z) tuple) : this(tuple.x, tuple.y, tuple.z) {}

    [MethodImpl(256 | 512)]
    public static implicit operator b32v3((b32 x, b32 y, b32 z) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v3(b32 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32v3(b32 value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create((uint)value, value, value, default);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b32v3 Scalar(b32 value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal b32v3(b32 value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar((uint)value);
        #else // NET8_0_OR_GREATER
        this.x = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b32v3 Load(ReadOnlySpan<b32> span) => new(span);

    [MethodImpl(256 | 512)]
    public b32v3(ReadOnlySpan<b32> span)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.LoadUnsafe(in MemoryMarshal.Cast<b32, uint>(span)[0]);
        #else // NET8_0_OR_GREATER
        this.x = span[0];
        this.y = span[1];
        this.z = span[2];
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static unsafe b32v3 Load(b32* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe b32v3(b32* ptr)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Load((uint*)ptr);
        #else // NET8_0_OR_GREATER
        this.x = ptr[0];
        this.y = ptr[1];
        this.z = ptr[2];
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out b32 x, out b32 y, out b32 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // deconstruct

    #region index

    public b32 this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // b32v3
#region b32v4

[Serializable]
[JsonConverter(typeof(b32v4JsonConverter))]
public partial struct b32v4 : 
    IVector4<b32>, IVectorSelf<b32v4>, IVectorSelf<b32, b32v4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128;
    }

    public static b32v4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static b32v4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true);
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<uint> vector;
    
    #region Unsafe Inner

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<uint>(b32v4 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<uint> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<uint> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<uint> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public b32 x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public b32 y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public b32 z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public b32 w
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(3);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private b32 _x;
    public b32 x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private b32 _y;
    public b32 y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private b32 _z;
    public b32 z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private b32 _w;
    public b32 w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    #endif // NET8_0_OR_GREATER
    public b32 r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public b32 g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public b32 b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public b32 a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal b32v4(Vector128<uint> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static b32v4 UnsafeFromInner(Vector128<uint> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public b32v4(b32 x, b32 y, b32 z, b32 w)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y, z, w);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public b32v4((b32 x, b32 y, b32 z, b32 w) tuple) : this(tuple.x, tuple.y, tuple.z, tuple.w) {}

    [MethodImpl(256 | 512)]
    public static implicit operator b32v4((b32 x, b32 y, b32 z, b32 w) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v4(b32 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32v4(b32 value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create((uint)value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        w = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b32v4 Scalar(b32 value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal b32v4(b32 value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar((uint)value);
        #else // NET8_0_OR_GREATER
        this.x = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b32v4 Load(ReadOnlySpan<b32> span) => new(span);

    [MethodImpl(256 | 512)]
    public b32v4(ReadOnlySpan<b32> span)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.LoadUnsafe(in MemoryMarshal.Cast<b32, uint>(span)[0]);
        #else // NET8_0_OR_GREATER
        this.x = span[0];
        this.y = span[1];
        this.z = span[2];
        this.w = span[3];
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static unsafe b32v4 Load(b32* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe b32v4(b32* ptr)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Load((uint*)ptr);
        #else // NET8_0_OR_GREATER
        this.x = ptr[0];
        this.y = ptr[1];
        this.z = ptr[2];
        this.w = ptr[3];
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out b32 x, out b32 y, out b32 z, out b32 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // deconstruct

    #region index

    public b32 this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // b32v4
#region b64v2

[Serializable]
[JsonConverter(typeof(b64v2JsonConverter))]
public partial struct b64v2 : 
    IVector2<b64>, IVectorSelf<b64v2>, IVectorSelf<b64, b64v2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128;
    }

    public static b64v2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static b64v2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true);
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<ulong> vector;
    
    #region Unsafe Inner

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<ulong>(b64v2 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<ulong> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<ulong> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<ulong> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public b64 x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public b64 y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private b64 _x;
    public b64 x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private b64 _y;
    public b64 y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    #endif // NET8_0_OR_GREATER
    public b64 r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public b64 g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal b64v2(Vector128<ulong> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static b64v2 UnsafeFromInner(Vector128<ulong> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public b64v2(b64 x, b64 y)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public b64v2((b64 x, b64 y) tuple) : this(tuple.x, tuple.y) {}

    [MethodImpl(256 | 512)]
    public static implicit operator b64v2((b64 x, b64 y) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v2(b64 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64v2(b64 value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create((ulong)value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b64v2 Scalar(b64 value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal b64v2(b64 value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar((ulong)value);
        #else // NET8_0_OR_GREATER
        this.x = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b64v2 Load(ReadOnlySpan<b64> span) => new(span);

    [MethodImpl(256 | 512)]
    public b64v2(ReadOnlySpan<b64> span)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.LoadUnsafe(in MemoryMarshal.Cast<b64, ulong>(span)[0]);
        #else // NET8_0_OR_GREATER
        this.x = span[0];
        this.y = span[1];
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static unsafe b64v2 Load(b64* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe b64v2(b64* ptr)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Load((ulong*)ptr);
        #else // NET8_0_OR_GREATER
        this.x = ptr[0];
        this.y = ptr[1];
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out b64 x, out b64 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // deconstruct

    #region index

    public b64 this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // b64v2
#region b64v3

[Serializable]
[JsonConverter(typeof(b64v3JsonConverter))]
public partial struct b64v3 : 
    IVector3<b64>, IVectorSelf<b64v3>, IVectorSelf<b64, b64v3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 32;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 256;
    }

    public static b64v3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static b64v3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true);
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector256<ulong> vector;
    
    #region Unsafe Inner

    [MethodImpl(256 | 512)]
    public static explicit operator Vector256<ulong>(b64v3 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector256<ulong> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector256<ulong> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector256<ulong> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public b64 x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public b64 y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public b64 z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private b64 _x;
    public b64 x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private b64 _y;
    public b64 y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private b64 _z;
    public b64 z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private b64 _align;
    #endif // NET8_0_OR_GREATER
    public b64 r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public b64 g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public b64 b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal b64v3(Vector256<ulong> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static b64v3 UnsafeFromInner(Vector256<ulong> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public b64v3(b64 x, b64 y, b64 z)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(x, y, z, default);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public b64v3((b64 x, b64 y, b64 z) tuple) : this(tuple.x, tuple.y, tuple.z) {}

    [MethodImpl(256 | 512)]
    public static implicit operator b64v3((b64 x, b64 y, b64 z) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v3(b64 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64v3(b64 value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create((ulong)value, value, value, default);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b64v3 Scalar(b64 value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal b64v3(b64 value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.CreateScalar((ulong)value);
        #else // NET8_0_OR_GREATER
        this.x = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b64v3 Load(ReadOnlySpan<b64> span) => new(span);

    [MethodImpl(256 | 512)]
    public b64v3(ReadOnlySpan<b64> span)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.LoadUnsafe(in MemoryMarshal.Cast<b64, ulong>(span)[0]);
        #else // NET8_0_OR_GREATER
        this.x = span[0];
        this.y = span[1];
        this.z = span[2];
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static unsafe b64v3 Load(b64* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe b64v3(b64* ptr)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Load((ulong*)ptr);
        #else // NET8_0_OR_GREATER
        this.x = ptr[0];
        this.y = ptr[1];
        this.z = ptr[2];
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out b64 x, out b64 y, out b64 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // deconstruct

    #region index

    public b64 this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // b64v3
#region b64v4

[Serializable]
[JsonConverter(typeof(b64v4JsonConverter))]
public partial struct b64v4 : 
    IVector4<b64>, IVectorSelf<b64v4>, IVectorSelf<b64, b64v4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true;
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4;
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 32;
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 256;
    }

    public static b64v4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static b64v4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true);
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector256<ulong> vector;
    
    #region Unsafe Inner

    [MethodImpl(256 | 512)]
    public static explicit operator Vector256<ulong>(b64v4 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector256<ulong> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector256<ulong> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector256<ulong> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public b64 x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public b64 y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public b64 z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public b64 w
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(3);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private b64 _x;
    public b64 x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private b64 _y;
    public b64 y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private b64 _z;
    public b64 z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private b64 _w;
    public b64 w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    #endif // NET8_0_OR_GREATER
    public b64 r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public b64 g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public b64 b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public b64 a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal b64v4(Vector256<ulong> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static b64v4 UnsafeFromInner(Vector256<ulong> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public b64v4(b64 x, b64 y, b64 z, b64 w)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(x, y, z, w);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public b64v4((b64 x, b64 y, b64 z, b64 w) tuple) : this(tuple.x, tuple.y, tuple.z, tuple.w) {}

    [MethodImpl(256 | 512)]
    public static implicit operator b64v4((b64 x, b64 y, b64 z, b64 w) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v4(b64 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64v4(b64 value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create((ulong)value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        w = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b64v4 Scalar(b64 value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal b64v4(b64 value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.CreateScalar((ulong)value);
        #else // NET8_0_OR_GREATER
        this.x = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b64v4 Load(ReadOnlySpan<b64> span) => new(span);

    [MethodImpl(256 | 512)]
    public b64v4(ReadOnlySpan<b64> span)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.LoadUnsafe(in MemoryMarshal.Cast<b64, ulong>(span)[0]);
        #else // NET8_0_OR_GREATER
        this.x = span[0];
        this.y = span[1];
        this.z = span[2];
        this.w = span[3];
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static unsafe b64v4 Load(b64* ptr) => new(ptr);

    [MethodImpl(256 | 512)]
    public unsafe b64v4(b64* ptr)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Load((ulong*)ptr);
        #else // NET8_0_OR_GREATER
        this.x = ptr[0];
        this.y = ptr[1];
        this.z = ptr[2];
        this.w = ptr[3];
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region deconstruct

    [MethodImpl(256 | 512)]
    public void Deconstruct(out b64 x, out b64 y, out b64 z, out b64 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // deconstruct

    #region index

    public b64 this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // index
}

#endregion // b64v4
