// generated by template, do not modify manually

namespace Coplt.Mathematics;
#region float2

[Serializable]
[JsonConverter(typeof(float2JsonConverter))]
public partial struct float2 : 
    IVector2<float>, IVectorSelf<float2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 64; 
    }

    public static float2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static float2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0f); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector64<float> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector64<float>(float2 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector64<float> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector64<float> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector64<float> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public float x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public float y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private float _x;
    public float x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private float _y;
    public float y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    #endif // NET8_0_OR_GREATER
    public float r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public float g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal float2(Vector64<float> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static float2 UnsafeFromInner(Vector64<float> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public float2(float x, float y)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.Create(x, y);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2(float value) => new(value);

    [MethodImpl(256 | 512)]
    public float2(float value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.Create(value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float2 Scalar(float value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal float2(float value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region Index

    public float this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // float2
#region float3

[Serializable]
[JsonConverter(typeof(float3JsonConverter))]
public partial struct float3 : 
    IVector3<float>, IVectorSelf<float3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128; 
    }

    public static float3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static float3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0f); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<float> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<float>(float3 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<float> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<float> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<float> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public float x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public float y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public float z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private float _x;
    public float x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private float _y;
    public float y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private float _z;
    public float z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private float _align;
    #endif // NET8_0_OR_GREATER
    public float r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public float g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public float b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal float3(Vector128<float> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static float3 UnsafeFromInner(Vector128<float> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public float3(float x, float y, float z)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y, z, default);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3(float value) => new(value);

    [MethodImpl(256 | 512)]
    public float3(float value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(value, value, value, default);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float3 Scalar(float value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal float3(float value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region Index

    public float this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // float3
#region float4

[Serializable]
[JsonConverter(typeof(float4JsonConverter))]
public partial struct float4 : 
    IVector4<float>, IVectorSelf<float4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128; 
    }

    public static float4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static float4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0f); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<float> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<float>(float4 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<float> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<float> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<float> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public float x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public float y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public float z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public float w
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(3);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private float _x;
    public float x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private float _y;
    public float y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private float _z;
    public float z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private float _w;
    public float w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    #endif // NET8_0_OR_GREATER
    public float r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public float g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public float b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public float a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal float4(Vector128<float> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static float4 UnsafeFromInner(Vector128<float> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public float4(float x, float y, float z, float w)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y, z, w);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4(float value) => new(value);

    [MethodImpl(256 | 512)]
    public float4(float value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        w = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static float4 Scalar(float value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal float4(float value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region Index

    public float this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // float4
#region double2

[Serializable]
[JsonConverter(typeof(double2JsonConverter))]
public partial struct double2 : 
    IVector2<double>, IVectorSelf<double2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128; 
    }

    public static double2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static double2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<double> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<double>(double2 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<double> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<double> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<double> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public double x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public double y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private double _x;
    public double x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private double _y;
    public double y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    #endif // NET8_0_OR_GREATER
    public double r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public double g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal double2(Vector128<double> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static double2 UnsafeFromInner(Vector128<double> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public double2(double x, double y)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2(double value) => new(value);

    [MethodImpl(256 | 512)]
    public double2(double value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double2 Scalar(double value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal double2(double value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region Index

    public double this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // double2
#region double3

[Serializable]
[JsonConverter(typeof(double3JsonConverter))]
public partial struct double3 : 
    IVector3<double>, IVectorSelf<double3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 32; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 256; 
    }

    public static double3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static double3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector256<double> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector256<double>(double3 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector256<double> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector256<double> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector256<double> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public double x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public double y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public double z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private double _x;
    public double x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private double _y;
    public double y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private double _z;
    public double z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private double _align;
    #endif // NET8_0_OR_GREATER
    public double r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public double g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public double b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal double3(Vector256<double> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static double3 UnsafeFromInner(Vector256<double> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public double3(double x, double y, double z)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(x, y, z, default);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3(double value) => new(value);

    [MethodImpl(256 | 512)]
    public double3(double value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(value, value, value, default);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double3 Scalar(double value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal double3(double value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region Index

    public double this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // double3
#region double4

[Serializable]
[JsonConverter(typeof(double4JsonConverter))]
public partial struct double4 : 
    IVector4<double>, IVectorSelf<double4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 32; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 256; 
    }

    public static double4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static double4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1.0); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector256<double> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector256<double>(double4 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector256<double> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector256<double> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector256<double> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public double x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public double y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public double z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public double w
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(3);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private double _x;
    public double x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private double _y;
    public double y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private double _z;
    public double z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private double _w;
    public double w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    #endif // NET8_0_OR_GREATER
    public double r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public double g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public double b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public double a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal double4(Vector256<double> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static double4 UnsafeFromInner(Vector256<double> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public double4(double x, double y, double z, double w)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(x, y, z, w);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4(double value) => new(value);

    [MethodImpl(256 | 512)]
    public double4(double value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        w = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static double4 Scalar(double value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal double4(double value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region Index

    public double this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // double4
#region int2

[Serializable]
[JsonConverter(typeof(int2JsonConverter))]
public partial struct int2 : 
    IVector2<int>, IVectorSelf<int2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 64; 
    }

    public static int2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static int2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector64<int> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector64<int>(int2 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector64<int> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector64<int> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector64<int> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public int x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public int y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private int _x;
    public int x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private int _y;
    public int y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    #endif // NET8_0_OR_GREATER
    public int r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public int g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal int2(Vector64<int> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static int2 UnsafeFromInner(Vector64<int> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public int2(int x, int y)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.Create(x, y);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2(int value) => new(value);

    [MethodImpl(256 | 512)]
    public int2(int value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.Create(value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int2 Scalar(int value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal int2(int value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region Index

    public int this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // int2
#region int3

[Serializable]
[JsonConverter(typeof(int3JsonConverter))]
public partial struct int3 : 
    IVector3<int>, IVectorSelf<int3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128; 
    }

    public static int3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static int3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<int> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<int>(int3 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<int> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<int> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<int> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public int x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public int y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public int z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private int _x;
    public int x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private int _y;
    public int y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private int _z;
    public int z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private int _align;
    #endif // NET8_0_OR_GREATER
    public int r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public int g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public int b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal int3(Vector128<int> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static int3 UnsafeFromInner(Vector128<int> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public int3(int x, int y, int z)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y, z, default);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3(int value) => new(value);

    [MethodImpl(256 | 512)]
    public int3(int value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(value, value, value, default);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int3 Scalar(int value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal int3(int value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region Index

    public int this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // int3
#region int4

[Serializable]
[JsonConverter(typeof(int4JsonConverter))]
public partial struct int4 : 
    IVector4<int>, IVectorSelf<int4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128; 
    }

    public static int4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static int4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<int> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<int>(int4 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<int> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<int> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<int> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public int x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public int y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public int z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public int w
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(3);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private int _x;
    public int x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private int _y;
    public int y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private int _z;
    public int z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private int _w;
    public int w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    #endif // NET8_0_OR_GREATER
    public int r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public int g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public int b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public int a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal int4(Vector128<int> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static int4 UnsafeFromInner(Vector128<int> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public int4(int x, int y, int z, int w)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y, z, w);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4(int value) => new(value);

    [MethodImpl(256 | 512)]
    public int4(int value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        w = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static int4 Scalar(int value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal int4(int value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region Index

    public int this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // int4
#region uint2

[Serializable]
[JsonConverter(typeof(uint2JsonConverter))]
public partial struct uint2 : 
    IVector2<uint>, IVectorSelf<uint2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 64; 
    }

    public static uint2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static uint2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1u); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector64<uint> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector64<uint>(uint2 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector64<uint> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector64<uint> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector64<uint> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public uint x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public uint y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private uint _x;
    public uint x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private uint _y;
    public uint y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    #endif // NET8_0_OR_GREATER
    public uint r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public uint g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal uint2(Vector64<uint> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static uint2 UnsafeFromInner(Vector64<uint> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public uint2(uint x, uint y)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.Create(x, y);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public uint2(uint value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.Create((uint)value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint2 Scalar(uint value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal uint2(uint value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.CreateScalar((uint)value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region Index

    public uint this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // uint2
#region uint3

[Serializable]
[JsonConverter(typeof(uint3JsonConverter))]
public partial struct uint3 : 
    IVector3<uint>, IVectorSelf<uint3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128; 
    }

    public static uint3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static uint3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1u); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<uint> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<uint>(uint3 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<uint> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<uint> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<uint> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public uint x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public uint y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public uint z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private uint _x;
    public uint x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private uint _y;
    public uint y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private uint _z;
    public uint z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private uint _align;
    #endif // NET8_0_OR_GREATER
    public uint r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public uint g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public uint b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal uint3(Vector128<uint> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static uint3 UnsafeFromInner(Vector128<uint> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public uint3(uint x, uint y, uint z)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y, z, default);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public uint3(uint value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create((uint)value, value, value, default);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint3 Scalar(uint value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal uint3(uint value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar((uint)value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region Index

    public uint this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // uint3
#region uint4

[Serializable]
[JsonConverter(typeof(uint4JsonConverter))]
public partial struct uint4 : 
    IVector4<uint>, IVectorSelf<uint4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128; 
    }

    public static uint4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static uint4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1u); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<uint> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<uint>(uint4 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<uint> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<uint> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<uint> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public uint x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public uint y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public uint z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public uint w
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(3);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private uint _x;
    public uint x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private uint _y;
    public uint y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private uint _z;
    public uint z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private uint _w;
    public uint w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    #endif // NET8_0_OR_GREATER
    public uint r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public uint g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public uint b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public uint a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal uint4(Vector128<uint> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static uint4 UnsafeFromInner(Vector128<uint> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public uint4(uint x, uint y, uint z, uint w)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y, z, w);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public uint4(uint value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create((uint)value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        w = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static uint4 Scalar(uint value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal uint4(uint value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar((uint)value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region Index

    public uint this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // uint4
#region long2

[Serializable]
[JsonConverter(typeof(long2JsonConverter))]
public partial struct long2 : 
    IVector2<long>, IVectorSelf<long2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128; 
    }

    public static long2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static long2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1L); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<long> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<long>(long2 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<long> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<long> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<long> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public long x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public long y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private long _x;
    public long x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private long _y;
    public long y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    #endif // NET8_0_OR_GREATER
    public long r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public long g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal long2(Vector128<long> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static long2 UnsafeFromInner(Vector128<long> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public long2(long x, long y)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2(long value) => new(value);

    [MethodImpl(256 | 512)]
    public long2(long value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long2 Scalar(long value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal long2(long value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region Index

    public long this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // long2
#region long3

[Serializable]
[JsonConverter(typeof(long3JsonConverter))]
public partial struct long3 : 
    IVector3<long>, IVectorSelf<long3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 32; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 256; 
    }

    public static long3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static long3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1L); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector256<long> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector256<long>(long3 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector256<long> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector256<long> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector256<long> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public long x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public long y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public long z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private long _x;
    public long x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private long _y;
    public long y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private long _z;
    public long z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private long _align;
    #endif // NET8_0_OR_GREATER
    public long r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public long g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public long b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal long3(Vector256<long> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static long3 UnsafeFromInner(Vector256<long> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public long3(long x, long y, long z)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(x, y, z, default);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3(long value) => new(value);

    [MethodImpl(256 | 512)]
    public long3(long value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(value, value, value, default);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long3 Scalar(long value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal long3(long value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region Index

    public long this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // long3
#region long4

[Serializable]
[JsonConverter(typeof(long4JsonConverter))]
public partial struct long4 : 
    IVector4<long>, IVectorSelf<long4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 32; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 256; 
    }

    public static long4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static long4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1L); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector256<long> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector256<long>(long4 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector256<long> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector256<long> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector256<long> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public long x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public long y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public long z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public long w
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(3);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private long _x;
    public long x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private long _y;
    public long y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private long _z;
    public long z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private long _w;
    public long w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    #endif // NET8_0_OR_GREATER
    public long r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public long g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public long b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public long a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal long4(Vector256<long> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static long4 UnsafeFromInner(Vector256<long> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public long4(long x, long y, long z, long w)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(x, y, z, w);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4(long value) => new(value);

    [MethodImpl(256 | 512)]
    public long4(long value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        w = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static long4 Scalar(long value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal long4(long value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.CreateScalar(value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region Index

    public long this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // long4
#region ulong2

[Serializable]
[JsonConverter(typeof(ulong2JsonConverter))]
public partial struct ulong2 : 
    IVector2<ulong>, IVectorSelf<ulong2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128; 
    }

    public static ulong2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ulong2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1UL); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<ulong> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<ulong>(ulong2 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<ulong> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<ulong> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<ulong> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public ulong x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public ulong y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private ulong _x;
    public ulong x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private ulong _y;
    public ulong y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    #endif // NET8_0_OR_GREATER
    public ulong r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public ulong g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal ulong2(Vector128<ulong> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static ulong2 UnsafeFromInner(Vector128<ulong> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public ulong2(ulong x, ulong y)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong2(ulong value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create((ulong)value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong2 Scalar(ulong value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal ulong2(ulong value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar((ulong)value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region Index

    public ulong this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // ulong2
#region ulong3

[Serializable]
[JsonConverter(typeof(ulong3JsonConverter))]
public partial struct ulong3 : 
    IVector3<ulong>, IVectorSelf<ulong3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 32; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 256; 
    }

    public static ulong3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ulong3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1UL); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector256<ulong> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector256<ulong>(ulong3 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector256<ulong> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector256<ulong> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector256<ulong> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public ulong x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public ulong y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public ulong z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private ulong _x;
    public ulong x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private ulong _y;
    public ulong y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private ulong _z;
    public ulong z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private ulong _align;
    #endif // NET8_0_OR_GREATER
    public ulong r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public ulong g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public ulong b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal ulong3(Vector256<ulong> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static ulong3 UnsafeFromInner(Vector256<ulong> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public ulong3(ulong x, ulong y, ulong z)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(x, y, z, default);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong3(ulong value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create((ulong)value, value, value, default);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong3 Scalar(ulong value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal ulong3(ulong value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.CreateScalar((ulong)value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region Index

    public ulong this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // ulong3
#region ulong4

[Serializable]
[JsonConverter(typeof(ulong4JsonConverter))]
public partial struct ulong4 : 
    IVector4<ulong>, IVectorSelf<ulong4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 32; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 256; 
    }

    public static ulong4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static ulong4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1UL); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector256<ulong> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector256<ulong>(ulong4 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector256<ulong> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector256<ulong> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector256<ulong> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public ulong x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public ulong y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public ulong z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public ulong w
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(3);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private ulong _x;
    public ulong x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private ulong _y;
    public ulong y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private ulong _z;
    public ulong z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private ulong _w;
    public ulong w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    #endif // NET8_0_OR_GREATER
    public ulong r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public ulong g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public ulong b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public ulong a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal ulong4(Vector256<ulong> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static ulong4 UnsafeFromInner(Vector256<ulong> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public ulong4(ulong x, ulong y, ulong z, ulong w)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(x, y, z, w);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong4(ulong value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create((ulong)value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        w = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static ulong4 Scalar(ulong value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal ulong4(ulong value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.CreateScalar((ulong)value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region Index

    public ulong this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // ulong4
#region decimal2

[Serializable]
[JsonConverter(typeof(decimal2JsonConverter))]
public partial struct decimal2 : 
    IVector2<decimal>, IVectorSelf<decimal2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 32; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 256; 
    }

    public static decimal2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static decimal2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1m); 
    }

    #endregion

    #region fields

    private decimal _x;
    public decimal x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private decimal _y;
    public decimal y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    public decimal r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public decimal g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public decimal2(decimal x, decimal y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal2(decimal value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal2(decimal value)
    {
        x = value;
        y = value;
    }

    [MethodImpl(256 | 512)]
    public static decimal2 Scalar(decimal value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal decimal2(decimal value, is_scalar _)
    {
        x = value;
    }

    #endregion // ctors

    #region Index

    public decimal this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // decimal2
#region decimal3

[Serializable]
[JsonConverter(typeof(decimal3JsonConverter))]
public partial struct decimal3 : 
    IVector3<decimal>, IVectorSelf<decimal3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 64; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 512; 
    }

    public static decimal3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static decimal3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1m); 
    }

    #endregion

    #region fields

    private decimal _x;
    public decimal x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private decimal _y;
    public decimal y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private decimal _z;
    public decimal z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private decimal _align;
    public decimal r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public decimal g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public decimal b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public decimal3(decimal x, decimal y, decimal z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal3(decimal value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal3(decimal value)
    {
        x = value;
        y = value;
        z = value;
    }

    [MethodImpl(256 | 512)]
    public static decimal3 Scalar(decimal value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal decimal3(decimal value, is_scalar _)
    {
        x = value;
    }

    #endregion // ctors

    #region Index

    public decimal this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // decimal3
#region decimal4

[Serializable]
[JsonConverter(typeof(decimal4JsonConverter))]
public partial struct decimal4 : 
    IVector4<decimal>, IVectorSelf<decimal4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 64; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 512; 
    }

    public static decimal4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static decimal4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(1m); 
    }

    #endregion

    #region fields

    private decimal _x;
    public decimal x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private decimal _y;
    public decimal y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private decimal _z;
    public decimal z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private decimal _w;
    public decimal w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    public decimal r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public decimal g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public decimal b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public decimal a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public decimal4(decimal x, decimal y, decimal z, decimal w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator decimal4(decimal value) => new(value);

    [MethodImpl(256 | 512)]
    public decimal4(decimal value)
    {
        x = value;
        y = value;
        z = value;
        w = value;
    }

    [MethodImpl(256 | 512)]
    public static decimal4 Scalar(decimal value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal decimal4(decimal value, is_scalar _)
    {
        x = value;
    }

    #endregion // ctors

    #region Index

    public decimal this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // decimal4
#region half2

[Serializable]
[JsonConverter(typeof(half2JsonConverter))]
public partial struct half2 : 
    IVector2<half>, IVectorSelf<half2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 32; 
    }

    public static half2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static half2 One
    { 
        [MethodImpl(256 | 512)]
        get => new((half)1.0); 
    }

    #endregion

    #region fields

    private half _x;
    public half x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private half _y;
    public half y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    public half r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public half g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public half2(half x, half y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half2(half value) => new(value);

    [MethodImpl(256 | 512)]
    public half2(half value)
    {
        x = value;
        y = value;
    }

    [MethodImpl(256 | 512)]
    public static half2 Scalar(half value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal half2(half value, is_scalar _)
    {
        x = value;
    }

    #endregion // ctors

    #region Index

    public half this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // half2
#region half3

[Serializable]
[JsonConverter(typeof(half3JsonConverter))]
public partial struct half3 : 
    IVector3<half>, IVectorSelf<half3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 64; 
    }

    public static half3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static half3 One
    { 
        [MethodImpl(256 | 512)]
        get => new((half)1.0); 
    }

    #endregion

    #region fields

    private half _x;
    public half x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private half _y;
    public half y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private half _z;
    public half z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private half _align;
    public half r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public half g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public half b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public half3(half x, half y, half z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half3(half value) => new(value);

    [MethodImpl(256 | 512)]
    public half3(half value)
    {
        x = value;
        y = value;
        z = value;
    }

    [MethodImpl(256 | 512)]
    public static half3 Scalar(half value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal half3(half value, is_scalar _)
    {
        x = value;
    }

    #endregion // ctors

    #region Index

    public half this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // half3
#region half4

[Serializable]
[JsonConverter(typeof(half4JsonConverter))]
public partial struct half4 : 
    IVector4<half>, IVectorSelf<half4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 64; 
    }

    public static half4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static half4 One
    { 
        [MethodImpl(256 | 512)]
        get => new((half)1.0); 
    }

    #endregion

    #region fields

    private half _x;
    public half x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private half _y;
    public half y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private half _z;
    public half z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private half _w;
    public half w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    public half r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public half g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public half b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public half a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public half4(half x, half y, half z, half w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator half4(half value) => new(value);

    [MethodImpl(256 | 512)]
    public half4(half value)
    {
        x = value;
        y = value;
        z = value;
        w = value;
    }

    [MethodImpl(256 | 512)]
    public static half4 Scalar(half value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal half4(half value, is_scalar _)
    {
        x = value;
    }

    #endregion // ctors

    #region Index

    public half this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // half4
#region b16v2

[Serializable]
[JsonConverter(typeof(b16v2JsonConverter))]
public partial struct b16v2 : 
    IVector2<b16>, IVectorSelf<b16v2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 32; 
    }

    public static b16v2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b16v2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    #endregion

    #region fields

    private b16 _x;
    public b16 x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private b16 _y;
    public b16 y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    public b16 r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public b16 g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public b16v2(b16 x, b16 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16v2(b16 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16v2(b16 value)
    {
        x = value;
        y = value;
    }

    [MethodImpl(256 | 512)]
    public static b16v2 Scalar(b16 value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal b16v2(b16 value, is_scalar _)
    {
        x = value;
    }

    #endregion // ctors

    #region Index

    public b16 this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // b16v2
#region b16v3

[Serializable]
[JsonConverter(typeof(b16v3JsonConverter))]
public partial struct b16v3 : 
    IVector3<b16>, IVectorSelf<b16v3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 64; 
    }

    public static b16v3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b16v3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    #endregion

    #region fields

    private b16 _x;
    public b16 x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private b16 _y;
    public b16 y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private b16 _z;
    public b16 z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private b16 _align;
    public b16 r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public b16 g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public b16 b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public b16v3(b16 x, b16 y, b16 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16v3(b16 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16v3(b16 value)
    {
        x = value;
        y = value;
        z = value;
    }

    [MethodImpl(256 | 512)]
    public static b16v3 Scalar(b16 value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal b16v3(b16 value, is_scalar _)
    {
        x = value;
    }

    #endregion // ctors

    #region Index

    public b16 this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // b16v3
#region b16v4

[Serializable]
[JsonConverter(typeof(b16v4JsonConverter))]
public partial struct b16v4 : 
    IVector4<b16>, IVectorSelf<b16v4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => false; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 64; 
    }

    public static b16v4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b16v4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    #endregion

    #region fields

    private b16 _x;
    public b16 x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private b16 _y;
    public b16 y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private b16 _z;
    public b16 z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private b16 _w;
    public b16 w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    public b16 r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public b16 g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public b16 b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public b16 a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors


    [MethodImpl(256 | 512)]
    public b16v4(b16 x, b16 y, b16 z, b16 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b16v4(b16 value) => new(value);

    [MethodImpl(256 | 512)]
    public b16v4(b16 value)
    {
        x = value;
        y = value;
        z = value;
        w = value;
    }

    [MethodImpl(256 | 512)]
    public static b16v4 Scalar(b16 value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal b16v4(b16 value, is_scalar _)
    {
        x = value;
    }

    #endregion // ctors

    #region Index

    public b16 this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // b16v4
#region b32v2

[Serializable]
[JsonConverter(typeof(b32v2JsonConverter))]
public partial struct b32v2 : 
    IVector2<b32>, IVectorSelf<b32v2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 64; 
    }

    public static b32v2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b32v2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector64<uint> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector64<uint>(b32v2 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector64<uint> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector64<uint> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector64<uint> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public b32 x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public b32 y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private b32 _x;
    public b32 x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private b32 _y;
    public b32 y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    #endif // NET8_0_OR_GREATER
    public b32 r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public b32 g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal b32v2(Vector64<uint> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static b32v2 UnsafeFromInner(Vector64<uint> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public b32v2(b32 x, b32 y)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.Create(x, y);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32v2(b32 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32v2(b32 value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.Create((uint)value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b32v2 Scalar(b32 value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal b32v2(b32 value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector64.CreateScalar((uint)value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region Index

    public b32 this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // b32v2
#region b32v3

[Serializable]
[JsonConverter(typeof(b32v3JsonConverter))]
public partial struct b32v3 : 
    IVector3<b32>, IVectorSelf<b32v3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128; 
    }

    public static b32v3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b32v3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<uint> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<uint>(b32v3 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<uint> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<uint> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<uint> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public b32 x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public b32 y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public b32 z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private b32 _x;
    public b32 x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private b32 _y;
    public b32 y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private b32 _z;
    public b32 z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private b32 _align;
    #endif // NET8_0_OR_GREATER
    public b32 r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public b32 g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public b32 b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal b32v3(Vector128<uint> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static b32v3 UnsafeFromInner(Vector128<uint> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public b32v3(b32 x, b32 y, b32 z)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y, z, default);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32v3(b32 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32v3(b32 value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create((uint)value, value, value, default);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b32v3 Scalar(b32 value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal b32v3(b32 value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar((uint)value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region Index

    public b32 this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // b32v3
#region b32v4

[Serializable]
[JsonConverter(typeof(b32v4JsonConverter))]
public partial struct b32v4 : 
    IVector4<b32>, IVectorSelf<b32v4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128; 
    }

    public static b32v4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b32v4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<uint> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<uint>(b32v4 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<uint> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<uint> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<uint> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public b32 x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public b32 y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public b32 z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public b32 w
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(3);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private b32 _x;
    public b32 x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private b32 _y;
    public b32 y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private b32 _z;
    public b32 z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private b32 _w;
    public b32 w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    #endif // NET8_0_OR_GREATER
    public b32 r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public b32 g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public b32 b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public b32 a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal b32v4(Vector128<uint> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static b32v4 UnsafeFromInner(Vector128<uint> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public b32v4(b32 x, b32 y, b32 z, b32 w)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y, z, w);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32v4(b32 value) => new(value);

    [MethodImpl(256 | 512)]
    public b32v4(b32 value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create((uint)value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        w = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b32v4 Scalar(b32 value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal b32v4(b32 value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar((uint)value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region Index

    public b32 this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // b32v4
#region b64v2

[Serializable]
[JsonConverter(typeof(b64v2JsonConverter))]
public partial struct b64v2 : 
    IVector2<b64>, IVectorSelf<b64v2>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 2; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 128; 
    }

    public static b64v2 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b64v2 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector128<ulong> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector128<ulong>(b64v2 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector128<ulong> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<ulong> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector128<ulong> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public b64 x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public b64 y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private b64 _x;
    public b64 x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private b64 _y;
    public b64 y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    #endif // NET8_0_OR_GREATER
    public b64 r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public b64 g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal b64v2(Vector128<ulong> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static b64v2 UnsafeFromInner(Vector128<ulong> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public b64v2(b64 x, b64 y)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(x, y);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64v2(b64 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64v2(b64 value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create((ulong)value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b64v2 Scalar(b64 value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal b64v2(b64 value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.CreateScalar((ulong)value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region Index

    public b64 this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // b64v2
#region b64v3

[Serializable]
[JsonConverter(typeof(b64v3JsonConverter))]
public partial struct b64v3 : 
    IVector3<b64>, IVectorSelf<b64v3>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 3; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 32; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 256; 
    }

    public static b64v3 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b64v3 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector256<ulong> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector256<ulong>(b64v3 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector256<ulong> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector256<ulong> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector256<ulong> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public b64 x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public b64 y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public b64 z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private b64 _x;
    public b64 x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private b64 _y;
    public b64 y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private b64 _z;
    public b64 z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private b64 _align;
    #endif // NET8_0_OR_GREATER
    public b64 r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public b64 g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public b64 b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal b64v3(Vector256<ulong> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static b64v3 UnsafeFromInner(Vector256<ulong> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public b64v3(b64 x, b64 y, b64 z)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(x, y, z, default);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64v3(b64 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64v3(b64 value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create((ulong)value, value, value, default);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b64v3 Scalar(b64 value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal b64v3(b64 value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.CreateScalar((ulong)value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region Index

    public b64 this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // b64v3
#region b64v4

[Serializable]
[JsonConverter(typeof(b64v4JsonConverter))]
public partial struct b64v4 : 
    IVector4<b64>, IVectorSelf<b64v4>
{

    #region Static

    public static bool IsSimdAccelerated
    { 
        [MethodImpl(256 | 512)]
        get => true; 
    }
    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }
    public static int SizeByte
    { 
        [MethodImpl(256 | 512)]
        get => 32; 
    }
    public static int SizeBit
    { 
        [MethodImpl(256 | 512)]
        get => 256; 
    }

    public static b64v4 Zero
    { 
        [MethodImpl(256 | 512)]
        get => default; 
    }

    public static b64v4 One
    { 
        [MethodImpl(256 | 512)]
        get => new(true); 
    }

    #endregion

    #region fields

    #if NET8_0_OR_GREATER
    internal Vector256<ulong> vector;
    
    #region Unsafe Inner    

    [MethodImpl(256 | 512)]
    public static explicit operator Vector256<ulong>(b64v4 self) => self.vector;

    [MethodImpl(256 | 512)]
    public Vector256<ulong> UnsafeGetInner() => vector;
    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector256<ulong> UnsafeGetInnerRef() => ref vector;
    [MethodImpl(256 | 512)]
    public void UnsafeSetInner(Vector256<ulong> vector) => this.vector = vector;
   
    #endregion // Unsafe Inner    

    public b64 x
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(0);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public b64 y
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(1);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public b64 z
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(2);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    public b64 w
    {
        [MethodImpl(256 | 512)]
        get => vector.GetElement(3);
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(0, value);
    }
    #else // NET8_0_OR_GREATER
    private b64 _x;
    public b64 x
    {
        [MethodImpl(256 | 512)]
        get => _x;
        [MethodImpl(256 | 512)]
        set => _x = value;
    }
    private b64 _y;
    public b64 y
    {
        [MethodImpl(256 | 512)]
        get => _y;
        [MethodImpl(256 | 512)]
        set => _y = value;
    }
    private b64 _z;
    public b64 z
    {
        [MethodImpl(256 | 512)]
        get => _z;
        [MethodImpl(256 | 512)]
        set => _z = value;
    }
    private b64 _w;
    public b64 w
    {
        [MethodImpl(256 | 512)]
        get => _w;
        [MethodImpl(256 | 512)]
        set => _w = value;
    }
    #endif // NET8_0_OR_GREATER
    public b64 r
    {
        [MethodImpl(256 | 512)]
        get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public b64 g
    {
        [MethodImpl(256 | 512)]
        get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public b64 b
    {
        [MethodImpl(256 | 512)]
        get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public b64 a
    {
        [MethodImpl(256 | 512)]
        get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    #endregion

    #region ctors

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    internal b64v4(Vector256<ulong> vector) => this.vector = vector;
    [MethodImpl(256 | 512)]
    public static b64v4 UnsafeFromInner(Vector256<ulong> vector) => new(vector);
    #endif // NET8_0_OR_GREATER

    [MethodImpl(256 | 512)]
    public b64v4(b64 x, b64 y, b64 z, b64 w)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(x, y, z, w);
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64v4(b64 value) => new(value);

    [MethodImpl(256 | 512)]
    public b64v4(b64 value)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create((ulong)value);
        #else // NET8_0_OR_GREATER
        x = value;
        y = value;
        z = value;
        w = value;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public static b64v4 Scalar(b64 value) => new(value, new is_scalar());

    [MethodImpl(256 | 512)]
    internal b64v4(b64 value, is_scalar _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.CreateScalar((ulong)value);
        #else // NET8_0_OR_GREATER
        x = value;
        #endif // NET8_0_OR_GREATER
    }

    #endregion // ctors

    #region Index

    public b64 this[int i]
    {
        [MethodImpl(256 | 512)]
        get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index
}

#endregion // b64v4
