<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics;
<#
    foreach (var typ in Typ.Typs)
    {
        if (!typ.f) continue;
        if (!typ.arith) continue;
        if (!typ.bin) continue;

        for (var i = 2; i <= 4; i++)
        {
            var typeName = $"{typ.name}{i}";

            var byteSize = typ.size * (i is 3 ? 4 : i);
            var bitSize = 8 * byteSize;

            var bSize = typ.size * 8;
            var bTypeName = $"b{bSize}v{i}";
#>

#region <#= typeName #>

public partial struct <#= typeName #>
{
    public static <#= typeName #> E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277<#= typ.suffix #>); 
    }
    public static <#= typeName #> PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923<#= typ.suffix #>);
    }
    public static <#= typeName #> π
    { 
        [MethodImpl(256 | 512)] 
        get => PI;
    }
    public static <#= typeName #> PI2
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846<#= typ.suffix #>);
    }
    public static <#= typeName #> π2
    { 
        [MethodImpl(256 | 512)] 
        get => PI2;
    }
    public static <#= typeName #> Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795862<#= typ.suffix #>);
    }
    public static <#= typeName #> Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094<#= typ.suffix #>); 
    }
    public static <#= typeName #> Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009<#= typ.suffix #>);
    }
    public static <#= typeName #> RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861<#= typ.suffix #>);
    }
    public static <#= typeName #> DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144<#= typ.suffix #>);
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static <#= bTypeName #> isInf(this <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(simd.IsInfinity(a.vector).AsUInt<#= bSize #>());
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.isInf()")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= bTypeName #> isPosInf(this <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(Vector<#= bitSize #>.Equals(a.vector, Vector<#= bitSize #>.Create(<#= typ.simdComp #>.PositiveInfinity)).AsUInt<#= bSize #>());
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.isPosInf()")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= bTypeName #> isNegInf(this <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(Vector<#= bitSize #>.Equals(a.vector, Vector<#= bitSize #>.Create(<#= typ.simdComp #>.NegativeInfinity)).AsUInt<#= bSize #>());
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.isNegInf()")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> log(this <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(simd.Log(a.vector));
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.log()")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> log2(this <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(simd.Log2(a.vector));
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.log2()")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> log(this <#= typeName #> a, <#= typeName #> b)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(simd.Log(a.vector) / simd.Log(b.vector));
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.log(b.{Typ.xyzw[n]})")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> log10(this <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(simd.Log10(a.vector));
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.log10()")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> pow(this <#= typeName #> a, <#= typeName #> b)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER && false
        return new(); // new(simd.Exp(simd.Log(a.vector) * b.vector)); // todo exp
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.pow(b.{Typ.xyzw[n]})")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> fma(this <#= typeName #> a, <#= typeName #> b, <#= typeName #> c)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(simd.Fma(a.vector, b.vector, c.vector));
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.fma(b.{Typ.xyzw[n]}, c.{Typ.xyzw[n]})")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }
}

#endregion // <#= typeName #>
<#
        }
    }
#>
