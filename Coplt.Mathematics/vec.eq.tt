<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics;
<#
    foreach (var typ in Typ.Typs)
    {
        for (var i = 2; i <= 4; i++)
        {
            var typeName = $"{typ.name}{i}";

            var byteSize = typ.size * (i is 3 ? 4 : i);
            var bitSize = 8 * byteSize;

            var bType = $"b{typ.size * 8}v";
            var bTyp = Typ.Typs.FirstOrDefault(a => a.name == bType);
            var bTypeName = $"{bType}{i}";
#>

#region <#= typeName #>

public partial struct <#= typeName #> : IEquatable<<#= typeName #>>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<<#= typeName #>, <#= typeName #>, bool>
<#
            if (bTyp.name != null)
            {
#>
    , IEqualityOperators<<#= typeName #>, <#= typeName #>, <#= bTypeName #>>
<#
            }
#>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(<#= typeName #> other) => EqualsAll(other);
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is <#= typeName #> other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return vector.GetHashCode();
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return HashCode.Combine(<#
            {
                var first = true;
                for (var n = 0; n < i; n++)
                {
                    if (first) first = false;
                    else Write(", ");
                    var comp = Typ.xyzw[n];
                    Write(comp);
                }
            }
#>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public bool EqualsAll(<#= typeName #> other)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return (this == other).all();
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return <#
            {
                var first = true;
                for (var n = 0; n < i; n++)
                {
                    if (first) first = false;
                    else Write(" && ");
                    var comp = Typ.xyzw[n];
#><#= comp #> == other.<#= comp #><#
                }
            }
#>;
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public bool EqualsAny(<#= typeName #> other)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return (this == other).any();
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return <#
            {
                var first = true;
                for (var n = 0; n < i; n++)
                {
                    if (first) first = false;
                    else Write(" || ");
                    var comp = Typ.xyzw[n];
#><#= comp #> == other.<#= comp #><#
                }
            }
#>;
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }
<#
            if (bTyp.name != null)
            {
#>

    [MethodImpl(256 | 512)]
    public <#= bTypeName #> EqualsVector(<#= typeName #> other)
    {
<#
                if (typ.simd)
                {
#>
        #if NET8_0_OR_GREATER
        return new(Vector<#= bitSize #>.Equals(vector, other.vector).As<#= bTyp.Type #>()<#
                    if (i == 3)
                    {
#> & Vector<#= bitSize #>.Create(-1, -1, -1, 0).As<#= bTyp.Type #>()<#
                    }
#>);
        #else // NET8_0_OR_GREATER
<#
                }
#>
        return new(<#
                {
                    var first = true;
                    for (var n = 0; n < i; n++)
                    {
                        if (first) first = false;
                        else Write(", ");
                        var comp = Typ.xyzw[n];
#><#= comp #> == other.<#= comp #><#
                    }
                }
#>);
<#
                if (typ.simd)
                {
#>
        #endif // NET8_0_OR_GREATER
<#
                }
#>
    }

    [MethodImpl(256 | 512)]
    public <#= bTypeName #> EqualsVectorNot(<#= typeName #> other)
    {
<#
                if (typ.simd)
                {
#>
        #if NET8_0_OR_GREATER
<#
                    if (typ.f && typ.bin)
                    {
#>
        return new(simd.Ne(vector, other.vector).As<#= bTyp.Type #>()<#
                    if (i == 3)
                    {
#> & Vector<#= bitSize #>.Create(-1, -1, -1, 0).As<#= bTyp.Type #>()<#
                    }
#>);
<#
                    }
                    else
                    {
#>
        return new(~Vector<#= bitSize #>.Equals(vector, other.vector).As<#= bTyp.Type #>()<#
                    if (i == 3)
                    {
#> & Vector<#= bitSize #>.Create(-1, -1, -1, 0).As<#= bTyp.Type #>()<#
                    }
#>);
<#
                    }
                    #>
        #else // NET8_0_OR_GREATER
<#
                }
#>
        return new(<#
                {
                    var first = true;
                    for (var n = 0; n < i; n++)
                    {
                        if (first) first = false;
                        else Write(", ");
                        var comp = Typ.xyzw[n];
#><#= comp #> != other.<#= comp #><#
                    }
                }
#>);
<#
                if (typ.simd)
                {
#>
        #endif // NET8_0_OR_GREATER
<#
                }
#>
    }
<#
            }
#>

    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<<#= typeName #>, <#= typeName #>, bool>.operator ==(<#= typeName #> left, <#= typeName #> right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<<#= typeName #>, <#= typeName #>, bool>.operator !=(<#= typeName #> left, <#= typeName #> right) => !left.Equals(right);
    #endif
<#
            if (bTyp.name != null)
            {
#>

    [MethodImpl(256 | 512)]
    public static <#= bTypeName #> operator ==(<#= typeName #> left, <#= typeName #> right) => left.EqualsVector(right);
    [MethodImpl(256 | 512)]
    public static <#= bTypeName #> operator !=(<#= typeName #> left, <#= typeName #> right) => left.EqualsVectorNot(right);
<#
            }
#>

    #endregion
}

#endregion // <#= typeName #>
<#
        }
    }
#>
