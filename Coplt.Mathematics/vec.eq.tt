<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics;
<#
    foreach (var typ in Typ.Typs)
    {
        for (var i = 2; i <= 4; i++)
        {
            var typeName = $"{typ.name}{i}";
            var type = typ.name;

            var byteSize = typ.size * (i is 3 ? 4 : i);
            var bitSize = 8 * byteSize;

            var format = string.Join(", ", Enumerable.Range(0, i).Select(n => $"{{{Typ.xyzw[n]}}}"));
            var format2 = !typ.formattable
                ? format
                : string.Join(", ", Enumerable.Range(0, i).Select(n => $"{{{Typ.xyzw[n]}.ToString(format, formatProvider)}}"));
#>

#region <#= typeName #>

public partial struct <#= typeName #> : IEquatable<<#= typeName #>>
    #if NET8_0_OR_GREATER
    , IEqualityOperators<<#= typeName #>, <#= typeName #>, bool>
    #endif
{
    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(<#= typeName #> other)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return vector.Equals(other.vector);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return <#
            {
                var first = true;
                for (var n = 0; n < i; n++)
                {
                    if (first) first = false;
                    else Write(" && ");
                    var comp = Typ.xyzw[n];
#><#= comp #>.Equals(other.<#= comp #>)<#
                }
            }
#>;
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }
    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is <#= typeName #> other && Equals(other);
    [MethodImpl(256 | 512)]
    public override int GetHashCode() 
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return vector.GetHashCode();
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return HashCode.Combine(<#
            {
                var first = true;
                for (var n = 0; n < i; n++)
                {
                    if (first) first = false;
                    else Write(", ");
                    var comp = Typ.xyzw[n];
                    Write(comp);
                }
            }
#>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }
    #if NET8_0_OR_GREATER
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<<#= typeName #>, <#= typeName #>, bool>.operator ==(<#= typeName #> left, <#= typeName #> right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<<#= typeName #>, <#= typeName #>, bool>.operator !=(<#= typeName #> left, <#= typeName #> right) => !left.Equals(right);
    #endif

    [MethodImpl(256 | 512)]
    public bool EqualsAll(<#= typeName #> other) => Equals(other);

    [MethodImpl(256 | 512)]
    public bool EqualsAny(<#= typeName #> other)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return Vector<#= bitSize #>.EqualsAny(vector, other.vector);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return <#
            {
                var first = true;
                for (var n = 0; n < i; n++)
                {
                    if (first) first = false;
                    else Write(" || ");
                    var comp = Typ.xyzw[n];
#><#= comp #> == other.<#= comp #><#
                }
            }
#>;
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    #endregion
}

#endregion // <#= typeName #>
<#
        }
    }
#>
