// generated by template, do not modify manually

namespace Coplt.Mathematics.Numerics;

#region inorm8

/// <summary>
/// 8 bits normalized signed number (-1 .. 1)
/// </summary>
[Serializable]
public readonly partial struct inorm8 : IEquatable<inorm8>, IComparable<inorm8>, IComparable
    #if NET8_0_OR_GREATER
    , IEqualityOperators<inorm8, inorm8, bool>
    , IComparisonOperators<inorm8, inorm8, bool>
    #endif
{
    private readonly i8 inner;

    [MethodImpl(256 | 512)]
    private inorm8(i8 inner) => this.inner = inner;

    #region Convert

    [MethodImpl(256 | 512)]
    public static implicit operator f16(inorm8 a) => math.remap((f16)a.inner, (f16)i8.MinValue, (f16)i8.MaxValue, (f16)(-1), (f16)1);

    [MethodImpl(256 | 512)]
    public static implicit operator f32(inorm8 a) => math.remap((f32)a.inner, i8.MinValue, i8.MaxValue, -1, 1);

    [MethodImpl(256 | 512)]
    public static implicit operator f64(inorm8 a) => math.remap((f64)a.inner, i8.MinValue, i8.MaxValue, -1, 1);

    [MethodImpl(256 | 512)]
    public static implicit operator inorm8(f16 a) => new((i8)math.remap(a, (f16)(-1), (f16)1, (f16)i8.MinValue, (f16)i8.MaxValue));

    [MethodImpl(256 | 512)]
    public static implicit operator inorm8(f32 a) => new((i8)math.remap(a, -1, 1, i8.MinValue, i8.MaxValue));

    [MethodImpl(256 | 512)]
    public static implicit operator inorm8(f64 a) => new((i8)math.remap(a, -1, 1, i8.MinValue, i8.MaxValue));

    [MethodImpl(256 | 512)]
    public f16 ToHalf(f16 min, f16 max) => (f16)math.remap((f32)inner, i8.MinValue, i8.MaxValue, (f32)min, (f32)max);

    [MethodImpl(256 | 512)]
    public f32 ToSingle(f32 min, f32 max) => math.remap((f32)inner, i8.MinValue, i8.MaxValue, min, max);

    [MethodImpl(256 | 512)]
    public f64 ToDouble(f64 min, f64 max) => math.remap((f64)inner, i8.MinValue, i8.MaxValue, min, max);

    [MethodImpl(256 | 512)]
    public static inorm8 FromHalf(f16 a, f16 min, f16 max) => new((i8)math.remap(a, (f16)min, (f16)max, (f16)i8.MinValue, (f16)i8.MaxValue));

    [MethodImpl(256 | 512)]
    public static inorm8 FromSingle(f32 a, f32 min, f32 max) => new((i8)math.remap(a, min, max, i8.MinValue, i8.MaxValue));

    [MethodImpl(256 | 512)]
    public static inorm8 FromDouble(f64 a, f64 min, f64 max) => new((i8)math.remap(a, min, max, i8.MinValue, i8.MaxValue));

    #endregion // Convert

    #region ToString

    [CpuOnly]
    public override string ToString() => $"{(f64)this}";

    #endregion // ToString

    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(inorm8 other) => inner == other.inner;

    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is inorm8 other && Equals(other);

    [MethodImpl(256 | 512)]
    public override int GetHashCode() => inner.GetHashCode();

    [MethodImpl(256 | 512)]
    public static bool operator ==(inorm8 left, inorm8 right) => left.inner == right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator !=(inorm8 left, inorm8 right) => left.inner != right.inner;

    #endregion

    #region CompareTo

    [MethodImpl(256 | 512)]
    public int CompareTo(inorm8 other) => inner.CompareTo(other.inner);

    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is inorm8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(inorm8)}");
    }

    [MethodImpl(256 | 512)]
    public static bool operator <(inorm8 left, inorm8 right) => left.inner < right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator >(inorm8 left, inorm8 right) => left.inner > right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator <=(inorm8 left, inorm8 right) => left.inner <= right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator >=(inorm8 left, inorm8 right) => left.inner >= right.inner;

    #endregion
}

#endregion // inorm8

#region inorm16

/// <summary>
/// 16 bits normalized signed number (-1 .. 1)
/// </summary>
[Serializable]
public readonly partial struct inorm16 : IEquatable<inorm16>, IComparable<inorm16>, IComparable
    #if NET8_0_OR_GREATER
    , IEqualityOperators<inorm16, inorm16, bool>
    , IComparisonOperators<inorm16, inorm16, bool>
    #endif
{
    private readonly i16 inner;

    [MethodImpl(256 | 512)]
    private inorm16(i16 inner) => this.inner = inner;

    #region Convert

    [MethodImpl(256 | 512)]
    public static implicit operator f16(inorm16 a) => math.remap((f16)a.inner, (f16)i16.MinValue, (f16)i16.MaxValue, (f16)(-1), (f16)1);

    [MethodImpl(256 | 512)]
    public static implicit operator f32(inorm16 a) => math.remap((f32)a.inner, i16.MinValue, i16.MaxValue, -1, 1);

    [MethodImpl(256 | 512)]
    public static implicit operator f64(inorm16 a) => math.remap((f64)a.inner, i16.MinValue, i16.MaxValue, -1, 1);

    [MethodImpl(256 | 512)]
    public static implicit operator inorm16(f16 a) => new((i16)math.remap(a, (f16)(-1), (f16)1, (f16)i16.MinValue, (f16)i16.MaxValue));

    [MethodImpl(256 | 512)]
    public static implicit operator inorm16(f32 a) => new((i16)math.remap(a, -1, 1, i16.MinValue, i16.MaxValue));

    [MethodImpl(256 | 512)]
    public static implicit operator inorm16(f64 a) => new((i16)math.remap(a, -1, 1, i16.MinValue, i16.MaxValue));

    [MethodImpl(256 | 512)]
    public f16 ToHalf(f16 min, f16 max) => (f16)math.remap((f32)inner, i16.MinValue, i16.MaxValue, (f32)min, (f32)max);

    [MethodImpl(256 | 512)]
    public f32 ToSingle(f32 min, f32 max) => math.remap((f32)inner, i16.MinValue, i16.MaxValue, min, max);

    [MethodImpl(256 | 512)]
    public f64 ToDouble(f64 min, f64 max) => math.remap((f64)inner, i16.MinValue, i16.MaxValue, min, max);

    [MethodImpl(256 | 512)]
    public static inorm16 FromHalf(f16 a, f16 min, f16 max) => new((i16)math.remap(a, (f16)min, (f16)max, (f16)i16.MinValue, (f16)i16.MaxValue));

    [MethodImpl(256 | 512)]
    public static inorm16 FromSingle(f32 a, f32 min, f32 max) => new((i16)math.remap(a, min, max, i16.MinValue, i16.MaxValue));

    [MethodImpl(256 | 512)]
    public static inorm16 FromDouble(f64 a, f64 min, f64 max) => new((i16)math.remap(a, min, max, i16.MinValue, i16.MaxValue));

    #endregion // Convert

    #region ToString

    [CpuOnly]
    public override string ToString() => $"{(f64)this}";

    #endregion // ToString

    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(inorm16 other) => inner == other.inner;

    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is inorm16 other && Equals(other);

    [MethodImpl(256 | 512)]
    public override int GetHashCode() => inner.GetHashCode();

    [MethodImpl(256 | 512)]
    public static bool operator ==(inorm16 left, inorm16 right) => left.inner == right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator !=(inorm16 left, inorm16 right) => left.inner != right.inner;

    #endregion

    #region CompareTo

    [MethodImpl(256 | 512)]
    public int CompareTo(inorm16 other) => inner.CompareTo(other.inner);

    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is inorm16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(inorm16)}");
    }

    [MethodImpl(256 | 512)]
    public static bool operator <(inorm16 left, inorm16 right) => left.inner < right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator >(inorm16 left, inorm16 right) => left.inner > right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator <=(inorm16 left, inorm16 right) => left.inner <= right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator >=(inorm16 left, inorm16 right) => left.inner >= right.inner;

    #endregion
}

#endregion // inorm16

#region inorm32

/// <summary>
/// 32 bits normalized signed number (-1 .. 1)
/// </summary>
[Serializable]
public readonly partial struct inorm32 : IEquatable<inorm32>, IComparable<inorm32>, IComparable
    #if NET8_0_OR_GREATER
    , IEqualityOperators<inorm32, inorm32, bool>
    , IComparisonOperators<inorm32, inorm32, bool>
    #endif
{
    private readonly i32 inner;

    [MethodImpl(256 | 512)]
    private inorm32(i32 inner) => this.inner = inner;

    #region Convert

    [MethodImpl(256 | 512)]
    public static implicit operator f16(inorm32 a) => math.remap((f16)a.inner, (f16)i32.MinValue, (f16)i32.MaxValue, (f16)(-1), (f16)1);

    [MethodImpl(256 | 512)]
    public static implicit operator f32(inorm32 a) => math.remap((f32)a.inner, i32.MinValue, i32.MaxValue, -1, 1);

    [MethodImpl(256 | 512)]
    public static implicit operator f64(inorm32 a) => math.remap((f64)a.inner, i32.MinValue, i32.MaxValue, -1, 1);

    [MethodImpl(256 | 512)]
    public static implicit operator inorm32(f16 a) => new((i32)math.remap(a, (f16)(-1), (f16)1, (f16)i32.MinValue, (f16)i32.MaxValue));

    [MethodImpl(256 | 512)]
    public static implicit operator inorm32(f32 a) => new((i32)math.remap(a, -1, 1, i32.MinValue, i32.MaxValue));

    [MethodImpl(256 | 512)]
    public static implicit operator inorm32(f64 a) => new((i32)math.remap(a, -1, 1, i32.MinValue, i32.MaxValue));

    [MethodImpl(256 | 512)]
    public f16 ToHalf(f16 min, f16 max) => (f16)math.remap((f32)inner, i32.MinValue, i32.MaxValue, (f32)min, (f32)max);

    [MethodImpl(256 | 512)]
    public f32 ToSingle(f32 min, f32 max) => math.remap((f32)inner, i32.MinValue, i32.MaxValue, min, max);

    [MethodImpl(256 | 512)]
    public f64 ToDouble(f64 min, f64 max) => math.remap((f64)inner, i32.MinValue, i32.MaxValue, min, max);

    [MethodImpl(256 | 512)]
    public static inorm32 FromHalf(f16 a, f16 min, f16 max) => new((i32)math.remap(a, (f16)min, (f16)max, (f16)i32.MinValue, (f16)i32.MaxValue));

    [MethodImpl(256 | 512)]
    public static inorm32 FromSingle(f32 a, f32 min, f32 max) => new((i32)math.remap(a, min, max, i32.MinValue, i32.MaxValue));

    [MethodImpl(256 | 512)]
    public static inorm32 FromDouble(f64 a, f64 min, f64 max) => new((i32)math.remap(a, min, max, i32.MinValue, i32.MaxValue));

    #endregion // Convert

    #region ToString

    [CpuOnly]
    public override string ToString() => $"{(f64)this}";

    #endregion // ToString

    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(inorm32 other) => inner == other.inner;

    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is inorm32 other && Equals(other);

    [MethodImpl(256 | 512)]
    public override int GetHashCode() => inner.GetHashCode();

    [MethodImpl(256 | 512)]
    public static bool operator ==(inorm32 left, inorm32 right) => left.inner == right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator !=(inorm32 left, inorm32 right) => left.inner != right.inner;

    #endregion

    #region CompareTo

    [MethodImpl(256 | 512)]
    public int CompareTo(inorm32 other) => inner.CompareTo(other.inner);

    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is inorm32 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(inorm32)}");
    }

    [MethodImpl(256 | 512)]
    public static bool operator <(inorm32 left, inorm32 right) => left.inner < right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator >(inorm32 left, inorm32 right) => left.inner > right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator <=(inorm32 left, inorm32 right) => left.inner <= right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator >=(inorm32 left, inorm32 right) => left.inner >= right.inner;

    #endregion
}

#endregion // inorm32

#region inorm64

/// <summary>
/// 64 bits normalized signed number (-1 .. 1)
/// </summary>
[Serializable]
public readonly partial struct inorm64 : IEquatable<inorm64>, IComparable<inorm64>, IComparable
    #if NET8_0_OR_GREATER
    , IEqualityOperators<inorm64, inorm64, bool>
    , IComparisonOperators<inorm64, inorm64, bool>
    #endif
{
    private readonly i64 inner;

    [MethodImpl(256 | 512)]
    private inorm64(i64 inner) => this.inner = inner;

    #region Convert

    [MethodImpl(256 | 512)]
    public static implicit operator f16(inorm64 a) => math.remap((f16)a.inner, (f16)i64.MinValue, (f16)i64.MaxValue, (f16)(-1), (f16)1);

    [MethodImpl(256 | 512)]
    public static implicit operator f32(inorm64 a) => math.remap((f32)a.inner, i64.MinValue, i64.MaxValue, -1, 1);

    [MethodImpl(256 | 512)]
    public static implicit operator f64(inorm64 a) => math.remap((f64)a.inner, i64.MinValue, i64.MaxValue, -1, 1);

    [MethodImpl(256 | 512)]
    public static implicit operator inorm64(f16 a) => new((i64)math.remap(a, (f16)(-1), (f16)1, (f16)i64.MinValue, (f16)i64.MaxValue));

    [MethodImpl(256 | 512)]
    public static implicit operator inorm64(f32 a) => new((i64)math.remap(a, -1, 1, i64.MinValue, i64.MaxValue));

    [MethodImpl(256 | 512)]
    public static implicit operator inorm64(f64 a) => new((i64)math.remap(a, -1, 1, i64.MinValue, i64.MaxValue));

    [MethodImpl(256 | 512)]
    public f16 ToHalf(f16 min, f16 max) => (f16)math.remap((f32)inner, i64.MinValue, i64.MaxValue, (f32)min, (f32)max);

    [MethodImpl(256 | 512)]
    public f32 ToSingle(f32 min, f32 max) => math.remap((f32)inner, i64.MinValue, i64.MaxValue, min, max);

    [MethodImpl(256 | 512)]
    public f64 ToDouble(f64 min, f64 max) => math.remap((f64)inner, i64.MinValue, i64.MaxValue, min, max);

    [MethodImpl(256 | 512)]
    public static inorm64 FromHalf(f16 a, f16 min, f16 max) => new((i64)math.remap(a, (f16)min, (f16)max, (f16)i64.MinValue, (f16)i64.MaxValue));

    [MethodImpl(256 | 512)]
    public static inorm64 FromSingle(f32 a, f32 min, f32 max) => new((i64)math.remap(a, min, max, i64.MinValue, i64.MaxValue));

    [MethodImpl(256 | 512)]
    public static inorm64 FromDouble(f64 a, f64 min, f64 max) => new((i64)math.remap(a, min, max, i64.MinValue, i64.MaxValue));

    #endregion // Convert

    #region ToString

    [CpuOnly]
    public override string ToString() => $"{(f64)this}";

    #endregion // ToString

    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(inorm64 other) => inner == other.inner;

    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is inorm64 other && Equals(other);

    [MethodImpl(256 | 512)]
    public override int GetHashCode() => inner.GetHashCode();

    [MethodImpl(256 | 512)]
    public static bool operator ==(inorm64 left, inorm64 right) => left.inner == right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator !=(inorm64 left, inorm64 right) => left.inner != right.inner;

    #endregion

    #region CompareTo

    [MethodImpl(256 | 512)]
    public int CompareTo(inorm64 other) => inner.CompareTo(other.inner);

    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is inorm64 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(inorm64)}");
    }

    [MethodImpl(256 | 512)]
    public static bool operator <(inorm64 left, inorm64 right) => left.inner < right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator >(inorm64 left, inorm64 right) => left.inner > right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator <=(inorm64 left, inorm64 right) => left.inner <= right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator >=(inorm64 left, inorm64 right) => left.inner >= right.inner;

    #endregion
}

#endregion // inorm64

#region unorm8

/// <summary>
/// 8 bits normalized unsigned number (0 .. 1)
/// </summary>
[Serializable]
public readonly partial struct unorm8 : IEquatable<unorm8>, IComparable<unorm8>, IComparable
    #if NET8_0_OR_GREATER
    , IEqualityOperators<unorm8, unorm8, bool>
    , IComparisonOperators<unorm8, unorm8, bool>
    #endif
{
    private readonly u8 inner;

    [MethodImpl(256 | 512)]
    private unorm8(u8 inner) => this.inner = inner;

    #region Convert

    [MethodImpl(256 | 512)]
    public static implicit operator f16(unorm8 a) => math.remap((f16)a.inner, (f16)u8.MinValue, (f16)u8.MaxValue, (f16)(0), (f16)1);

    [MethodImpl(256 | 512)]
    public static implicit operator f32(unorm8 a) => math.remap((f32)a.inner, u8.MinValue, u8.MaxValue, 0, 1);

    [MethodImpl(256 | 512)]
    public static implicit operator f64(unorm8 a) => math.remap((f64)a.inner, u8.MinValue, u8.MaxValue, 0, 1);

    [MethodImpl(256 | 512)]
    public static implicit operator unorm8(f16 a) => new((u8)math.remap(a, (f16)(0), (f16)1, (f16)u8.MinValue, (f16)u8.MaxValue));

    [MethodImpl(256 | 512)]
    public static implicit operator unorm8(f32 a) => new((u8)math.remap(a, 0, 1, u8.MinValue, u8.MaxValue));

    [MethodImpl(256 | 512)]
    public static implicit operator unorm8(f64 a) => new((u8)math.remap(a, 0, 1, u8.MinValue, u8.MaxValue));

    [MethodImpl(256 | 512)]
    public f16 ToHalf(f16 min, f16 max) => (f16)math.remap((f32)inner, u8.MinValue, u8.MaxValue, (f32)min, (f32)max);

    [MethodImpl(256 | 512)]
    public f32 ToSingle(f32 min, f32 max) => math.remap((f32)inner, u8.MinValue, u8.MaxValue, min, max);

    [MethodImpl(256 | 512)]
    public f64 ToDouble(f64 min, f64 max) => math.remap((f64)inner, u8.MinValue, u8.MaxValue, min, max);

    [MethodImpl(256 | 512)]
    public static unorm8 FromHalf(f16 a, f16 min, f16 max) => new((u8)math.remap(a, (f16)min, (f16)max, (f16)u8.MinValue, (f16)u8.MaxValue));

    [MethodImpl(256 | 512)]
    public static unorm8 FromSingle(f32 a, f32 min, f32 max) => new((u8)math.remap(a, min, max, u8.MinValue, u8.MaxValue));

    [MethodImpl(256 | 512)]
    public static unorm8 FromDouble(f64 a, f64 min, f64 max) => new((u8)math.remap(a, min, max, u8.MinValue, u8.MaxValue));

    #endregion // Convert

    #region ToString

    [CpuOnly]
    public override string ToString() => $"{(f64)this}";

    #endregion // ToString

    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(unorm8 other) => inner == other.inner;

    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is unorm8 other && Equals(other);

    [MethodImpl(256 | 512)]
    public override int GetHashCode() => inner.GetHashCode();

    [MethodImpl(256 | 512)]
    public static bool operator ==(unorm8 left, unorm8 right) => left.inner == right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator !=(unorm8 left, unorm8 right) => left.inner != right.inner;

    #endregion

    #region CompareTo

    [MethodImpl(256 | 512)]
    public int CompareTo(unorm8 other) => inner.CompareTo(other.inner);

    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is unorm8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(unorm8)}");
    }

    [MethodImpl(256 | 512)]
    public static bool operator <(unorm8 left, unorm8 right) => left.inner < right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator >(unorm8 left, unorm8 right) => left.inner > right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator <=(unorm8 left, unorm8 right) => left.inner <= right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator >=(unorm8 left, unorm8 right) => left.inner >= right.inner;

    #endregion
}

#endregion // unorm8

#region unorm16

/// <summary>
/// 16 bits normalized unsigned number (0 .. 1)
/// </summary>
[Serializable]
public readonly partial struct unorm16 : IEquatable<unorm16>, IComparable<unorm16>, IComparable
    #if NET8_0_OR_GREATER
    , IEqualityOperators<unorm16, unorm16, bool>
    , IComparisonOperators<unorm16, unorm16, bool>
    #endif
{
    private readonly u16 inner;

    [MethodImpl(256 | 512)]
    private unorm16(u16 inner) => this.inner = inner;

    #region Convert

    [MethodImpl(256 | 512)]
    public static implicit operator f16(unorm16 a) => math.remap((f16)a.inner, (f16)u16.MinValue, (f16)u16.MaxValue, (f16)(0), (f16)1);

    [MethodImpl(256 | 512)]
    public static implicit operator f32(unorm16 a) => math.remap((f32)a.inner, u16.MinValue, u16.MaxValue, 0, 1);

    [MethodImpl(256 | 512)]
    public static implicit operator f64(unorm16 a) => math.remap((f64)a.inner, u16.MinValue, u16.MaxValue, 0, 1);

    [MethodImpl(256 | 512)]
    public static implicit operator unorm16(f16 a) => new((u16)math.remap(a, (f16)(0), (f16)1, (f16)u16.MinValue, (f16)u16.MaxValue));

    [MethodImpl(256 | 512)]
    public static implicit operator unorm16(f32 a) => new((u16)math.remap(a, 0, 1, u16.MinValue, u16.MaxValue));

    [MethodImpl(256 | 512)]
    public static implicit operator unorm16(f64 a) => new((u16)math.remap(a, 0, 1, u16.MinValue, u16.MaxValue));

    [MethodImpl(256 | 512)]
    public f16 ToHalf(f16 min, f16 max) => (f16)math.remap((f32)inner, u16.MinValue, u16.MaxValue, (f32)min, (f32)max);

    [MethodImpl(256 | 512)]
    public f32 ToSingle(f32 min, f32 max) => math.remap((f32)inner, u16.MinValue, u16.MaxValue, min, max);

    [MethodImpl(256 | 512)]
    public f64 ToDouble(f64 min, f64 max) => math.remap((f64)inner, u16.MinValue, u16.MaxValue, min, max);

    [MethodImpl(256 | 512)]
    public static unorm16 FromHalf(f16 a, f16 min, f16 max) => new((u16)math.remap(a, (f16)min, (f16)max, (f16)u16.MinValue, (f16)u16.MaxValue));

    [MethodImpl(256 | 512)]
    public static unorm16 FromSingle(f32 a, f32 min, f32 max) => new((u16)math.remap(a, min, max, u16.MinValue, u16.MaxValue));

    [MethodImpl(256 | 512)]
    public static unorm16 FromDouble(f64 a, f64 min, f64 max) => new((u16)math.remap(a, min, max, u16.MinValue, u16.MaxValue));

    #endregion // Convert

    #region ToString

    [CpuOnly]
    public override string ToString() => $"{(f64)this}";

    #endregion // ToString

    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(unorm16 other) => inner == other.inner;

    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is unorm16 other && Equals(other);

    [MethodImpl(256 | 512)]
    public override int GetHashCode() => inner.GetHashCode();

    [MethodImpl(256 | 512)]
    public static bool operator ==(unorm16 left, unorm16 right) => left.inner == right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator !=(unorm16 left, unorm16 right) => left.inner != right.inner;

    #endregion

    #region CompareTo

    [MethodImpl(256 | 512)]
    public int CompareTo(unorm16 other) => inner.CompareTo(other.inner);

    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is unorm16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(unorm16)}");
    }

    [MethodImpl(256 | 512)]
    public static bool operator <(unorm16 left, unorm16 right) => left.inner < right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator >(unorm16 left, unorm16 right) => left.inner > right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator <=(unorm16 left, unorm16 right) => left.inner <= right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator >=(unorm16 left, unorm16 right) => left.inner >= right.inner;

    #endregion
}

#endregion // unorm16

#region unorm32

/// <summary>
/// 32 bits normalized unsigned number (0 .. 1)
/// </summary>
[Serializable]
public readonly partial struct unorm32 : IEquatable<unorm32>, IComparable<unorm32>, IComparable
    #if NET8_0_OR_GREATER
    , IEqualityOperators<unorm32, unorm32, bool>
    , IComparisonOperators<unorm32, unorm32, bool>
    #endif
{
    private readonly u32 inner;

    [MethodImpl(256 | 512)]
    private unorm32(u32 inner) => this.inner = inner;

    #region Convert

    [MethodImpl(256 | 512)]
    public static implicit operator f16(unorm32 a) => math.remap((f16)a.inner, (f16)u32.MinValue, (f16)u32.MaxValue, (f16)(0), (f16)1);

    [MethodImpl(256 | 512)]
    public static implicit operator f32(unorm32 a) => math.remap((f32)a.inner, u32.MinValue, u32.MaxValue, 0, 1);

    [MethodImpl(256 | 512)]
    public static implicit operator f64(unorm32 a) => math.remap((f64)a.inner, u32.MinValue, u32.MaxValue, 0, 1);

    [MethodImpl(256 | 512)]
    public static implicit operator unorm32(f16 a) => new((u32)math.remap(a, (f16)(0), (f16)1, (f16)u32.MinValue, (f16)u32.MaxValue));

    [MethodImpl(256 | 512)]
    public static implicit operator unorm32(f32 a) => new((u32)math.remap(a, 0, 1, u32.MinValue, u32.MaxValue));

    [MethodImpl(256 | 512)]
    public static implicit operator unorm32(f64 a) => new((u32)math.remap(a, 0, 1, u32.MinValue, u32.MaxValue));

    [MethodImpl(256 | 512)]
    public f16 ToHalf(f16 min, f16 max) => (f16)math.remap((f32)inner, u32.MinValue, u32.MaxValue, (f32)min, (f32)max);

    [MethodImpl(256 | 512)]
    public f32 ToSingle(f32 min, f32 max) => math.remap((f32)inner, u32.MinValue, u32.MaxValue, min, max);

    [MethodImpl(256 | 512)]
    public f64 ToDouble(f64 min, f64 max) => math.remap((f64)inner, u32.MinValue, u32.MaxValue, min, max);

    [MethodImpl(256 | 512)]
    public static unorm32 FromHalf(f16 a, f16 min, f16 max) => new((u32)math.remap(a, (f16)min, (f16)max, (f16)u32.MinValue, (f16)u32.MaxValue));

    [MethodImpl(256 | 512)]
    public static unorm32 FromSingle(f32 a, f32 min, f32 max) => new((u32)math.remap(a, min, max, u32.MinValue, u32.MaxValue));

    [MethodImpl(256 | 512)]
    public static unorm32 FromDouble(f64 a, f64 min, f64 max) => new((u32)math.remap(a, min, max, u32.MinValue, u32.MaxValue));

    #endregion // Convert

    #region ToString

    [CpuOnly]
    public override string ToString() => $"{(f64)this}";

    #endregion // ToString

    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(unorm32 other) => inner == other.inner;

    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is unorm32 other && Equals(other);

    [MethodImpl(256 | 512)]
    public override int GetHashCode() => inner.GetHashCode();

    [MethodImpl(256 | 512)]
    public static bool operator ==(unorm32 left, unorm32 right) => left.inner == right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator !=(unorm32 left, unorm32 right) => left.inner != right.inner;

    #endregion

    #region CompareTo

    [MethodImpl(256 | 512)]
    public int CompareTo(unorm32 other) => inner.CompareTo(other.inner);

    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is unorm32 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(unorm32)}");
    }

    [MethodImpl(256 | 512)]
    public static bool operator <(unorm32 left, unorm32 right) => left.inner < right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator >(unorm32 left, unorm32 right) => left.inner > right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator <=(unorm32 left, unorm32 right) => left.inner <= right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator >=(unorm32 left, unorm32 right) => left.inner >= right.inner;

    #endregion
}

#endregion // unorm32

#region unorm64

/// <summary>
/// 64 bits normalized unsigned number (0 .. 1)
/// </summary>
[Serializable]
public readonly partial struct unorm64 : IEquatable<unorm64>, IComparable<unorm64>, IComparable
    #if NET8_0_OR_GREATER
    , IEqualityOperators<unorm64, unorm64, bool>
    , IComparisonOperators<unorm64, unorm64, bool>
    #endif
{
    private readonly u64 inner;

    [MethodImpl(256 | 512)]
    private unorm64(u64 inner) => this.inner = inner;

    #region Convert

    [MethodImpl(256 | 512)]
    public static implicit operator f16(unorm64 a) => math.remap((f16)a.inner, (f16)u64.MinValue, (f16)u64.MaxValue, (f16)(0), (f16)1);

    [MethodImpl(256 | 512)]
    public static implicit operator f32(unorm64 a) => math.remap((f32)a.inner, u64.MinValue, u64.MaxValue, 0, 1);

    [MethodImpl(256 | 512)]
    public static implicit operator f64(unorm64 a) => math.remap((f64)a.inner, u64.MinValue, u64.MaxValue, 0, 1);

    [MethodImpl(256 | 512)]
    public static implicit operator unorm64(f16 a) => new((u64)math.remap(a, (f16)(0), (f16)1, (f16)u64.MinValue, (f16)u64.MaxValue));

    [MethodImpl(256 | 512)]
    public static implicit operator unorm64(f32 a) => new((u64)math.remap(a, 0, 1, u64.MinValue, u64.MaxValue));

    [MethodImpl(256 | 512)]
    public static implicit operator unorm64(f64 a) => new((u64)math.remap(a, 0, 1, u64.MinValue, u64.MaxValue));

    [MethodImpl(256 | 512)]
    public f16 ToHalf(f16 min, f16 max) => (f16)math.remap((f32)inner, u64.MinValue, u64.MaxValue, (f32)min, (f32)max);

    [MethodImpl(256 | 512)]
    public f32 ToSingle(f32 min, f32 max) => math.remap((f32)inner, u64.MinValue, u64.MaxValue, min, max);

    [MethodImpl(256 | 512)]
    public f64 ToDouble(f64 min, f64 max) => math.remap((f64)inner, u64.MinValue, u64.MaxValue, min, max);

    [MethodImpl(256 | 512)]
    public static unorm64 FromHalf(f16 a, f16 min, f16 max) => new((u64)math.remap(a, (f16)min, (f16)max, (f16)u64.MinValue, (f16)u64.MaxValue));

    [MethodImpl(256 | 512)]
    public static unorm64 FromSingle(f32 a, f32 min, f32 max) => new((u64)math.remap(a, min, max, u64.MinValue, u64.MaxValue));

    [MethodImpl(256 | 512)]
    public static unorm64 FromDouble(f64 a, f64 min, f64 max) => new((u64)math.remap(a, min, max, u64.MinValue, u64.MaxValue));

    #endregion // Convert

    #region ToString

    [CpuOnly]
    public override string ToString() => $"{(f64)this}";

    #endregion // ToString

    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(unorm64 other) => inner == other.inner;

    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is unorm64 other && Equals(other);

    [MethodImpl(256 | 512)]
    public override int GetHashCode() => inner.GetHashCode();

    [MethodImpl(256 | 512)]
    public static bool operator ==(unorm64 left, unorm64 right) => left.inner == right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator !=(unorm64 left, unorm64 right) => left.inner != right.inner;

    #endregion

    #region CompareTo

    [MethodImpl(256 | 512)]
    public int CompareTo(unorm64 other) => inner.CompareTo(other.inner);

    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is unorm64 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(unorm64)}");
    }

    [MethodImpl(256 | 512)]
    public static bool operator <(unorm64 left, unorm64 right) => left.inner < right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator >(unorm64 left, unorm64 right) => left.inner > right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator <=(unorm64 left, unorm64 right) => left.inner <= right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator >=(unorm64 left, unorm64 right) => left.inner >= right.inner;

    #endregion
}

#endregion // unorm64
