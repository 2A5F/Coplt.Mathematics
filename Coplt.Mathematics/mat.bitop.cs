// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region float2x2

public partial struct float2x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<float2x2, float2x2, float2x2>
    , IShiftOperators<float2x2, int, float2x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static float2x2 operator ~(float2x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static float2x2 operator |(float2x2 a, float2x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static float2x2 operator &(float2x2 a, float2x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static float2x2 operator ^(float2x2 a, float2x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    [MethodImpl(256 | 512)]
    public static float2x2 operator <<(float2x2 a, int b) => new(a.c0 << b, a.c1 << b);

    [MethodImpl(256 | 512)]
    public static float2x2 operator >>(float2x2 a, int b) => new(a.c0 >> b, a.c1 >> b);

    [MethodImpl(256 | 512)]
    public static float2x2 operator >>>(float2x2 a, int b) => new(a.c0 >>> b, a.c1 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float2x2 BitAndNot(this float2x2 a, float2x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // float2x2

#region float2x3

public partial struct float2x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<float2x3, float2x3, float2x3>
    , IShiftOperators<float2x3, int, float2x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static float2x3 operator ~(float2x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static float2x3 operator |(float2x3 a, float2x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static float2x3 operator &(float2x3 a, float2x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static float2x3 operator ^(float2x3 a, float2x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    [MethodImpl(256 | 512)]
    public static float2x3 operator <<(float2x3 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b);

    [MethodImpl(256 | 512)]
    public static float2x3 operator >>(float2x3 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b);

    [MethodImpl(256 | 512)]
    public static float2x3 operator >>>(float2x3 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float2x3 BitAndNot(this float2x3 a, float2x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // float2x3

#region float2x4

public partial struct float2x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<float2x4, float2x4, float2x4>
    , IShiftOperators<float2x4, int, float2x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static float2x4 operator ~(float2x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static float2x4 operator |(float2x4 a, float2x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static float2x4 operator &(float2x4 a, float2x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static float2x4 operator ^(float2x4 a, float2x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    [MethodImpl(256 | 512)]
    public static float2x4 operator <<(float2x4 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b, a.c3 << b);

    [MethodImpl(256 | 512)]
    public static float2x4 operator >>(float2x4 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b, a.c3 >> b);

    [MethodImpl(256 | 512)]
    public static float2x4 operator >>>(float2x4 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b, a.c3 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float2x4 BitAndNot(this float2x4 a, float2x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // float2x4

#region float3x2

public partial struct float3x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<float3x2, float3x2, float3x2>
    , IShiftOperators<float3x2, int, float3x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static float3x2 operator ~(float3x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static float3x2 operator |(float3x2 a, float3x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static float3x2 operator &(float3x2 a, float3x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static float3x2 operator ^(float3x2 a, float3x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    [MethodImpl(256 | 512)]
    public static float3x2 operator <<(float3x2 a, int b) => new(a.c0 << b, a.c1 << b);

    [MethodImpl(256 | 512)]
    public static float3x2 operator >>(float3x2 a, int b) => new(a.c0 >> b, a.c1 >> b);

    [MethodImpl(256 | 512)]
    public static float3x2 operator >>>(float3x2 a, int b) => new(a.c0 >>> b, a.c1 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float3x2 BitAndNot(this float3x2 a, float3x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // float3x2

#region float3x3

public partial struct float3x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<float3x3, float3x3, float3x3>
    , IShiftOperators<float3x3, int, float3x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static float3x3 operator ~(float3x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static float3x3 operator |(float3x3 a, float3x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static float3x3 operator &(float3x3 a, float3x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static float3x3 operator ^(float3x3 a, float3x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    [MethodImpl(256 | 512)]
    public static float3x3 operator <<(float3x3 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b);

    [MethodImpl(256 | 512)]
    public static float3x3 operator >>(float3x3 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b);

    [MethodImpl(256 | 512)]
    public static float3x3 operator >>>(float3x3 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float3x3 BitAndNot(this float3x3 a, float3x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // float3x3

#region float3x4

public partial struct float3x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<float3x4, float3x4, float3x4>
    , IShiftOperators<float3x4, int, float3x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static float3x4 operator ~(float3x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static float3x4 operator |(float3x4 a, float3x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static float3x4 operator &(float3x4 a, float3x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static float3x4 operator ^(float3x4 a, float3x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    [MethodImpl(256 | 512)]
    public static float3x4 operator <<(float3x4 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b, a.c3 << b);

    [MethodImpl(256 | 512)]
    public static float3x4 operator >>(float3x4 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b, a.c3 >> b);

    [MethodImpl(256 | 512)]
    public static float3x4 operator >>>(float3x4 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b, a.c3 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float3x4 BitAndNot(this float3x4 a, float3x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // float3x4

#region float4x2

public partial struct float4x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<float4x2, float4x2, float4x2>
    , IShiftOperators<float4x2, int, float4x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static float4x2 operator ~(float4x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static float4x2 operator |(float4x2 a, float4x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static float4x2 operator &(float4x2 a, float4x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static float4x2 operator ^(float4x2 a, float4x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    [MethodImpl(256 | 512)]
    public static float4x2 operator <<(float4x2 a, int b) => new(a.c0 << b, a.c1 << b);

    [MethodImpl(256 | 512)]
    public static float4x2 operator >>(float4x2 a, int b) => new(a.c0 >> b, a.c1 >> b);

    [MethodImpl(256 | 512)]
    public static float4x2 operator >>>(float4x2 a, int b) => new(a.c0 >>> b, a.c1 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float4x2 BitAndNot(this float4x2 a, float4x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // float4x2

#region float4x3

public partial struct float4x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<float4x3, float4x3, float4x3>
    , IShiftOperators<float4x3, int, float4x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static float4x3 operator ~(float4x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static float4x3 operator |(float4x3 a, float4x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static float4x3 operator &(float4x3 a, float4x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static float4x3 operator ^(float4x3 a, float4x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    [MethodImpl(256 | 512)]
    public static float4x3 operator <<(float4x3 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b);

    [MethodImpl(256 | 512)]
    public static float4x3 operator >>(float4x3 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b);

    [MethodImpl(256 | 512)]
    public static float4x3 operator >>>(float4x3 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float4x3 BitAndNot(this float4x3 a, float4x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // float4x3

#region float4x4

public partial struct float4x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<float4x4, float4x4, float4x4>
    , IShiftOperators<float4x4, int, float4x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static float4x4 operator ~(float4x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static float4x4 operator |(float4x4 a, float4x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static float4x4 operator &(float4x4 a, float4x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static float4x4 operator ^(float4x4 a, float4x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    [MethodImpl(256 | 512)]
    public static float4x4 operator <<(float4x4 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b, a.c3 << b);

    [MethodImpl(256 | 512)]
    public static float4x4 operator >>(float4x4 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b, a.c3 >> b);

    [MethodImpl(256 | 512)]
    public static float4x4 operator >>>(float4x4 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b, a.c3 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float4x4 BitAndNot(this float4x4 a, float4x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // float4x4

#region double2x2

public partial struct double2x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<double2x2, double2x2, double2x2>
    , IShiftOperators<double2x2, int, double2x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static double2x2 operator ~(double2x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static double2x2 operator |(double2x2 a, double2x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static double2x2 operator &(double2x2 a, double2x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static double2x2 operator ^(double2x2 a, double2x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    [MethodImpl(256 | 512)]
    public static double2x2 operator <<(double2x2 a, int b) => new(a.c0 << b, a.c1 << b);

    [MethodImpl(256 | 512)]
    public static double2x2 operator >>(double2x2 a, int b) => new(a.c0 >> b, a.c1 >> b);

    [MethodImpl(256 | 512)]
    public static double2x2 operator >>>(double2x2 a, int b) => new(a.c0 >>> b, a.c1 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double2x2 BitAndNot(this double2x2 a, double2x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // double2x2

#region double2x3

public partial struct double2x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<double2x3, double2x3, double2x3>
    , IShiftOperators<double2x3, int, double2x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static double2x3 operator ~(double2x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static double2x3 operator |(double2x3 a, double2x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static double2x3 operator &(double2x3 a, double2x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static double2x3 operator ^(double2x3 a, double2x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    [MethodImpl(256 | 512)]
    public static double2x3 operator <<(double2x3 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b);

    [MethodImpl(256 | 512)]
    public static double2x3 operator >>(double2x3 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b);

    [MethodImpl(256 | 512)]
    public static double2x3 operator >>>(double2x3 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double2x3 BitAndNot(this double2x3 a, double2x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // double2x3

#region double2x4

public partial struct double2x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<double2x4, double2x4, double2x4>
    , IShiftOperators<double2x4, int, double2x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static double2x4 operator ~(double2x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static double2x4 operator |(double2x4 a, double2x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static double2x4 operator &(double2x4 a, double2x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static double2x4 operator ^(double2x4 a, double2x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    [MethodImpl(256 | 512)]
    public static double2x4 operator <<(double2x4 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b, a.c3 << b);

    [MethodImpl(256 | 512)]
    public static double2x4 operator >>(double2x4 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b, a.c3 >> b);

    [MethodImpl(256 | 512)]
    public static double2x4 operator >>>(double2x4 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b, a.c3 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double2x4 BitAndNot(this double2x4 a, double2x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // double2x4

#region double3x2

public partial struct double3x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<double3x2, double3x2, double3x2>
    , IShiftOperators<double3x2, int, double3x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static double3x2 operator ~(double3x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static double3x2 operator |(double3x2 a, double3x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static double3x2 operator &(double3x2 a, double3x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static double3x2 operator ^(double3x2 a, double3x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    [MethodImpl(256 | 512)]
    public static double3x2 operator <<(double3x2 a, int b) => new(a.c0 << b, a.c1 << b);

    [MethodImpl(256 | 512)]
    public static double3x2 operator >>(double3x2 a, int b) => new(a.c0 >> b, a.c1 >> b);

    [MethodImpl(256 | 512)]
    public static double3x2 operator >>>(double3x2 a, int b) => new(a.c0 >>> b, a.c1 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double3x2 BitAndNot(this double3x2 a, double3x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // double3x2

#region double3x3

public partial struct double3x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<double3x3, double3x3, double3x3>
    , IShiftOperators<double3x3, int, double3x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static double3x3 operator ~(double3x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static double3x3 operator |(double3x3 a, double3x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static double3x3 operator &(double3x3 a, double3x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static double3x3 operator ^(double3x3 a, double3x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    [MethodImpl(256 | 512)]
    public static double3x3 operator <<(double3x3 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b);

    [MethodImpl(256 | 512)]
    public static double3x3 operator >>(double3x3 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b);

    [MethodImpl(256 | 512)]
    public static double3x3 operator >>>(double3x3 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double3x3 BitAndNot(this double3x3 a, double3x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // double3x3

#region double3x4

public partial struct double3x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<double3x4, double3x4, double3x4>
    , IShiftOperators<double3x4, int, double3x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static double3x4 operator ~(double3x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static double3x4 operator |(double3x4 a, double3x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static double3x4 operator &(double3x4 a, double3x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static double3x4 operator ^(double3x4 a, double3x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    [MethodImpl(256 | 512)]
    public static double3x4 operator <<(double3x4 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b, a.c3 << b);

    [MethodImpl(256 | 512)]
    public static double3x4 operator >>(double3x4 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b, a.c3 >> b);

    [MethodImpl(256 | 512)]
    public static double3x4 operator >>>(double3x4 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b, a.c3 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double3x4 BitAndNot(this double3x4 a, double3x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // double3x4

#region double4x2

public partial struct double4x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<double4x2, double4x2, double4x2>
    , IShiftOperators<double4x2, int, double4x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static double4x2 operator ~(double4x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static double4x2 operator |(double4x2 a, double4x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static double4x2 operator &(double4x2 a, double4x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static double4x2 operator ^(double4x2 a, double4x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    [MethodImpl(256 | 512)]
    public static double4x2 operator <<(double4x2 a, int b) => new(a.c0 << b, a.c1 << b);

    [MethodImpl(256 | 512)]
    public static double4x2 operator >>(double4x2 a, int b) => new(a.c0 >> b, a.c1 >> b);

    [MethodImpl(256 | 512)]
    public static double4x2 operator >>>(double4x2 a, int b) => new(a.c0 >>> b, a.c1 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double4x2 BitAndNot(this double4x2 a, double4x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // double4x2

#region double4x3

public partial struct double4x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<double4x3, double4x3, double4x3>
    , IShiftOperators<double4x3, int, double4x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static double4x3 operator ~(double4x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static double4x3 operator |(double4x3 a, double4x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static double4x3 operator &(double4x3 a, double4x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static double4x3 operator ^(double4x3 a, double4x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    [MethodImpl(256 | 512)]
    public static double4x3 operator <<(double4x3 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b);

    [MethodImpl(256 | 512)]
    public static double4x3 operator >>(double4x3 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b);

    [MethodImpl(256 | 512)]
    public static double4x3 operator >>>(double4x3 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double4x3 BitAndNot(this double4x3 a, double4x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // double4x3

#region double4x4

public partial struct double4x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<double4x4, double4x4, double4x4>
    , IShiftOperators<double4x4, int, double4x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static double4x4 operator ~(double4x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static double4x4 operator |(double4x4 a, double4x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static double4x4 operator &(double4x4 a, double4x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static double4x4 operator ^(double4x4 a, double4x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    [MethodImpl(256 | 512)]
    public static double4x4 operator <<(double4x4 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b, a.c3 << b);

    [MethodImpl(256 | 512)]
    public static double4x4 operator >>(double4x4 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b, a.c3 >> b);

    [MethodImpl(256 | 512)]
    public static double4x4 operator >>>(double4x4 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b, a.c3 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double4x4 BitAndNot(this double4x4 a, double4x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // double4x4

#region short2x2

public partial struct short2x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<short2x2, short2x2, short2x2>
    , IShiftOperators<short2x2, int, short2x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static short2x2 operator ~(short2x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static short2x2 operator |(short2x2 a, short2x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static short2x2 operator &(short2x2 a, short2x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static short2x2 operator ^(short2x2 a, short2x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    [MethodImpl(256 | 512)]
    public static short2x2 operator <<(short2x2 a, int b) => new(a.c0 << b, a.c1 << b);

    [MethodImpl(256 | 512)]
    public static short2x2 operator >>(short2x2 a, int b) => new(a.c0 >> b, a.c1 >> b);

    [MethodImpl(256 | 512)]
    public static short2x2 operator >>>(short2x2 a, int b) => new(a.c0 >>> b, a.c1 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static short2x2 BitAndNot(this short2x2 a, short2x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // short2x2

#region short2x3

public partial struct short2x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<short2x3, short2x3, short2x3>
    , IShiftOperators<short2x3, int, short2x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static short2x3 operator ~(short2x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static short2x3 operator |(short2x3 a, short2x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static short2x3 operator &(short2x3 a, short2x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static short2x3 operator ^(short2x3 a, short2x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    [MethodImpl(256 | 512)]
    public static short2x3 operator <<(short2x3 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b);

    [MethodImpl(256 | 512)]
    public static short2x3 operator >>(short2x3 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b);

    [MethodImpl(256 | 512)]
    public static short2x3 operator >>>(short2x3 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static short2x3 BitAndNot(this short2x3 a, short2x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // short2x3

#region short2x4

public partial struct short2x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<short2x4, short2x4, short2x4>
    , IShiftOperators<short2x4, int, short2x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static short2x4 operator ~(short2x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static short2x4 operator |(short2x4 a, short2x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static short2x4 operator &(short2x4 a, short2x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static short2x4 operator ^(short2x4 a, short2x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    [MethodImpl(256 | 512)]
    public static short2x4 operator <<(short2x4 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b, a.c3 << b);

    [MethodImpl(256 | 512)]
    public static short2x4 operator >>(short2x4 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b, a.c3 >> b);

    [MethodImpl(256 | 512)]
    public static short2x4 operator >>>(short2x4 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b, a.c3 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static short2x4 BitAndNot(this short2x4 a, short2x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // short2x4

#region short3x2

public partial struct short3x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<short3x2, short3x2, short3x2>
    , IShiftOperators<short3x2, int, short3x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static short3x2 operator ~(short3x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static short3x2 operator |(short3x2 a, short3x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static short3x2 operator &(short3x2 a, short3x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static short3x2 operator ^(short3x2 a, short3x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    [MethodImpl(256 | 512)]
    public static short3x2 operator <<(short3x2 a, int b) => new(a.c0 << b, a.c1 << b);

    [MethodImpl(256 | 512)]
    public static short3x2 operator >>(short3x2 a, int b) => new(a.c0 >> b, a.c1 >> b);

    [MethodImpl(256 | 512)]
    public static short3x2 operator >>>(short3x2 a, int b) => new(a.c0 >>> b, a.c1 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static short3x2 BitAndNot(this short3x2 a, short3x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // short3x2

#region short3x3

public partial struct short3x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<short3x3, short3x3, short3x3>
    , IShiftOperators<short3x3, int, short3x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static short3x3 operator ~(short3x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static short3x3 operator |(short3x3 a, short3x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static short3x3 operator &(short3x3 a, short3x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static short3x3 operator ^(short3x3 a, short3x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    [MethodImpl(256 | 512)]
    public static short3x3 operator <<(short3x3 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b);

    [MethodImpl(256 | 512)]
    public static short3x3 operator >>(short3x3 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b);

    [MethodImpl(256 | 512)]
    public static short3x3 operator >>>(short3x3 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static short3x3 BitAndNot(this short3x3 a, short3x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // short3x3

#region short3x4

public partial struct short3x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<short3x4, short3x4, short3x4>
    , IShiftOperators<short3x4, int, short3x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static short3x4 operator ~(short3x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static short3x4 operator |(short3x4 a, short3x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static short3x4 operator &(short3x4 a, short3x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static short3x4 operator ^(short3x4 a, short3x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    [MethodImpl(256 | 512)]
    public static short3x4 operator <<(short3x4 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b, a.c3 << b);

    [MethodImpl(256 | 512)]
    public static short3x4 operator >>(short3x4 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b, a.c3 >> b);

    [MethodImpl(256 | 512)]
    public static short3x4 operator >>>(short3x4 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b, a.c3 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static short3x4 BitAndNot(this short3x4 a, short3x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // short3x4

#region short4x2

public partial struct short4x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<short4x2, short4x2, short4x2>
    , IShiftOperators<short4x2, int, short4x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static short4x2 operator ~(short4x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static short4x2 operator |(short4x2 a, short4x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static short4x2 operator &(short4x2 a, short4x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static short4x2 operator ^(short4x2 a, short4x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    [MethodImpl(256 | 512)]
    public static short4x2 operator <<(short4x2 a, int b) => new(a.c0 << b, a.c1 << b);

    [MethodImpl(256 | 512)]
    public static short4x2 operator >>(short4x2 a, int b) => new(a.c0 >> b, a.c1 >> b);

    [MethodImpl(256 | 512)]
    public static short4x2 operator >>>(short4x2 a, int b) => new(a.c0 >>> b, a.c1 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static short4x2 BitAndNot(this short4x2 a, short4x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // short4x2

#region short4x3

public partial struct short4x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<short4x3, short4x3, short4x3>
    , IShiftOperators<short4x3, int, short4x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static short4x3 operator ~(short4x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static short4x3 operator |(short4x3 a, short4x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static short4x3 operator &(short4x3 a, short4x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static short4x3 operator ^(short4x3 a, short4x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    [MethodImpl(256 | 512)]
    public static short4x3 operator <<(short4x3 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b);

    [MethodImpl(256 | 512)]
    public static short4x3 operator >>(short4x3 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b);

    [MethodImpl(256 | 512)]
    public static short4x3 operator >>>(short4x3 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static short4x3 BitAndNot(this short4x3 a, short4x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // short4x3

#region short4x4

public partial struct short4x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<short4x4, short4x4, short4x4>
    , IShiftOperators<short4x4, int, short4x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static short4x4 operator ~(short4x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static short4x4 operator |(short4x4 a, short4x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static short4x4 operator &(short4x4 a, short4x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static short4x4 operator ^(short4x4 a, short4x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    [MethodImpl(256 | 512)]
    public static short4x4 operator <<(short4x4 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b, a.c3 << b);

    [MethodImpl(256 | 512)]
    public static short4x4 operator >>(short4x4 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b, a.c3 >> b);

    [MethodImpl(256 | 512)]
    public static short4x4 operator >>>(short4x4 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b, a.c3 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static short4x4 BitAndNot(this short4x4 a, short4x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // short4x4

#region ushort2x2

public partial struct ushort2x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<ushort2x2, ushort2x2, ushort2x2>
    , IShiftOperators<ushort2x2, int, ushort2x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static ushort2x2 operator ~(ushort2x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static ushort2x2 operator |(ushort2x2 a, ushort2x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static ushort2x2 operator &(ushort2x2 a, ushort2x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static ushort2x2 operator ^(ushort2x2 a, ushort2x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    [MethodImpl(256 | 512)]
    public static ushort2x2 operator <<(ushort2x2 a, int b) => new(a.c0 << b, a.c1 << b);

    [MethodImpl(256 | 512)]
    public static ushort2x2 operator >>(ushort2x2 a, int b) => new(a.c0 >> b, a.c1 >> b);

    [MethodImpl(256 | 512)]
    public static ushort2x2 operator >>>(ushort2x2 a, int b) => new(a.c0 >>> b, a.c1 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ushort2x2 BitAndNot(this ushort2x2 a, ushort2x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // ushort2x2

#region ushort2x3

public partial struct ushort2x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<ushort2x3, ushort2x3, ushort2x3>
    , IShiftOperators<ushort2x3, int, ushort2x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static ushort2x3 operator ~(ushort2x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static ushort2x3 operator |(ushort2x3 a, ushort2x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static ushort2x3 operator &(ushort2x3 a, ushort2x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static ushort2x3 operator ^(ushort2x3 a, ushort2x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    [MethodImpl(256 | 512)]
    public static ushort2x3 operator <<(ushort2x3 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b);

    [MethodImpl(256 | 512)]
    public static ushort2x3 operator >>(ushort2x3 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b);

    [MethodImpl(256 | 512)]
    public static ushort2x3 operator >>>(ushort2x3 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ushort2x3 BitAndNot(this ushort2x3 a, ushort2x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // ushort2x3

#region ushort2x4

public partial struct ushort2x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<ushort2x4, ushort2x4, ushort2x4>
    , IShiftOperators<ushort2x4, int, ushort2x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static ushort2x4 operator ~(ushort2x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static ushort2x4 operator |(ushort2x4 a, ushort2x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static ushort2x4 operator &(ushort2x4 a, ushort2x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static ushort2x4 operator ^(ushort2x4 a, ushort2x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    [MethodImpl(256 | 512)]
    public static ushort2x4 operator <<(ushort2x4 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b, a.c3 << b);

    [MethodImpl(256 | 512)]
    public static ushort2x4 operator >>(ushort2x4 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b, a.c3 >> b);

    [MethodImpl(256 | 512)]
    public static ushort2x4 operator >>>(ushort2x4 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b, a.c3 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ushort2x4 BitAndNot(this ushort2x4 a, ushort2x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // ushort2x4

#region ushort3x2

public partial struct ushort3x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<ushort3x2, ushort3x2, ushort3x2>
    , IShiftOperators<ushort3x2, int, ushort3x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static ushort3x2 operator ~(ushort3x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static ushort3x2 operator |(ushort3x2 a, ushort3x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static ushort3x2 operator &(ushort3x2 a, ushort3x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static ushort3x2 operator ^(ushort3x2 a, ushort3x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    [MethodImpl(256 | 512)]
    public static ushort3x2 operator <<(ushort3x2 a, int b) => new(a.c0 << b, a.c1 << b);

    [MethodImpl(256 | 512)]
    public static ushort3x2 operator >>(ushort3x2 a, int b) => new(a.c0 >> b, a.c1 >> b);

    [MethodImpl(256 | 512)]
    public static ushort3x2 operator >>>(ushort3x2 a, int b) => new(a.c0 >>> b, a.c1 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ushort3x2 BitAndNot(this ushort3x2 a, ushort3x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // ushort3x2

#region ushort3x3

public partial struct ushort3x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<ushort3x3, ushort3x3, ushort3x3>
    , IShiftOperators<ushort3x3, int, ushort3x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static ushort3x3 operator ~(ushort3x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static ushort3x3 operator |(ushort3x3 a, ushort3x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static ushort3x3 operator &(ushort3x3 a, ushort3x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static ushort3x3 operator ^(ushort3x3 a, ushort3x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    [MethodImpl(256 | 512)]
    public static ushort3x3 operator <<(ushort3x3 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b);

    [MethodImpl(256 | 512)]
    public static ushort3x3 operator >>(ushort3x3 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b);

    [MethodImpl(256 | 512)]
    public static ushort3x3 operator >>>(ushort3x3 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ushort3x3 BitAndNot(this ushort3x3 a, ushort3x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // ushort3x3

#region ushort3x4

public partial struct ushort3x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<ushort3x4, ushort3x4, ushort3x4>
    , IShiftOperators<ushort3x4, int, ushort3x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static ushort3x4 operator ~(ushort3x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static ushort3x4 operator |(ushort3x4 a, ushort3x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static ushort3x4 operator &(ushort3x4 a, ushort3x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static ushort3x4 operator ^(ushort3x4 a, ushort3x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    [MethodImpl(256 | 512)]
    public static ushort3x4 operator <<(ushort3x4 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b, a.c3 << b);

    [MethodImpl(256 | 512)]
    public static ushort3x4 operator >>(ushort3x4 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b, a.c3 >> b);

    [MethodImpl(256 | 512)]
    public static ushort3x4 operator >>>(ushort3x4 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b, a.c3 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ushort3x4 BitAndNot(this ushort3x4 a, ushort3x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // ushort3x4

#region ushort4x2

public partial struct ushort4x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<ushort4x2, ushort4x2, ushort4x2>
    , IShiftOperators<ushort4x2, int, ushort4x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static ushort4x2 operator ~(ushort4x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static ushort4x2 operator |(ushort4x2 a, ushort4x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static ushort4x2 operator &(ushort4x2 a, ushort4x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static ushort4x2 operator ^(ushort4x2 a, ushort4x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    [MethodImpl(256 | 512)]
    public static ushort4x2 operator <<(ushort4x2 a, int b) => new(a.c0 << b, a.c1 << b);

    [MethodImpl(256 | 512)]
    public static ushort4x2 operator >>(ushort4x2 a, int b) => new(a.c0 >> b, a.c1 >> b);

    [MethodImpl(256 | 512)]
    public static ushort4x2 operator >>>(ushort4x2 a, int b) => new(a.c0 >>> b, a.c1 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ushort4x2 BitAndNot(this ushort4x2 a, ushort4x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // ushort4x2

#region ushort4x3

public partial struct ushort4x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<ushort4x3, ushort4x3, ushort4x3>
    , IShiftOperators<ushort4x3, int, ushort4x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static ushort4x3 operator ~(ushort4x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static ushort4x3 operator |(ushort4x3 a, ushort4x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static ushort4x3 operator &(ushort4x3 a, ushort4x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static ushort4x3 operator ^(ushort4x3 a, ushort4x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    [MethodImpl(256 | 512)]
    public static ushort4x3 operator <<(ushort4x3 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b);

    [MethodImpl(256 | 512)]
    public static ushort4x3 operator >>(ushort4x3 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b);

    [MethodImpl(256 | 512)]
    public static ushort4x3 operator >>>(ushort4x3 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ushort4x3 BitAndNot(this ushort4x3 a, ushort4x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // ushort4x3

#region ushort4x4

public partial struct ushort4x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<ushort4x4, ushort4x4, ushort4x4>
    , IShiftOperators<ushort4x4, int, ushort4x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static ushort4x4 operator ~(ushort4x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static ushort4x4 operator |(ushort4x4 a, ushort4x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static ushort4x4 operator &(ushort4x4 a, ushort4x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static ushort4x4 operator ^(ushort4x4 a, ushort4x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    [MethodImpl(256 | 512)]
    public static ushort4x4 operator <<(ushort4x4 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b, a.c3 << b);

    [MethodImpl(256 | 512)]
    public static ushort4x4 operator >>(ushort4x4 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b, a.c3 >> b);

    [MethodImpl(256 | 512)]
    public static ushort4x4 operator >>>(ushort4x4 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b, a.c3 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ushort4x4 BitAndNot(this ushort4x4 a, ushort4x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // ushort4x4

#region int2x2

public partial struct int2x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<int2x2, int2x2, int2x2>
    , IShiftOperators<int2x2, int, int2x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static int2x2 operator ~(int2x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static int2x2 operator |(int2x2 a, int2x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static int2x2 operator &(int2x2 a, int2x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static int2x2 operator ^(int2x2 a, int2x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    [MethodImpl(256 | 512)]
    public static int2x2 operator <<(int2x2 a, int b) => new(a.c0 << b, a.c1 << b);

    [MethodImpl(256 | 512)]
    public static int2x2 operator >>(int2x2 a, int b) => new(a.c0 >> b, a.c1 >> b);

    [MethodImpl(256 | 512)]
    public static int2x2 operator >>>(int2x2 a, int b) => new(a.c0 >>> b, a.c1 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int2x2 BitAndNot(this int2x2 a, int2x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // int2x2

#region int2x3

public partial struct int2x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<int2x3, int2x3, int2x3>
    , IShiftOperators<int2x3, int, int2x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static int2x3 operator ~(int2x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static int2x3 operator |(int2x3 a, int2x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static int2x3 operator &(int2x3 a, int2x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static int2x3 operator ^(int2x3 a, int2x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    [MethodImpl(256 | 512)]
    public static int2x3 operator <<(int2x3 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b);

    [MethodImpl(256 | 512)]
    public static int2x3 operator >>(int2x3 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b);

    [MethodImpl(256 | 512)]
    public static int2x3 operator >>>(int2x3 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int2x3 BitAndNot(this int2x3 a, int2x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // int2x3

#region int2x4

public partial struct int2x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<int2x4, int2x4, int2x4>
    , IShiftOperators<int2x4, int, int2x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static int2x4 operator ~(int2x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static int2x4 operator |(int2x4 a, int2x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static int2x4 operator &(int2x4 a, int2x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static int2x4 operator ^(int2x4 a, int2x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    [MethodImpl(256 | 512)]
    public static int2x4 operator <<(int2x4 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b, a.c3 << b);

    [MethodImpl(256 | 512)]
    public static int2x4 operator >>(int2x4 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b, a.c3 >> b);

    [MethodImpl(256 | 512)]
    public static int2x4 operator >>>(int2x4 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b, a.c3 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int2x4 BitAndNot(this int2x4 a, int2x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // int2x4

#region int3x2

public partial struct int3x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<int3x2, int3x2, int3x2>
    , IShiftOperators<int3x2, int, int3x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static int3x2 operator ~(int3x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static int3x2 operator |(int3x2 a, int3x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static int3x2 operator &(int3x2 a, int3x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static int3x2 operator ^(int3x2 a, int3x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    [MethodImpl(256 | 512)]
    public static int3x2 operator <<(int3x2 a, int b) => new(a.c0 << b, a.c1 << b);

    [MethodImpl(256 | 512)]
    public static int3x2 operator >>(int3x2 a, int b) => new(a.c0 >> b, a.c1 >> b);

    [MethodImpl(256 | 512)]
    public static int3x2 operator >>>(int3x2 a, int b) => new(a.c0 >>> b, a.c1 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int3x2 BitAndNot(this int3x2 a, int3x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // int3x2

#region int3x3

public partial struct int3x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<int3x3, int3x3, int3x3>
    , IShiftOperators<int3x3, int, int3x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static int3x3 operator ~(int3x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static int3x3 operator |(int3x3 a, int3x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static int3x3 operator &(int3x3 a, int3x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static int3x3 operator ^(int3x3 a, int3x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    [MethodImpl(256 | 512)]
    public static int3x3 operator <<(int3x3 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b);

    [MethodImpl(256 | 512)]
    public static int3x3 operator >>(int3x3 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b);

    [MethodImpl(256 | 512)]
    public static int3x3 operator >>>(int3x3 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int3x3 BitAndNot(this int3x3 a, int3x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // int3x3

#region int3x4

public partial struct int3x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<int3x4, int3x4, int3x4>
    , IShiftOperators<int3x4, int, int3x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static int3x4 operator ~(int3x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static int3x4 operator |(int3x4 a, int3x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static int3x4 operator &(int3x4 a, int3x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static int3x4 operator ^(int3x4 a, int3x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    [MethodImpl(256 | 512)]
    public static int3x4 operator <<(int3x4 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b, a.c3 << b);

    [MethodImpl(256 | 512)]
    public static int3x4 operator >>(int3x4 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b, a.c3 >> b);

    [MethodImpl(256 | 512)]
    public static int3x4 operator >>>(int3x4 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b, a.c3 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int3x4 BitAndNot(this int3x4 a, int3x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // int3x4

#region int4x2

public partial struct int4x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<int4x2, int4x2, int4x2>
    , IShiftOperators<int4x2, int, int4x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static int4x2 operator ~(int4x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static int4x2 operator |(int4x2 a, int4x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static int4x2 operator &(int4x2 a, int4x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static int4x2 operator ^(int4x2 a, int4x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    [MethodImpl(256 | 512)]
    public static int4x2 operator <<(int4x2 a, int b) => new(a.c0 << b, a.c1 << b);

    [MethodImpl(256 | 512)]
    public static int4x2 operator >>(int4x2 a, int b) => new(a.c0 >> b, a.c1 >> b);

    [MethodImpl(256 | 512)]
    public static int4x2 operator >>>(int4x2 a, int b) => new(a.c0 >>> b, a.c1 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int4x2 BitAndNot(this int4x2 a, int4x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // int4x2

#region int4x3

public partial struct int4x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<int4x3, int4x3, int4x3>
    , IShiftOperators<int4x3, int, int4x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static int4x3 operator ~(int4x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static int4x3 operator |(int4x3 a, int4x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static int4x3 operator &(int4x3 a, int4x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static int4x3 operator ^(int4x3 a, int4x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    [MethodImpl(256 | 512)]
    public static int4x3 operator <<(int4x3 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b);

    [MethodImpl(256 | 512)]
    public static int4x3 operator >>(int4x3 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b);

    [MethodImpl(256 | 512)]
    public static int4x3 operator >>>(int4x3 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int4x3 BitAndNot(this int4x3 a, int4x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // int4x3

#region int4x4

public partial struct int4x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<int4x4, int4x4, int4x4>
    , IShiftOperators<int4x4, int, int4x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static int4x4 operator ~(int4x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static int4x4 operator |(int4x4 a, int4x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static int4x4 operator &(int4x4 a, int4x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static int4x4 operator ^(int4x4 a, int4x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    [MethodImpl(256 | 512)]
    public static int4x4 operator <<(int4x4 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b, a.c3 << b);

    [MethodImpl(256 | 512)]
    public static int4x4 operator >>(int4x4 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b, a.c3 >> b);

    [MethodImpl(256 | 512)]
    public static int4x4 operator >>>(int4x4 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b, a.c3 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int4x4 BitAndNot(this int4x4 a, int4x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // int4x4

#region uint2x2

public partial struct uint2x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<uint2x2, uint2x2, uint2x2>
    , IShiftOperators<uint2x2, int, uint2x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static uint2x2 operator ~(uint2x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static uint2x2 operator |(uint2x2 a, uint2x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static uint2x2 operator &(uint2x2 a, uint2x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static uint2x2 operator ^(uint2x2 a, uint2x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    [MethodImpl(256 | 512)]
    public static uint2x2 operator <<(uint2x2 a, int b) => new(a.c0 << b, a.c1 << b);

    [MethodImpl(256 | 512)]
    public static uint2x2 operator >>(uint2x2 a, int b) => new(a.c0 >> b, a.c1 >> b);

    [MethodImpl(256 | 512)]
    public static uint2x2 operator >>>(uint2x2 a, int b) => new(a.c0 >>> b, a.c1 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint2x2 BitAndNot(this uint2x2 a, uint2x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // uint2x2

#region uint2x3

public partial struct uint2x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<uint2x3, uint2x3, uint2x3>
    , IShiftOperators<uint2x3, int, uint2x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static uint2x3 operator ~(uint2x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static uint2x3 operator |(uint2x3 a, uint2x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static uint2x3 operator &(uint2x3 a, uint2x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static uint2x3 operator ^(uint2x3 a, uint2x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    [MethodImpl(256 | 512)]
    public static uint2x3 operator <<(uint2x3 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b);

    [MethodImpl(256 | 512)]
    public static uint2x3 operator >>(uint2x3 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b);

    [MethodImpl(256 | 512)]
    public static uint2x3 operator >>>(uint2x3 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint2x3 BitAndNot(this uint2x3 a, uint2x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // uint2x3

#region uint2x4

public partial struct uint2x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<uint2x4, uint2x4, uint2x4>
    , IShiftOperators<uint2x4, int, uint2x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static uint2x4 operator ~(uint2x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static uint2x4 operator |(uint2x4 a, uint2x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static uint2x4 operator &(uint2x4 a, uint2x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static uint2x4 operator ^(uint2x4 a, uint2x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    [MethodImpl(256 | 512)]
    public static uint2x4 operator <<(uint2x4 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b, a.c3 << b);

    [MethodImpl(256 | 512)]
    public static uint2x4 operator >>(uint2x4 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b, a.c3 >> b);

    [MethodImpl(256 | 512)]
    public static uint2x4 operator >>>(uint2x4 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b, a.c3 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint2x4 BitAndNot(this uint2x4 a, uint2x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // uint2x4

#region uint3x2

public partial struct uint3x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<uint3x2, uint3x2, uint3x2>
    , IShiftOperators<uint3x2, int, uint3x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static uint3x2 operator ~(uint3x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static uint3x2 operator |(uint3x2 a, uint3x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static uint3x2 operator &(uint3x2 a, uint3x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static uint3x2 operator ^(uint3x2 a, uint3x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    [MethodImpl(256 | 512)]
    public static uint3x2 operator <<(uint3x2 a, int b) => new(a.c0 << b, a.c1 << b);

    [MethodImpl(256 | 512)]
    public static uint3x2 operator >>(uint3x2 a, int b) => new(a.c0 >> b, a.c1 >> b);

    [MethodImpl(256 | 512)]
    public static uint3x2 operator >>>(uint3x2 a, int b) => new(a.c0 >>> b, a.c1 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint3x2 BitAndNot(this uint3x2 a, uint3x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // uint3x2

#region uint3x3

public partial struct uint3x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<uint3x3, uint3x3, uint3x3>
    , IShiftOperators<uint3x3, int, uint3x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static uint3x3 operator ~(uint3x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static uint3x3 operator |(uint3x3 a, uint3x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static uint3x3 operator &(uint3x3 a, uint3x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static uint3x3 operator ^(uint3x3 a, uint3x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    [MethodImpl(256 | 512)]
    public static uint3x3 operator <<(uint3x3 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b);

    [MethodImpl(256 | 512)]
    public static uint3x3 operator >>(uint3x3 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b);

    [MethodImpl(256 | 512)]
    public static uint3x3 operator >>>(uint3x3 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint3x3 BitAndNot(this uint3x3 a, uint3x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // uint3x3

#region uint3x4

public partial struct uint3x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<uint3x4, uint3x4, uint3x4>
    , IShiftOperators<uint3x4, int, uint3x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static uint3x4 operator ~(uint3x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static uint3x4 operator |(uint3x4 a, uint3x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static uint3x4 operator &(uint3x4 a, uint3x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static uint3x4 operator ^(uint3x4 a, uint3x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    [MethodImpl(256 | 512)]
    public static uint3x4 operator <<(uint3x4 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b, a.c3 << b);

    [MethodImpl(256 | 512)]
    public static uint3x4 operator >>(uint3x4 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b, a.c3 >> b);

    [MethodImpl(256 | 512)]
    public static uint3x4 operator >>>(uint3x4 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b, a.c3 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint3x4 BitAndNot(this uint3x4 a, uint3x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // uint3x4

#region uint4x2

public partial struct uint4x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<uint4x2, uint4x2, uint4x2>
    , IShiftOperators<uint4x2, int, uint4x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static uint4x2 operator ~(uint4x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static uint4x2 operator |(uint4x2 a, uint4x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static uint4x2 operator &(uint4x2 a, uint4x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static uint4x2 operator ^(uint4x2 a, uint4x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    [MethodImpl(256 | 512)]
    public static uint4x2 operator <<(uint4x2 a, int b) => new(a.c0 << b, a.c1 << b);

    [MethodImpl(256 | 512)]
    public static uint4x2 operator >>(uint4x2 a, int b) => new(a.c0 >> b, a.c1 >> b);

    [MethodImpl(256 | 512)]
    public static uint4x2 operator >>>(uint4x2 a, int b) => new(a.c0 >>> b, a.c1 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint4x2 BitAndNot(this uint4x2 a, uint4x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // uint4x2

#region uint4x3

public partial struct uint4x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<uint4x3, uint4x3, uint4x3>
    , IShiftOperators<uint4x3, int, uint4x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static uint4x3 operator ~(uint4x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static uint4x3 operator |(uint4x3 a, uint4x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static uint4x3 operator &(uint4x3 a, uint4x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static uint4x3 operator ^(uint4x3 a, uint4x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    [MethodImpl(256 | 512)]
    public static uint4x3 operator <<(uint4x3 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b);

    [MethodImpl(256 | 512)]
    public static uint4x3 operator >>(uint4x3 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b);

    [MethodImpl(256 | 512)]
    public static uint4x3 operator >>>(uint4x3 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint4x3 BitAndNot(this uint4x3 a, uint4x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // uint4x3

#region uint4x4

public partial struct uint4x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<uint4x4, uint4x4, uint4x4>
    , IShiftOperators<uint4x4, int, uint4x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static uint4x4 operator ~(uint4x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static uint4x4 operator |(uint4x4 a, uint4x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static uint4x4 operator &(uint4x4 a, uint4x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static uint4x4 operator ^(uint4x4 a, uint4x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    [MethodImpl(256 | 512)]
    public static uint4x4 operator <<(uint4x4 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b, a.c3 << b);

    [MethodImpl(256 | 512)]
    public static uint4x4 operator >>(uint4x4 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b, a.c3 >> b);

    [MethodImpl(256 | 512)]
    public static uint4x4 operator >>>(uint4x4 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b, a.c3 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint4x4 BitAndNot(this uint4x4 a, uint4x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // uint4x4

#region long2x2

public partial struct long2x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<long2x2, long2x2, long2x2>
    , IShiftOperators<long2x2, int, long2x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static long2x2 operator ~(long2x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static long2x2 operator |(long2x2 a, long2x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static long2x2 operator &(long2x2 a, long2x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static long2x2 operator ^(long2x2 a, long2x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    [MethodImpl(256 | 512)]
    public static long2x2 operator <<(long2x2 a, int b) => new(a.c0 << b, a.c1 << b);

    [MethodImpl(256 | 512)]
    public static long2x2 operator >>(long2x2 a, int b) => new(a.c0 >> b, a.c1 >> b);

    [MethodImpl(256 | 512)]
    public static long2x2 operator >>>(long2x2 a, int b) => new(a.c0 >>> b, a.c1 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long2x2 BitAndNot(this long2x2 a, long2x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // long2x2

#region long2x3

public partial struct long2x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<long2x3, long2x3, long2x3>
    , IShiftOperators<long2x3, int, long2x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static long2x3 operator ~(long2x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static long2x3 operator |(long2x3 a, long2x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static long2x3 operator &(long2x3 a, long2x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static long2x3 operator ^(long2x3 a, long2x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    [MethodImpl(256 | 512)]
    public static long2x3 operator <<(long2x3 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b);

    [MethodImpl(256 | 512)]
    public static long2x3 operator >>(long2x3 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b);

    [MethodImpl(256 | 512)]
    public static long2x3 operator >>>(long2x3 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long2x3 BitAndNot(this long2x3 a, long2x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // long2x3

#region long2x4

public partial struct long2x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<long2x4, long2x4, long2x4>
    , IShiftOperators<long2x4, int, long2x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static long2x4 operator ~(long2x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static long2x4 operator |(long2x4 a, long2x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static long2x4 operator &(long2x4 a, long2x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static long2x4 operator ^(long2x4 a, long2x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    [MethodImpl(256 | 512)]
    public static long2x4 operator <<(long2x4 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b, a.c3 << b);

    [MethodImpl(256 | 512)]
    public static long2x4 operator >>(long2x4 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b, a.c3 >> b);

    [MethodImpl(256 | 512)]
    public static long2x4 operator >>>(long2x4 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b, a.c3 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long2x4 BitAndNot(this long2x4 a, long2x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // long2x4

#region long3x2

public partial struct long3x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<long3x2, long3x2, long3x2>
    , IShiftOperators<long3x2, int, long3x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static long3x2 operator ~(long3x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static long3x2 operator |(long3x2 a, long3x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static long3x2 operator &(long3x2 a, long3x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static long3x2 operator ^(long3x2 a, long3x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    [MethodImpl(256 | 512)]
    public static long3x2 operator <<(long3x2 a, int b) => new(a.c0 << b, a.c1 << b);

    [MethodImpl(256 | 512)]
    public static long3x2 operator >>(long3x2 a, int b) => new(a.c0 >> b, a.c1 >> b);

    [MethodImpl(256 | 512)]
    public static long3x2 operator >>>(long3x2 a, int b) => new(a.c0 >>> b, a.c1 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long3x2 BitAndNot(this long3x2 a, long3x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // long3x2

#region long3x3

public partial struct long3x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<long3x3, long3x3, long3x3>
    , IShiftOperators<long3x3, int, long3x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static long3x3 operator ~(long3x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static long3x3 operator |(long3x3 a, long3x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static long3x3 operator &(long3x3 a, long3x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static long3x3 operator ^(long3x3 a, long3x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    [MethodImpl(256 | 512)]
    public static long3x3 operator <<(long3x3 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b);

    [MethodImpl(256 | 512)]
    public static long3x3 operator >>(long3x3 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b);

    [MethodImpl(256 | 512)]
    public static long3x3 operator >>>(long3x3 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long3x3 BitAndNot(this long3x3 a, long3x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // long3x3

#region long3x4

public partial struct long3x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<long3x4, long3x4, long3x4>
    , IShiftOperators<long3x4, int, long3x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static long3x4 operator ~(long3x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static long3x4 operator |(long3x4 a, long3x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static long3x4 operator &(long3x4 a, long3x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static long3x4 operator ^(long3x4 a, long3x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    [MethodImpl(256 | 512)]
    public static long3x4 operator <<(long3x4 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b, a.c3 << b);

    [MethodImpl(256 | 512)]
    public static long3x4 operator >>(long3x4 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b, a.c3 >> b);

    [MethodImpl(256 | 512)]
    public static long3x4 operator >>>(long3x4 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b, a.c3 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long3x4 BitAndNot(this long3x4 a, long3x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // long3x4

#region long4x2

public partial struct long4x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<long4x2, long4x2, long4x2>
    , IShiftOperators<long4x2, int, long4x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static long4x2 operator ~(long4x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static long4x2 operator |(long4x2 a, long4x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static long4x2 operator &(long4x2 a, long4x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static long4x2 operator ^(long4x2 a, long4x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    [MethodImpl(256 | 512)]
    public static long4x2 operator <<(long4x2 a, int b) => new(a.c0 << b, a.c1 << b);

    [MethodImpl(256 | 512)]
    public static long4x2 operator >>(long4x2 a, int b) => new(a.c0 >> b, a.c1 >> b);

    [MethodImpl(256 | 512)]
    public static long4x2 operator >>>(long4x2 a, int b) => new(a.c0 >>> b, a.c1 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long4x2 BitAndNot(this long4x2 a, long4x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // long4x2

#region long4x3

public partial struct long4x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<long4x3, long4x3, long4x3>
    , IShiftOperators<long4x3, int, long4x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static long4x3 operator ~(long4x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static long4x3 operator |(long4x3 a, long4x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static long4x3 operator &(long4x3 a, long4x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static long4x3 operator ^(long4x3 a, long4x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    [MethodImpl(256 | 512)]
    public static long4x3 operator <<(long4x3 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b);

    [MethodImpl(256 | 512)]
    public static long4x3 operator >>(long4x3 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b);

    [MethodImpl(256 | 512)]
    public static long4x3 operator >>>(long4x3 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long4x3 BitAndNot(this long4x3 a, long4x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // long4x3

#region long4x4

public partial struct long4x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<long4x4, long4x4, long4x4>
    , IShiftOperators<long4x4, int, long4x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static long4x4 operator ~(long4x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static long4x4 operator |(long4x4 a, long4x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static long4x4 operator &(long4x4 a, long4x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static long4x4 operator ^(long4x4 a, long4x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    [MethodImpl(256 | 512)]
    public static long4x4 operator <<(long4x4 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b, a.c3 << b);

    [MethodImpl(256 | 512)]
    public static long4x4 operator >>(long4x4 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b, a.c3 >> b);

    [MethodImpl(256 | 512)]
    public static long4x4 operator >>>(long4x4 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b, a.c3 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long4x4 BitAndNot(this long4x4 a, long4x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // long4x4

#region ulong2x2

public partial struct ulong2x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<ulong2x2, ulong2x2, ulong2x2>
    , IShiftOperators<ulong2x2, int, ulong2x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static ulong2x2 operator ~(ulong2x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static ulong2x2 operator |(ulong2x2 a, ulong2x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static ulong2x2 operator &(ulong2x2 a, ulong2x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static ulong2x2 operator ^(ulong2x2 a, ulong2x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    [MethodImpl(256 | 512)]
    public static ulong2x2 operator <<(ulong2x2 a, int b) => new(a.c0 << b, a.c1 << b);

    [MethodImpl(256 | 512)]
    public static ulong2x2 operator >>(ulong2x2 a, int b) => new(a.c0 >> b, a.c1 >> b);

    [MethodImpl(256 | 512)]
    public static ulong2x2 operator >>>(ulong2x2 a, int b) => new(a.c0 >>> b, a.c1 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong2x2 BitAndNot(this ulong2x2 a, ulong2x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // ulong2x2

#region ulong2x3

public partial struct ulong2x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<ulong2x3, ulong2x3, ulong2x3>
    , IShiftOperators<ulong2x3, int, ulong2x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static ulong2x3 operator ~(ulong2x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static ulong2x3 operator |(ulong2x3 a, ulong2x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static ulong2x3 operator &(ulong2x3 a, ulong2x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static ulong2x3 operator ^(ulong2x3 a, ulong2x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    [MethodImpl(256 | 512)]
    public static ulong2x3 operator <<(ulong2x3 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b);

    [MethodImpl(256 | 512)]
    public static ulong2x3 operator >>(ulong2x3 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b);

    [MethodImpl(256 | 512)]
    public static ulong2x3 operator >>>(ulong2x3 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong2x3 BitAndNot(this ulong2x3 a, ulong2x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // ulong2x3

#region ulong2x4

public partial struct ulong2x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<ulong2x4, ulong2x4, ulong2x4>
    , IShiftOperators<ulong2x4, int, ulong2x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static ulong2x4 operator ~(ulong2x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static ulong2x4 operator |(ulong2x4 a, ulong2x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static ulong2x4 operator &(ulong2x4 a, ulong2x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static ulong2x4 operator ^(ulong2x4 a, ulong2x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    [MethodImpl(256 | 512)]
    public static ulong2x4 operator <<(ulong2x4 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b, a.c3 << b);

    [MethodImpl(256 | 512)]
    public static ulong2x4 operator >>(ulong2x4 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b, a.c3 >> b);

    [MethodImpl(256 | 512)]
    public static ulong2x4 operator >>>(ulong2x4 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b, a.c3 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong2x4 BitAndNot(this ulong2x4 a, ulong2x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // ulong2x4

#region ulong3x2

public partial struct ulong3x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<ulong3x2, ulong3x2, ulong3x2>
    , IShiftOperators<ulong3x2, int, ulong3x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static ulong3x2 operator ~(ulong3x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static ulong3x2 operator |(ulong3x2 a, ulong3x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static ulong3x2 operator &(ulong3x2 a, ulong3x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static ulong3x2 operator ^(ulong3x2 a, ulong3x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    [MethodImpl(256 | 512)]
    public static ulong3x2 operator <<(ulong3x2 a, int b) => new(a.c0 << b, a.c1 << b);

    [MethodImpl(256 | 512)]
    public static ulong3x2 operator >>(ulong3x2 a, int b) => new(a.c0 >> b, a.c1 >> b);

    [MethodImpl(256 | 512)]
    public static ulong3x2 operator >>>(ulong3x2 a, int b) => new(a.c0 >>> b, a.c1 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong3x2 BitAndNot(this ulong3x2 a, ulong3x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // ulong3x2

#region ulong3x3

public partial struct ulong3x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<ulong3x3, ulong3x3, ulong3x3>
    , IShiftOperators<ulong3x3, int, ulong3x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static ulong3x3 operator ~(ulong3x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static ulong3x3 operator |(ulong3x3 a, ulong3x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static ulong3x3 operator &(ulong3x3 a, ulong3x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static ulong3x3 operator ^(ulong3x3 a, ulong3x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    [MethodImpl(256 | 512)]
    public static ulong3x3 operator <<(ulong3x3 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b);

    [MethodImpl(256 | 512)]
    public static ulong3x3 operator >>(ulong3x3 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b);

    [MethodImpl(256 | 512)]
    public static ulong3x3 operator >>>(ulong3x3 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong3x3 BitAndNot(this ulong3x3 a, ulong3x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // ulong3x3

#region ulong3x4

public partial struct ulong3x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<ulong3x4, ulong3x4, ulong3x4>
    , IShiftOperators<ulong3x4, int, ulong3x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static ulong3x4 operator ~(ulong3x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static ulong3x4 operator |(ulong3x4 a, ulong3x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static ulong3x4 operator &(ulong3x4 a, ulong3x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static ulong3x4 operator ^(ulong3x4 a, ulong3x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    [MethodImpl(256 | 512)]
    public static ulong3x4 operator <<(ulong3x4 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b, a.c3 << b);

    [MethodImpl(256 | 512)]
    public static ulong3x4 operator >>(ulong3x4 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b, a.c3 >> b);

    [MethodImpl(256 | 512)]
    public static ulong3x4 operator >>>(ulong3x4 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b, a.c3 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong3x4 BitAndNot(this ulong3x4 a, ulong3x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // ulong3x4

#region ulong4x2

public partial struct ulong4x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<ulong4x2, ulong4x2, ulong4x2>
    , IShiftOperators<ulong4x2, int, ulong4x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static ulong4x2 operator ~(ulong4x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static ulong4x2 operator |(ulong4x2 a, ulong4x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static ulong4x2 operator &(ulong4x2 a, ulong4x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static ulong4x2 operator ^(ulong4x2 a, ulong4x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    [MethodImpl(256 | 512)]
    public static ulong4x2 operator <<(ulong4x2 a, int b) => new(a.c0 << b, a.c1 << b);

    [MethodImpl(256 | 512)]
    public static ulong4x2 operator >>(ulong4x2 a, int b) => new(a.c0 >> b, a.c1 >> b);

    [MethodImpl(256 | 512)]
    public static ulong4x2 operator >>>(ulong4x2 a, int b) => new(a.c0 >>> b, a.c1 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong4x2 BitAndNot(this ulong4x2 a, ulong4x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // ulong4x2

#region ulong4x3

public partial struct ulong4x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<ulong4x3, ulong4x3, ulong4x3>
    , IShiftOperators<ulong4x3, int, ulong4x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static ulong4x3 operator ~(ulong4x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static ulong4x3 operator |(ulong4x3 a, ulong4x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static ulong4x3 operator &(ulong4x3 a, ulong4x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static ulong4x3 operator ^(ulong4x3 a, ulong4x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    [MethodImpl(256 | 512)]
    public static ulong4x3 operator <<(ulong4x3 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b);

    [MethodImpl(256 | 512)]
    public static ulong4x3 operator >>(ulong4x3 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b);

    [MethodImpl(256 | 512)]
    public static ulong4x3 operator >>>(ulong4x3 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong4x3 BitAndNot(this ulong4x3 a, ulong4x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // ulong4x3

#region ulong4x4

public partial struct ulong4x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<ulong4x4, ulong4x4, ulong4x4>
    , IShiftOperators<ulong4x4, int, ulong4x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static ulong4x4 operator ~(ulong4x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static ulong4x4 operator |(ulong4x4 a, ulong4x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static ulong4x4 operator &(ulong4x4 a, ulong4x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static ulong4x4 operator ^(ulong4x4 a, ulong4x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    [MethodImpl(256 | 512)]
    public static ulong4x4 operator <<(ulong4x4 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b, a.c3 << b);

    [MethodImpl(256 | 512)]
    public static ulong4x4 operator >>(ulong4x4 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b, a.c3 >> b);

    [MethodImpl(256 | 512)]
    public static ulong4x4 operator >>>(ulong4x4 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b, a.c3 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong4x4 BitAndNot(this ulong4x4 a, ulong4x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // ulong4x4

#region half2x2

public partial struct half2x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<half2x2, half2x2, half2x2>
    , IShiftOperators<half2x2, int, half2x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static half2x2 operator ~(half2x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static half2x2 operator |(half2x2 a, half2x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static half2x2 operator &(half2x2 a, half2x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static half2x2 operator ^(half2x2 a, half2x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    [MethodImpl(256 | 512)]
    public static half2x2 operator <<(half2x2 a, int b) => new(a.c0 << b, a.c1 << b);

    [MethodImpl(256 | 512)]
    public static half2x2 operator >>(half2x2 a, int b) => new(a.c0 >> b, a.c1 >> b);

    [MethodImpl(256 | 512)]
    public static half2x2 operator >>>(half2x2 a, int b) => new(a.c0 >>> b, a.c1 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half2x2 BitAndNot(this half2x2 a, half2x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // half2x2

#region half2x3

public partial struct half2x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<half2x3, half2x3, half2x3>
    , IShiftOperators<half2x3, int, half2x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static half2x3 operator ~(half2x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static half2x3 operator |(half2x3 a, half2x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static half2x3 operator &(half2x3 a, half2x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static half2x3 operator ^(half2x3 a, half2x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    [MethodImpl(256 | 512)]
    public static half2x3 operator <<(half2x3 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b);

    [MethodImpl(256 | 512)]
    public static half2x3 operator >>(half2x3 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b);

    [MethodImpl(256 | 512)]
    public static half2x3 operator >>>(half2x3 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half2x3 BitAndNot(this half2x3 a, half2x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // half2x3

#region half2x4

public partial struct half2x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<half2x4, half2x4, half2x4>
    , IShiftOperators<half2x4, int, half2x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static half2x4 operator ~(half2x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static half2x4 operator |(half2x4 a, half2x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static half2x4 operator &(half2x4 a, half2x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static half2x4 operator ^(half2x4 a, half2x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    [MethodImpl(256 | 512)]
    public static half2x4 operator <<(half2x4 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b, a.c3 << b);

    [MethodImpl(256 | 512)]
    public static half2x4 operator >>(half2x4 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b, a.c3 >> b);

    [MethodImpl(256 | 512)]
    public static half2x4 operator >>>(half2x4 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b, a.c3 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half2x4 BitAndNot(this half2x4 a, half2x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // half2x4

#region half3x2

public partial struct half3x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<half3x2, half3x2, half3x2>
    , IShiftOperators<half3x2, int, half3x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static half3x2 operator ~(half3x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static half3x2 operator |(half3x2 a, half3x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static half3x2 operator &(half3x2 a, half3x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static half3x2 operator ^(half3x2 a, half3x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    [MethodImpl(256 | 512)]
    public static half3x2 operator <<(half3x2 a, int b) => new(a.c0 << b, a.c1 << b);

    [MethodImpl(256 | 512)]
    public static half3x2 operator >>(half3x2 a, int b) => new(a.c0 >> b, a.c1 >> b);

    [MethodImpl(256 | 512)]
    public static half3x2 operator >>>(half3x2 a, int b) => new(a.c0 >>> b, a.c1 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half3x2 BitAndNot(this half3x2 a, half3x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // half3x2

#region half3x3

public partial struct half3x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<half3x3, half3x3, half3x3>
    , IShiftOperators<half3x3, int, half3x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static half3x3 operator ~(half3x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static half3x3 operator |(half3x3 a, half3x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static half3x3 operator &(half3x3 a, half3x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static half3x3 operator ^(half3x3 a, half3x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    [MethodImpl(256 | 512)]
    public static half3x3 operator <<(half3x3 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b);

    [MethodImpl(256 | 512)]
    public static half3x3 operator >>(half3x3 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b);

    [MethodImpl(256 | 512)]
    public static half3x3 operator >>>(half3x3 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half3x3 BitAndNot(this half3x3 a, half3x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // half3x3

#region half3x4

public partial struct half3x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<half3x4, half3x4, half3x4>
    , IShiftOperators<half3x4, int, half3x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static half3x4 operator ~(half3x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static half3x4 operator |(half3x4 a, half3x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static half3x4 operator &(half3x4 a, half3x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static half3x4 operator ^(half3x4 a, half3x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    [MethodImpl(256 | 512)]
    public static half3x4 operator <<(half3x4 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b, a.c3 << b);

    [MethodImpl(256 | 512)]
    public static half3x4 operator >>(half3x4 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b, a.c3 >> b);

    [MethodImpl(256 | 512)]
    public static half3x4 operator >>>(half3x4 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b, a.c3 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half3x4 BitAndNot(this half3x4 a, half3x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // half3x4

#region half4x2

public partial struct half4x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<half4x2, half4x2, half4x2>
    , IShiftOperators<half4x2, int, half4x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static half4x2 operator ~(half4x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static half4x2 operator |(half4x2 a, half4x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static half4x2 operator &(half4x2 a, half4x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static half4x2 operator ^(half4x2 a, half4x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    [MethodImpl(256 | 512)]
    public static half4x2 operator <<(half4x2 a, int b) => new(a.c0 << b, a.c1 << b);

    [MethodImpl(256 | 512)]
    public static half4x2 operator >>(half4x2 a, int b) => new(a.c0 >> b, a.c1 >> b);

    [MethodImpl(256 | 512)]
    public static half4x2 operator >>>(half4x2 a, int b) => new(a.c0 >>> b, a.c1 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half4x2 BitAndNot(this half4x2 a, half4x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // half4x2

#region half4x3

public partial struct half4x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<half4x3, half4x3, half4x3>
    , IShiftOperators<half4x3, int, half4x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static half4x3 operator ~(half4x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static half4x3 operator |(half4x3 a, half4x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static half4x3 operator &(half4x3 a, half4x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static half4x3 operator ^(half4x3 a, half4x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    [MethodImpl(256 | 512)]
    public static half4x3 operator <<(half4x3 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b);

    [MethodImpl(256 | 512)]
    public static half4x3 operator >>(half4x3 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b);

    [MethodImpl(256 | 512)]
    public static half4x3 operator >>>(half4x3 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half4x3 BitAndNot(this half4x3 a, half4x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // half4x3

#region half4x4

public partial struct half4x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<half4x4, half4x4, half4x4>
    , IShiftOperators<half4x4, int, half4x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static half4x4 operator ~(half4x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static half4x4 operator |(half4x4 a, half4x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static half4x4 operator &(half4x4 a, half4x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static half4x4 operator ^(half4x4 a, half4x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    [MethodImpl(256 | 512)]
    public static half4x4 operator <<(half4x4 a, int b) => new(a.c0 << b, a.c1 << b, a.c2 << b, a.c3 << b);

    [MethodImpl(256 | 512)]
    public static half4x4 operator >>(half4x4 a, int b) => new(a.c0 >> b, a.c1 >> b, a.c2 >> b, a.c3 >> b);

    [MethodImpl(256 | 512)]
    public static half4x4 operator >>>(half4x4 a, int b) => new(a.c0 >>> b, a.c1 >>> b, a.c2 >>> b, a.c3 >>> b);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half4x4 BitAndNot(this half4x4 a, half4x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // half4x4

#region b16m2x2

public partial struct b16m2x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<b16m2x2, b16m2x2, b16m2x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static b16m2x2 operator ~(b16m2x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static b16m2x2 operator |(b16m2x2 a, b16m2x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static b16m2x2 operator &(b16m2x2 a, b16m2x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static b16m2x2 operator ^(b16m2x2 a, b16m2x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b16m2x2 BitAndNot(this b16m2x2 a, b16m2x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // b16m2x2

#region b16m2x3

public partial struct b16m2x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<b16m2x3, b16m2x3, b16m2x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static b16m2x3 operator ~(b16m2x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static b16m2x3 operator |(b16m2x3 a, b16m2x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static b16m2x3 operator &(b16m2x3 a, b16m2x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static b16m2x3 operator ^(b16m2x3 a, b16m2x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b16m2x3 BitAndNot(this b16m2x3 a, b16m2x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // b16m2x3

#region b16m2x4

public partial struct b16m2x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<b16m2x4, b16m2x4, b16m2x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static b16m2x4 operator ~(b16m2x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static b16m2x4 operator |(b16m2x4 a, b16m2x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static b16m2x4 operator &(b16m2x4 a, b16m2x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static b16m2x4 operator ^(b16m2x4 a, b16m2x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b16m2x4 BitAndNot(this b16m2x4 a, b16m2x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // b16m2x4

#region b16m3x2

public partial struct b16m3x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<b16m3x2, b16m3x2, b16m3x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static b16m3x2 operator ~(b16m3x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static b16m3x2 operator |(b16m3x2 a, b16m3x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static b16m3x2 operator &(b16m3x2 a, b16m3x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static b16m3x2 operator ^(b16m3x2 a, b16m3x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b16m3x2 BitAndNot(this b16m3x2 a, b16m3x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // b16m3x2

#region b16m3x3

public partial struct b16m3x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<b16m3x3, b16m3x3, b16m3x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static b16m3x3 operator ~(b16m3x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static b16m3x3 operator |(b16m3x3 a, b16m3x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static b16m3x3 operator &(b16m3x3 a, b16m3x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static b16m3x3 operator ^(b16m3x3 a, b16m3x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b16m3x3 BitAndNot(this b16m3x3 a, b16m3x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // b16m3x3

#region b16m3x4

public partial struct b16m3x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<b16m3x4, b16m3x4, b16m3x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static b16m3x4 operator ~(b16m3x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static b16m3x4 operator |(b16m3x4 a, b16m3x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static b16m3x4 operator &(b16m3x4 a, b16m3x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static b16m3x4 operator ^(b16m3x4 a, b16m3x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b16m3x4 BitAndNot(this b16m3x4 a, b16m3x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // b16m3x4

#region b16m4x2

public partial struct b16m4x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<b16m4x2, b16m4x2, b16m4x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static b16m4x2 operator ~(b16m4x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static b16m4x2 operator |(b16m4x2 a, b16m4x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static b16m4x2 operator &(b16m4x2 a, b16m4x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static b16m4x2 operator ^(b16m4x2 a, b16m4x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b16m4x2 BitAndNot(this b16m4x2 a, b16m4x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // b16m4x2

#region b16m4x3

public partial struct b16m4x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<b16m4x3, b16m4x3, b16m4x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static b16m4x3 operator ~(b16m4x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static b16m4x3 operator |(b16m4x3 a, b16m4x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static b16m4x3 operator &(b16m4x3 a, b16m4x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static b16m4x3 operator ^(b16m4x3 a, b16m4x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b16m4x3 BitAndNot(this b16m4x3 a, b16m4x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // b16m4x3

#region b16m4x4

public partial struct b16m4x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<b16m4x4, b16m4x4, b16m4x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static b16m4x4 operator ~(b16m4x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static b16m4x4 operator |(b16m4x4 a, b16m4x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static b16m4x4 operator &(b16m4x4 a, b16m4x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static b16m4x4 operator ^(b16m4x4 a, b16m4x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b16m4x4 BitAndNot(this b16m4x4 a, b16m4x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // b16m4x4

#region b32m2x2

public partial struct b32m2x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<b32m2x2, b32m2x2, b32m2x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static b32m2x2 operator ~(b32m2x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static b32m2x2 operator |(b32m2x2 a, b32m2x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static b32m2x2 operator &(b32m2x2 a, b32m2x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static b32m2x2 operator ^(b32m2x2 a, b32m2x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b32m2x2 BitAndNot(this b32m2x2 a, b32m2x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // b32m2x2

#region b32m2x3

public partial struct b32m2x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<b32m2x3, b32m2x3, b32m2x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static b32m2x3 operator ~(b32m2x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static b32m2x3 operator |(b32m2x3 a, b32m2x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static b32m2x3 operator &(b32m2x3 a, b32m2x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static b32m2x3 operator ^(b32m2x3 a, b32m2x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b32m2x3 BitAndNot(this b32m2x3 a, b32m2x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // b32m2x3

#region b32m2x4

public partial struct b32m2x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<b32m2x4, b32m2x4, b32m2x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static b32m2x4 operator ~(b32m2x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static b32m2x4 operator |(b32m2x4 a, b32m2x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static b32m2x4 operator &(b32m2x4 a, b32m2x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static b32m2x4 operator ^(b32m2x4 a, b32m2x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b32m2x4 BitAndNot(this b32m2x4 a, b32m2x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // b32m2x4

#region b32m3x2

public partial struct b32m3x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<b32m3x2, b32m3x2, b32m3x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static b32m3x2 operator ~(b32m3x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static b32m3x2 operator |(b32m3x2 a, b32m3x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static b32m3x2 operator &(b32m3x2 a, b32m3x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static b32m3x2 operator ^(b32m3x2 a, b32m3x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b32m3x2 BitAndNot(this b32m3x2 a, b32m3x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // b32m3x2

#region b32m3x3

public partial struct b32m3x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<b32m3x3, b32m3x3, b32m3x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static b32m3x3 operator ~(b32m3x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static b32m3x3 operator |(b32m3x3 a, b32m3x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static b32m3x3 operator &(b32m3x3 a, b32m3x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static b32m3x3 operator ^(b32m3x3 a, b32m3x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b32m3x3 BitAndNot(this b32m3x3 a, b32m3x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // b32m3x3

#region b32m3x4

public partial struct b32m3x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<b32m3x4, b32m3x4, b32m3x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static b32m3x4 operator ~(b32m3x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static b32m3x4 operator |(b32m3x4 a, b32m3x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static b32m3x4 operator &(b32m3x4 a, b32m3x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static b32m3x4 operator ^(b32m3x4 a, b32m3x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b32m3x4 BitAndNot(this b32m3x4 a, b32m3x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // b32m3x4

#region b32m4x2

public partial struct b32m4x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<b32m4x2, b32m4x2, b32m4x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static b32m4x2 operator ~(b32m4x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static b32m4x2 operator |(b32m4x2 a, b32m4x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static b32m4x2 operator &(b32m4x2 a, b32m4x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static b32m4x2 operator ^(b32m4x2 a, b32m4x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b32m4x2 BitAndNot(this b32m4x2 a, b32m4x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // b32m4x2

#region b32m4x3

public partial struct b32m4x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<b32m4x3, b32m4x3, b32m4x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static b32m4x3 operator ~(b32m4x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static b32m4x3 operator |(b32m4x3 a, b32m4x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static b32m4x3 operator &(b32m4x3 a, b32m4x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static b32m4x3 operator ^(b32m4x3 a, b32m4x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b32m4x3 BitAndNot(this b32m4x3 a, b32m4x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // b32m4x3

#region b32m4x4

public partial struct b32m4x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<b32m4x4, b32m4x4, b32m4x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static b32m4x4 operator ~(b32m4x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static b32m4x4 operator |(b32m4x4 a, b32m4x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static b32m4x4 operator &(b32m4x4 a, b32m4x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static b32m4x4 operator ^(b32m4x4 a, b32m4x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b32m4x4 BitAndNot(this b32m4x4 a, b32m4x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // b32m4x4

#region b64m2x2

public partial struct b64m2x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<b64m2x2, b64m2x2, b64m2x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static b64m2x2 operator ~(b64m2x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static b64m2x2 operator |(b64m2x2 a, b64m2x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static b64m2x2 operator &(b64m2x2 a, b64m2x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static b64m2x2 operator ^(b64m2x2 a, b64m2x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b64m2x2 BitAndNot(this b64m2x2 a, b64m2x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // b64m2x2

#region b64m2x3

public partial struct b64m2x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<b64m2x3, b64m2x3, b64m2x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static b64m2x3 operator ~(b64m2x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static b64m2x3 operator |(b64m2x3 a, b64m2x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static b64m2x3 operator &(b64m2x3 a, b64m2x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static b64m2x3 operator ^(b64m2x3 a, b64m2x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b64m2x3 BitAndNot(this b64m2x3 a, b64m2x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // b64m2x3

#region b64m2x4

public partial struct b64m2x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<b64m2x4, b64m2x4, b64m2x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static b64m2x4 operator ~(b64m2x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static b64m2x4 operator |(b64m2x4 a, b64m2x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static b64m2x4 operator &(b64m2x4 a, b64m2x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static b64m2x4 operator ^(b64m2x4 a, b64m2x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b64m2x4 BitAndNot(this b64m2x4 a, b64m2x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // b64m2x4

#region b64m3x2

public partial struct b64m3x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<b64m3x2, b64m3x2, b64m3x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static b64m3x2 operator ~(b64m3x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static b64m3x2 operator |(b64m3x2 a, b64m3x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static b64m3x2 operator &(b64m3x2 a, b64m3x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static b64m3x2 operator ^(b64m3x2 a, b64m3x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b64m3x2 BitAndNot(this b64m3x2 a, b64m3x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // b64m3x2

#region b64m3x3

public partial struct b64m3x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<b64m3x3, b64m3x3, b64m3x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static b64m3x3 operator ~(b64m3x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static b64m3x3 operator |(b64m3x3 a, b64m3x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static b64m3x3 operator &(b64m3x3 a, b64m3x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static b64m3x3 operator ^(b64m3x3 a, b64m3x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b64m3x3 BitAndNot(this b64m3x3 a, b64m3x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // b64m3x3

#region b64m3x4

public partial struct b64m3x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<b64m3x4, b64m3x4, b64m3x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static b64m3x4 operator ~(b64m3x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static b64m3x4 operator |(b64m3x4 a, b64m3x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static b64m3x4 operator &(b64m3x4 a, b64m3x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static b64m3x4 operator ^(b64m3x4 a, b64m3x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b64m3x4 BitAndNot(this b64m3x4 a, b64m3x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // b64m3x4

#region b64m4x2

public partial struct b64m4x2 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<b64m4x2, b64m4x2, b64m4x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public static b64m4x2 operator ~(b64m4x2 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static b64m4x2 operator |(b64m4x2 a, b64m4x2 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static b64m4x2 operator &(b64m4x2 a, b64m4x2 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static b64m4x2 operator ^(b64m4x2 a, b64m4x2 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b64m4x2 BitAndNot(this b64m4x2 a, b64m4x2 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1));
}

#endregion // b64m4x2

#region b64m4x3

public partial struct b64m4x3 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<b64m4x3, b64m4x3, b64m4x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public static b64m4x3 operator ~(b64m4x3 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static b64m4x3 operator |(b64m4x3 a, b64m4x3 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static b64m4x3 operator &(b64m4x3 a, b64m4x3 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static b64m4x3 operator ^(b64m4x3 a, b64m4x3 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b64m4x3 BitAndNot(this b64m4x3 a, b64m4x3 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2));
}

#endregion // b64m4x3

#region b64m4x4

public partial struct b64m4x4 : IMatrixBitops
    #if NET8_0_OR_GREATER
    , IBitwiseOperators<b64m4x4, b64m4x4, b64m4x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public static b64m4x4 operator ~(b64m4x4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static b64m4x4 operator |(b64m4x4 a, b64m4x4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static b64m4x4 operator &(b64m4x4 a, b64m4x4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static b64m4x4 operator ^(b64m4x4 a, b64m4x4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b64m4x4 BitAndNot(this b64m4x4 a, b64m4x4 b) => new(a.c0.BitAndNot(b.c0), a.c1.BitAndNot(b.c1), a.c2.BitAndNot(b.c2), a.c3.BitAndNot(b.c3));
}

#endregion // b64m4x4
