<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="..\Coplt.Mathematics\types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics.SignedDistances;

/// <summary>
/// Signed distance function
/// </summary>
public static partial class sdf
{

<#
    foreach (var typ in Typ.Typs)
    {
        if (!typ.f || !typ.bin) continue;
        if (typ.name == "half") continue;

        var typeBitSize = typ.size * 8;

        var byteSize = typ.size * 4;
        var bitSize = 8 * byteSize;

        var suffix = typ.suffix;

        var scalar = typ.compType;
        var vec4 = $"{typ.name}{4}";
        var vec3 = $"{typ.name}{3}";
        var vec2 = $"{typ.name}{2}";
#>
    #region <#= typ.name #>

    [MethodImpl(256 | 512)]
    public static <#=scalar#> add(<#=scalar#> d1, <#=scalar#> d2) => d1.min(d2);

    [MethodImpl(256 | 512)]
    public static <#=scalar#> sub(<#=scalar#> d1, <#=scalar#> d2) => (-d1).max(d2);

    [MethodImpl(256 | 512)]
    public static <#=scalar#> and(<#=scalar#> d1, <#=scalar#> d2) => d1.max(d2);

    [MethodImpl(256 | 512)]
    public static <#=scalar#> xor(<#=scalar#> d1, <#=scalar#> d2) => d1.min(d2).max(-d1.max(d2));

    [MethodImpl(256 | 512)]
    public static <#=scalar#> add_smooth(<#=scalar#> d1, <#=scalar#> d2, <#=scalar#> k) =>
        add_smooth(d1, d2, k, out _);

    [MethodImpl(256 | 512)]
    public static <#=scalar#> add_smooth(<#=scalar#> d1, <#=scalar#> d2, <#=scalar#> k, out <#=scalar#> h)
    {
        h = (0.5<#=suffix#> + 0.5<#=suffix#> * (d2 - d1) / k).clamp(0.0<#=suffix#>, 1.0<#=suffix#>);
        return h.lerp(d2, d1) - k * h * (1.0<#=suffix#> - h);
    }

    [MethodImpl(256 | 512)]
    public static <#=scalar#> sub_smooth(<#=scalar#> d1, <#=scalar#> d2, <#=scalar#> k) =>
        sub_smooth(d1, d2, k, out _);

    [MethodImpl(256 | 512)]
    public static <#=scalar#> sub_smooth(<#=scalar#> d1, <#=scalar#> d2, <#=scalar#> k, out <#=scalar#> h)
    {
        h = (0.5<#=suffix#> - 0.5<#=suffix#> * (d2 + d1) / k).clamp(0.0<#=suffix#>, 1.0<#=suffix#>);
        return h.lerp(d2, -d1) + k * h * (1.0<#=suffix#> - h);
    }

    [MethodImpl(256 | 512)]
    public static <#=scalar#> and_smooth(<#=scalar#> d1, <#=scalar#> d2, <#=scalar#> k) =>
        and_smooth(d1, d2, k, out _);

    [MethodImpl(256 | 512)]
    public static <#=scalar#> and_smooth(<#=scalar#> d1, <#=scalar#> d2, <#=scalar#> k, out <#=scalar#> h)
    {
        h = (0.5<#=suffix#> - 0.5<#=suffix#> * (d2 - d1) / k).clamp(0.0<#=suffix#>, 1.0<#=suffix#>);
        return h.lerp(d2, d1) + k * h * (1.0<#=suffix#> - h);
    }

    #endregion // <#= typ.name #>

<#
    }
#>
}
