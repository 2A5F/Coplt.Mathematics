// generated by template, do not modify manually

namespace Coplt.Mathematics.SignedDistances;

/// <summary>
/// Signed distance function
/// </summary>
public static partial class sdf
{

    #region float

    [MethodImpl(256 | 512)]
    public static float add(float d1, float d2) => d1.min(d2);

    [MethodImpl(256 | 512)]
    public static float sub(float d1, float d2) => (-d1).max(d2);

    [MethodImpl(256 | 512)]
    public static float and(float d1, float d2) => d1.max(d2);

    [MethodImpl(256 | 512)]
    public static float xor(float d1, float d2) => d1.min(d2).max(-d1.max(d2));

    [MethodImpl(256 | 512)]
    public static float add_smooth(float d1, float d2, float k) =>
        add_smooth(d1, d2, k, out _);

    [MethodImpl(256 | 512)]
    public static float add_smooth(float d1, float d2, float k, out float h)
    {
        h = (0.5f + 0.5f * (d2 - d1) / k).clamp(0.0f, 1.0f);
        return h.lerp(d2, d1) - k * h * (1.0f - h);
    }

    [MethodImpl(256 | 512)]
    public static float sub_smooth(float d1, float d2, float k) =>
        sub_smooth(d1, d2, k, out _);

    [MethodImpl(256 | 512)]
    public static float sub_smooth(float d1, float d2, float k, out float h)
    {
        h = (0.5f - 0.5f * (d2 + d1) / k).clamp(0.0f, 1.0f);
        return h.lerp(d2, -d1) + k * h * (1.0f - h);
    }

    [MethodImpl(256 | 512)]
    public static float and_smooth(float d1, float d2, float k) =>
        and_smooth(d1, d2, k, out _);

    [MethodImpl(256 | 512)]
    public static float and_smooth(float d1, float d2, float k, out float h)
    {
        h = (0.5f - 0.5f * (d2 - d1) / k).clamp(0.0f, 1.0f);
        return h.lerp(d2, d1) + k * h * (1.0f - h);
    }

    #endregion // float

    #region double

    [MethodImpl(256 | 512)]
    public static double add(double d1, double d2) => d1.min(d2);

    [MethodImpl(256 | 512)]
    public static double sub(double d1, double d2) => (-d1).max(d2);

    [MethodImpl(256 | 512)]
    public static double and(double d1, double d2) => d1.max(d2);

    [MethodImpl(256 | 512)]
    public static double xor(double d1, double d2) => d1.min(d2).max(-d1.max(d2));

    [MethodImpl(256 | 512)]
    public static double add_smooth(double d1, double d2, double k) =>
        add_smooth(d1, d2, k, out _);

    [MethodImpl(256 | 512)]
    public static double add_smooth(double d1, double d2, double k, out double h)
    {
        h = (0.5 + 0.5 * (d2 - d1) / k).clamp(0.0, 1.0);
        return h.lerp(d2, d1) - k * h * (1.0 - h);
    }

    [MethodImpl(256 | 512)]
    public static double sub_smooth(double d1, double d2, double k) =>
        sub_smooth(d1, d2, k, out _);

    [MethodImpl(256 | 512)]
    public static double sub_smooth(double d1, double d2, double k, out double h)
    {
        h = (0.5 - 0.5 * (d2 + d1) / k).clamp(0.0, 1.0);
        return h.lerp(d2, -d1) + k * h * (1.0 - h);
    }

    [MethodImpl(256 | 512)]
    public static double and_smooth(double d1, double d2, double k) =>
        and_smooth(d1, d2, k, out _);

    [MethodImpl(256 | 512)]
    public static double and_smooth(double d1, double d2, double k, out double h)
    {
        h = (0.5 - 0.5 * (d2 - d1) / k).clamp(0.0, 1.0);
        return h.lerp(d2, d1) + k * h * (1.0 - h);
    }

    #endregion // double

}
